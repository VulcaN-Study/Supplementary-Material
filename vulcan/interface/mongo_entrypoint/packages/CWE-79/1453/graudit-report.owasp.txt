/src/angular.min.js.map-6-"sources":["angular.js"],
/src/angular.min.js.map:7:"names":["window","document","undefined","minErr","isArrayLike","obj","isWindow","isArray","isString","jqLite","length","Object","isNumber","Array","item","forEach","iterator","context","key","isFunction","hasOwnProperty","call","isPrimitive","isBlankObject","forEachSorted","keys","sort","i","reverseParams","iteratorFn","value","nextUid","uid","baseExtend","dst","objs","deep","h","$$hashKey","ii","isObject","j","jj","src","isDate","Date","valueOf","isRegExp","RegExp","nodeName","cloneNode","isElement","clone","extend","slice","arguments","merge","toInt","str","parseInt","inherit","parent","extra","create","noop","identity","$","valueFn","hasCustomToString","toString","isUndefined","isDefined","getPrototypeOf","isScope","$evalAsync","$watch","isBoolean","isTypedArray","TYPED_ARRAY_REGEXP","test","node","prop","attr","find","makeMap","items","split","nodeName_","element","lowercase","arrayRemove","array","index","indexOf","splice","copy","source","destination","copyRecurse","push","copyElement","stackSource","stackDest","ngMinErr","needsRecurse","constructor","getTime","match","lastIndex","type","shallowCopy","charAt","equals","o1","o2","t1","t2","keySet","createMap","concat","array1","array2","bind","self","fn","curryArgs","startIndex","apply","toJsonReplacer","val","toJson","pretty","JSON","stringify","fromJson","json","parse","timezoneToOffset","timezone","fallback","replace","ALL_COLONS","requestedTimezoneOffset","isNaN","convertTimezoneToLocal","date","reverse","dateTimezoneOffset","getTimezoneOffset","timezoneOffset","setMinutes","getMinutes","minutes","startingTag","empty","e","elemHtml","append","html","nodeType","NODE_TYPE_TEXT","tryDecodeURIComponent","decodeURIComponent","parseKeyValue","keyValue","splitPoint","substring","toKeyValue","parts","arrayValue","encodeUriQuery","join","encodeUriSegment","pctEncodeSpaces","encodeURIComponent","getNgAttribute","ngAttr","ngAttrPrefixes","getAttribute","angularInit","bootstrap","appElement","module","config","prefix","name","hasAttribute","candidate","querySelector","strictDi","modules","defaultConfig","doBootstrap","injector","tag","unshift","$provide","debugInfoEnabled","$compileProvider","createInjector","invoke","bootstrapApply","scope","compile","$apply","data","NG_ENABLE_DEBUG_INFO","NG_DEFER_BOOTSTRAP","angular","resumeBootstrap","angular.resumeBootstrap","extraModules","resumeDeferredBootstrap","reloadWithDebugInfo","location","reload","getTestability","rootElement","get","snake_case","separator","SNAKE_CASE_REGEXP","letter","pos","toLowerCase","bindJQuery","originalCleanData","bindJQueryFired","jqName","jq","jQuery","on","JQLitePrototype","isolateScope","controller","inheritedData","cleanData","jQuery.cleanData","elems","events","skipDestroyOnNextJQueryCleanData","elem","_data","$destroy","triggerHandler","JQLite","assertArg","arg","reason","assertArgFn","acceptArrayAnnotation","assertNotHasOwnProperty","getter","path","bindFnToScope","lastInstance","len","getBlockNodes","nodes","endNode","blockNodes","nextSibling","setupModuleLoader","ensure","factory","$injectorMinErr","$$minErr","requires","configFn","invokeLater","provider","method","insertMethod","queue","invokeQueue","moduleInstance","invokeLaterAndSetModuleName","recipeName","factoryFunction","$$moduleName","configBlocks","runBlocks","_invokeQueue","_configBlocks","_runBlocks","service","constant","decorator","animation","filter","directive","run","block","publishExternalAPI","version","uppercase","counter","csp","angularModule","ngModule","$$sanitizeUri","$$SanitizeUriProvider","$CompileProvider","a","htmlAnchorDirective","input","inputDirective","textarea","form","formDirective","script","scriptDirective","select","selectDirective","style","styleDirective","option","optionDirective","ngBind","ngBindDirective","ngBindHtml","ngBindHtmlDirective","ngBindTemplate","ngBindTemplateDirective","ngClass","ngClassDirective","ngClassEven","ngClassEvenDirective","ngClassOdd","ngClassOddDirective","ngCloak","ngCloakDirective","ngController","ngControllerDirective","ngForm","ngFormDirective","ngHide","ngHideDirective","ngIf","ngIfDirective","ngInclude","ngIncludeDirective","ngInit","ngInitDirective","ngNonBindable","ngNonBindableDirective","ngPluralize","ngPluralizeDirective","ngRepeat","ngRepeatDirective","ngShow","ngShowDirective","ngStyle","ngStyleDirective","ngSwitch","ngSwitchDirective","ngSwitchWhen","ngSwitchWhenDirective","ngSwitchDefault","ngSwitchDefaultDirective","ngOptions","ngOptionsDirective","ngTransclude","ngTranscludeDirective","ngModel","ngModelDirective","ngList","ngListDirective","ngChange","ngChangeDirective","pattern","patternDirective","ngPattern","required","requiredDirective","ngRequired","minlength","minlengthDirective","ngMinlength","maxlength","maxlengthDirective","ngMaxlength","ngValue","ngValueDirective","ngModelOptions","ngModelOptionsDirective","ngIncludeFillContentDirective","ngAttributeAliasDirectives","ngEventDirectives","$anchorScroll","$AnchorScrollProvider","$animate","$AnimateProvider","$animateCss","$CoreAnimateCssProvider","$$animateJs","$$CoreAnimateJsProvider","$$animateQueue","$$CoreAnimateQueueProvider","$$AnimateRunner","$$AnimateRunnerFactoryProvider","$$animateAsyncRun","$$AnimateAsyncRunFactoryProvider","$browser","$BrowserProvider","$cacheFactory","$CacheFactoryProvider","$controller","$ControllerProvider","$document","$DocumentProvider","$exceptionHandler","$ExceptionHandlerProvider","$filter","$FilterProvider","$$forceReflow","$$ForceReflowProvider","$interpolate","$InterpolateProvider","$interval","$IntervalProvider","$http","$HttpProvider","$httpParamSerializer","$HttpParamSerializerProvider","$httpParamSerializerJQLike","$HttpParamSerializerJQLikeProvider","$httpBackend","$HttpBackendProvider","$xhrFactory","$xhrFactoryProvider","$location","$LocationProvider","$log","$LogProvider","$parse","$ParseProvider","$rootScope","$RootScopeProvider","$q","$QProvider","$$q","$$QProvider","$sce","$SceProvider","$sceDelegate","$SceDelegateProvider","$sniffer","$SnifferProvider","$templateCache","$TemplateCacheProvider","$templateRequest","$TemplateRequestProvider","$$testability","$$TestabilityProvider","$timeout","$TimeoutProvider","$window","$WindowProvider","$$rAF","$$RAFProvider","$$jqLite","$$jqLiteProvider","$$HashMap","$$HashMapProvider","$$cookieReader","$$CookieReaderProvider","camelCase","SPECIAL_CHARS_REGEXP","_","offset","toUpperCase","MOZ_HACK_REGEXP","jqLiteAcceptsData","NODE_TYPE_ELEMENT","NODE_TYPE_DOCUMENT","jqLiteBuildFragment","tmp","fragment","createDocumentFragment","HTML_REGEXP","appendChild","createElement","TAG_NAME_REGEXP","exec","wrap","wrapMap","_default","innerHTML","XHTML_TAG_REGEXP","lastChild","childNodes","firstChild","textContent","createTextNode","jqLiteWrapNode","wrapper","parentNode","replaceChild","argIsString","trim","jqLiteMinErr","parsed","SINGLE_TAG_REGEXP","jqLiteAddNodes","jqLiteClone","jqLiteDealoc","onlyDescendants","jqLiteRemoveData","querySelectorAll","descendants","l","jqLiteOff","unsupported","expandoStore","jqLiteExpandoStore","handle","removeHandler","listenerFns","removeEventListener","MOUSE_EVENT_MAP","expandoId","ng339","jqCache","createIfNecessary","jqId","jqLiteData","isSimpleSetter","isSimpleGetter","massGetter","jqLiteHasClass","selector","jqLiteRemoveClass","cssClasses","setAttribute","cssClass","jqLiteAddClass","existingClasses","root","elements","jqLiteController","jqLiteInheritedData","documentElement","names","NODE_TYPE_DOCUMENT_FRAGMENT","host","jqLiteEmpty","removeChild","jqLiteRemove","keepData","jqLiteDocumentLoaded","action","win","readyState","setTimeout","getBooleanAttrName","booleanAttr","BOOLEAN_ATTR","BOOLEAN_ELEMENTS","createEventHandler","eventHandler","event","isDefaultPrevented","event.isDefaultPrevented","defaultPrevented","eventFns","eventFnsLength","immediatePropagationStopped","originalStopImmediatePropagation","stopImmediatePropagation","event.stopImmediatePropagation","stopPropagation","isImmediatePropagationStopped","event.isImmediatePropagationStopped","handlerWrapper","specialHandlerWrapper","defaultHandlerWrapper","handler","specialMouseHandlerWrapper","target","related","relatedTarget","jqLiteContains","$get","this.$get","hasClass","classes","addClass","removeClass","hashKey","nextUidFn","objType","HashMap","isolatedUid","this.nextUid","put","anonFn","args","fnText","STRIP_COMMENTS","FN_ARGS","modulesToLoad","supportObject","delegate","provider_","providerInjector","instantiate","providerCache","providerSuffix","enforceReturnValue","enforcedReturnValue","result","instanceInjector","factoryFn","enforce","loadModules","moduleFn","runInvokeQueue","invokeArgs","loadedModules","message","stack","createInternalInjector","cache","getService","serviceName","caller","INSTANTIATING","err","shift","locals","$inject","$$annotate","Type","instance","prototype","returnedValue","annotate","has","$injector","instanceCache","decorFn","origProvider","orig$get","origProvider.$get","origInstance","$delegate","autoScrollingEnabled","disableAutoScrolling","this.disableAutoScrolling","getFirstAnchor","list","some","scrollTo","scrollIntoView","scroll","yOffset","getComputedStyle","position","getBoundingClientRect","bottom","elemTop","top","scrollBy","hash","elm","getElementById","getElementsByName","autoScrollWatch","autoScrollWatchAction","newVal","oldVal","mergeClasses","b","splitClasses","klass","prepareAnimateOptions","options","Browser","completeOutstandingRequest","outstandingRequestCount","outstandingRequestCallbacks","pop","error","cacheStateAndFireUrlChange","pendingLocation","cacheState","fireUrlChange","history","state","cachedState","lastCachedState","lastBrowserUrl","url","lastHistoryState","urlChangeListeners","listener","clearTimeout","pendingDeferIds","isMock","$$completeOutstandingRequest","$$incOutstandingRequestCount","self.$$incOutstandingRequestCount","notifyWhenNoOutstandingRequests","self.notifyWhenNoOutstandingRequests","callback","href","baseElement","self.url","sameState","sameBase","stripHash","substr","self.state","urlChangeInit","onUrlChange","self.onUrlChange","$$applicationDestroyed","self.$$applicationDestroyed","off","$$checkUrlChange","baseHref","self.baseHref","defer","self.defer","delay","timeoutId","cancel","self.defer.cancel","deferId","cacheFactory","cacheId","refresh","entry","freshEnd","staleEnd","n","link","p","nextEntry","prevEntry","caches","size","stats","id","capacity","Number","MAX_VALUE","lruHash","lruEntry","remove","removeAll","destroy","info","cacheFactory.info","cacheFactory.get","$$sanitizeUriProvider","parseIsolateBindings","directiveName","isController","LOCAL_REGEXP","bindings","definition","scopeName","bindingCache","$compileMinErr","mode","collection","optional","attrName","assertValidDirectiveName","hasDirectives","COMMENT_DIRECTIVE_REGEXP","CLASS_DIRECTIVE_REGEXP","ALL_OR_NOTHING_ATTRS","REQUIRE_PREFIX_REGEXP","EVENT_HANDLER_ATTR_REGEXP","this.directive","registerDirective","directiveFactory","Suffix","directives","priority","require","restrict","aHrefSanitizationWhitelist","this.aHrefSanitizationWhitelist","regexp","imgSrcSanitizationWhitelist","this.imgSrcSanitizationWhitelist","this.debugInfoEnabled","enabled","safeAddClass","$element","className","$compileNodes","transcludeFn","maxPriority","ignoreDirective","previousCompileContext","NOT_EMPTY","domNode","nodeValue","compositeLinkFn","compileNodes","$$addScopeClass","namespace","publicLinkFn","cloneConnectFn","needsNewScope","$parent","$new","parentBoundTranscludeFn","transcludeControllers","futureParentElement","$$boundTransclude","$linkNode","wrapTemplate","controllerName","$$addScopeInfo","nodeList","$rootElement","childLinkFn","childScope","childBoundTranscludeFn","stableNodeList","nodeLinkFnFound","linkFns","idx","nodeLinkFn","transcludeOnThisElement","createBoundTranscludeFn","transclude","templateOnThisElement","attrs","linkFnFound","Attributes","collectDirectives","applyDirectivesToNode","$$element","terminal","previousBoundTranscludeFn","boundTranscludeFn","transcludedScope","cloneFn","controllers","containingScope","$$transcluded","attrsMap","$attr","addDirective","directiveNormalize","isNgAttr","nAttrs","attributes","attrStartName","attrEndName","ngAttrName","NG_ATTR_BINDING","PREFIX_REGEXP","multiElementMatch","MULTI_ELEMENT_DIR_RE","directiveIsMultiElement","nName","addAttrInterpolateDirective","animVal","msie","addTextInterpolateDirective","NODE_TYPE_COMMENT","byPriority","groupScan","attrStart","attrEnd","depth","groupElementsLinkFnWrapper","linkFn","compileNode","templateAttrs","jqCollection","originalReplaceDirective","preLinkFns","postLinkFns","addLinkFns","pre","post","newIsolateScopeDirective","$$isolateScope","cloneAndAnnotateFn","getControllers","elementControllers","inheritType","dataName","setupControllers","controllerDirectives","controllerKey","$scope","$attrs","$transclude","controllerInstance","controllerAs","linkNode","controllersBoundTransclude","cloneAttachFn","hasElementTranscludeDirective","scopeToChild","controllerScope","removeScopeBindingWatches","newScopeDirective","templateDirective","$$originalDirective","$$isolateBindings","initializeDirectiveBindings","$on","controllerDirective","$$bindings","bindToController","identifier","removeControllerBindingWatches","controllerResult","invokeLinkFn","template","templateUrl","terminalPriority","nonTlbTranscludeDirective","hasTranscludeDirective","hasTemplate","$compileNode","$template","childTranscludeFn","$$start","$$end","directiveValue","assertNoDuplicate","$$tlb","createComment","replaceWith","replaceDirective","contents","$$newScope","denormalizeTemplate","removeComments","templateNamespace","newTemplateAttrs","templateDirectives","unprocessedDirectives","markDirectiveScope","mergeTemplateAttributes","compileTemplateUrl","Math","max","newScope","tDirectives","startAttrName","endAttrName","ident","CNTRL_REG","multiElement","srcAttr","dstAttr","$set","tAttrs","linkQueue","afterTemplateNodeLinkFn","afterTemplateChildLinkFn","beforeTemplateCompileNode","origAsyncDirective","derivedSyncDirective","then","content","tempTemplateAttrs","beforeTemplateLinkNode","linkRootElement","$$destroyed","oldClasses","delayedNodeLinkFn","ignoreChildLinkFn","diff","what","previousDirective","wrapModuleNameIfDefined","moduleName","text","interpolateFn","textInterpolateCompileFn","templateNode","templateNodeParent","hasCompileParent","$$addBindingClass","textInterpolateLinkFn","$$addBindingInfo","expressions","interpolateFnWatchAction","getTrustedContext","attrNormalizedName","HTML","RESOURCE_URL","allOrNothing","trustedContext","attrInterpolatePreLinkFn","$$observers","newValue","$$inter","$$scope","oldValue","$updateClass","elementsToRemove","newNode","firstElementToRemove","removeCount","j2","hasData","expando","k","kk","annotation","removeWatchCollection","lastValue","parentGet","parentSet","compare","$observe","literal","assign","parentValueWatch","parentValue","$stateful","removeWatch","$watchCollection","removeWatches","attributesToCopy","$normalize","$addClass","classVal","$removeClass","newClasses","toAdd","tokenDifference","toRemove","writeAttr","booleanKey","aliasedKey","ALIASED_ATTR","observer","trimmedSrcset","srcPattern","rawUris","nbrUrisWith2parts","floor","innerIdx","lastTuple","removeAttr","listeners","startSymbol","endSymbol","binding","isolated","noTemplate","str1","str2","values","tokens1","tokens2","token","jqNodes","globals","register","this.register","allowGlobals","this.allowGlobals","addIdentifier","expression","later","$controllerMinErr","controllerPrototype","exception","cause","serializeValue","v","toISOString","ngParamSerializer","params","jQueryLikeParamSerializer","serialize","toSerialize","topLevel","defaultHttpResponseTransform","headers","tempData","JSON_PROTECTION_PREFIX","contentType","jsonStart","JSON_START","JSON_ENDS","parseHeaders","line","headerVal","headerKey","headersGetter","headersObj","transformData","status","fns","defaults","transformResponse","transformRequest","d","common","CONTENT_TYPE_APPLICATION_JSON","patch","xsrfCookieName","xsrfHeaderName","paramSerializer","useApplyAsync","this.useApplyAsync","useLegacyPromise","useLegacyPromiseExtensions","this.useLegacyPromiseExtensions","interceptorFactories","interceptors","requestConfig","response","resp","reject","executeHeaderFns","headerContent","processedHeaders","headerFn","header","mergeHeaders","defHeaders","reqHeaders","defHeaderName","lowercaseDefHeaderName","reqHeaderName","chain","serverRequest","reqData","withCredentials","sendReq","promise","when","reversedInterceptors","interceptor","request","requestError","responseError","thenFn","rejectFn","success","promise.success","promise.error","$httpMinErrLegacyFn","done","headersString","statusText","resolveHttpPromise","resolvePromise","$applyAsync","$$phase","deferred","resolve","resolvePromiseWithResult","removePendingReq","pendingRequests","cachedResp","buildUrl","defaultCache","xsrfValue","urlIsSameOrigin","timeout","responseType","serializedParams","interceptorFactory","createShortMethods","createShortMethodsWithData","createXhr","XMLHttpRequest","createHttpBackend","callbacks","$browserDefer","rawDocument","jsonpReq","callbackId","async","body","called","addEventListener","timeoutRequest","jsonpDone","xhr","abort","completeRequest","open","setRequestHeader","onload","xhr.onload","responseText","urlResolve","protocol","getAllResponseHeaders","onerror","onabort","send","this.startSymbol","this.endSymbol","escape","ch","unescapeText","escapedStartRegexp","escapedEndRegexp","mustHaveExpression","parseStringifyInterceptor","getTrusted","$interpolateMinErr","interr","endIndex","parseFns","textLength","expressionPositions","startSymbolLength","exp","endSymbolLength","throwNoconcat","compute","interpolationFn","$$watchDelegate","$watchGroup","interpolateFnWatcher","oldValues","currValue","$interpolate.startSymbol","$interpolate.endSymbol","interval","count","invokeApply","hasParams","setInterval","clearInterval","iteration","skipApply","$$intervalId","tick","notify","intervals","interval.cancel","encodePath","segments","parseAbsoluteUrl","absoluteUrl","locationObj","parsedUrl","$$protocol","$$host","hostname","$$port","port","DEFAULT_PORTS","parseAppUrl","relativeUrl","prefixed","$$path","pathname","$$search","search","$$hash","beginsWith","begin","whole","trimEmptyHash","LocationHtml5Url","appBase","appBaseNoFile","basePrefix","$$html5","$$parse","this.$$parse","pathUrl","$locationMinErr","$$compose","this.$$compose","$$url","$$absUrl","$$parseLinkUrl","this.$$parseLinkUrl","relHref","appUrl","prevAppUrl","rewrittenUrl","LocationHashbangUrl","hashPrefix","withoutBaseUrl","withoutHashUrl","windowsFilePathExp","base","firstPathSegmentMatch","LocationHashbangInHtml5Url","locationGetter","property","locationGetterSetter","preprocess","html5Mode","requireBase","rewriteLinks","this.hashPrefix","this.html5Mode","setBrowserUrlWithFallback","oldUrl","oldState","$$state","afterLocationChange","$broadcast","absUrl","LocationMode","initialUrl","lastIndexOf","IGNORE_URI_REGEXP","ctrlKey","metaKey","shiftKey","which","button","absHref","preventDefault","initializing","newUrl","newState","$digest","$locationWatch","currentReplace","$$replace","urlOrStateChanged","debug","debugEnabled","this.debugEnabled","flag","formatError","Error","sourceURL","consoleLog","console","logFn","log","hasApply","arg1","arg2","warn","ensureSafeMemberName","fullExpression","$parseMinErr","getStringValue","ensureSafeObject","children","ensureSafeFunction","CALL","APPLY","BIND","ensureSafeAssignContext","Function","ifDefined","plusFn","r","findConstantAndWatchExpressions","ast","allConstants","argsToWatch","AST","Program","expr","Literal","toWatch","UnaryExpression","argument","BinaryExpression","left","right","LogicalExpression","ConditionalExpression","alternate","consequent","Identifier","MemberExpression","object","computed","CallExpression","callee","AssignmentExpression","ArrayExpression","ObjectExpression","properties","ThisExpression","getInputs","lastExpression","isAssignable","assignableAST","NGValueParameter","operator","isLiteral","ASTCompiler","astBuilder","ASTInterpreter","isPossiblyDangerousMemberName","getValueOf","objectValueOf","cacheDefault","cacheExpensive","interceptorFn","expensiveChecks","parsedExpression","oneTime","cacheKey","runningChecksEnabled","parseOptions","$parseOptionsExpensive","$parseOptions","lexer","Lexer","parser","Parser","constantWatchDelegate","oneTimeLiteralWatchDelegate","oneTimeWatchDelegate","inputs","inputsWatchDelegate","expensiveChecksInterceptor","addInterceptor","expensiveCheckFn","expensiveCheckOldValue","expressionInputDirtyCheck","oldValueOfValue","objectEquality","prettyPrintExpression","inputExpressions","lastResult","oldInputValueOf","expressionInputWatch","newInputValue","oldInputValueOfValues","oldInputValues","expressionInputsWatch","changed","unwatch","oneTimeWatch","oneTimeListener","old","$$postDigest","isAllDefined","allDefined","constantWatch","constantListener","watchDelegate","useInputs","regularInterceptedExpression","oneTimeInterceptedExpression","noUnsafeEval","$$runningExpensiveChecks","$parse.$$runningExpensiveChecks","qFactory","nextTick","exceptionHandler","callOnce","resolveFn","Promise","simpleBind","scheduleProcessQueue","processScheduled","pending","Deferred","$qMinErr","TypeError","onFulfilled","onRejected","progressBack","catch","finally","handleCallback","$$reject","$$resolve","progress","makePromise","resolved","isResolved","callbackOutput","errback","$Q","Q","resolver","all","promises","results","requestAnimationFrame","webkitRequestAnimationFrame","cancelAnimationFrame","webkitCancelAnimationFrame","webkitCancelRequestAnimationFrame","rafSupported","raf","timer","supported","createChildScopeClass","ChildScope","$$watchers","$$nextSibling","$$childHead","$$childTail","$$listeners","$$listenerCount","$$watchersCount","$id","$$ChildScope","TTL","$rootScopeMinErr","lastDirtyWatch","applyAsyncId","digestTtl","this.digestTtl","destroyChildScope","$event","currentScope","cleanUpScope","$$prevSibling","$root","Scope","beginPhase","phase","incrementWatchersCount","current","decrementListenerCount","initWatchVal","flushApplyAsync","applyAsyncQueue","scheduleApplyAsync","isolate","child","watchExp","watcher","last","eq","deregisterWatch","watchExpressions","watchGroupAction","changeReactionScheduled","firstRun","newValues","deregisterFns","shouldCall","deregisterWatchGroup","unwatchFn","watchGroupSubAction","$watchCollectionInterceptor","_value","bothNaN","newItem","oldItem","internalArray","oldLength","changeDetected","newLength","internalObject","veryOldValue","trackVeryOldValue","changeDetector","initRun","$watchCollectionAction","watch","watchers","dirty","ttl","watchLog","logIdx","asyncTask","asyncQueue","$eval","msg","next","postDigestQueue","eventName","this.$watchGroup","$applyAsyncExpression","namedListeners","indexOfListener","$emit","targetScope","listenerArgs","$$asyncQueue","$$postDigestQueue","$$applyAsyncQueue","sanitizeUri","uri","isImage","regex","normalizedVal","adjustMatcher","matcher","$sceMinErr","escapeForRegexp","adjustMatchers","matchers","adjustedMatchers","SCE_CONTEXTS","resourceUrlWhitelist","resourceUrlBlacklist","this.resourceUrlWhitelist","this.resourceUrlBlacklist","matchUrl","generateHolderType","Base","holderType","trustedValue","$$unwrapTrustedValue","this.$$unwrapTrustedValue","holderType.prototype.valueOf","holderType.prototype.toString","htmlSanitizer","trustedValueHolderBase","byType","CSS","URL","JS","trustAs","Constructor","maybeTrusted","allowed","this.enabled","sce","isEnabled","sce.isEnabled","sce.getTrusted","parseAs","sce.parseAs","enumValue","lName","eventSupport","android","userAgent","navigator","boxee","vendorPrefix","vendorRegex","bodyStyle","transitions","animations","webkitTransition","webkitAnimation","pushState","hasEvent","divElm","handleRequestFn","tpl","ignoreRequestError","totalPendingRequests","getTrustedResourceUrl","transformer","httpOptions","handleError","testability","testability.findBindings","opt_exactMatch","getElementsByClassName","matches","dataBinding","bindingName","testability.findModels","prefixes","attributeEquals","testability.getLocation","testability.setLocation","testability.whenStable","deferreds","$$timeoutId","timeout.cancel","urlParsingNode","requestUrl","originUrl","$$CookieReader","safeDecodeURIComponent","lastCookies","lastCookieString","cookieArray","cookie","currentCookieString","filters","suffix","currencyFilter","dateFilter","filterFilter","jsonFilter","limitToFilter","lowercaseFilter","numberFilter","orderByFilter","uppercaseFilter","comparator","matchAgainstAnyProp","getTypeForFilter","expressionType","predicateFn","createPredicateFn","shouldMatchPrimitives","actual","expected","deepCompare","dontMatchWholeObject","actualType","expectedType","expectedVal","matchAnyProperty","actualVal","$locale","formats","NUMBER_FORMATS","amount","currencySymbol","fractionSize","CURRENCY_SYM","PATTERNS","maxFrac","formatNumber","GROUP_SEP","DECIMAL_SEP","number","numStr","exponent","digits","numberOfIntegerDigits","zeros","ZERO_CHAR","MAX_DIGITS","roundNumber","parsedNumber","minFrac","fractionLen","min","roundAt","digit","carry","reduceRight","groupSep","decimalSep","isInfinity","isFinite","isZero","abs","formattedText","integerLen","decimals","reduce","groups","lgSize","gSize","negPre","negSuf","posPre","posSuf","padNumber","num","neg","dateGetter","dateStrGetter","shortForm","getFirstThursdayOfYear","year","dayOfWeekOnFirst","getDay","weekGetter","firstThurs","getFullYear","thisThurs","getMonth","getDate","round","eraGetter","ERAS","jsonStringToDate","string","R_ISO8601_STR","tzHour","tzMin","dateSetter","setUTCFullYear","setFullYear","timeSetter","setUTCHours","setHours","m","s","ms","parseFloat","format","DATETIME_FORMATS","NUMBER_STRING","DATE_FORMATS_SPLIT","DATE_FORMATS","spacing","limit","Infinity","processPredicates","sortPredicate","reverseOrder","map","predicate","descending","predicates","compareValues","getComparisonObject","predicateValues","doComparison","v1","v2","ngDirective","FormController","controls","$error","$$success","$pending","$name","$dirty","$pristine","$valid","$invalid","$submitted","$$parentForm","nullFormCtrl","$rollbackViewValue","form.$rollbackViewValue","control","$commitViewValue","form.$commitViewValue","$addControl","form.$addControl","$$renameControl","form.$$renameControl","newName","oldName","$removeControl","form.$removeControl","$setValidity","addSetValidityMethod","ctrl","set","unset","$setDirty","form.$setDirty","PRISTINE_CLASS","DIRTY_CLASS","$setPristine","form.$setPristine","setClass","SUBMITTED_CLASS","$setUntouched","form.$setUntouched","$setSubmitted","form.$setSubmitted","stringBasedInputType","$formatters","$isEmpty","baseInputType","composing","ev","ngTrim","$viewValue","$$hasNativeValidators","$setViewValue","deferListener","origValue","keyCode","PARTIAL_VALIDATION_TYPES","PARTIAL_VALIDATION_EVENTS","validity","origBadInput","badInput","origTypeMismatch","typeMismatch","$render","ctrl.$render","createDateParser","mapping","iso","ISO_DATE_REGEXP","yyyy","MM","dd","HH","getHours","mm","ss","getSeconds","sss","getMilliseconds","part","NaN","createDateInputType","parseDate","dynamicDateInputType","isValidDate","parseObservedDateValue","badInputChecker","$options","previousDate","$$parserName","$parsers","parsedDate","ngModelMinErr","ngMin","minVal","$validators","ctrl.$validators.min","$validate","ngMax","maxVal","ctrl.$validators.max","VALIDITY_STATE_PROPERTY","parseConstantExpr","parseFn","classDirective","arrayDifference","arrayClasses","addClasses","digestClassCounts","classCounts","classesToUpdate","updateClasses","ngClassWatchAction","$index","old$index","mod","cachedToggleClass","switchValue","classCache","toggleValidationCss","validationErrorKey","isValid","VALID_CLASS","INVALID_CLASS","setValidity","isObjectEmpty","PENDING_CLASS","combinedState","REGEX_STRING_REGEXP","documentMode","rules","ngCspElement","ngCspAttribute","noInlineStyle","name_","el","full","major","minor","dot","codeName","JQLite._data","mouseleave","mouseenter","optgroup","tbody","tfoot","colgroup","caption","thead","th","td","Node","contains","compareDocumentPosition","ready","trigger","fired","removeData","jqLiteHasData","removeAttribute","css","NODE_TYPE_ATTRIBUTE","lowercasedName","specified","getNamedItem","ret","getText","$dv","multiple","selected","nodeCount","jqLiteOn","types","addHandler","noEventListener","one","onFn","replaceNode","insertBefore","contentDocument","prepend","wrapNode","detach","after","newElement","toggleClass","condition","classCondition","nextElementSibling","getElementsByTagName","extraParameters","dummyEvent","handlerArgs","eventFnsCopy","arg3","unbind","FN_ARG_SPLIT","FN_ARG","argDecl","underscore","$animateMinErr","postDigestElements","updateData","handleCSSClassChanges","existing","pin","domOperation","from","to","classesAdded","add","classesRemoved","runner","complete","$$registeredAnimations","classNameFilter","this.classNameFilter","$$classNameFilter","reservedRegex","NG_ANIMATE_CLASSNAME","domInsert","parentElement","afterElement","afterNode","ELEMENT_NODE","previousElementSibling","end","enter","move","leave","addclass","animate","tempClasses","waitForTick","waitQueue","passed","AnimateRunner","setHost","rafTick","_doneCallbacks","_tick","this._tick","doc","hidden","_state","AnimateRunner.chain","AnimateRunner.all","runners","onProgress","DONE_COMPLETE_STATE","getPromise","resolveHandler","rejectHandler","pause","resume","_resolve","INITIAL_STATE","DONE_PENDING_STATE","initialOptions","closed","$$prepared","cleanupStyles","start","offsetWidth","APPLICATION_JSON","$httpMinErr","$interpolateMinErr.throwNoconcat","$interpolateMinErr.interr","PATH_MATCH","locationPrototype","paramValue","Location","Location.prototype.state","OPERATORS","ESCAPE","lex","tokens","readString","peek","readNumber","isIdent","readIdent","is","isWhitespace","ch2","ch3","op2","op3","op1","throwError","chars","isExpOperator","colStr","peekCh","quote","rawString","hex","String","fromCharCode","rep","ExpressionStatement","Property","program","expressionStatement","expect","filterChain","assignment","ternary","logicalOR","consume","logicalAND","equality","relational","additive","multiplicative","unary","primary","arrayDeclaration","constants","parseArguments","baseExpression","peekToken","kind","e1","e2","e3","e4","peekAhead","t","nextId","vars","own","assignable","stage","computing","recurse","return_","generateFunction","fnKey","intoId","watchId","fnString","USE","STRICT","filterPrefix","watchFns","varsPrefix","section","nameId","recursionFn","skipWatchIdCheck","if_","lazyAssign","computedMember","lazyRecurse","plus","not","getHasOwnProperty","nonComputedMember","addEnsureSafeObject","notNull","addEnsureSafeAssignContext","addEnsureSafeMemberName","addEnsureSafeFunction","member","filterName","defaultValue","stringEscapeRegex","stringEscapeFn","c","charCodeAt","skip","init","fn.assign","rhs","lhs","unary+","unary-","unary!","binary+","binary-","binary*","binary/","binary%","binary===","binary!==","binary==","binary!=","binary<","binary>","binary<=","binary>=","binary&&","binary||","ternary?:","astCompiler","yy","y","MMMM","MMM","M","H","hh","EEEE","EEE","ampmGetter","AMPMS","Z","timeZoneGetter","zone","paddedZone","ww","w","G","GG","GGG","GGGG","longEraGetter","ERANAMES","xlinkHref","propName","defaultLinkFn","normalized","ngBooleanAttrWatchAction","htmlAttr","ngAttrAliasWatchAction","nullFormRenameControl","formDirectiveFactory","isNgForm","getSetter","ngFormCompile","formElement","nameAttr","ngFormPreLink","ctrls","handleFormSubmission","setter","URL_REGEXP","EMAIL_REGEXP","NUMBER_REGEXP","DATE_REGEXP","DATETIMELOCAL_REGEXP","WEEK_REGEXP","MONTH_REGEXP","TIME_REGEXP","inputType","textInputType","weekParser","isoWeek","existingDate","week","hours","seconds","milliseconds","addDays","numberInputType","urlInputType","ctrl.$validators.url","modelValue","viewValue","emailInputType","email","ctrl.$validators.email","radioInputType","checked","checkboxInputType","trueValue","ngTrueValue","falseValue","ngFalseValue","ctrl.$isEmpty","CONSTANT_VALUE_REGEXP","tplAttr","ngValueConstantLink","ngValueLink","valueWatchAction","$compile","ngBindCompile","templateElement","ngBindLink","ngBindWatchAction","ngBindTemplateCompile","ngBindTemplateLink","ngBindHtmlCompile","tElement","ngBindHtmlGetter","ngBindHtmlWatch","sceValueOf","ngBindHtmlLink","ngBindHtmlWatchAction","getTrustedHtml","$viewChangeListeners","forceAsyncEvents","ngEventHandler","previousElements","ngIfWatchAction","srcExp","onloadExp","autoScrollExp","autoscroll","changeCounter","previousElement","currentElement","cleanupLastIncludeContent","ngIncludeWatchAction","afterAnimation","thisChangeId","namespaceAdaptedClone","trimValues","NgModelController","$modelValue","$$rawModelValue","$asyncValidators","$untouched","$touched","parsedNgModel","parsedNgModelAssign","ngModelGet","ngModelSet","pendingDebounce","parserValid","$$setOptions","this.$$setOptions","getterSetter","invokeModelGetter","invokeModelSetter","$$$p","this.$isEmpty","currentValidationRunId","this.$setPristine","this.$setDirty","this.$setUntouched","UNTOUCHED_CLASS","TOUCHED_CLASS","$setTouched","this.$setTouched","this.$rollbackViewValue","$$lastCommittedViewValue","this.$validate","prevValid","prevModelValue","allowInvalid","$$runValidators","allValid","$$writeModelToScope","this.$$runValidators","doneCallback","processSyncValidators","syncValidatorsValid","validator","processAsyncValidators","validatorPromises","validationDone","localValidationRunId","processParseErrors","errorKey","this.$commitViewValue","$$parseAndValidate","this.$$parseAndValidate","this.$$writeModelToScope","this.$setViewValue","updateOnDefault","$$debounceViewValueCommit","this.$$debounceViewValueCommit","debounceDelay","debounce","ngModelWatch","formatters","ngModelCompile","ngModelPreLink","modelCtrl","formCtrl","ngModelPostLink","updateOn","DEFAULT_REGEXP","that","ngOptionsMinErr","NG_OPTIONS_REGEXP","parseOptionsExpression","optionsExp","selectElement","Option","selectValue","label","group","disabled","getOptionValuesKeys","optionValues","optionValuesKeys","keyName","itemKey","valueName","selectAs","trackBy","viewValueFn","trackByFn","getTrackByValueFn","getHashOfValue","getTrackByValue","getLocals","displayFn","groupByFn","disableWhenFn","valuesFn","getWatchables","watchedArray","optionValuesLength","disableWhen","getOptions","optionItems","selectValueMap","optionItem","getOptionFromViewValue","getViewValueFromOption","optionTemplate","optGroupTemplate","ngOptionsPreLink","registerOption","ngOptionsPostLink","updateOptionElement","addOrReuseElement","removeExcessElements","skipEmptyAndUnknownOptions","emptyOption_","emptyOption","unknownOption_","unknownOption","updateOptions","previousValue","selectCtrl","readValue","groupMap","providedEmptyOption","updateOption","optionElement","groupElement","currentOptionElement","ngModelCtrl","nextValue","ngModelCtrl.$isEmpty","writeValue","selectCtrl.writeValue","selectCtrl.readValue","selectedValues","selections","selectedOption","BRACE","IS_WHEN","updateElementText","newText","numberExp","whenExp","whens","whensExpFns","braceReplacement","watchRemover","lastCount","attributeName","tmpMatch","whenKey","ngPluralizeWatchAction","countIsNaN","pluralCat","whenExpFn","ngRepeatMinErr","updateScope","valueIdentifier","keyIdentifier","arrayLength","$first","$last","$middle","$odd","$even","ngRepeatCompile","ngRepeatEndComment","aliasAs","trackByExp","trackByExpGetter","trackByIdExpFn","trackByIdArrayFn","trackByIdObjFn","hashFnLocals","ngRepeatLink","lastBlockMap","ngRepeatAction","previousNode","nextNode","nextBlockMap","collectionLength","trackById","collectionKeys","nextBlockOrder","trackByIdFn","blockKey","ngRepeatTransclude","ngShowWatchAction","NG_HIDE_CLASS","NG_HIDE_IN_PROGRESS_CLASS","ngHideWatchAction","ngStyleWatchAction","newStyles","oldStyles","ngSwitchController","cases","selectedTranscludes","selectedElements","previousLeaveAnimations","selectedScopes","spliceFactory","ngSwitchWatchAction","selectedTransclude","caseElement","selectedScope","anchor","noopNgModelController","SelectController","optionsMap","renderUnknownOption","self.renderUnknownOption","unknownVal","removeUnknownOption","self.removeUnknownOption","self.readValue","self.writeValue","hasOption","addOption","self.addOption","removeOption","self.removeOption","self.hasOption","self.registerOption","optionScope","optionAttrs","interpolateValueFn","interpolateTextFn","valueAttributeObserveAction","interpolateWatchAction","selectPreLink","lastView","lastViewRef","selectMultipleWatch","selectPostLink","ngModelCtrl.$render","selectCtrlName","ctrl.$validators.required","patternExp","ctrl.$validators.pattern","intVal","ctrl.$validators.maxlength","ctrl.$validators.minlength","getDecimals","opt_precision","pow","ONE","OTHER","$$csp","head"]
/src/angular.min.js.map-8-}
##############################################
/src/angular.js-731-function isScope(obj) {
/src/angular.js:732:  return obj && obj.$evalAsync && obj.$watch;
/src/angular.js-733-}
##############################################
/src/angular.js-1101-      csp.rules = {
/src/angular.js:1102:        noUnsafeEval: !ngCspAttribute || (ngCspAttribute.indexOf('no-unsafe-eval') !== -1),
/src/angular.js-1103-        noInlineStyle: !ngCspAttribute || (ngCspAttribute.indexOf('no-inline-style') !== -1)
##############################################
/src/angular.js-1201- *
/src/angular.js:1202: * @param {Object} self Context which `fn` should be evaluated in.
/src/angular.js-1203- * @param {function()} fn Function to be bound.
##############################################
/src/angular.js-1741-  window.name = 'NG_ENABLE_DEBUG_INFO!' + window.name;
/src/angular.js:1742:  window.location.reload();
/src/angular.js-1743-}
##############################################
/src/angular.js-3770- * In the following example a new block of HTML containing a `ng-controller`
/src/angular.js:3771: * directive is added to the end of the document body by JQuery. We then compile and link
/src/angular.js-3772- * it into the current AngularJS scope.
##############################################
/src/angular.js-3775- * var $div = $('<div ng-controller="MyCtrl">{{content.label}}</div>');
/src/angular.js:3776: * $(document.body).append($div);
/src/angular.js-3777- *
##############################################
/src/angular.js-4602- * Use `$anchorScrollProvider` to disable automatic scrolling whenever
/src/angular.js:4603: * {@link ng.$location#hash $location.hash()} changes.
/src/angular.js-4604- */
##############################################
/src/angular.js-4614-   * By default, {@link ng.$anchorScroll $anchorScroll()} will automatically detect changes to
/src/angular.js:4615:   * {@link ng.$location#hash $location.hash()} and scroll to the element matching the new hash.<br />
/src/angular.js-4616-   * Use this method to disable automatic scrolling.
##############################################
/src/angular.js-4635-   * When called, it scrolls to the element related to the specified `hash` or (if omitted) to the
/src/angular.js:4636:   * current value of {@link ng.$location#hash $location.hash()}, according to the rules specified
/src/angular.js-4637-   * in the
##############################################
/src/angular.js-4639-   *
/src/angular.js:4640:   * It also watches the {@link ng.$location#hash $location.hash()} and automatically scrolls to
/src/angular.js-4641-   * match any anchor whenever it changes. This can be disabled by calling
##############################################
/src/angular.js-4647-   * @param {string=} hash The hash specifying the element to scroll to. If omitted, the value of
/src/angular.js:4648:   *                       {@link ng.$location#hash $location.hash()} will be used.
/src/angular.js-4649-   *
##############################################
/src/angular.js-4682-               $scope.gotoBottom = function() {
/src/angular.js:4683:                 // set the location.hash to the id of
/src/angular.js-4684-                 // the element you wish to scroll to.
/src/angular.js:4685:                 $location.hash('bottom');
/src/angular.js-4686-
##############################################
/src/angular.js-4729-                 var newHash = 'anchor' + x;
/src/angular.js:4730:                 if ($location.hash() !== newHash) {
/src/angular.js:4731:                   // set the $location.hash to `newHash` and
/src/angular.js-4732-                   // $anchorScroll will automatically scroll to it
/src/angular.js:4733:                   $location.hash('anchor' + x);
/src/angular.js-4734-                 } else {
/src/angular.js-4735-                   // call $anchorScroll() explicitly,
/src/angular.js:4736:                   // since $location.hash hasn't changed
/src/angular.js-4737-                   $anchorScroll();
##############################################
/src/angular.js-4833-    function scroll(hash) {
/src/angular.js:4834:      hash = isString(hash) ? hash : $location.hash();
/src/angular.js-4835-      var elm;
##############################################
/src/angular.js-4850-    // does not scroll when user clicks on anchor link that is currently on
/src/angular.js:4851:    // (no url change, no $location.hash() change), browser native does scroll
/src/angular.js-4852-    if (autoScrollingEnabled) {
/src/angular.js:4853:      $rootScope.$watch(function autoScrollWatch() {return $location.hash();},
/src/angular.js-4854-        function autoScrollWatchAction(newVal, oldVal) {
/src/angular.js:4855:          // skip the initial scroll if $location.hash is empty
/src/angular.js-4856-          if (newVal === oldVal && newVal === '') return;
##############################################
/src/angular.js-4858-          jqLiteDocumentLoaded(function() {
/src/angular.js:4859:            $rootScope.$evalAsync(scroll);
/src/angular.js-4860-          });
##############################################
/src/angular.js-5215-       *    was bootstrapped on an element that is somewhere inside of the `<body>` tag, but we wanted to allow for an element to be situated
/src/angular.js:5216:       *    as a direct child of `document.body`, then this can be achieved by pinning the element via `$animate.pin(element)`. Keep in mind
/src/angular.js-5217-       *    that calling `$animate.pin(element, parentElement)` will not actually insert into the DOM anywhere; it will just create the association.
##############################################
/src/angular.js-5394-       *    triggers an animation surrounding the class addition/removal. Much like `$animate.addClass` and
/src/angular.js:5395:       *    `$animate.removeClass`, `setClass` will only evaluate the classes being added/removed once a digest has
/src/angular.js-5396-       *    passed. Note that class-based animations are treated differently compared to structural animations
##############################################
/src/angular.js-5742-      rawDocument = document[0],
/src/angular.js:5743:      location = window.location,
/src/angular.js-5744-      history = window.history,
/src/angular.js:5745:      setTimeout = window.setTimeout,
/src/angular.js-5746-      clearTimeout = window.clearTimeout,
##############################################
/src/angular.js-5802-  var cachedState, lastHistoryState,
/src/angular.js:5803:      lastBrowserUrl = location.href,
/src/angular.js-5804-      baseElement = document.find('base'),
##############################################
/src/angular.js-5814-   * GETTER:
/src/angular.js:5815:   * Without any argument, this method just returns current value of location.href.
/src/angular.js-5816-   *
##############################################
/src/angular.js-5819-   * If html5 history api supported, pushState/replaceState is used, otherwise
/src/angular.js:5820:   * location.href/location.replace is used.
/src/angular.js-5821-   * Returns its own instance to allow chaining
##############################################
/src/angular.js-5838-    // Android Browser BFCache causes location, history reference to become stale.
/src/angular.js:5839:    if (location !== window.location) location = window.location;
/src/angular.js-5840-    if (history !== window.history) history = window.history;
##############################################
/src/angular.js-5870-        } else if (!sameBase) {
/src/angular.js:5871:          location.href = url;
/src/angular.js-5872-        } else {
/src/angular.js:5873:          location.hash = getHash(url);
/src/angular.js-5874-        }
/src/angular.js:5875:        if (location.href !== url) {
/src/angular.js-5876-          pendingLocation = url;
##############################################
/src/angular.js-5882-      // - pendingLocation is needed as browsers don't allow to read out
/src/angular.js:5883:      //   the new location.href if a reload happened or if there is a bug like in iOS 9 (see
/src/angular.js-5884-      //   https://openradar.appspot.com/22186109).
/src/angular.js-5885-      // - the replacement is a workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=407172
/src/angular.js:5886:      return pendingLocation || location.href.replace(/%27/g,"'");
/src/angular.js-5887-    }
##############################################
/src/angular.js-6434- * @description
/src/angular.js:6435: * The first time a template is used, it is loaded in the template cache for quick retrieval. You
/src/angular.js-6436- * can load templates directly into the cache in a `script` tag, or by consuming the
##############################################
/src/angular.js-6652- * * `=` or `=attr` - set up a bidirectional binding between a local scope property and an expression
/src/angular.js:6653: *   passed via the attribute `attr`. The expression is evaluated in the context of the parent scope.
/src/angular.js-6654- *   If no `attr` name is specified then the attribute name is assumed to be the same as the local
##############################################
/src/angular.js-6665- *   equality check is done by value (using the {@link angular.equals} function). It's also possible
/src/angular.js:6666: *   to watch the evaluated value shallowly with {@link ng.$rootScope.Scope#$watchCollection
/src/angular.js-6667- *   `$watchCollection`}: use `=*` or `=*attr` (`=*?` or `=*?attr` if the attribute is optional).
##############################################
/src/angular.js-7079- *   the only way to easily get the actual value because during the linking phase the interpolation
/src/angular.js:7080: *   hasn't been evaluated yet and so the value is at this time set to `undefined`.
/src/angular.js-7081- *
##############################################
/src/angular.js-7115-                 // watch the 'compile' expression for changes
/src/angular.js:7116:                return scope.$eval(attrs.compile);
/src/angular.js-7117-              },
##############################################
/src/angular.js-7712-        listeners.push(fn);
/src/angular.js:7713:        $rootScope.$evalAsync(function() {
/src/angular.js-7714-          if (!listeners.$$inter && attrs.hasOwnProperty(key) && !isUndefined(attrs[key])) {
##############################################
/src/angular.js-7791-        if (domNode.nodeType === NODE_TYPE_TEXT && domNode.nodeValue.match(NOT_EMPTY) /* non-empty */) {
/src/angular.js:7792:          jqLiteWrapNode(domNode, $compileNodes[i] = document.createElement('span'));
/src/angular.js-7793-        }
##############################################
/src/angular.js-8277-            $compileNode = templateAttrs.$$element =
/src/angular.js:8278:                jqLite(document.createComment(' ' + directiveName + ': ' +
/src/angular.js-8279-                                              templateAttrs[directiveName] + ' '));
##############################################
/src/angular.js-8911-      case 'math':
/src/angular.js:8912:        var wrapper = document.createElement('div');
/src/angular.js-8913-        wrapper.innerHTML = '<' + type + '>' + template + '</' + type + '>';
##############################################
/src/angular.js-9052-      // TODO(perf): what's this document fragment for? is it needed? can we at least reuse it?
/src/angular.js:9053:      var fragment = document.createDocumentFragment();
/src/angular.js-9054-      fragment.appendChild(firstElementToRemove);
##############################################
/src/angular.js-9375-     *    * check if a controller with given name is registered via `$controllerProvider`
/src/angular.js:9376:     *    * check if evaluating the string on the current scope returns a constructor
/src/angular.js-9377-     *    * if $controllerProvider#allowGlobals, check `window[constructor]` on the global
##############################################
/src/angular.js-11076-    // we can't use jQuery/jqLite here because jQuery does crazy stuff with script elements, e.g.:
/src/angular.js:11077:    // - fetches local scripts via XHR and evals them
/src/angular.js-11078-    // - adds and immediately removes script elements from the document
##############################################
/src/angular.js-11255-     * `true`, the interpolation function will return `undefined` unless all embedded expressions
/src/angular.js:11256:     * evaluate to a value other than `undefined`.
/src/angular.js-11257-     *
##############################################
/src/angular.js-11324-     * @param {boolean=} allOrNothing if `true`, then the returned function returns undefined
/src/angular.js:11325:     *    unless all embedded expressions evaluate to a value other than `undefined`.
/src/angular.js-11326-     * @returns {function(context)} an interpolation function which is used to compute the
##############################################
/src/angular.js-11328-     *
/src/angular.js:11329:     * - `context`: evaluation context for all expressions embedded in the interpolated text
/src/angular.js-11330-     */
##############################################
/src/angular.js-11477-      * @description
/src/angular.js:11478:      * Angular's wrapper for `window.setInterval`. The `fn` function is executed every `delay`
/src/angular.js-11479-      * milliseconds.
##############################################
/src/angular.js-11600-          args = hasParams ? sliceArgs(arguments, 4) : [],
/src/angular.js:11601:          setInterval = $window.setInterval,
/src/angular.js-11602-          clearInterval = $window.clearInterval,
##############################################
/src/angular.js-12158-   * @ngdoc method
/src/angular.js:12159:   * @name $location#search
/src/angular.js-12160-   *
##############################################
/src/angular.js-12170-   * // given url http://example.com/#/some/path?foo=bar&baz=xoxo
/src/angular.js:12171:   * var searchObject = $location.search();
/src/angular.js-12172-   * // => {foo: 'bar', baz: 'xoxo'}
##############################################
/src/angular.js-12174-   * // set foo to 'yipee'
/src/angular.js:12175:   * $location.search('foo', 'yipee');
/src/angular.js:12176:   * // $location.search() => {foo: 'yipee', baz: 'xoxo'}
/src/angular.js-12177-   * ```
##############################################
/src/angular.js-12219-          throw $locationMinErr('isrcharg',
/src/angular.js:12220:              'The first argument of the `$location#search()` call must be a string or an object.');
/src/angular.js-12221-        }
##############################################
/src/angular.js-12236-   * @ngdoc method
/src/angular.js:12237:   * @name $location#hash
/src/angular.js-12238-   *
##############################################
/src/angular.js-12248-   * // given url http://example.com/#/some/path?foo=bar&baz=xoxo#hashValue
/src/angular.js:12249:   * var hash = $location.hash();
/src/angular.js-12250-   * // => "hashValue"
##############################################
/src/angular.js-12343- * The $location service parses the URL in the browser address bar (based on the
/src/angular.js:12344: * [window.location](https://developer.mozilla.org/en/window.location)) and makes the URL
/src/angular.js-12345- * available to your application. Changes to the URL in the address bar are reflected into
##############################################
/src/angular.js-12577-        // If we are navigating outside of the app then force a reload
/src/angular.js:12578:        $window.location.href = newUrl;
/src/angular.js-12579-        return;
##############################################
/src/angular.js-12581-
/src/angular.js:12582:      $rootScope.$evalAsync(function() {
/src/angular.js-12583-        var oldUrl = $location.absUrl();
##############################################
/src/angular.js-12620-
/src/angular.js:12621:        $rootScope.$evalAsync(function() {
/src/angular.js-12622-          var newUrl = $location.absUrl();
##############################################
/src/angular.js-12644-
/src/angular.js:12645:      // we don't need to return anything because $evalAsync will make the digest loop dirty when
/src/angular.js-12646-      // there is a change
##############################################
/src/angular.js-14527- *    * `context` – `{object}` – an object against which any expressions embedded in the strings
/src/angular.js:14528: *      are evaluated against (typically a scope object).
/src/angular.js-14529- *    * `locals` – `{object=}` – local variables context object, useful for overriding values in
##############################################
/src/angular.js-15022-    return qFactory(function(callback) {
/src/angular.js:15023:      $rootScope.$evalAsync(callback);
/src/angular.js-15024-    }, $exceptionHandler);
##############################################
/src/angular.js-15728-       * After a watcher is registered with the scope, the `listener` fn is called asynchronously
/src/angular.js:15729:       * (via {@link ng.$rootScope.Scope#$evalAsync $evalAsync}) to initialize the
/src/angular.js-15730-       * watcher. In rare cases, this is undesirable because the listener is called when the result
##############################################
/src/angular.js-15794-       *
/src/angular.js:15795:       * @param {(function()|string)} watchExpression Expression that is evaluated on each
/src/angular.js-15796-       *    {@link ng.$rootScope.Scope#$digest $digest} cycle. A change in the return value triggers
##############################################
/src/angular.js-15884-          var shouldCall = true;
/src/angular.js:15885:          self.$evalAsync(function() {
/src/angular.js-15886-            if (shouldCall) listener(newValues, newValues, self);
##############################################
/src/angular.js-15907-              changeReactionScheduled = true;
/src/angular.js:15908:              self.$evalAsync(watchGroupAction);
/src/angular.js-15909-            }
##############################################
/src/angular.js-15972-       * @param {string|function(scope)} obj Evaluated as {@link guide/expression expression}. The
/src/angular.js:15973:       *    expression value should evaluate to an object or an array which is observed on each
/src/angular.js-15974-       *    {@link ng.$rootScope.Scope#$digest $digest} cycle. Any shallow change within the
##############################################
/src/angular.js-16185-          // If this is the root scope, and $applyAsync has scheduled a deferred $apply(), then
/src/angular.js:16186:          // cancel the scheduled $apply and flush the queue of expressions to be evaluated.
/src/angular.js-16187-          $browser.defer.cancel(applyAsyncId);
##############################################
/src/angular.js-16199-              asyncTask = asyncQueue.shift();
/src/angular.js:16200:              asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);
/src/angular.js-16201-            } catch (e) {
##############################################
/src/angular.js-16345-        // Disable listeners, watchers and apply/digest methods
/src/angular.js:16346:        this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
/src/angular.js-16347-        this.$on = this.$watch = this.$watchGroup = function() { return noop; };
##############################################
/src/angular.js-16356-       * @ngdoc method
/src/angular.js:16357:       * @name $rootScope.Scope#$eval
/src/angular.js-16358-       * @kind function
##############################################
/src/angular.js-16361-       * Executes the `expression` on the current scope and returns the result. Any exceptions in
/src/angular.js:16362:       * the expression are propagated (uncaught). This is useful when evaluating Angular
/src/angular.js-16363-       * expressions.
##############################################
/src/angular.js-16370-
/src/angular.js:16371:           expect(scope.$eval('a+b')).toEqual(3);
/src/angular.js:16372:           expect(scope.$eval(function(scope){ return scope.a + scope.b; })).toEqual(3);
/src/angular.js-16373-       * ```
##############################################
/src/angular.js-16380-       * @param {(object)=} locals Local variables object, useful for overriding values in scope.
/src/angular.js:16381:       * @returns {*} The result of evaluating the expression.
/src/angular.js-16382-       */
/src/angular.js:16383:      $eval: function(expr, locals) {
/src/angular.js-16384-        return $parse(expr)(this, locals);
##############################################
/src/angular.js-16388-       * @ngdoc method
/src/angular.js:16389:       * @name $rootScope.Scope#$evalAsync
/src/angular.js-16390-       * @kind function
##############################################
/src/angular.js-16394-       *
/src/angular.js:16395:       * The `$evalAsync` makes no guarantees as to when the `expression` will be executed, only
/src/angular.js-16396-       * that:
/src/angular.js-16397-       *
/src/angular.js:16398:       *   - it will execute after the function that scheduled the evaluation (preferably before DOM
/src/angular.js-16399-       *     rendering).
##############################################
/src/angular.js-16407-       * will be scheduled. However, it is encouraged to always call code that changes the model
/src/angular.js:16408:       * from within an `$apply` call. That includes code evaluated via `$evalAsync`.
/src/angular.js-16409-       *
##############################################
/src/angular.js-16416-       */
/src/angular.js:16417:      $evalAsync: function(expr, locals) {
/src/angular.js-16418-        // if we are outside of an $digest loop and this is the first time we are scheduling async
##############################################
/src/angular.js-16452-             try {
/src/angular.js:16453:               return $eval(expr);
/src/angular.js-16454-             } catch (e) {
##############################################
/src/angular.js-16465-       * 1. The {@link guide/expression expression} is executed using the
/src/angular.js:16466:       *    {@link ng.$rootScope.Scope#$eval $eval()} method.
/src/angular.js-16467-       * 2. Any exceptions from the execution of the expression are forwarded to the
##############################################
/src/angular.js-16477-       *
/src/angular.js:16478:       * @returns {*} The result of evaluating the expression.
/src/angular.js-16479-       */
##############################################
/src/angular.js-16483-          try {
/src/angular.js:16484:            return this.$eval(expr);
/src/angular.js-16485-          } finally {
##############################################
/src/angular.js-16508-       *
/src/angular.js:16509:       * This can be used to queue up multiple expressions which need to be evaluated in the same
/src/angular.js-16510-       * digest.
##############################################
/src/angular.js-16523-        function $applyAsyncExpression() {
/src/angular.js:16524:          scope.$eval(expr);
/src/angular.js-16525-        }
##############################################
/src/angular.js-17661-     *    * `context` – `{object}` – an object against which any expressions embedded in the strings
/src/angular.js:17662:     *      are evaluated against (typically a scope object).
/src/angular.js-17663-     *    * `locals` – `{object=}` – local variables context object, useful for overriding values in
##############################################
/src/angular.js-17845-     *    * `context` – `{object}` – an object against which any expressions embedded in the strings
/src/angular.js:17846:     *      are evaluated against (typically a scope object).
/src/angular.js-17847-     *    * `locals` – `{object=}` – local variables context object, useful for overriding values in
##############################################
/src/angular.js-17862-     *    * `context` – `{object}` – an object against which any expressions embedded in the strings
/src/angular.js:17863:     *      are evaluated against (typically a scope object).
/src/angular.js-17864-     *    * `locals` – `{object=}` – local variables context object, useful for overriding values in
##############################################
/src/angular.js-17879-     *    * `context` – `{object}` – an object against which any expressions embedded in the strings
/src/angular.js:17880:     *      are evaluated against (typically a scope object).
/src/angular.js-17881-     *    * `locals` – `{object=}` – local variables context object, useful for overriding values in
##############################################
/src/angular.js-17896-     *    * `context` – `{object}` – an object against which any expressions embedded in the strings
/src/angular.js:17897:     *      are evaluated against (typically a scope object).
/src/angular.js-17898-     *    * `locals` – `{object=}` – local variables context object, useful for overriding values in
##############################################
/src/angular.js-17913-     *    * `context` – `{object}` – an object against which any expressions embedded in the strings
/src/angular.js:17914:     *      are evaluated against (typically a scope object).
/src/angular.js-17915-     *    * `locals` – `{object=}` – local variables context object, useful for overriding values in
##############################################
/src/angular.js-17963-        vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/,
/src/angular.js:17964:        bodyStyle = document.body && document.body.style,
/src/angular.js-17965-        transitions = false,
##############################################
/src/angular.js-18012-        if (isUndefined(eventSupport[event])) {
/src/angular.js:18013:          var divElm = document.createElement('div');
/src/angular.js-18014-          eventSupport[event] = 'on' + event in divElm;
##############################################
/src/angular.js-18228-      * @description
/src/angular.js:18229:      * Angular's wrapper for `window.setTimeout`. The `fn` function is wrapped into a try/catch
/src/angular.js-18230-      * block and delegates any exceptions to
##############################################
/src/angular.js-18318-// service.
/src/angular.js:18319:var urlParsingNode = document.createElement("a");
/src/angular.js:18320:var originUrl = urlResolve(window.location.href);
/src/angular.js-18321-
##############################################
/src/angular.js-18418- * Expressions, like the one defined for the `ngClick` directive in the example
/src/angular.js:18419: * below, are evaluated with respect to the current scope.  Therefore, there is
/src/angular.js-18420- * no risk of inadvertently coding in a dependency on a global value in such an
##############################################
/src/angular.js-18430-             $scope.doGreeting = function(greeting) {
/src/angular.js:18431:               $window.alert(greeting);
/src/angular.js-18432-             };
##############################################
/src/angular.js-19938-    var predicates = processPredicates(sortPredicate, reverseOrder);
/src/angular.js:19939:    // Add a predicate at the end that evaluates to the element index. This makes the
/src/angular.js-19940-    // sort stable as it works as a tie-breaker when all the input predicates cannot
##############################################
/src/angular.js-20252- * This directive sets the `disabled` attribute on the element if the
/src/angular.js:20253: * {@link guide/expression expression} inside `ngDisabled` evaluates to truthy.
/src/angular.js-20254- *
##############################################
/src/angular.js-20421-
/src/angular.js:20422:// boolean attrs are evaluated
/src/angular.js-20423-forEach(BOOLEAN_ATTR, function(propName, attrName) {
##############################################
/src/angular.js-20453-
/src/angular.js:20454:// aliased input attrs are evaluated
/src/angular.js-20455-forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
##############################################
/src/angular.js-21115-   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
/src/angular.js:21116:   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
/src/angular.js-21117-   *    `required` when you want to data-bind to the `required` attribute.
##############################################
/src/angular.js-21126-   * @param {string=} ngPattern Sets `pattern` validation error key if the ngModel value does not match
/src/angular.js:21127:   *    a RegExp found by evaluating the Angular expression given in the attribute value.
/src/angular.js:21128:   *    If the expression evaluates to a RegExp object, then this is used directly.
/src/angular.js:21129:   *    If the expression evaluates to a string, then it will be converted to a RegExp
/src/angular.js-21130-   *    after wrapping it in `^` and `$` characters. For instance, `"abc"` will be converted to
##############################################
/src/angular.js-21227-     * @param {(date|string)=} ngMin Sets the `min` validation constraint to the Date / ISO date string
/src/angular.js:21228:     *   the `ngMin` expression evaluates to. Note that it does not set the `min` attribute.
/src/angular.js-21229-     * @param {(date|string)=} ngMax Sets the `max` validation constraint to the Date / ISO date string
/src/angular.js:21230:     *   the `ngMax` expression evaluates to. Note that it does not set the `max` attribute.
/src/angular.js-21231-     * @param {string=} required Sets `required` validation error key if the value is not entered.
/src/angular.js-21232-     * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
/src/angular.js:21233:     *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
/src/angular.js-21234-     *    `required` when you want to data-bind to the `required` attribute.
##############################################
/src/angular.js-21330-    * @param {(date|string)=} ngMin Sets the `min` validation error key to the Date / ISO datetime string
/src/angular.js:21331:    *   the `ngMin` expression evaluates to. Note that it does not set the `min` attribute.
/src/angular.js-21332-    * @param {(date|string)=} ngMax Sets the `max` validation error key to the Date / ISO datetime string
/src/angular.js:21333:    *   the `ngMax` expression evaluates to. Note that it does not set the `max` attribute.
/src/angular.js-21334-    * @param {string=} required Sets `required` validation error key if the value is not entered.
/src/angular.js-21335-    * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
/src/angular.js:21336:    *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
/src/angular.js-21337-    *    `required` when you want to data-bind to the `required` attribute.
##############################################
/src/angular.js-21434-   * @param {(date|string)=} ngMin Sets the `min` validation constraint to the Date / ISO time string the
/src/angular.js:21435:   *   `ngMin` expression evaluates to. Note that it does not set the `min` attribute.
/src/angular.js-21436-   * @param {(date|string)=} ngMax Sets the `max` validation constraint to the Date / ISO time string the
/src/angular.js:21437:   *   `ngMax` expression evaluates to. Note that it does not set the `max` attribute.
/src/angular.js-21438-   * @param {string=} required Sets `required` validation error key if the value is not entered.
/src/angular.js-21439-   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
/src/angular.js:21440:   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
/src/angular.js-21441-   *    `required` when you want to data-bind to the `required` attribute.
##############################################
/src/angular.js-21537-    * @param {(date|string)=} ngMin Sets the `min` validation constraint to the Date / ISO week string
/src/angular.js:21538:    *   the `ngMin` expression evaluates to. Note that it does not set the `min` attribute.
/src/angular.js-21539-    * @param {(date|string)=} ngMax Sets the `max` validation constraint to the Date / ISO week string
/src/angular.js:21540:    *   the `ngMax` expression evaluates to. Note that it does not set the `max` attribute.
/src/angular.js-21541-    * @param {string=} required Sets `required` validation error key if the value is not entered.
/src/angular.js-21542-    * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
/src/angular.js:21543:    *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
/src/angular.js-21544-    *    `required` when you want to data-bind to the `required` attribute.
##############################################
/src/angular.js-21642-   * @param {(date|string)=} ngMin Sets the `min` validation constraint to the Date / ISO week string
/src/angular.js:21643:   *   the `ngMin` expression evaluates to. Note that it does not set the `min` attribute.
/src/angular.js-21644-   * @param {(date|string)=} ngMax Sets the `max` validation constraint to the Date / ISO week string
/src/angular.js:21645:   *   the `ngMax` expression evaluates to. Note that it does not set the `max` attribute.
/src/angular.js-21646-
##############################################
/src/angular.js-21648-   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
/src/angular.js:21649:   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
/src/angular.js-21650-   *    `required` when you want to data-bind to the `required` attribute.
##############################################
/src/angular.js-21750-   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
/src/angular.js:21751:   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
/src/angular.js-21752-   *    `required` when you want to data-bind to the `required` attribute.
##############################################
/src/angular.js-21761-   * @param {string=} ngPattern Sets `pattern` validation error key if the ngModel value does not match
/src/angular.js:21762:   *    a RegExp found by evaluating the Angular expression given in the attribute value.
/src/angular.js:21763:   *    If the expression evaluates to a RegExp object, then this is used directly.
/src/angular.js:21764:   *    If the expression evaluates to a string, then it will be converted to a RegExp
/src/angular.js-21765-   *    after wrapping it in `^` and `$` characters. For instance, `"abc"` will be converted to
##############################################
/src/angular.js-21848-   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
/src/angular.js:21849:   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
/src/angular.js-21850-   *    `required` when you want to data-bind to the `required` attribute.
##############################################
/src/angular.js-21859-   * @param {string=} ngPattern Sets `pattern` validation error key if the ngModel value does not match
/src/angular.js:21860:   *    a RegExp found by evaluating the Angular expression given in the attribute value.
/src/angular.js:21861:   *    If the expression evaluates to a RegExp object, then this is used directly.
/src/angular.js:21862:   *    If the expression evaluates to a string, then it will be converted to a RegExp
/src/angular.js-21863-   *    after wrapping it in `^` and `$` characters. For instance, `"abc"` will be converted to
##############################################
/src/angular.js-21947-   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
/src/angular.js:21948:   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
/src/angular.js-21949-   *    `required` when you want to data-bind to the `required` attribute.
##############################################
/src/angular.js-21958-   * @param {string=} ngPattern Sets `pattern` validation error key if the ngModel value does not match
/src/angular.js:21959:   *    a RegExp found by evaluating the Angular expression given in the attribute value.
/src/angular.js:21960:   *    If the expression evaluates to a RegExp object, then this is used directly.
/src/angular.js:21961:   *    If the expression evaluates to a string, then it will be converted to a RegExp
/src/angular.js-21962-   *    after wrapping it in `^` and `$` characters. For instance, `"abc"` will be converted to
##############################################
/src/angular.js-22206-    // If a control is suffering from bad input (due to native validators), browsers discard its
/src/angular.js:22207:    // value, so it may be necessary to revalidate (by calling $setViewValue again) even if the
/src/angular.js-22208-    // control's value is the same empty value twice in a row.
##############################################
/src/angular.js-22607- * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
/src/angular.js:22608: *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
/src/angular.js-22609- *    `required` when you want to data-bind to the `required` attribute.
##############################################
/src/angular.js-22615- * @param {string=} ngPattern Sets `pattern` validation error key if the ngModel value does not match
/src/angular.js:22616: *    a RegExp found by evaluating the Angular expression given in the attribute value.
/src/angular.js:22617: *    If the expression evaluates to a RegExp object, then this is used directly.
/src/angular.js:22618: *    If the expression evaluates to a string, then it will be converted to a RegExp
/src/angular.js-22619- *    after wrapping it in `^` and `$` characters. For instance, `"abc"` will be converted to
##############################################
/src/angular.js-22654- * @param {string=} ngPattern Sets `pattern` validation error key if the ngModel value does not match
/src/angular.js:22655: *    a RegExp found by evaluating the Angular expression given in the attribute value.
/src/angular.js:22656: *    If the expression evaluates to a RegExp object, then this is used directly.
/src/angular.js:22657: *    If the expression evaluates to a string, then it will be converted to a RegExp
/src/angular.js-22658- *    after wrapping it in `^` and `$` characters. For instance, `"abc"` will be converted to
##############################################
/src/angular.js-22849-        return function ngValueConstantLink(scope, elm, attr) {
/src/angular.js:22850:          attr.$set('value', scope.$eval(attr.ngValue));
/src/angular.js-22851-        };
##############################################
/src/angular.js-22884- * @element ANY
/src/angular.js:22885: * @param {expression} ngBind {@link guide/expression Expression} to evaluate.
/src/angular.js-22886- *
##############################################
/src/angular.js-22944- * @param {string} ngBindTemplate template of form
/src/angular.js:22945: *   <tt>{{</tt> <tt>expression</tt> <tt>}}</tt> to eval.
/src/angular.js-22946- *
##############################################
/src/angular.js-23017- * @element ANY
/src/angular.js:23018: * @param {expression} ngBindHtml {@link guide/expression Expression} to evaluate.
/src/angular.js-23019- *
##############################################
/src/angular.js-23075- * Evaluate the given expression when the user changes the input.
/src/angular.js:23076: * The expression is evaluated immediately, unlike the JavaScript onchange event
/src/angular.js-23077- * which only triggers at the end of a change (usually, when the user leaves the
##############################################
/src/angular.js-23079- *
/src/angular.js:23080: * The `ngChange` expression is only evaluated when a change in the input value causes
/src/angular.js-23081- * a new value to be committed to the model.
/src/angular.js-23082- *
/src/angular.js:23083: * It will not be evaluated:
/src/angular.js-23084- * * if the value returned from the `$parsers` transformation pipeline has not changed
##############################################
/src/angular.js-23091- * @element input
/src/angular.js:23092: * @param {expression} ngChange {@link guide/expression Expression} to evaluate upon change
/src/angular.js-23093- * in input value.
##############################################
/src/angular.js-23118- *
/src/angular.js:23119: *     it('should evaluate the expression if changing from view', function() {
/src/angular.js-23120- *       expect(counter.getText()).toContain('0');
##############################################
/src/angular.js-23127- *
/src/angular.js:23128: *     it('should not evaluate the expression if changing from model', function() {
/src/angular.js-23129- *       element(by.id('ng-change-example2')).click();
##############################################
/src/angular.js-23141-    ctrl.$viewChangeListeners.push(function() {
/src/angular.js:23142:      scope.$eval(attr.ngChange);
/src/angular.js-23143-    });
##############################################
/src/angular.js-23157-        attr.$observe('class', function(value) {
/src/angular.js:23158:          ngClassWatchAction(scope.$eval(attr[name]));
/src/angular.js-23159-        });
##############################################
/src/angular.js-23166-            if (mod !== (old$index & 1)) {
/src/angular.js:23167:              var classes = arrayClasses(scope.$eval(attr[name]));
/src/angular.js-23168-              mod === selector ?
##############################################
/src/angular.js-23279- * The directive operates in three different ways, depending on which of three types the expression
/src/angular.js:23280: * evaluates to:
/src/angular.js-23281- *
/src/angular.js:23282: * 1. If the expression evaluates to a string, the string should be one or more space-delimited class
/src/angular.js-23283- * names.
/src/angular.js-23284- *
/src/angular.js:23285: * 2. If the expression evaluates to an object, then for each key-value pair of the
/src/angular.js-23286- * object with a truthy value the corresponding key is used as a class name.
/src/angular.js-23287- *
/src/angular.js:23288: * 3. If the expression evaluates to an array, each element of the array should either be a string as in
/src/angular.js-23289- * type 1 or an object as in type 2. This means that you can mix strings and objects together in an array
##############################################
/src/angular.js-23303- * @element ANY
/src/angular.js:23304: * @param {expression} ngClass {@link guide/expression Expression} to eval. The result
/src/angular.js:23305: *   of the evaluation can be a string representing space delimited class
/src/angular.js-23306- *   names, an array, or a map of class names to boolean values. In the case of a map, the
##############################################
/src/angular.js-23462- * @element ANY
/src/angular.js:23463: * @param {expression} ngClassOdd {@link guide/expression Expression} to eval. The result
/src/angular.js:23464: *   of the evaluation can be a string representing space delimited class names or an array.
/src/angular.js-23465- *
##############################################
/src/angular.js-23510- * @element ANY
/src/angular.js:23511: * @param {expression} ngClassEven {@link guide/expression Expression} to eval. The
/src/angular.js:23512: *   result of the evaluation can be a string representing space delimited class names or an array.
/src/angular.js-23513- *
##############################################
/src/angular.js-23629- * {@link ng.$controllerProvider $controllerProvider} or an {@link guide/expression expression}
/src/angular.js:23630: * that on the current scope evaluates to a constructor function.
/src/angular.js-23631- *
##############################################
/src/angular.js-23855- *
/src/angular.js:23856: * * `unsafe-eval`: this rule forbids apps to use `eval` or `Function(string)` generated functions
/src/angular.js-23857- * (among other things). Angular makes use of this in the {@link $parse} service to provide a 30%
/src/angular.js:23858: * increase in the speed of evaluating Angular expressions.
/src/angular.js-23859- *
##############################################
/src/angular.js-23864- *
/src/angular.js:23865: * If you do not provide `ngCsp` then Angular tries to autodetect if CSP is blocking unsafe-eval
/src/angular.js-23866- * and automatically deactivates this feature in the {@link $parse} service. This autodetection,
##############################################
/src/angular.js-23869- * ```
/src/angular.js:23870: * Refused to evaluate a string as JavaScript because 'unsafe-eval' is not an allowed source of
/src/angular.js-23871- * script in the following Content Security Policy directive: "default-src 'self'". Note that
##############################################
/src/angular.js-23885- *
/src/angular.js:23886: * * no-unsafe-eval: this stops Angular from optimising $parse with unsafe eval of strings
/src/angular.js-23887- *
##############################################
/src/angular.js-23891- * * No declaration means that Angular will assume that you can do inline styles, but it will do
/src/angular.js:23892: * a runtime check for unsafe-eval. E.g. `<body>`. This is backwardly compatible with previous versions
/src/angular.js-23893- * of Angular.
##############################################
/src/angular.js-23895- * * A simple `ng-csp` (or `data-ng-csp`) attribute will tell Angular to deactivate both inline
/src/angular.js:23896: * styles and unsafe eval. E.g. `<body ng-csp>`. This is backwardly compatible with previous versions
/src/angular.js-23897- * of Angular.
/src/angular.js-23898- *
/src/angular.js:23899: * * Specifying only `no-unsafe-eval` tells Angular that we must not use eval, but that we can inject
/src/angular.js:23900: * inline styles. E.g. `<body ng-csp="no-unsafe-eval">`.
/src/angular.js-23901- *
/src/angular.js-23902- * * Specifying only `no-inline-style` tells Angular that we must not inject styles, but that we can
/src/angular.js:23903: * run eval - no automcatic check for unsafe eval will occur. E.g. `<body ng-csp="no-inline-style">`
/src/angular.js-23904- *
/src/angular.js:23905: * * Specifying both `no-unsafe-eval` and `no-inline-style` tells Angular that we must not inject
/src/angular.js:23906: * styles nor use eval, which is the same as an empty: ng-csp.
/src/angular.js:23907: * E.g.`<body ng-csp="no-inline-style;no-unsafe-eval">`
/src/angular.js-23908- *
##############################################
/src/angular.js-23948-                  try {
/src/angular.js:23949:                    eval('1+2');
/src/angular.js-23950-                  } catch (e) {
##############################################
/src/angular.js-24021-
/src/angular.js:24022:          it('should evaluate expressions', function() {
/src/angular.js-24023-            expect(counter.getText()).toEqual('0');
##############################################
/src/angular.js-24028-
/src/angular.js:24029:          it('should throw and report an error when using "eval"', function() {
/src/angular.js-24030-            evilBtn.click();
##############################################
/src/angular.js-24051- * @priority 0
/src/angular.js:24052: * @param {expression} ngClick {@link guide/expression Expression} to evaluate upon
/src/angular.js-24053- * click. ({@link guide/expression#-event- Event object is available as `$event`})
##############################################
/src/angular.js-24080-// For events that might fire synchronously during DOM manipulation
/src/angular.js:24081:// we need to execute their event handlers asynchronously using $evalAsync,
/src/angular.js-24082-// so that they are not executed in an inconsistent state.
##############################################
/src/angular.js-24105-              if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
/src/angular.js:24106:                scope.$evalAsync(callback);
/src/angular.js-24107-              } else {
##############################################
/src/angular.js-24126- * @priority 0
/src/angular.js:24127: * @param {expression} ngDblclick {@link guide/expression Expression} to evaluate upon
/src/angular.js-24128- * a dblclick. (The Event object is available as `$event`)
##############################################
/src/angular.js-24150- * @priority 0
/src/angular.js:24151: * @param {expression} ngMousedown {@link guide/expression Expression} to evaluate upon
/src/angular.js-24152- * mousedown. ({@link guide/expression#-event- Event object is available as `$event`})
##############################################
/src/angular.js-24174- * @priority 0
/src/angular.js:24175: * @param {expression} ngMouseup {@link guide/expression Expression} to evaluate upon
/src/angular.js-24176- * mouseup. ({@link guide/expression#-event- Event object is available as `$event`})
##############################################
/src/angular.js-24197- * @priority 0
/src/angular.js:24198: * @param {expression} ngMouseover {@link guide/expression Expression} to evaluate upon
/src/angular.js-24199- * mouseover. ({@link guide/expression#-event- Event object is available as `$event`})
##############################################
/src/angular.js-24221- * @priority 0
/src/angular.js:24222: * @param {expression} ngMouseenter {@link guide/expression Expression} to evaluate upon
/src/angular.js-24223- * mouseenter. ({@link guide/expression#-event- Event object is available as `$event`})
##############################################
/src/angular.js-24245- * @priority 0
/src/angular.js:24246: * @param {expression} ngMouseleave {@link guide/expression Expression} to evaluate upon
/src/angular.js-24247- * mouseleave. ({@link guide/expression#-event- Event object is available as `$event`})
##############################################
/src/angular.js-24269- * @priority 0
/src/angular.js:24270: * @param {expression} ngMousemove {@link guide/expression Expression} to evaluate upon
/src/angular.js-24271- * mousemove. ({@link guide/expression#-event- Event object is available as `$event`})
##############################################
/src/angular.js-24293- * @priority 0
/src/angular.js:24294: * @param {expression} ngKeydown {@link guide/expression Expression} to evaluate upon
/src/angular.js-24295- * keydown. (Event object is available as `$event` and can be interrogated for keyCode, altKey, etc.)
##############################################
/src/angular.js-24315- * @priority 0
/src/angular.js:24316: * @param {expression} ngKeyup {@link guide/expression Expression} to evaluate upon
/src/angular.js-24317- * keyup. (Event object is available as `$event` and can be interrogated for keyCode, altKey, etc.)
##############################################
/src/angular.js-24341- * @element ANY
/src/angular.js:24342: * @param {expression} ngKeypress {@link guide/expression Expression} to evaluate upon
/src/angular.js-24343- * keypress. ({@link guide/expression#-event- Event object is available as `$event`}
##############################################
/src/angular.js-24375- * @priority 0
/src/angular.js:24376: * @param {expression} ngSubmit {@link guide/expression Expression} to eval.
/src/angular.js-24377- * ({@link guide/expression#-event- Event object is available as `$event`})
##############################################
/src/angular.js-24426- * Note: As the `focus` event is executed synchronously when calling `input.focus()`
/src/angular.js:24427: * AngularJS executes the expression using `scope.$evalAsync` if the event is fired
/src/angular.js-24428- * during an `$apply` to ensure a consistent state.
##############################################
/src/angular.js-24431- * @priority 0
/src/angular.js:24432: * @param {expression} ngFocus {@link guide/expression Expression} to evaluate upon
/src/angular.js-24433- * focus. ({@link guide/expression#-event- Event object is available as `$event`})
##############################################
/src/angular.js-24450- * (e.g. removing a focussed input),
/src/angular.js:24451: * AngularJS executes the expression using `scope.$evalAsync` if the event is fired
/src/angular.js-24452- * during an `$apply` to ensure a consistent state.
##############################################
/src/angular.js-24455- * @priority 0
/src/angular.js:24456: * @param {expression} ngBlur {@link guide/expression Expression} to evaluate upon
/src/angular.js-24457- * blur. ({@link guide/expression#-event- Event object is available as `$event`})
##############################################
/src/angular.js-24471- * @priority 0
/src/angular.js:24472: * @param {expression} ngCopy {@link guide/expression Expression} to evaluate upon
/src/angular.js-24473- * copy. ({@link guide/expression#-event- Event object is available as `$event`})
##############################################
/src/angular.js-24492- * @priority 0
/src/angular.js:24493: * @param {expression} ngCut {@link guide/expression Expression} to evaluate upon
/src/angular.js-24494- * cut. ({@link guide/expression#-event- Event object is available as `$event`})
##############################################
/src/angular.js-24513- * @priority 0
/src/angular.js:24514: * @param {expression} ngPaste {@link guide/expression Expression} to evaluate upon
/src/angular.js-24515- * paste. ({@link guide/expression#-event- Event object is available as `$event`})
##############################################
/src/angular.js-24533- * The `ngIf` directive removes or recreates a portion of the DOM tree based on an
/src/angular.js:24534: * {expression}. If the expression assigned to `ngIf` evaluates to a false
/src/angular.js-24535- * value then the element is removed from the DOM, otherwise a clone of the
##############################################
/src/angular.js-24617-                childScope = newScope;
/src/angular.js:24618:                clone[clone.length++] = document.createComment(' end ngIf: ' + $attr.ngIf + ' ');
/src/angular.js-24619-                // Note: We only need the first/last node of the cloned nodes.
##############################################
/src/angular.js-24680- *
/src/angular.js:24681: * @param {string} ngInclude|src angular expression evaluating to URL. If the source is a string constant,
/src/angular.js-24682- *                 make sure you wrap it in **single** quotes, e.g. `src="'myPartialTemplate.html'"`.
/src/angular.js:24683: * @param {string=} onload Expression to evaluate when a new partial is loaded.
/src/angular.js-24684- *                  <div class="alert alert-warning">
##############################################
/src/angular.js-24695- *                  - If the attribute is set without value, enable scrolling.
/src/angular.js:24696: *                  - Otherwise enable scrolling only if the expression evaluates to truthy value.
/src/angular.js-24697- *
##############################################
/src/angular.js-24871-          var afterAnimation = function() {
/src/angular.js:24872:            if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
/src/angular.js-24873-              $anchorScroll();
##############################################
/src/angular.js-24902-              currentScope.$emit('$includeContentLoaded', src);
/src/angular.js:24903:              scope.$eval(onloadExp);
/src/angular.js-24904-            }, function() {
##############################################
/src/angular.js-24958- * @description
/src/angular.js:24959: * The `ngInit` directive allows you to evaluate an expression in the
/src/angular.js-24960- * current scope.
##############################################
/src/angular.js-24980- * @element ANY
/src/angular.js:24981: * @param {expression} ngInit {@link guide/expression Expression} to eval.
/src/angular.js-24982- *
##############################################
/src/angular.js-25015-      pre: function(scope, element, attrs) {
/src/angular.js:25016:        scope.$eval(attrs.ngInit);
/src/angular.js-25017-      }
##############################################
/src/angular.js-25316-              element.on('blur keyup change', function() {
/src/angular.js:25317:                scope.$evalAsync(read);
/src/angular.js-25318-              });
##############################################
/src/angular.js-26045- *
/src/angular.js:26046: * Note: `ngModel` will try to bind to the property given by evaluating the expression on the
/src/angular.js-26047- * current scope. If the property doesn't already exist on this scope, it will be created
##############################################
/src/angular.js-26252-            if ($rootScope.$$phase) {
/src/angular.js:26253:              scope.$evalAsync(modelCtrl.$setTouched);
/src/angular.js-26254-            } else {
##############################################
/src/angular.js-26431-      var that = this;
/src/angular.js:26432:      this.$options = copy($scope.$eval($attrs.ngModelOptions));
/src/angular.js-26433-      // Allow adding/overriding bound events
##############################################
/src/angular.js-26601- * The `ngOptions` attribute can be used to dynamically generate a list of `<option>`
/src/angular.js:26602: * elements for the `<select>` element using the array or object obtained by evaluating the
/src/angular.js-26603- * `ngOptions` comprehension expression.
##############################################
/src/angular.js-26693- * **`track by`** expression is also applied to the `ngModel` value. In the first example, the
/src/angular.js:26694: * `ngModel` value is `items[0]` and the **`track by`** expression evaluates to `items[0].id` with
/src/angular.js-26695- * no issue. In the second example, the `ngModel` value is `items[0].subItem` and the **`track by`**
/src/angular.js:26696: * expression evaluates to `items[0].subItem.id` (which is undefined). As a result, the model value
/src/angular.js-26697- * is not matched against any `<option>` and the `<select>` appears as having no selected value.
##############################################
/src/angular.js-26703- * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
/src/angular.js:26704: *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
/src/angular.js-26705- *    `required` when you want to data-bind to the `required` attribute.
##############################################
/src/angular.js-26728- *
/src/angular.js:26729: *   * `array` / `object`: an expression which evaluates to an array / object to iterate over.
/src/angular.js-26730- *   * `value`: local variable which will refer to each item in the `array` or each property value
##############################################
/src/angular.js-26995-  // to create it in <select> and IE barfs otherwise.
/src/angular.js:26996:  var optionTemplate = document.createElement('option'),
/src/angular.js:26997:      optGroupTemplate = document.createElement('optgroup');
/src/angular.js-26998-
##############################################
/src/angular.js-27386- * The value of the `count` attribute can be either a string or an {@link guide/expression
/src/angular.js:27387: * Angular expression}; these are evaluated on the current scope for its bound value.
/src/angular.js-27388- *
##############################################
/src/angular.js-27542-          offset = attr.offset || 0,
/src/angular.js:27543:          whens = scope.$eval(whenExp) || {},
/src/angular.js-27544-          whensExpFns = {},
##############################################
/src/angular.js-27735- *
/src/angular.js:27736: * And with an input of {@type ['A','B']} for the items variable in the example above, the output will evaluate to:
/src/angular.js-27737- * ```html
##############################################
/src/angular.js-27941-      var expression = $attr.ngRepeat;
/src/angular.js:27942:      var ngRepeatEndComment = document.createComment(' end ngRepeat: ' + expression + ' ');
/src/angular.js-27943-
##############################################
/src/angular.js-28157- *
/src/angular.js:28158: * When the `ngShow` expression evaluates to a falsy value then the `.ng-hide` CSS class is added to the class
/src/angular.js-28159- * attribute on the element causing it to become hidden. When truthy, the `.ng-hide` CSS class is removed
##############################################
/src/angular.js-28224- * @animations
/src/angular.js:28225: * addClass: `.ng-hide` - happens after the `ngShow` expression evaluates to a truthy value and the just before contents are set to visible
/src/angular.js:28226: * removeClass: `.ng-hide` - happens after the `ngShow` expression evaluates to a non truthy value and just before the contents are set to hidden
/src/angular.js-28227- *
##############################################
/src/angular.js-28331- *
/src/angular.js:28332: * When the `ngHide` expression evaluates to a truthy value then the `.ng-hide` CSS class is added to the class
/src/angular.js-28333- * attribute on the element causing it to become hidden. When falsy, the `.ng-hide` CSS class is removed
##############################################
/src/angular.js-28388- * @animations
/src/angular.js:28389: * removeClass: `.ng-hide` - happens after the `ngHide` expression evaluates to a truthy value and just before the contents are set to hidden
/src/angular.js:28390: * addClass: `.ng-hide` - happens after the `ngHide` expression evaluates to a non truthy value and just before the contents are set to visible
/src/angular.js-28391- *
##############################################
/src/angular.js-28480- *
/src/angular.js:28481: * {@link guide/expression Expression} which evals to an
/src/angular.js-28482- * object whose keys are CSS style names and values are corresponding values for those CSS
##############################################
/src/angular.js-28536- * from the template cache), `ngSwitch` simply chooses one of the nested elements and makes it visible based on which element
/src/angular.js:28537: * matches the value obtained from the evaluated expression. In other words, you define a container element
/src/angular.js-28538- * (where you place the directive), place an expression on the **`on="..."` attribute**
##############################################
/src/angular.js-28540- * a when attribute per element. The when attribute is used to inform ngSwitch which element to display when the on
/src/angular.js:28541: * expression is evaluated. If a matching expression is not found via a when attribute then an element with the default
/src/angular.js-28542- * attribute is displayed.
##############################################
/src/angular.js-28692-              var anchor = selectedTransclude.element;
/src/angular.js:28693:              caseElement[caseElement.length++] = document.createComment(' end ngSwitchWhen: ');
/src/angular.js-28694-              var block = { clone: caseElement };
##############################################
/src/angular.js-28881-  // to create it in <select> and IE barfs otherwise.
/src/angular.js:28882:  self.unknownOption = jqLite(document.createElement('option'));
/src/angular.js-28883-  self.renderUnknownOption = function(val) {
##############################################
/src/angular.js-29041- * @param {string=} ngRequired Adds required attribute and required validation constraint to
/src/angular.js:29042: * the element when the ngRequired expression evaluates to true. Use ngRequired instead of required
/src/angular.js-29043- * when you want to data-bind to the required attribute.
##############################################
/src/angular.js-29347- * The directive sets the `required` attribute on the element if the Angular expression inside
/src/angular.js:29348: * `ngRequired` evaluates to true. A special directive for setting `required` is necessary because we
/src/angular.js-29349- * cannot use interpolation inside `required`. See the {@link guide/interpolation interpolation guide}
##############################################
/src/angular.js-29423- * The validator sets the `pattern` error key if the {@link ngModel.NgModelController#$viewValue `ngModel.$viewValue`}
/src/angular.js:29424: * does not match a RegExp which is obtained by evaluating the Angular expression given in the
/src/angular.js-29425- * `ngPattern` attribute value:
/src/angular.js:29426: * * If the expression evaluates to a RegExp object, then this is used directly.
/src/angular.js:29427: * * If the expression evaluates to a string, then it will be converted to a RegExp after wrapping it
/src/angular.js-29428- * in `^` and `$` characters. For instance, `"abc"` will be converted to `new RegExp('^abc$')`.
##############################################
/src/angular.js-29529- * The validator sets the `maxlength` error key if the {@link ngModel.NgModelController#$viewValue `ngModel.$viewValue`}
/src/angular.js:29530: * is longer than the integer obtained by evaluating the Angular expression given in the
/src/angular.js-29531- * `ngMaxlength` attribute value.
##############################################
/src/angular.js-29615- * The validator sets the `minlength` error key if the {@link ngModel.NgModelController#$viewValue `ngModel.$viewValue`}
/src/angular.js:29616: * is shorter than the integer obtained by evaluating the Angular expression given in the
/src/angular.js-29617- * `ngMinlength` attribute value.
##############################################
/src/angular.min.js-9-Nb(n)?a[l]=n.clone():(K(a[l])||(a[l]=L(n)?[]:{}),Mb(a[l],[n],!0)):a[l]=n}}c?a.$$hashKey=c:delete a.$$hashKey;return a}function N(a){return Mb(a,ta.call(arguments,1),!1)}function Yd(a){return Mb(a,ta.call(arguments,1),!0)}function ca(a){return parseInt(a,10)}function Ob(a,b){return N(Object.create(a),b)}function v(){}function Za(a){return a}function ma(a){return function(){return a}}function qc(a){return G(a.toString)&&a.toString!==na}function r(a){return"undefined"===typeof a}function u(a){return"undefined"!==
/src/angular.min.js:10:typeof a}function K(a){return null!==a&&"object"===typeof a}function nc(a){return null!==a&&"object"===typeof a&&!rc(a)}function H(a){return"string"===typeof a}function P(a){return"number"===typeof a}function ea(a){return"[object Date]"===na.call(a)}function G(a){return"function"===typeof a}function La(a){return"[object RegExp]"===na.call(a)}function Ya(a){return a&&a.window===a}function $a(a){return a&&a.$evalAsync&&a.$watch}function Ma(a){return"boolean"===typeof a}function sc(a){return a&&P(a.length)&&
/src/angular.min.js-11-Zd.test(na.call(a))}function Nb(a){return!(!a||!(a.nodeName||a.prop&&a.attr&&a.find))}function $d(a){var b={};a=a.split(",");var d;for(d=0;d<a.length;d++)b[a[d]]=!0;return b}function oa(a){return M(a.nodeName||a[0]&&a[0].nodeName)}function ab(a,b){var d=a.indexOf(b);0<=d&&a.splice(d,1);return d}function Na(a,b){function d(a,b){var d=b.$$hashKey,e;if(L(a)){e=0;for(var f=a.length;e<f;e++)b.push(c(a[e]))}else if(nc(a))for(e in a)b[e]=c(a[e]);else if(a&&"function"===typeof a.hasOwnProperty)for(e in a)a.hasOwnProperty(e)&&
##############################################
/src/angular.min.js-42-"$rootScope",function(b,d,c){function e(a){var b=null;Array.prototype.some.call(a,function(a){if("a"===oa(a))return b=a,!0});return b}function f(a){if(a){a.scrollIntoView();var c;c=g.yOffset;G(c)?c=c():Nb(c)?(c=c[0],c="fixed"!==b.getComputedStyle(c).position?0:c.getBoundingClientRect().bottom):P(c)||(c=0);c&&(a=a.getBoundingClientRect().top,b.scrollBy(0,a-c))}else b.scrollTo(0,0)}function g(a){a=H(a)?a:d.hash();var b;a?(b=h.getElementById(a))?f(b):(b=e(h.getElementsByName(a)))?f(b):"top"===a&&f(null):
/src/angular.min.js:43:f(null)}var h=b.document;a&&c.$watch(function(){return d.hash()},function(a,b){a===b&&""===a||Nf(function(){c.$evalAsync(g)})});return g}]}function gb(a,b){if(!a&&!b)return"";if(!a)return b;if(!b)return a;L(a)&&(a=a.join(" "));L(b)&&(b=b.join(" "));return a+" "+b}function Tf(a){H(a)&&(a=a.split(" "));var b=Z();p(a,function(a){a.length&&(b[a]=!0)});return b}function Fa(a){return K(a)?a:{}}function Uf(a,b,d,c){function e(a){try{a.apply(null,ta.call(arguments,1))}finally{if(t--,0===t)for(;A.length;)try{A.pop()()}catch(b){d.error(b)}}}
/src/angular.min.js-44-function f(){F=null;g();h()}function g(){a:{try{q=l.state;break a}catch(a){}q=void 0}q=r(q)?null:q;la(q,C)&&(q=C);C=q}function h(){if(w!==k.url()||y!==q)w=k.url(),y=q,p(Q,function(a){a(k.url(),q)})}var k=this,m=a.location,l=a.history,n=a.setTimeout,J=a.clearTimeout,z={};k.isMock=!1;var t=0,A=[];k.$$completeOutstandingRequest=e;k.$$incOutstandingRequestCount=function(){t++};k.notifyWhenNoOutstandingRequests=function(a){0===t?a():A.push(a)};var q,y,w=m.href,V=b.find("base"),F=null;g();y=q;k.url=function(b,
##############################################
/src/angular.min.js-77-e:(e=this.$attr[a])||(this.$attr[a]=e=zc(a,"-"));f=oa(this.$$element);if("a"===f&&"href"===a||"img"===f&&"src"===a)this[a]=b=E(b,"src"===a);else if("img"===f&&"srcset"===a&&u(b)){for(var f="",g=T(b),k=/(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/,k=/\s/.test(g)?k:/(,)/,g=g.split(k),k=Math.floor(g.length/2),m=0;m<k;m++)var l=2*m,f=f+E(T(g[l]),!0),f=f+(" "+T(g[l+1]));g=T(g[2*m]).split(/\s/);f+=E(T(g[0]),!0);2===g.length&&(f+=" "+T(g[1]));this[a]=b=f}!1!==d&&(null===b||r(b)?this.$$element.removeAttr(e):this.$$element.attr(e,
/src/angular.min.js:78:b));(a=this.$$observers)&&p(a[h],function(a){try{a(b)}catch(d){c(d)}})},$observe:function(a,b){var c=this,d=c.$$observers||(c.$$observers=Z()),e=d[a]||(d[a]=[]);e.push(b);V.$evalAsync(function(){e.$$inter||!c.hasOwnProperty(a)||r(c[a])||b(c[a])});return function(){ab(e,b)}}};var ea=b.startSymbol(),fa=b.endSymbol(),ha="{{"==ea&&"}}"==fa?Za:function(a){return a.replace(/\{\{/g,ea).replace(/}}/g,fa)},ja=/^ngAttr[A-Z]/,ka=/^(.+)Start$/;I.$$addBindingInfo=n?function(a,b){var c=a.data("$binding")||[];L(b)?
/src/angular.min.js-79-c=c.concat(b):c.push(b);a.data("$binding",c)}:v;I.$$addBindingClass=n?function(a){C(a,"ng-binding")}:v;I.$$addScopeInfo=n?function(a,b,c,d){a.data(c?d?"$isolateScopeNoTemplate":"$isolateScope":"$scope",b)}:v;I.$$addScopeClass=n?function(a,b){C(a,b?"ng-isolate-scope":"ng-scope")}:v;return I}]}function va(a){return eb(a.replace(Wc,""))}function $c(a,b){var d="",c=a.split(/\s+/),e=b.split(/\s+/),f=0;a:for(;f<c.length;f++){for(var g=c[f],h=0;h<e.length;h++)if(g==e[h])continue a;d+=(0<d.length?" ":"")+
##############################################
/src/angular.min.js-105-c.state();var t=/^\s*(javascript|mailto):/i;f.on("click",function(a){if(b.rewriteLinks&&!a.ctrlKey&&!a.metaKey&&!a.shiftKey&&2!=a.which&&2!=a.button){for(var e=D(a.target);"a"!==oa(e[0]);)if(e[0]===f[0]||!(e=e.parent())[0])return;var h=e.prop("href"),k=e.attr("href")||e.attr("xlink:href");K(h)&&"[object SVGAnimatedString]"===h.toString()&&(h=xa(h.animVal).href);t.test(h)||!h||e.attr("target")||a.isDefaultPrevented()||!m.$$parseLinkUrl(h,k)||(a.preventDefault(),m.absUrl()!=c.url()&&(d.$apply(),g.angular["ff-684208-preventDefault"]=
/src/angular.min.js:106:!0))}});hb(m.absUrl())!=hb(n)&&c.url(m.absUrl(),!0);var A=!0;c.onUrlChange(function(a,b){r(ra(z,a))?g.location.href=a:(d.$evalAsync(function(){var c=m.absUrl(),e=m.$$state,f;a=hb(a);m.$$parse(a);m.$$state=b;f=d.$broadcast("$locationChangeStart",a,c,b,e).defaultPrevented;m.absUrl()===a&&(f?(m.$$parse(c),m.$$state=e,h(c,!1,e)):(A=!1,k(c,e)))}),d.$$phase||d.$digest())});d.$watch(function(){var a=hb(c.url()),b=hb(m.absUrl()),f=c.state(),g=m.$$replace,l=a!==b||m.$$html5&&e.history&&f!==m.$$state;if(A||
/src/angular.min.js:107:l)A=!1,d.$evalAsync(function(){var b=m.absUrl(),c=d.$broadcast("$locationChangeStart",b,a,m.$$state,f).defaultPrevented;m.absUrl()===b&&(c?(m.$$parse(a),m.$$state=f):(l&&h(b,g,f===m.$$state?null:m.$$state),k(a,f)))});m.$$replace=!1});return m}]}function qf(){var a=!0,b=this;this.debugEnabled=function(b){return u(b)?(a=b,this):a};this.$get=["$window",function(d){function c(a){a instanceof Error&&(a.stack?a=a.message&&-1===a.stack.indexOf(a.message)?"Error: "+a.message+"\n"+a.stack:a.stack:a.sourceURL&&
/src/angular.min.js-108-(a=a.message+"\n"+a.sourceURL+":"+a.line));return a}function e(a){var b=d.console||{},e=b[a]||b.log||v;a=!1;try{a=!!e.apply}catch(k){}return a?function(){var a=[];p(arguments,function(b){a.push(c(b))});return e.apply(b,a)}:function(a,b){e(a,null==b?"":b)}}return{log:e("log"),info:e("info"),warn:e("warn"),error:e("error"),debug:function(){var c=e("debug");return function(){a&&c.apply(b,arguments)}}()}}]}function Wa(a,b){if("__defineGetter__"===a||"__defineSetter__"===a||"__lookupGetter__"===a||"__lookupSetter__"===
##############################################
/src/angular.min.js-118-d.$$postDigest(function(){u(f)&&e()})},c)}function k(a,b,c,d){function e(a){var b=!0;p(a,function(a){u(a)||(b=!1)});return b}var f,g;return f=a.$watch(function(a){return d(a)},function(a,c,d){g=a;G(b)&&b.call(this,a,c,d);e(a)&&d.$$postDigest(function(){e(g)&&f()})},c)}function m(a,b,c,d){var e;return e=a.$watch(function(a){return d(a)},function(a,c,d){G(b)&&b.apply(this,arguments);e()},c)}function l(a,b){if(!b)return a;var c=a.$$watchDelegate,d=!1,c=c!==k&&c!==h?function(c,e,f,g){f=d&&g?g[0]:a(c,
/src/angular.min.js:119:e,f,g);return b(f,c,e)}:function(c,d,e,f){e=a(c,d,e,f);c=b(e,c,d);return u(e)?c:e};a.$$watchDelegate&&a.$$watchDelegate!==g?c.$$watchDelegate=a.$$watchDelegate:b.$stateful||(c.$$watchDelegate=g,d=!a.inputs,c.inputs=a.inputs?a.inputs:[a]);return c}var n=Ca().noUnsafeEval,J={csp:n,expensiveChecks:!1},z={csp:n,expensiveChecks:!0},t=!1;c.$$runningExpensiveChecks=function(){return t};return c}]}function tf(){this.$get=["$rootScope","$exceptionHandler",function(a,b){return ud(function(b){a.$evalAsync(b)},
/src/angular.min.js-120-b)}]}function uf(){this.$get=["$browser","$exceptionHandler",function(a,b){return ud(function(b){a.defer(b)},b)}]}function ud(a,b){function d(a,b,c){function d(b){return function(c){e||(e=!0,b.call(a,c))}}var e=!1;return[d(b),d(c)]}function c(){this.$$state={status:0}}function e(a,b){return function(c){b.call(a,c)}}function f(c){!c.processScheduled&&c.pending&&(c.processScheduled=!0,a(function(){var a,d,e;e=c.pending;c.processScheduled=!1;c.pending=x;for(var f=0,g=e.length;f<g;++f){d=e[f][0];a=e[f][c.status];
##############################################
/src/angular.min.js-129-d.$parent=c;d.$$prevSibling=c.$$childTail;c.$$childHead?(c.$$childTail.$$nextSibling=d,c.$$childTail=d):c.$$childHead=c.$$childTail=d;(b||c!=this)&&d.$on("$destroy",m);return d},$watch:function(a,b,d,e){var f=h(a);if(f.$$watchDelegate)return f.$$watchDelegate(this,b,d,f,a);var g=this,k=g.$$watchers,l={fn:b,last:A,get:f,exp:e||a,eq:!!d};c=null;G(b)||(l.fn=v);k||(k=g.$$watchers=[]);k.unshift(l);z(this,1);return function(){0<=ab(k,l)&&z(g,-1);c=null}},$watchGroup:function(a,b){function c(){h=!1;k?(k=
/src/angular.min.js:130:!1,b(e,e,g)):b(e,d,g)}var d=Array(a.length),e=Array(a.length),f=[],g=this,h=!1,k=!0;if(!a.length){var l=!0;g.$evalAsync(function(){l&&b(e,e,g)});return function(){l=!1}}if(1===a.length)return this.$watch(a[0],function(a,c,f){e[0]=a;d[0]=c;b(e,a===c?e:d,f)});p(a,function(a,b){var k=g.$watch(a,function(a,f){e[b]=a;d[b]=f;h||(h=!0,g.$evalAsync(c))});f.push(k)});return function(){for(;f.length;)f.shift()()}},$watchCollection:function(a,b){function c(a){e=a;var b,d,g,h;if(!r(e)){if(K(e))if(Aa(e))for(f!==
/src/angular.min.js-131-n&&(f=n,p=f.length=0,l++),a=e.length,p!==a&&(l++,f.length=p=a),b=0;b<a;b++)h=f[b],g=e[b],d=h!==h&&g!==g,d||h===g||(l++,f[b]=g);else{f!==q&&(f=q={},p=0,l++);a=0;for(b in e)sa.call(e,b)&&(a++,g=e[b],h=f[b],b in f?(d=h!==h&&g!==g,d||h===g||(l++,f[b]=g)):(p++,f[b]=g,l++));if(p>a)for(b in l++,f)sa.call(e,b)||(p--,delete f[b])}else f!==e&&(f=e,l++);return l}}c.$stateful=!0;var d=this,e,f,g,k=1<b.length,l=0,m=h(a,c),n=[],q={},J=!0,p=0;return this.$watch(m,function(){J?(J=!1,b(e,e,d)):b(e,g,d);if(k)if(K(e))if(Aa(e)){g=
/src/angular.min.js:132:Array(e.length);for(var a=0;a<e.length;a++)g[a]=e[a]}else for(a in g={},e)sa.call(e,a)&&(g[a]=e[a]);else g=e})},$digest:function(){var a,f,h,l,m,n,p,z,y=b,t,r=[],Q,x;J("$digest");k.$$checkUrlChange();this===w&&null!==e&&(k.defer.cancel(e),q());c=null;do{z=!1;for(t=this;s.length;){try{x=s.shift(),x.scope.$eval(x.expression,x.locals)}catch(u){g(u)}c=null}a:do{if(n=t.$$watchers)for(p=n.length;p--;)try{if(a=n[p])if(m=a.get,(f=m(t))!==(h=a.last)&&!(a.eq?la(f,h):"number"===typeof f&&"number"===typeof h&&
/src/angular.min.js-133-isNaN(f)&&isNaN(h)))z=!0,c=a,a.last=a.eq?Na(f,null):f,l=a.fn,l(f,h===A?f:h,t),5>y&&(Q=4-y,r[Q]||(r[Q]=[]),r[Q].push({msg:G(a.exp)?"fn: "+(a.exp.name||a.exp.toString()):a.exp,newVal:f,oldVal:h}));else if(a===c){z=!1;break a}}catch(v){g(v)}if(!(n=t.$$watchersCount&&t.$$childHead||t!==this&&t.$$nextSibling))for(;t!==this&&!(n=t.$$nextSibling);)t=t.$parent}while(t=n);if((z||s.length)&&!y--)throw w.$$phase=null,d("infdig",b,r);}while(z||s.length);for(w.$$phase=null;F.length;)try{F.shift()()}catch(D){g(D)}},
/src/angular.min.js-134-$destroy:function(){if(!this.$$destroyed){var a=this.$parent;this.$broadcast("$destroy");this.$$destroyed=!0;this===w&&k.$$applicationDestroyed();z(this,-this.$$watchersCount);for(var b in this.$$listenerCount)t(this,this.$$listenerCount[b],b);a&&a.$$childHead==this&&(a.$$childHead=this.$$nextSibling);a&&a.$$childTail==this&&(a.$$childTail=this.$$prevSibling);this.$$prevSibling&&(this.$$prevSibling.$$nextSibling=this.$$nextSibling);this.$$nextSibling&&(this.$$nextSibling.$$prevSibling=this.$$prevSibling);
/src/angular.min.js:135:this.$destroy=this.$digest=this.$apply=this.$evalAsync=this.$applyAsync=v;this.$on=this.$watch=this.$watchGroup=function(){return v};this.$$listeners={};this.$$nextSibling=null;l(this)}},$eval:function(a,b){return h(a)(this,b)},$evalAsync:function(a,b){w.$$phase||s.length||k.defer(function(){s.length&&w.$digest()});s.push({scope:this,expression:h(a),locals:b})},$$postDigest:function(a){F.push(a)},$apply:function(a){try{J("$apply");try{return this.$eval(a)}finally{w.$$phase=null}}catch(b){g(b)}finally{try{w.$digest()}catch(c){throw g(c),
/src/angular.min.js:136:c;}}},$applyAsync:function(a){function b(){c.$eval(a)}var c=this;a&&Q.push(b);a=h(a);y()},$on:function(a,b){var c=this.$$listeners[a];c||(this.$$listeners[a]=c=[]);c.push(b);var d=this;do d.$$listenerCount[a]||(d.$$listenerCount[a]=0),d.$$listenerCount[a]++;while(d=d.$parent);var e=this;return function(){var d=c.indexOf(b);-1!==d&&(c[d]=null,t(e,1,a))}},$emit:function(a,b){var c=[],d,e=this,f=!1,h={name:a,targetScope:e,stopPropagation:function(){f=!0},preventDefault:function(){h.defaultPrevented=
/src/angular.min.js-137-!0},defaultPrevented:!1},k=bb([h],arguments,1),l,m;do{d=e.$$listeners[a]||c;h.currentScope=e;l=0;for(m=d.length;l<m;l++)if(d[l])try{d[l].apply(null,k)}catch(n){g(n)}else d.splice(l,1),l--,m--;if(f)return h.currentScope=null,h;e=e.$parent}while(e);h.currentScope=null;return h},$broadcast:function(a,b){var c=this,d=this,e={name:a,targetScope:this,preventDefault:function(){e.defaultPrevented=!0},defaultPrevented:!1};if(!this.$$listenerCount[a])return e;for(var f=bb([e],arguments,1),h,k;c=d;){e.currentScope=
##############################################
/src/angular.min.js-171-(b=b.concat(c.split(" ")))}),b):a}return{restrict:"AC",link:function(f,g,h){function k(a){a=m(a,1);h.$addClass(a)}function m(a,b){var c=g.data("$classCounts")||Z(),d=[];p(a,function(a){if(0<b||c[a])c[a]=(c[a]||0)+b,c[a]===+(0<b)&&d.push(a)});g.data("$classCounts",c);return d.join(" ")}function l(a,b){var e=c(b,a),f=c(a,b),e=m(e,1),f=m(f,-1);e&&e.length&&d.addClass(g,e);f&&f.length&&d.removeClass(g,f)}function n(a){if(!0===b||f.$index%2===b){var c=e(a||[]);if(!r)k(c);else if(!la(a,r)){var d=e(r);l(d,
/src/angular.min.js:172:c)}}r=L(a)?a.map(function(a){return fa(a)}):fa(a)}var r;f.$watch(h[a],n,!0);h.$observe("class",function(b){n(f.$eval(h[a]))});"ngClass"!==a&&f.$watch("$index",function(c,d){var g=c&1;if(g!==(d&1)){var l=e(f.$eval(h[a]));g===b?k(l):(g=m(l,-1),h.$removeClass(g))}})}}}]}function Jd(a){function b(a,b){b&&!f[a]?(k.addClass(e,a),f[a]=!0):!b&&f[a]&&(k.removeClass(e,a),f[a]=!1)}function d(a,c){a=a?"-"+zc(a,"-"):"";b(lb+a,!0===c);b(Nd+a,!1===c)}var c=a.ctrl,e=a.$element,f={},g=a.set,h=a.unset,k=a.$animate;
/src/angular.min.js-173-f[Nd]=!(f[lb]=e.hasClass(lb));c.$setValidity=function(a,e,f){r(e)?(c.$pending||(c.$pending={}),g(c.$pending,a,f)):(c.$pending&&h(c.$pending,a,f),Od(c.$pending)&&(c.$pending=x));Ma(e)?e?(h(c.$error,a,f),g(c.$$success,a,f)):(g(c.$error,a,f),h(c.$$success,a,f)):(h(c.$error,a,f),h(c.$$success,a,f));c.$pending?(b(Pd,!0),c.$valid=c.$invalid=x,d("",null)):(b(Pd,!1),c.$valid=Od(c.$error),c.$invalid=!c.$valid,d("",c.$valid));e=c.$pending&&c.$pending[a]?x:c.$error[a]?!1:c.$$success[a]?!0:null;d(a,e);c.$$parentForm.$setValidity(a,
/src/angular.min.js-174-e,c)}}function Od(a){if(a)for(var b in a)if(a.hasOwnProperty(b))return!1;return!0}var vg=/^\/(.+)\/([a-z]*)$/,M=function(a){return H(a)?a.toLowerCase():a},sa=Object.prototype.hasOwnProperty,rb=function(a){return H(a)?a.toUpperCase():a},Ha,D,pa,ta=[].slice,Xf=[].splice,wg=[].push,na=Object.prototype.toString,rc=Object.getPrototypeOf,Ba=B("ng"),da=R.angular||(R.angular={}),Sb,mb=0;Ha=U.documentMode;v.$inject=[];Za.$inject=[];var L=Array.isArray,Zd=/^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array\]$/,
/src/angular.min.js:175:T=function(a){return H(a)?a.trim():a},vd=function(a){return a.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g,"\\$1").replace(/\x08/g,"\\x08")},Ca=function(){if(!u(Ca.rules)){var a=U.querySelector("[ng-csp]")||U.querySelector("[data-ng-csp]");if(a){var b=a.getAttribute("ng-csp")||a.getAttribute("data-ng-csp");Ca.rules={noUnsafeEval:!b||-1!==b.indexOf("no-unsafe-eval"),noInlineStyle:!b||-1!==b.indexOf("no-inline-style")}}else{a=Ca;try{new Function(""),b=!1}catch(d){b=!0}a.rules={noUnsafeEval:b,noInlineStyle:!1}}}return Ca.rules},
/src/angular.min.js-176-ob=function(){if(u(ob.name_))return ob.name_;var a,b,d=Pa.length,c,e;for(b=0;b<d;++b)if(c=Pa[b],a=U.querySelector("["+c.replace(":","\\:")+"jq]")){e=a.getAttribute(c+"jq");break}return ob.name_=e},be=/:/g,Pa=["ng-","data-ng-","ng:","x-ng-"],ge=/[A-Z]/g,Ac=!1,Rb,Oa=3,ke={full:"1.4.14",major:1,minor:4,dot:14,codeName:"material-distinction"};S.expando="ng339";var fb=S.cache={},Mf=1;S._data=function(a){return this.cache[a[this.expando]]||{}};var Hf=/([\:\-\_]+(.))/g,If=/^moz([A-Z])/,wb={mouseleave:"mouseout",
##############################################
/src/angular.min.js-243-h}},inputs:function(a,b){return function(d,c,e,f){return f?f[b]:a(d,c,e)}}};var gc=function(a,b,d){this.lexer=a;this.$filter=b;this.options=d;this.ast=new s(this.lexer);this.astCompiler=d.csp?new td(this.ast,b):new sd(this.ast,b)};gc.prototype={constructor:gc,parse:function(a){return this.astCompiler.compile(a,this.options.expensiveChecks)}};var hg=Object.prototype.valueOf,za=B("$sce"),ka={HTML:"html",CSS:"css",URL:"url",RESOURCE_URL:"resourceUrl",JS:"js"},ga=B("$compile"),Y=U.createElement("a"),
/src/angular.min.js:244:xd=xa(R.location.href);yd.$inject=["$document"];Jc.$inject=["$provide"];var Fd=22,Ed=".",ic="0";zd.$inject=["$locale"];Bd.$inject=["$locale"];var tg={yyyy:ba("FullYear",4),yy:ba("FullYear",2,0,!0),y:ba("FullYear",1),MMMM:Hb("Month"),MMM:Hb("Month",!0),MM:ba("Month",2,1),M:ba("Month",1,1),dd:ba("Date",2),d:ba("Date",1),HH:ba("Hours",2),H:ba("Hours",1),hh:ba("Hours",2,-12),h:ba("Hours",1,-12),mm:ba("Minutes",2),m:ba("Minutes",1),ss:ba("Seconds",2),s:ba("Seconds",1),sss:ba("Milliseconds",3),EEEE:Hb("Day"),
/src/angular.min.js-245-EEE:Hb("Day",!0),a:function(a,b){return 12>a.getHours()?b.AMPMS[0]:b.AMPMS[1]},Z:function(a,b,d){a=-1*d;return a=(0<=a?"+":"")+(Gb(Math[0<a?"floor":"ceil"](a/60),2)+Gb(Math.abs(a%60),2))},ww:Hd(2),w:Hd(1),G:jc,GG:jc,GGG:jc,GGGG:function(a,b){return 0>=a.getFullYear()?b.ERANAMES[0]:b.ERANAMES[1]}},sg=/((?:[^yMdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/,rg=/^\-?\d+$/;Ad.$inject=["$locale"];var mg=ma(M),ng=ma(rb);Cd.$inject=["$parse"];var me=ma({restrict:"E",compile:function(a,
##############################################
/src/angular.min.js-255-!0),m=Md(h,a,"ngFalseValue",d.ngFalseValue,!1);b.on("click",function(a){c.$setViewValue(b[0].checked,a&&a.type)});c.$render=function(){b[0].checked=c.$viewValue};c.$isEmpty=function(a){return!1===a};c.$formatters.push(function(a){return la(a,k)});c.$parsers.push(function(a){return a?k:m})},hidden:v,button:v,submit:v,reset:v,file:v},Dc=["$browser","$sniffer","$filter","$parse",function(a,b,d,c){return{restrict:"E",require:["?ngModel"],link:{pre:function(e,f,g,h){h[0]&&(Wd[M(g.type)]||Wd.text)(e,f,
/src/angular.min.js:256:g,h[0],b,a,d,c)}}}}],Gg=/^(true|false|\d+)$/,Se=function(){return{restrict:"A",priority:100,compile:function(a,b){return Gg.test(b.ngValue)?function(a,b,e){e.$set("value",a.$eval(e.ngValue))}:function(a,b,e){a.$watch(e.ngValue,function(a){e.$set("value",a)})}}}},se=["$compile",function(a){return{restrict:"AC",compile:function(b){a.$$addBindingClass(b);return function(b,c,e){a.$$addBindingInfo(c,e.ngBind);c=c[0];b.$watch(e.ngBind,function(a){c.textContent=r(a)?"":a})}}}}],ue=["$interpolate","$compile",
/src/angular.min.js-257-function(a,b){return{compile:function(d){b.$$addBindingClass(d);return function(c,d,f){c=a(d.attr(f.$attr.ngBindTemplate));b.$$addBindingInfo(d,c.expressions);d=d[0];f.$observe("ngBindTemplate",function(a){d.textContent=r(a)?"":a})}}}}],te=["$sce","$parse","$compile",function(a,b,d){return{restrict:"A",compile:function(c,e){var f=b(e.ngBindHtml),g=b(e.ngBindHtml,function(b){return a.valueOf(b)});d.$$addBindingClass(c);return function(b,c,e){d.$$addBindingInfo(c,e.ngBindHtml);b.$watch(g,function(){var d=
/src/angular.min.js:258:f(b);c.html(a.getTrustedHtml(d)||"")})}}}}],Re=ma({restrict:"A",require:"ngModel",link:function(a,b,d,c){c.$viewChangeListeners.push(function(){a.$eval(d.ngChange)})}}),ve=lc("",!0),xe=lc("Odd",0),we=lc("Even",1),ye=Ka({compile:function(a,b){b.$set("ngCloak",x);a.removeClass("ng-cloak")}}),ze=[function(){return{restrict:"A",scope:!0,controller:"@",priority:500}}],Ic={},Hg={blur:!0,focus:!0};p("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "),
/src/angular.min.js:259:function(a){var b=va("ng-"+a);Ic[b]=["$parse","$rootScope",function(d,c){return{restrict:"A",compile:function(e,f){var g=d(f[b],null,!0);return function(b,d){d.on(a,function(d){var e=function(){g(b,{$event:d})};Hg[a]&&c.$$phase?b.$evalAsync(e):b.$apply(e)})}}}}]});var Ce=["$animate",function(a){return{multiElement:!0,transclude:"element",priority:600,terminal:!0,restrict:"A",$$tlb:!0,link:function(b,d,c,e,f){var g,h,k;b.$watch(c.ngIf,function(b){b?h||f(function(b,e){h=e;b[b.length++]=U.createComment(" end ngIf: "+
/src/angular.min.js-260-c.ngIf+" ");g={clone:b};a.enter(b,d.parent(),d)}):(k&&(k.remove(),k=null),h&&(h.$destroy(),h=null),g&&(k=qb(g.clone),a.leave(k).then(function(){k=null}),g=null))})}}}],De=["$templateRequest","$anchorScroll","$animate",function(a,b,d){return{restrict:"ECA",priority:400,terminal:!0,transclude:"element",controller:da.noop,compile:function(c,e){var f=e.ngInclude||e.src,g=e.onload||"",h=e.autoscroll;return function(c,e,l,n,p){var r=0,t,s,q,y=function(){s&&(s.remove(),s=null);t&&(t.$destroy(),t=null);q&&
/src/angular.min.js:261:(d.leave(q).then(function(){s=null}),s=q,q=null)};c.$watch(f,function(f){var l=function(){!u(h)||h&&!c.$eval(h)||b()},s=++r;f?(a(f,!0).then(function(a){if(!c.$$destroyed&&s===r){var b=c.$new();n.template=a;a=p(b,function(a){y();d.enter(a,null,e).then(l)});t=b;q=a;t.$emit("$includeContentLoaded",f);c.$eval(g)}},function(){c.$$destroyed||s!==r||(y(),c.$emit("$includeContentError",f))}),c.$emit("$includeContentRequested",f)):(y(),n.template=null)})}}}}],Ue=["$compile",function(a){return{restrict:"ECA",
/src/angular.min.js:262:priority:-400,require:"ngInclude",link:function(b,d,c,e){/SVG/.test(d[0].toString())?(d.empty(),a(Lc(e.template,U).childNodes)(b,function(a){d.append(a)},{futureParentElement:d})):(d.html(e.template),a(d.contents())(b))}}}],Ee=Ka({priority:450,compile:function(){return{pre:function(a,b,d){a.$eval(d.ngInit)}}}}),Qe=function(){return{restrict:"A",priority:100,require:"ngModel",link:function(a,b,d,c){var e=b.attr(d.$attr.ngList)||", ",f="false"!==d.ngTrim,g=f?T(e):e;c.$parsers.push(function(a){if(!r(a)){var b=
/src/angular.min.js-263-[];a&&p(a.split(g),function(a){a&&b.push(f?T(a):a)});return b}});c.$formatters.push(function(a){return L(a)?a.join(e):x});c.$isEmpty=function(a){return!a||!a.length}}}},lb="ng-valid",Nd="ng-invalid",Xa="ng-pristine",Jb="ng-dirty",Pd="ng-pending",kb=B("ngModel"),Ig=["$scope","$exceptionHandler","$attrs","$element","$parse","$animate","$timeout","$rootScope","$q","$interpolate",function(a,b,d,c,e,f,g,h,k,m){this.$modelValue=this.$viewValue=Number.NaN;this.$$rawModelValue=x;this.$validators={};this.$asyncValidators=
##############################################
/src/angular.min.js-271-s(a);if(b!==q.$modelValue&&(q.$modelValue===q.$modelValue||b===b)){q.$modelValue=q.$$rawModelValue=b;A=x;for(var c=q.$formatters,d=c.length,e=b;d--;)e=c[d](e);q.$viewValue!==e&&(q.$viewValue=q.$$lastCommittedViewValue=e,q.$render(),q.$$runValidators(b,e,v))}return b})}],Pe=["$rootScope",function(a){return{restrict:"A",require:["ngModel","^?form","^?ngModelOptions"],controller:Ig,priority:1,compile:function(b){b.addClass(Xa).addClass("ng-untouched").addClass(lb);return{pre:function(a,b,e,f){var g=
/src/angular.min.js:272:f[0];b=f[1]||g.$$parentForm;g.$$setOptions(f[2]&&f[2].$options);b.$addControl(g);e.$observe("name",function(a){g.$name!==a&&g.$$parentForm.$$renameControl(g,a)});a.$on("$destroy",function(){g.$$parentForm.$removeControl(g)})},post:function(b,c,e,f){var g=f[0];if(g.$options&&g.$options.updateOn)c.on(g.$options.updateOn,function(a){g.$$debounceViewValueCommit(a&&a.type)});c.on("blur",function(c){g.$touched||(a.$$phase?b.$evalAsync(g.$setTouched):b.$apply(g.$setTouched))})}}}}}],Jg=/(\s+|^)default(\s+|$)/,
/src/angular.min.js:273:Te=function(){return{restrict:"A",controller:["$scope","$attrs",function(a,b){var d=this;this.$options=Na(a.$eval(b.ngModelOptions));u(this.$options.updateOn)?(this.$options.updateOnDefault=!1,this.$options.updateOn=T(this.$options.updateOn.replace(Jg,function(){d.$options.updateOnDefault=!0;return" "}))):this.$options.updateOnDefault=!0}]}},Fe=Ka({terminal:!0,priority:1E3}),Kg=B("ngOptions"),Lg=/^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/,
/src/angular.min.js-274-Ne=["$compile","$parse",function(a,b){function d(a,c,d){function e(a,b,c,d,f){this.selectValue=a;this.viewValue=b;this.label=c;this.group=d;this.disabled=f}function m(a){var b;if(!p&&Aa(a))b=a;else{b=[];for(var c in a)a.hasOwnProperty(c)&&"$"!==c.charAt(0)&&b.push(c)}return b}var l=a.match(Lg);if(!l)throw Kg("iexp",a,ua(c));var n=l[5]||l[7],p=l[6];a=/ as /.test(l[0])&&l[1];var r=l[9];c=b(l[2]?l[1]:n);var t=a&&b(a)||c,s=r&&b(r),q=r?function(a,b){return s(d,b)}:function(a){return Da(a)},y=function(a,
##############################################
/src/angular.min.js-281-!0),y.attr("selected",!0)):(F||y.remove(),g.prepend(u),g.val("?"),u.prop("selected",!0),u.attr("selected",!0))},x.readValue=function(){var a=E.selectValueMap[g.val()];return a&&!a.disabled?(F||y.remove(),u.remove(),E.getViewValueFromOption(a)):null},C.trackBy&&b.$watch(function(){return C.getTrackByValue(t.$viewValue)},function(){t.$render()}));F?(y.remove(),a(y)(b),y.removeClass("ng-scope")):y=D(c.cloneNode(!1));s();b.$watchCollection(C.getWatchables,s)}}}}}],Ge=["$locale","$interpolate","$log",
/src/angular.min.js:282:function(a,b,d){var c=/{}/g,e=/^when(Minus)?(.+)$/;return{link:function(f,g,h){function k(a){g.text(a||"")}var m=h.count,l=h.$attr.when&&g.attr(h.$attr.when),n=h.offset||0,s=f.$eval(l)||{},x={},t=b.startSymbol(),u=b.endSymbol(),q=t+m+"-"+n+u,y=da.noop,w;p(h,function(a,b){var c=e.exec(b);c&&(c=(c[1]?"-":"")+M(c[2]),s[c]=g.attr(h.$attr[b]))});p(s,function(a,d){x[d]=b(a.replace(c,q))});f.$watch(m,function(b){var c=parseFloat(b),e=isNaN(c);e||c in s||(c=a.pluralCat(c-n));c===w||e&&P(w)&&isNaN(w)||(y(),
/src/angular.min.js-283-e=x[c],r(e)?(null!=b&&d.debug("ngPluralize: no rule defined for '"+c+"' in "+l),y=v,k()):y=f.$watch(e,k),w=c)})}}}],He=["$parse","$animate",function(a,b){var d=B("ngRepeat"),c=function(a,b,c,d,k,m,l){a[c]=d;k&&(a[k]=m);a.$index=b;a.$first=0===b;a.$last=b===l-1;a.$middle=!(a.$first||a.$last);a.$odd=!(a.$even=0===(b&1))};return{restrict:"A",multiElement:!0,transclude:"element",priority:1E3,terminal:!0,$$tlb:!0,compile:function(e,f){var g=f.ngRepeat,h=U.createComment(" end ngRepeat: "+g+" "),k=g.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);

/src/angular.min.js.map-6-"sources":["angular.js"],
/src/angular.min.js.map:7:"names":["window","errorHandlingConfig","config","isObject","isDefined","objectMaxDepth","minErrConfig","isValidObjectMaxDepth","NaN","urlErrorParamsEnabled","isBoolean","maxDepth","isNumber","minErr","isArrayLike","obj","isWindow","isArray","isString","jqLite","length","Object","item","forEach","iterator","context","key","isFunction","hasOwnProperty","call","isPrimitive","isBlankObject","forEachSorted","keys","sort","i","reverseParams","iteratorFn","value","nextUid","uid","baseExtend","dst","objs","deep","h","$$hashKey","ii","j","jj","src","isDate","Date","valueOf","isRegExp","RegExp","nodeName","cloneNode","isElement","clone","extend","slice","arguments","merge","toInt","str","parseInt","inherit","parent","extra","create","noop","identity","$","valueFn","valueRef","hasCustomToString","toString","isUndefined","getPrototypeOf","arr","Array","isError","tag","Error","isScope","$evalAsync","$watch","isTypedArray","TYPED_ARRAY_REGEXP","test","node","prop","attr","find","makeMap","items","split","nodeName_","element","lowercase","arrayRemove","array","index","indexOf","splice","copy","source","destination","copyRecurse","push","copyElement","stackSource","stackDest","ngMinErr","needsRecurse","copyType","undefined","constructor","buffer","byteOffset","copied","ArrayBuffer","byteLength","set","Uint8Array","re","match","lastIndex","type","simpleCompare","a","b","equals","o1","o2","t1","t2","getTime","keySet","createMap","charAt","concat","array1","array2","bind","self","fn","curryArgs","startIndex","apply","toJsonReplacer","val","document","toJson","pretty","JSON","stringify","fromJson","json","parse","timezoneToOffset","timezone","fallback","replace","ALL_COLONS","requestedTimezoneOffset","isNumberNaN","addDateMinutes","date","minutes","setMinutes","getMinutes","convertTimezoneToLocal","reverse","dateTimezoneOffset","getTimezoneOffset","timezoneOffset","startingTag","empty","elemHtml","append","html","nodeType","NODE_TYPE_TEXT","e","tryDecodeURIComponent","decodeURIComponent","parseKeyValue","keyValue","splitPoint","substring","toKeyValue","parts","arrayValue","encodeUriQuery","join","encodeUriSegment","pctEncodeSpaces","encodeURIComponent","getNgAttribute","ngAttr","ngAttrPrefixes","getAttribute","angularInit","bootstrap","appElement","module","prefix","name","hasAttribute","candidate","querySelector","isAutoBootstrapAllowed","strictDi","console","error","modules","defaultConfig","doBootstrap","injector","unshift","$provide","debugInfoEnabled","$compileProvider","createInjector","invoke","bootstrapApply","scope","compile","$apply","data","NG_ENABLE_DEBUG_INFO","NG_DEFER_BOOTSTRAP","angular","resumeBootstrap","angular.resumeBootstrap","extraModules","resumeDeferredBootstrap","reloadWithDebugInfo","location","reload","getTestability","rootElement","get","snake_case","separator","SNAKE_CASE_REGEXP","letter","pos","toLowerCase","bindJQuery","originalCleanData","bindJQueryFired","jqName","jq","jQuery","on","JQLitePrototype","isolateScope","controller","inheritedData","JQLite","cleanData","jqLite.cleanData","elems","events","elem","_data","$destroy","triggerHandler","assertArg","arg","reason","assertArgFn","acceptArrayAnnotation","assertNotHasOwnProperty","getter","path","bindFnToScope","lastInstance","len","getBlockNodes","nodes","endNode","blockNodes","nextSibling","setupModuleLoader","ensure","factory","$injectorMinErr","$$minErr","requires","configFn","info","invokeLater","provider","method","insertMethod","queue","invokeQueue","moduleInstance","invokeLaterAndSetModuleName","recipeName","factoryFunction","$$moduleName","configBlocks","runBlocks","_invokeQueue","_configBlocks","_runBlocks","service","constant","decorator","animation","filter","directive","component","run","block","shallowCopy","serializeObject","seen","publishExternalAPI","version","$$counter","csp","uppercase","angularModule","ngModule","$$sanitizeUri","$$SanitizeUriProvider","$CompileProvider","htmlAnchorDirective","input","inputDirective","textarea","form","formDirective","script","scriptDirective","select","selectDirective","option","optionDirective","ngBind","ngBindDirective","ngBindHtml","ngBindHtmlDirective","ngBindTemplate","ngBindTemplateDirective","ngClass","ngClassDirective","ngClassEven","ngClassEvenDirective","ngClassOdd","ngClassOddDirective","ngCloak","ngCloakDirective","ngController","ngControllerDirective","ngForm","ngFormDirective","ngHide","ngHideDirective","ngIf","ngIfDirective","ngInclude","ngIncludeDirective","ngInit","ngInitDirective","ngNonBindable","ngNonBindableDirective","ngPluralize","ngPluralizeDirective","ngRef","ngRefDirective","ngRepeat","ngRepeatDirective","ngShow","ngShowDirective","ngStyle","ngStyleDirective","ngSwitch","ngSwitchDirective","ngSwitchWhen","ngSwitchWhenDirective","ngSwitchDefault","ngSwitchDefaultDirective","ngOptions","ngOptionsDirective","ngTransclude","ngTranscludeDirective","ngModel","ngModelDirective","ngList","ngListDirective","ngChange","ngChangeDirective","pattern","patternDirective","ngPattern","required","requiredDirective","ngRequired","minlength","minlengthDirective","ngMinlength","maxlength","maxlengthDirective","ngMaxlength","ngValue","ngValueDirective","ngModelOptions","ngModelOptionsDirective","ngIncludeFillContentDirective","hiddenInputBrowserCacheDirective","ngAttributeAliasDirectives","ngEventDirectives","$anchorScroll","$AnchorScrollProvider","$animate","$AnimateProvider","$animateCss","$CoreAnimateCssProvider","$$animateJs","$$CoreAnimateJsProvider","$$animateQueue","$$CoreAnimateQueueProvider","$$AnimateRunner","$$AnimateRunnerFactoryProvider","$$animateAsyncRun","$$AnimateAsyncRunFactoryProvider","$browser","$BrowserProvider","$cacheFactory","$CacheFactoryProvider","$controller","$ControllerProvider","$document","$DocumentProvider","$$isDocumentHidden","$$IsDocumentHiddenProvider","$exceptionHandler","$ExceptionHandlerProvider","$filter","$FilterProvider","$$forceReflow","$$ForceReflowProvider","$interpolate","$InterpolateProvider","$interval","$IntervalProvider","$$intervalFactory","$$IntervalFactoryProvider","$http","$HttpProvider","$httpParamSerializer","$HttpParamSerializerProvider","$httpParamSerializerJQLike","$HttpParamSerializerJQLikeProvider","$httpBackend","$HttpBackendProvider","$xhrFactory","$xhrFactoryProvider","$jsonpCallbacks","$jsonpCallbacksProvider","$location","$LocationProvider","$log","$LogProvider","$parse","$ParseProvider","$rootScope","$RootScopeProvider","$q","$QProvider","$$q","$$QProvider","$sce","$SceProvider","$sceDelegate","$SceDelegateProvider","$sniffer","$SnifferProvider","$$taskTrackerFactory","$$TaskTrackerFactoryProvider","$templateCache","$TemplateCacheProvider","$templateRequest","$TemplateRequestProvider","$$testability","$$TestabilityProvider","$timeout","$TimeoutProvider","$window","$WindowProvider","$$rAF","$$RAFProvider","$$jqLite","$$jqLiteProvider","$$Map","$$MapProvider","$$cookieReader","$$CookieReaderProvider","angularVersion","fnCamelCaseReplace","all","toUpperCase","kebabToCamel","DASH_LOWERCASE_REGEXP","jqLiteAcceptsData","NODE_TYPE_ELEMENT","NODE_TYPE_DOCUMENT","jqLiteBuildFragment","tmp","fragment","createDocumentFragment","HTML_REGEXP","appendChild","createElement","TAG_NAME_REGEXP","exec","wrap","wrapMap","_default","innerHTML","XHTML_TAG_REGEXP","lastChild","childNodes","firstChild","textContent","createTextNode","argIsString","trim","jqLiteMinErr","parsed","SINGLE_TAG_REGEXP","jqLiteAddNodes","jqLiteReady","jqLiteClone","jqLiteDealoc","onlyDescendants","querySelectorAll","isEmptyObject","removeIfEmptyData","expandoId","ng339","expandoStore","jqCache","jqLiteOff","unsupported","jqLiteExpandoStore","handle","removeHandler","listenerFns","removeEventListener","MOUSE_EVENT_MAP","jqLiteRemoveData","createIfNecessary","jqId","jqLiteData","isSimpleSetter","isSimpleGetter","massGetter","jqLiteHasClass","selector","jqLiteRemoveClass","cssClasses","setAttribute","existingClasses","newClasses","cssClass","jqLiteAddClass","root","elements","jqLiteController","jqLiteInheritedData","documentElement","names","parentNode","NODE_TYPE_DOCUMENT_FRAGMENT","host","jqLiteEmpty","removeChild","jqLiteRemove","keepData","jqLiteDocumentLoaded","action","win","readyState","setTimeout","trigger","addEventListener","getBooleanAttrName","booleanAttr","BOOLEAN_ATTR","BOOLEAN_ELEMENTS","createEventHandler","eventHandler","event","isDefaultPrevented","event.isDefaultPrevented","defaultPrevented","eventFns","eventFnsLength","immediatePropagationStopped","originalStopImmediatePropagation","stopImmediatePropagation","event.stopImmediatePropagation","stopPropagation","isImmediatePropagationStopped","event.isImmediatePropagationStopped","handlerWrapper","specialHandlerWrapper","defaultHandlerWrapper","handler","specialMouseHandlerWrapper","target","related","relatedTarget","jqLiteContains","$get","this.$get","hasClass","classes","addClass","removeClass","hashKey","nextUidFn","objType","NgMapShim","_keys","_values","_lastKey","_lastIndex","extractArgs","fnText","Function","prototype","STRIP_COMMENTS","ARROW_ARG","FN_ARGS","anonFn","args","modulesToLoad","supportObject","delegate","provider_","providerInjector","instantiate","providerCache","providerSuffix","enforceReturnValue","enforcedReturnValue","result","instanceInjector","factoryFn","enforce","loadModules","moduleFn","runInvokeQueue","invokeArgs","loadedModules","message","stack","createInternalInjector","cache","getService","serviceName","caller","INSTANTIATING","err","shift","injectionArgs","locals","$inject","$$annotate","msie","func","$$ngIsClass","Type","ctor","annotate","has","NgMap","$injector","instanceCache","decorFn","origProvider","orig$get","origProvider.$get","origInstance","$delegate","protoInstanceInjector","loadNewModules","instanceInjector.loadNewModules","mods","autoScrollingEnabled","disableAutoScrolling","this.disableAutoScrolling","getFirstAnchor","list","some","scrollTo","scrollIntoView","offset","scroll","yOffset","getComputedStyle","style","position","getBoundingClientRect","bottom","elemTop","top","scrollBy","hash","elm","getElementById","getElementsByName","autoScrollWatch","autoScrollWatchAction","newVal","oldVal","mergeClasses","splitClasses","klass","prepareAnimateOptions","options","Browser","cacheStateAndFireUrlChange","pendingLocation","fireStateOrUrlChange","cacheState","cachedState","getCurrentState","lastCachedState","lastHistoryState","prevLastHistoryState","lastBrowserUrl","url","urlChangeListeners","listener","history","clearTimeout","pendingDeferIds","taskTracker","isMock","$$completeOutstandingRequest","completeTask","$$incOutstandingRequestCount","incTaskCount","notifyWhenNoOutstandingRequests","notifyWhenNoPendingTasks","href","baseElement","state","self.url","sameState","urlResolve","sameBase","stripHash","substr","self.state","urlChangeInit","onUrlChange","self.onUrlChange","callback","$$applicationDestroyed","self.$$applicationDestroyed","off","$$checkUrlChange","baseHref","self.baseHref","defer","self.defer","delay","taskType","timeoutId","DEFAULT_TASK_TYPE","cancel","self.defer.cancel","deferId","cacheFactory","cacheId","refresh","entry","freshEnd","staleEnd","n","link","p","nextEntry","prevEntry","caches","size","stats","id","capacity","Number","MAX_VALUE","lruHash","put","lruEntry","remove","removeAll","destroy","cacheFactory.info","cacheFactory.get","$$sanitizeUriProvider","parseIsolateBindings","directiveName","isController","LOCAL_REGEXP","bindings","definition","scopeName","bindingCache","$compileMinErr","mode","collection","optional","attrName","assertValidDirectiveName","getDirectiveRequire","require","REQUIRE_PREFIX_REGEXP","hasDirectives","COMMENT_DIRECTIVE_REGEXP","CLASS_DIRECTIVE_REGEXP","ALL_OR_NOTHING_ATTRS","EVENT_HANDLER_ATTR_REGEXP","this.directive","registerDirective","directiveFactory","Suffix","directives","priority","restrict","this.component","registerComponent","makeInjectable","tElement","tAttrs","$element","$attrs","template","templateUrl","ddo","controllerAs","identifierForController","transclude","bindToController","aHrefSanitizationWhitelist","this.aHrefSanitizationWhitelist","regexp","imgSrcSanitizationWhitelist","this.imgSrcSanitizationWhitelist","this.debugInfoEnabled","enabled","strictComponentBindingsEnabled","this.strictComponentBindingsEnabled","TTL","onChangesTtl","this.onChangesTtl","commentDirectivesEnabledConfig","commentDirectivesEnabled","this.commentDirectivesEnabled","cssClassDirectivesEnabledConfig","cssClassDirectivesEnabled","this.cssClassDirectivesEnabled","PROP_CONTEXTS","addPropertySecurityContext","this.addPropertySecurityContext","elementName","propertyName","ctx","registerNativePropertyContexts","registerContext","values","v","SCE_CONTEXTS","HTML","CSS","URL","MEDIA_URL","RESOURCE_URL","flushOnChangesQueue","onChangesQueue","sanitizeSrcset","invokeType","trimmedSrcset","srcPattern","rawUris","nbrUrisWith2parts","Math","floor","innerIdx","getTrustedMediaUrl","lastTuple","Attributes","attributesToCopy","l","$attr","$$element","setSpecialAttr","specialAttrHolder","attributes","attribute","removeNamedItem","setNamedItem","safeAddClass","className","$compileNodes","transcludeFn","maxPriority","ignoreDirective","previousCompileContext","compositeLinkFn","compileNodes","$$addScopeClass","namespace","publicLinkFn","cloneConnectFn","needsNewScope","$parent","$new","parentBoundTranscludeFn","transcludeControllers","futureParentElement","$$boundTransclude","$linkNode","wrapTemplate","controllerName","instance","$$addScopeInfo","nodeList","$rootElement","childLinkFn","childScope","childBoundTranscludeFn","stableNodeList","nodeLinkFnFound","linkFns","idx","nodeLinkFn","transcludeOnThisElement","createBoundTranscludeFn","templateOnThisElement","notLiveList","attrs","linkFnFound","mergeConsecutiveTextNodes","collectDirectives","applyDirectivesToNode","terminal","sibling","nodeValue","previousBoundTranscludeFn","boundTranscludeFn","transcludedScope","cloneFn","controllers","containingScope","$$transcluded","boundSlots","$$slots","slotName","attrsMap","addDirective","directiveNormalize","nName","ngPrefixMatch","nAttrs","attrStartName","attrEndName","isNgAttr","isNgProp","isNgEvent","multiElementMatch","NG_PREFIX_BINDING","PREFIX_REGEXP","MULTI_ELEMENT_DIR_RE","directiveIsMultiElement","addPropertyDirective","createEventDirective","addAttrInterpolateDirective","animVal","addTextInterpolateDirective","NODE_TYPE_COMMENT","collectCommentDirectives","byPriority","groupScan","attrStart","attrEnd","depth","groupElementsLinkFnWrapper","linkFn","groupedElementsLink","compilationGenerator","eager","compiled","lazyCompilation","compileNode","templateAttrs","jqCollection","originalReplaceDirective","preLinkFns","postLinkFns","addLinkFns","pre","post","newIsolateScopeDirective","$$isolateScope","cloneAndAnnotateFn","linkNode","controllersBoundTransclude","cloneAttachFn","hasElementTranscludeDirective","elementControllers","slotTranscludeFn","scopeToChild","controllerScope","newScopeDirective","isSlotFilled","transcludeFn.isSlotFilled","controllerDirectives","setupControllers","templateDirective","$$originalDirective","$$isolateBindings","scopeBindingInfo","initializeDirectiveBindings","removeWatches","$on","controllerDirective","$$bindings","bindingInfo","getControllers","controllerInstance","$onChanges","initialChanges","$onInit","$doCheck","$onDestroy","callOnDestroyHook","invokeLinkFn","$postLink","terminalPriority","nonTlbTranscludeDirective","hasTranscludeDirective","hasTemplate","$compileNode","$template","childTranscludeFn","didScanForMultipleTransclusion","mightHaveMultipleTransclusionError","directiveValue","$$start","$$end","assertNoDuplicate","$$tlb","scanningIndex","candidateDirective","$$createComment","replaceWith","replaceDirective","slots","slotMap","filledSlots","elementSelector","contents","filled","slotCompileNodes","$$newScope","denormalizeTemplate","removeComments","templateNamespace","newTemplateAttrs","templateDirectives","unprocessedDirectives","markDirectiveScope","mergeTemplateAttributes","compileTemplateUrl","max","inheritType","dataName","property","controllerKey","$scope","$transclude","newScope","tDirectives","startAttrName","endAttrName","multiElement","srcAttr","dstAttr","$set","linkQueue","afterTemplateNodeLinkFn","afterTemplateChildLinkFn","beforeTemplateCompileNode","origAsyncDirective","derivedSyncDirective","then","content","tempTemplateAttrs","beforeTemplateLinkNode","linkRootElement","$$destroyed","oldClasses","catch","delayedNodeLinkFn","ignoreChildLinkFn","diff","what","previousDirective","wrapModuleNameIfDefined","moduleName","text","interpolateFn","textInterpolateCompileFn","templateNode","templateNodeParent","hasCompileParent","$$addBindingClass","textInterpolateLinkFn","$$addBindingInfo","expressions","interpolateFnWatchAction","wrapper","getTrustedAttrContext","attrNormalizedName","getTrustedPropContext","propNormalizedName","sanitizeSrcsetPropertyValue","propName","trustedContext","sanitizer","getTrusted","ngPropCompileFn","_","ngPropGetter","ngPropWatch","sceValueOf","ngPropPreLinkFn","applyPropValue","propValue","allOrNothing","mustHaveExpression","attrInterpolatePreLinkFn","$$observers","newValue","$$inter","$$scope","oldValue","$updateClass","elementsToRemove","newNode","firstElementToRemove","removeCount","j2","replaceChild","hasData","annotation","strictBindingsCheck","recordChanges","currentValue","previousValue","$$postDigest","changes","triggerOnChangesHook","SimpleChange","removeWatchCollection","initializeBinding","lastValue","parentGet","parentSet","compare","removeWatch","$observe","_UNINITIALIZED_VALUE","literal","assign","parentValueWatch","parentValue","$stateful","$watchCollection","isLiteral","initialValue","parentValueWatchAction","SIMPLE_ATTR_NAME","$normalize","$addClass","classVal","$removeClass","toAdd","tokenDifference","toRemove","writeAttr","booleanKey","aliasedKey","ALIASED_ATTR","observer","removeAttr","listeners","startSymbol","endSymbol","binding","isolated","noTemplate","compile.$$createComment","comment","createComment","previous","current","SPECIAL_CHARS_REGEXP","str1","str2","tokens1","tokens2","token","jqNodes","ident","CNTRL_REG","this.has","register","this.register","addIdentifier","identifier","expression","later","$controllerMinErr","controllerPrototype","$controllerInit","changeListener","hidden","doc","exception","cause","serializeValue","toISOString","ngParamSerializer","params","jQueryLikeParamSerializer","serialize","toSerialize","topLevel","defaultHttpResponseTransform","headers","tempData","JSON_PROTECTION_PREFIX","contentType","hasJsonContentType","APPLICATION_JSON","jsonStart","JSON_START","JSON_ENDS","$httpMinErr","parseHeaders","line","headerVal","headerKey","headersGetter","headersObj","transformData","status","fns","defaults","transformResponse","transformRequest","d","common","CONTENT_TYPE_APPLICATION_JSON","patch","xsrfCookieName","xsrfHeaderName","paramSerializer","jsonpCallbackParam","useApplyAsync","this.useApplyAsync","interceptorFactories","interceptors","xsrfWhitelistedOrigins","requestConfig","chainInterceptors","promise","thenFn","rejectFn","executeHeaderFns","headerContent","processedHeaders","headerFn","header","response","resp","reject","mergeHeaders","defHeaders","reqHeaders","defHeaderName","lowercaseDefHeaderName","reqHeaderName","requestInterceptors","responseInterceptors","resolve","reversedInterceptors","interceptor","request","requestError","responseError","serverRequest","reqData","withCredentials","sendReq","finally","completeOutstandingRequest","createApplyHandlers","eventHandlers","applyHandlers","callEventHandler","$applyAsync","$$phase","done","headersString","statusText","xhrStatus","resolveHttpPromise","resolvePromise","deferred","resolvePromiseWithResult","removePendingReq","pendingRequests","cachedResp","isJsonp","getTrustedResourceUrl","buildUrl","sanitizeJsonpCallbackParam","defaultCache","xsrfValue","urlIsAllowedOrigin","timeout","responseType","uploadEventHandlers","serializedParams","cbKey","interceptorFactory","urlIsAllowedOriginFactory","createShortMethods","createShortMethodsWithData","createXhr","XMLHttpRequest","createHttpBackend","$browserDefer","callbacks","rawDocument","jsonpReq","callbackPath","async","body","wasCalled","timeoutRequest","abortedByTimeout","jsonpDone","xhr","abort","completeRequest","createCallback","getResponse","removeCallback","open","setRequestHeader","onload","xhr.onload","responseText","protocol","getAllResponseHeaders","onerror","ontimeout","requestTimeout","onabort","requestAborted","upload","send","$$timeoutId","this.startSymbol","this.endSymbol","escape","ch","unescapeText","escapedStartRegexp","escapedEndRegexp","constantWatchDelegate","objectEquality","constantInterp","unwatch","constantInterpolateWatch","parseStringifyInterceptor","contextAllowsConcatenation","$interpolateMinErr","interr","unescapedText","exp","$$watchDelegate","endIndex","parseFns","textLength","expressionPositions","singleExpression","startSymbolLength","endSymbolLength","map","compute","throwNoconcat","interpolationFn","$watchGroup","interpolateFnWatcher","oldValues","currValue","$interpolate.startSymbol","$interpolate.endSymbol","intervals","clearIntervalFn","clearInterval","interval","setIntervalFn","tick","setInterval","interval.cancel","$intervalMinErr","$$intervalId","q","$$state","pur","intervalFactory","intervalFn","count","invokeApply","hasParams","iteration","skipApply","notify","parseAbsoluteUrl","absoluteUrl","locationObj","parsedUrl","$$protocol","$$host","hostname","$$port","port","DEFAULT_PORTS","parseAppUrl","html5Mode","DOUBLE_SLASH_REGEX","$locationMinErr","prefixed","segments","pathname","$$path","$$search","search","$$hash","startsWith","stripBaseUrl","base","LocationHtml5Url","appBase","appBaseNoFile","basePrefix","$$html5","$$parse","this.$$parse","pathUrl","$$compose","$$normalizeUrl","this.$$normalizeUrl","$$parseLinkUrl","this.$$parseLinkUrl","relHref","appUrl","prevAppUrl","rewrittenUrl","LocationHashbangUrl","hashPrefix","withoutBaseUrl","withoutHashUrl","windowsFilePathExp","firstPathSegmentMatch","LocationHashbangInHtml5Url","locationGetter","locationGetterSetter","preprocess","requireBase","rewriteLinks","this.hashPrefix","this.html5Mode","urlsEqual","setBrowserUrlWithFallback","oldUrl","oldState","afterLocationChange","$broadcast","absUrl","LocationMode","initialUrl","lastIndexOf","IGNORE_URI_REGEXP","ctrlKey","metaKey","shiftKey","which","button","absHref","preventDefault","initializing","newUrl","newState","$digest","$locationWatch","$$urlUpdatedByLocation","currentReplace","$$replace","urlOrStateChanged","debug","debugEnabled","this.debugEnabled","flag","formatError","formatStackTrace","sourceURL","consoleLog","logFn","log","navigator","userAgent","warn","getStringValue","ifDefined","plusFn","r","isPure","parentIsPure","AST","MemberExpression","computed","UnaryExpression","PURITY_ABSOLUTE","BinaryExpression","operator","CallExpression","PURITY_RELATIVE","findConstantAndWatchExpressions","ast","allConstants","argsToWatch","astIsPure","Program","expr","Literal","toWatch","argument","left","right","LogicalExpression","ConditionalExpression","alternate","consequent","Identifier","object","isStatelessFilter","callee","AssignmentExpression","ArrayExpression","ObjectExpression","properties","ThisExpression","LocalsExpression","getInputs","lastExpression","isAssignable","assignableAST","NGValueParameter","ASTCompiler","ASTInterpreter","Parser","lexer","astCompiler","getValueOf","objectValueOf","literals","identStart","identContinue","addLiteral","this.addLiteral","literalName","literalValue","setIdentifierFns","this.setIdentifierFns","identifierStart","identifierContinue","interceptorFn","parsedExpression","cacheKey","Lexer","$parseOptions","parser","addWatchDelegate","addInterceptor","expressionInputDirtyCheck","oldValueOfValue","compareObjectIdentity","inputsWatchDelegate","prettyPrintExpression","inputExpressions","inputs","lastResult","oldInputValueOf","expressionInputWatch","newInputValue","oldInputValueOfValues","oldInputValues","expressionInputsWatch","changed","oneTimeWatchDelegate","unwatchIfDone","isDone","oneTimeWatch","useInputs","isAllDefined","$$intercepted","$$interceptor","allDefined","constantWatch","oneTime","first","second","chainedInterceptor","$$pure","depurifier","s","noUnsafeEval","isIdentifierStart","isIdentifierContinue","$$getAst","getAst","errorOnUnhandledRejections","qFactory","this.errorOnUnhandledRejections","nextTick","exceptionHandler","Deferred","Promise","this.resolve","this.reject","rejectPromise","this.notify","progress","notifyPromise","processChecks","queueSize","checkQueue","toCheck","errorMessage","scheduleProcessQueue","pending","processScheduled","$$passToExceptionHandler","$$reject","$qMinErr","$$resolve","doResolve","doReject","doNotify","handleCallback","resolver","callbackOutput","when","errback","progressBack","$Q","resolveFn","TypeError","onFulfilled","onRejected","promises","counter","results","race","requestAnimationFrame","webkitRequestAnimationFrame","cancelAnimationFrame","webkitCancelAnimationFrame","webkitCancelRequestAnimationFrame","rafSupported","raf","timer","supported","createChildScopeClass","ChildScope","$$watchers","$$nextSibling","$$childHead","$$childTail","$$listeners","$$listenerCount","$$watchersCount","$id","$$ChildScope","$$suspended","$rootScopeMinErr","lastDirtyWatch","applyAsyncId","digestTtl","this.digestTtl","destroyChildScope","$event","currentScope","cleanUpScope","$$prevSibling","$root","Scope","beginPhase","phase","incrementWatchersCount","decrementListenerCount","initWatchVal","flushApplyAsync","applyAsyncQueue","scheduleApplyAsync","isolate","child","watchExp","watcher","last","eq","$$digestWatchIndex","deregisterWatch","watchExpressions","watchGroupAction","changeReactionScheduled","firstRun","newValues","deregisterFns","shouldCall","deregisterWatchGroup","unwatchFn","watchGroupSubAction","$watchCollectionInterceptor","_value","bothNaN","newItem","oldItem","internalArray","oldLength","changeDetected","newLength","internalObject","veryOldValue","trackVeryOldValue","changeDetector","initRun","$watchCollectionAction","watch","watchers","dirty","ttl","asyncQueue","watchLog","logIdx","asyncTask","asyncQueuePosition","msg","next","postDigestQueuePosition","postDigestQueue","$suspend","$isSuspended","$resume","eventName","this.$watchGroup","$eval","$applyAsyncExpression","namedListeners","indexOfListener","$emit","targetScope","listenerArgs","$$asyncQueue","$$postDigestQueue","$$applyAsyncQueue","sanitizeUri","uri","isMediaUrl","regex","normalizedVal","adjustMatcher","matcher","$sceMinErr","escapeForRegexp","adjustMatchers","matchers","adjustedMatchers","resourceUrlWhitelist","resourceUrlBlacklist","this.resourceUrlWhitelist","this.resourceUrlBlacklist","matchUrl","baseURI","baseUrlParsingNode","generateHolderType","Base","holderType","trustedValue","$$unwrapTrustedValue","this.$$unwrapTrustedValue","holderType.prototype.valueOf","holderType.prototype.toString","htmlSanitizer","trustedValueHolderBase","byType","JS","trustAs","Constructor","maybeTrusted","allowed","this.enabled","sce","isEnabled","sce.isEnabled","sce.getTrusted","parseAs","sce.parseAs","enumValue","lName","UNDERSCORE_LOWERCASE_REGEXP","eventSupport","hasHistoryPushState","nw","process","chrome","app","runtime","pushState","android","boxee","bodyStyle","transitions","animations","hasEvent","divElm","TaskTracker","getLastCallback","cbInfo","taskCallbacks","pop","cb","getLastCallbackForType","taskCounts","ALL_TASKS_TYPE","countForType","countForAll","getNextCallback","nextCb","httpOptions","this.httpOptions","handleRequestFn","tpl","ignoreRequestError","totalPendingRequests","transformer","handleError","$templateRequestMinErr","testability","testability.findBindings","opt_exactMatch","getElementsByClassName","matches","dataBinding","bindingName","testability.findModels","prefixes","attributeEquals","testability.getLocation","testability.setLocation","testability.whenStable","deferreds","timeout.cancel","$timeoutMinErr","urlParsingNode","ipv6InBrackets","whitelistedOriginUrls","parsedAllowedOriginUrls","originUrl","requestUrl","urlsAreSameOrigin","url1","url2","$$CookieReader","safeDecodeURIComponent","lastCookies","lastCookieString","cookieArray","cookie","currentCookieString","filters","suffix","currencyFilter","dateFilter","filterFilter","jsonFilter","limitToFilter","lowercaseFilter","numberFilter","orderByFilter","uppercaseFilter","comparator","anyPropertyKey","matchAgainstAnyProp","getTypeForFilter","expressionType","predicateFn","createPredicateFn","shouldMatchPrimitives","actual","expected","deepCompare","dontMatchWholeObject","actualType","expectedType","expectedVal","matchAnyProperty","actualVal","$locale","formats","NUMBER_FORMATS","amount","currencySymbol","fractionSize","CURRENCY_SYM","PATTERNS","maxFrac","currencySymbolRe","formatNumber","GROUP_SEP","DECIMAL_SEP","number","numStr","exponent","digits","numberOfIntegerDigits","zeros","ZERO_CHAR","MAX_DIGITS","roundNumber","parsedNumber","minFrac","fractionLen","min","roundAt","digit","k","carry","reduceRight","groupSep","decimalSep","isNaN","isInfinity","isFinite","isZero","abs","formattedText","integerLen","decimals","reduce","groups","lgSize","gSize","negPre","negSuf","posPre","posSuf","padNumber","num","negWrap","neg","dateGetter","dateStrGetter","shortForm","standAlone","getFirstThursdayOfYear","year","dayOfWeekOnFirst","getDay","weekGetter","firstThurs","getFullYear","thisThurs","getMonth","getDate","round","eraGetter","ERAS","jsonStringToDate","string","R_ISO8601_STR","tzHour","tzMin","dateSetter","setUTCFullYear","setFullYear","timeSetter","setUTCHours","setHours","m","ms","parseFloat","format","DATETIME_FORMATS","NUMBER_STRING","DATE_FORMATS_SPLIT","DATE_FORMATS","spacing","limit","begin","Infinity","sliceFn","end","processPredicates","sortPredicates","predicate","descending","defaultCompare","v1","v2","type1","type2","value1","value2","sortPredicate","reverseOrder","compareFn","predicates","compareValues","getComparisonObject","tieBreaker","predicateValues","doComparison","ngDirective","FormController","$$controls","$error","$$success","$pending","$name","$dirty","$valid","$pristine","$submitted","$invalid","$$parentForm","nullFormCtrl","$$animate","setupValidity","$$classCache","INVALID_CLASS","VALID_CLASS","addSetValidityMethod","cachedToggleClass","ctrl","switchValue","toggleValidationCss","validationErrorKey","isValid","unset","clazz","$setValidity","clazz.prototype.$setValidity","isObjectEmpty","PENDING_CLASS","combinedState","stringBasedInputType","$formatters","$isEmpty","baseInputType","composing","ev","ngTrim","$viewValue","$$hasNativeValidators","$setViewValue","deferListener","origValue","keyCode","PARTIAL_VALIDATION_TYPES","PARTIAL_VALIDATION_EVENTS","validity","origBadInput","badInput","origTypeMismatch","typeMismatch","$render","ctrl.$render","createDateParser","mapping","iso","previousDate","ISO_DATE_REGEXP","yyyy","MM","dd","HH","getHours","mm","ss","getSeconds","sss","getMilliseconds","part","createDateInputType","parseDate","dynamicDateInputType","isValidDate","parseObservedDateValue","parseDateAndConvertTimeZoneToLocal","$options","getOption","previousTimezone","parsedDate","badInputChecker","isTimeType","$parsers","$$parserName","ngModelMinErr","targetFormat","formatted","ngMin","minVal","parsedMinVal","$validators","ctrl.$validators.min","$validate","ngMax","maxVal","parsedMaxVal","ctrl.$validators.max","parserName","VALIDITY_STATE_PROPERTY","numberFormatterParser","NUMBER_REGEXP","parseNumberAttrVal","countDecimals","numString","decimalSymbolIndex","isValidForStep","viewValue","stepBase","step","isNonIntegerValue","isNonIntegerStepBase","isNonIntegerStep","valueDecimals","stepBaseDecimals","stepDecimals","decimalCount","multiplier","pow","parseConstantExpr","parseFn","classDirective","arrayDifference","toClassString","classValue","classString","indexWatchExpression","digestClassCounts","classArray","classesToUpdate","classCounts","ngClassIndexWatchAction","newModulo","oldClassString","oldModulo","moduloTwo","$index","ngClassWatchAction","newClassString","oldClassArray","newClassArray","toRemoveArray","toAddArray","toRemoveString","toAddString","forceAsync","ngEventHandler","NgModelController","$modelValue","$$rawModelValue","$asyncValidators","$viewChangeListeners","$untouched","$touched","defaultModelOptions","$$updateEvents","$$updateEventHandler","$$parsedNgModel","$$parsedNgModelAssign","$$ngModelGet","$$ngModelSet","$$pendingDebounce","$$parserValid","$$currentValidationRunId","$$rootScope","$$attr","$$timeout","$$exceptionHandler","setupModelWatcher","ngModelWatch","modelValue","$$setModelValue","ModelOptions","$$options","setOptionSelectedStatus","optionEl","parsePatternAttr","patternExp","parseLength","intVal","REGEX_STRING_REGEXP","documentMode","rules","ngCspElement","ngCspAttribute","noInlineStyle","name_","el","allowAutoBootstrap","currentScript","HTMLScriptElement","SVGScriptElement","srcs","getNamedItem","every","origin","full","major","minor","dot","codeName","expando","JQLite._data","MS_HACK_REGEXP","mouseleave","mouseenter","optgroup","tbody","tfoot","colgroup","caption","thead","th","td","Node","contains","compareDocumentPosition","ready","removeData","jqLiteHasData","jqLiteCleanData","removeAttribute","css","NODE_TYPE_ATTRIBUTE","lowercasedName","isBooleanAttr","ret","getText","$dv","multiple","selected","arg1","arg2","nodeCount","jqLiteOn","types","addHandler","noEventListener","one","onFn","replaceNode","insertBefore","children","contentDocument","prepend","wrapNode","detach","after","newElement","toggleClass","condition","classCondition","nextElementSibling","getElementsByTagName","extraParameters","dummyEvent","handlerArgs","eventFnsCopy","arg3","unbind","nanKey","_idx","_transformKey","delete","FN_ARG_SPLIT","FN_ARG","argDecl","underscore","$animateMinErr","postDigestElements","updateData","handleCSSClassChanges","existing","pin","domOperation","from","to","classesAdded","add","classesRemoved","runner","complete","classNameFilter","customFilter","$$registeredAnimations","this.customFilter","filterFn","this.classNameFilter","reservedRegex","NG_ANIMATE_CLASSNAME","domInsert","parentElement","afterElement","afterNode","ELEMENT_NODE","previousElementSibling","enter","move","leave","addclass","setClass","animate","tempClasses","waitForTick","waitQueue","passed","AnimateRunner","setHost","rafTick","_doneCallbacks","_tick","this._tick","_state","chain","AnimateRunner.chain","AnimateRunner.all","runners","onProgress","DONE_COMPLETE_STATE","getPromise","resolveHandler","rejectHandler","pause","resume","_resolve","INITIAL_STATE","DONE_PENDING_STATE","initialOptions","closed","$$prepared","cleanupStyles","start","UNINITIALIZED_VALUE","isFirstChange","SimpleChange.prototype.isFirstChange","domNode","offsetWidth","$interpolateMinErr.throwNoconcat","$interpolateMinErr.interr","callbackId","called","callbackMap","PATH_MATCH","locationPrototype","$$absUrl","hashValue","pathValue","$$url","paramValue","Location","Location.prototype.state","$parseMinErr","OPERATORS","ESCAPE","lex","tokens","readString","peek","readNumber","peekMultichar","readIdent","is","isWhitespace","ch2","ch3","op2","op3","op1","throwError","chars","codePointAt","isValidIdentifierStart","isValidIdentifierContinue","cp","charCodeAt","cp1","cp2","isExpOperator","colStr","peekCh","quote","rawString","hex","String","fromCharCode","rep","ExpressionStatement","Property","program","expressionStatement","expect","filterChain","assignment","ternary","logicalOR","consume","logicalAND","equality","relational","additive","multiplicative","unary","primary","arrayDeclaration","selfReferential","parseArguments","baseExpression","peekToken","kind","e1","e2","e3","e4","peekAhead","t","nextId","vars","own","assignable","stage","computing","recurse","return_","generateFunction","fnKey","intoId","watchId","fnString","USE","STRICT","filterPrefix","watchFns","varsPrefix","section","nameId","recursionFn","skipWatchIdCheck","if_","lazyAssign","computedMember","lazyRecurse","plus","not","getHasOwnProperty","isNull","nonComputedMember","notNull","member","filterName","defaultValue","UNSAFE_CHARACTERS","SAFE_IDENTIFIER","stringEscapeFn","stringEscapeRegex","c","skip","init","fn.assign","rhs","lhs","unary+","unary-","unary!","binary+","binary-","binary*","binary/","binary%","binary===","binary!==","binary==","binary!=","binary<","binary>","binary<=","binary>=","binary&&","binary||","ternary?:","yy","y","MMMM","MMM","M","LLLL","H","hh","EEEE","EEE","ampmGetter","AMPMS","Z","timeZoneGetter","zone","paddedZone","ww","w","G","GG","GGG","GGGG","longEraGetter","ERANAMES","xlinkHref","defaultLinkFn","normalized","ngBooleanAttrWatchAction","htmlAttr","ngAttrAliasWatchAction","$addControl","$getControls","$$renameControl","nullFormRenameControl","control","$removeControl","$setDirty","$setPristine","$setSubmitted","$$setSubmitted","$rollbackViewValue","$commitViewValue","newName","oldName","PRISTINE_CLASS","DIRTY_CLASS","SUBMITTED_CLASS","$setUntouched","rootForm","formDirectiveFactory","isNgForm","getSetter","ngFormCompile","formElement","nameAttr","ngFormPreLink","ctrls","handleFormSubmission","setter","URL_REGEXP","EMAIL_REGEXP","DATE_REGEXP","DATETIMELOCAL_REGEXP","WEEK_REGEXP","MONTH_REGEXP","TIME_REGEXP","inputType","textInputType","weekParser","isoWeek","existingDate","week","hours","seconds","milliseconds","addDays","numberInputType","ngStep","stepVal","parsedStepVal","ctrl.$validators.step","urlInputType","ctrl.$validators.url","emailInputType","email","ctrl.$validators.email","radioInputType","doTrim","checked","rangeInputType","setInitialValueAndObserver","htmlAttrName","changeFn","wrappedObserver","minChange","supportsRange","elVal","maxChange","stepChange","hasMinAttr","hasMaxAttr","hasStepAttr","originalRender","rangeUnderflow","rangeOverflow","rangeRender","noopMinValidator","minValidator","noopMaxValidator","maxValidator","nativeStepValidator","stepMismatch","stepValidator","checkboxInputType","trueValue","ngTrueValue","falseValue","ngFalseValue","ctrl.$isEmpty","valueProperty","configurable","enumerable","defineProperty","CONSTANT_VALUE_REGEXP","updateElementValue","tplAttr","ngValueConstantLink","ngValueLink","valueWatchAction","$compile","ngBindCompile","templateElement","ngBindLink","ngBindWatchAction","ngBindTemplateCompile","ngBindTemplateLink","ngBindHtmlCompile","ngBindHtmlGetter","ngBindHtmlWatch","ngBindHtmlLink","ngBindHtmlWatchAction","getTrustedHtml","forceAsyncEvents","previousElements","ngIfWatchAction","srcExp","onloadExp","autoScrollExp","autoscroll","changeCounter","previousElement","currentElement","cleanupLastIncludeContent","ngIncludeWatchAction","afterAnimation","thisChangeId","namespaceAdaptedClone","trimValues","$$initGetterSetters","invokeModelGetter","invokeModelSetter","this.$$ngModelGet","this.$$ngModelSet","$$$p","$$updateEmptyClasses","NOT_EMPTY_CLASS","EMPTY_CLASS","UNTOUCHED_CLASS","TOUCHED_CLASS","$setTouched","$$lastCommittedViewValue","prevValid","prevModelValue","allowInvalid","that","$$runValidators","allValid","$$writeModelToScope","doneCallback","processSyncValidators","syncValidatorsValid","validator","Boolean","setValidity","processAsyncValidators","validatorPromises","validationDone","localValidationRunId","processParseErrors","errorKey","$$parseAndValidate","$$debounceViewValueCommit","debounceDelay","$overrideModelOptions","createChild","$$setUpdateOnEvents","$processModelValue","$$format","formatters","ngModelCompile","ngModelPreLink","modelCtrl","formCtrl","optionsCtrl","ngModelPostLink","setTouched","DEFAULT_REGEXP","inheritAll","updateOnDefault","updateOn","debounce","getterSetter","NgModelOptionsController","$$attrs","parentOptions","parentCtrl","modelOptionsDefinition","ngOptionsMinErr","NG_OPTIONS_REGEXP","parseOptionsExpression","optionsExp","selectElement","Option","selectValue","label","group","disabled","getOptionValuesKeys","optionValues","optionValuesKeys","keyName","itemKey","valueName","selectAs","trackBy","viewValueFn","trackByFn","getTrackByValueFn","getHashOfValue","getTrackByValue","getLocals","displayFn","groupByFn","disableWhenFn","valuesFn","getWatchables","watchedArray","optionValuesLength","disableWhen","getOptions","optionItems","selectValueMap","optionItem","getOptionFromViewValue","getViewValueFromOption","optionTemplate","optGroupTemplate","ngOptionsPreLink","registerOption","ngOptionsPostLink","getAndUpdateSelectedOption","updateOptionElement","selectCtrl","ngModelCtrl","hasEmptyOption","emptyOption","providedEmptyOption","unknownOption","listFragment","generateUnknownOptionValue","selectCtrl.generateUnknownOptionValue","writeValue","selectCtrl.writeValue","selectedOptions","readValue","selectCtrl.readValue","selectedValues","selections","selectedOption","selectedIndex","removeUnknownOption","selectUnknownOrEmptyOption","unselectEmptyOption","selectCtrl.registerOption","optionScope","needsRerender","$isEmptyOptionSelected","updateOptions","groupElementMap","addOption","groupElement","optionElement","nextValue","BRACE","IS_WHEN","updateElementText","newText","numberExp","whenExp","whens","whensExpFns","braceReplacement","watchRemover","lastCount","attributeName","tmpMatch","whenKey","ngPluralizeWatchAction","countIsNaN","pluralCat","whenExpFn","ngRefMinErr","refValue","ngRefRead","ngRepeatMinErr","updateScope","valueIdentifier","keyIdentifier","arrayLength","$first","$last","$middle","$odd","$even","trackByIdArrayFn","trackByIdObjFn","ngRepeatCompile","ngRepeatEndComment","aliasAs","trackByExp","trackByIdExpFn","hashFnLocals","trackByExpGetter","ngRepeatLink","lastBlockMap","ngRepeatAction","previousNode","nextNode","nextBlockMap","collectionLength","trackById","collectionKeys","nextBlockOrder","trackByIdFn","blockKey","ngRepeatTransclude","ngShowWatchAction","NG_HIDE_CLASS","NG_HIDE_IN_PROGRESS_CLASS","ngHideWatchAction","ngStyleWatchAction","newStyles","oldStyles","NgSwitchController","cases","ngSwitchController","selectedTranscludes","selectedElements","previousLeaveAnimations","selectedScopes","spliceFactory","ngSwitchWatchAction","selectedTransclude","caseElement","selectedScope","anchor","ngSwitchWhenSeparator","whenCase","ngTranscludeMinErr","ngTranscludeCompile","fallbackLinkFn","ngTranscludePostLink","useFallbackContent","ngTranscludeSlot","ngTranscludeCloneAttachFn","noopNgModelController","SelectController","scheduleRender","renderScheduled","scheduleViewValueUpdate","renderAfter","updateScheduled","optionsMap","renderUnknownOption","self.renderUnknownOption","unknownVal","updateUnknownOption","self.updateUnknownOption","self.generateUnknownOptionValue","self.removeUnknownOption","selectEmptyOption","self.selectEmptyOption","self.unselectEmptyOption","self.readValue","realVal","hasOption","self.writeValue","currentlySelectedOption","hashedVal","self.addOption","removeOption","self.removeOption","self.hasOption","$hasEmptyOption","self.$hasEmptyOption","$isUnknownOptionSelected","self.$isUnknownOptionSelected","self.$isEmptyOptionSelected","self.selectUnknownOrEmptyOption","self.registerOption","optionAttrs","interpolateValueFn","interpolateTextFn","valueAttributeObserveAction","removal","previouslySelected","interpolateWatchAction","removeValue","selectPreLink","shouldBeSelected","lastView","lastViewRef","selectMultipleWatch","ngModelCtrl.$isEmpty","selectPostLink","ngModelCtrl.$render","selectCtrlName","ctrl.$validators.required","tElm","tAttr","attrVal","oldRegexp","ctrl.$validators.pattern","maxlengthParsed","ctrl.$validators.maxlength","minlengthParsed","ctrl.$validators.minlength","getDecimals","opt_precision","ONE","OTHER","$$csp","head"]
/src/angular.min.js.map-8-}
##############################################
/src/angular.js-818-function isScope(obj) {
/src/angular.js:819:  return obj && obj.$evalAsync && obj.$watch;
/src/angular.js-820-}
##############################################
/src/angular.js-1272-      csp.rules = {
/src/angular.js:1273:        noUnsafeEval: !ngCspAttribute || (ngCspAttribute.indexOf('no-unsafe-eval') !== -1),
/src/angular.js-1274-        noInlineStyle: !ngCspAttribute || (ngCspAttribute.indexOf('no-inline-style') !== -1)
##############################################
/src/angular.js-1371- *
/src/angular.js:1372: * @param {Object} self Context which `fn` should be evaluated in.
/src/angular.js-1373- * @param {function()} fn Function to be bound.
##############################################
/src/angular.js-1666-
/src/angular.js:1667:    var link = document.createElement('a');
/src/angular.js-1668-    link.href = src.value;
/src/angular.js-1669-
/src/angular.js:1670:    if (document.location.origin === link.origin) {
/src/angular.js-1671-      // Same-origin resources are always allowed, even for non-whitelisted schemes.
##############################################
/src/angular.js-1861-      window.console.error('AngularJS: disabling automatic bootstrap. <script> protocol indicates ' +
/src/angular.js:1862:          'an extension, document.location.href does not match.');
/src/angular.js-1863-      return;
##############################################
/src/angular.js-2008-  window.name = 'NG_ENABLE_DEBUG_INFO!' + window.name;
/src/angular.js:2009:  window.location.reload();
/src/angular.js-2010-}
##############################################
/src/angular.js-3524-  if (window.document.readyState === 'complete') {
/src/angular.js:3525:    window.setTimeout(fn);
/src/angular.js-3526-  } else {
##############################################
/src/angular.js-4238- * In the following example a new block of HTML containing a `ng-controller`
/src/angular.js:4239: * directive is added to the end of the document body by JQuery. We then compile and link
/src/angular.js-4240- * it into the current AngularJS scope.
##############################################
/src/angular.js-4243- * var $div = $('<div ng-controller="MyCtrl">{{content.label}}</div>');
/src/angular.js:4244: * $(document.body).append($div);
/src/angular.js-4245- *
##############################################
/src/angular.js-5180- * Use `$anchorScrollProvider` to disable automatic scrolling whenever
/src/angular.js:5181: * {@link ng.$location#hash $location.hash()} changes.
/src/angular.js-5182- */
##############################################
/src/angular.js-5192-   * By default, {@link ng.$anchorScroll $anchorScroll()} will automatically detect changes to
/src/angular.js:5193:   * {@link ng.$location#hash $location.hash()} and scroll to the element matching the new hash.<br />
/src/angular.js-5194-   * Use this method to disable automatic scrolling.
##############################################
/src/angular.js-5213-   * When called, it scrolls to the element related to the specified `hash` or (if omitted) to the
/src/angular.js:5214:   * current value of {@link ng.$location#hash $location.hash()}, according to the rules specified
/src/angular.js-5215-   * in the
##############################################
/src/angular.js-5217-   *
/src/angular.js:5218:   * It also watches the {@link ng.$location#hash $location.hash()} and automatically scrolls to
/src/angular.js-5219-   * match any anchor whenever it changes. This can be disabled by calling
##############################################
/src/angular.js-5225-   * @param {string=} hash The hash specifying the element to scroll to. If omitted, the value of
/src/angular.js:5226:   *                       {@link ng.$location#hash $location.hash()} will be used.
/src/angular.js-5227-   *
##############################################
/src/angular.js-5260-               $scope.gotoBottom = function() {
/src/angular.js:5261:                 // set the location.hash to the id of
/src/angular.js-5262-                 // the element you wish to scroll to.
/src/angular.js:5263:                 $location.hash('bottom');
/src/angular.js-5264-
##############################################
/src/angular.js-5307-                 var newHash = 'anchor' + x;
/src/angular.js:5308:                 if ($location.hash() !== newHash) {
/src/angular.js:5309:                   // set the $location.hash to `newHash` and
/src/angular.js-5310-                   // $anchorScroll will automatically scroll to it
/src/angular.js:5311:                   $location.hash('anchor' + x);
/src/angular.js-5312-                 } else {
/src/angular.js-5313-                   // call $anchorScroll() explicitly,
/src/angular.js:5314:                   // since $location.hash hasn't changed
/src/angular.js-5315-                   $anchorScroll();
##############################################
/src/angular.js-5412-      // Allow numeric hashes
/src/angular.js:5413:      hash = isString(hash) ? hash : isNumber(hash) ? hash.toString() : $location.hash();
/src/angular.js-5414-      var elm;
##############################################
/src/angular.js-5429-    // does not scroll when user clicks on anchor link that is currently on
/src/angular.js:5430:    // (no url change, no $location.hash() change), browser native does scroll
/src/angular.js-5431-    if (autoScrollingEnabled) {
/src/angular.js:5432:      $rootScope.$watch(function autoScrollWatch() {return $location.hash();},
/src/angular.js-5433-        function autoScrollWatchAction(newVal, oldVal) {
/src/angular.js:5434:          // skip the initial scroll if $location.hash is empty
/src/angular.js-5435-          if (newVal === oldVal && newVal === '') return;
##############################################
/src/angular.js-5437-          jqLiteDocumentLoaded(function() {
/src/angular.js:5438:            $rootScope.$evalAsync(scroll);
/src/angular.js-5439-          });
##############################################
/src/angular.js-5890-       *    was bootstrapped on an element that is somewhere inside of the `<body>` tag, but we wanted to allow for an element to be situated
/src/angular.js:5891:       *    as a direct child of `document.body`, then this can be achieved by pinning the element via `$animate.pin(element)`. Keep in mind
/src/angular.js-5892-       *    that calling `$animate.pin(element, parentElement)` will not actually insert into the DOM anywhere; it will just create the association.
##############################################
/src/angular.js-6163-       *    triggers an animation surrounding the class addition/removal. Much like `$animate.addClass` and
/src/angular.js:6164:       *    `$animate.removeClass`, `setClass` will only evaluate the classes being added/removed once a digest has
/src/angular.js-6165-       *    passed. Note that class-based animations are treated differently compared to structural animations
##############################################
/src/angular.js-6537-  var self = this,
/src/angular.js:6538:      location = window.location,
/src/angular.js-6539-      history = window.history,
/src/angular.js:6540:      setTimeout = window.setTimeout,
/src/angular.js-6541-      clearTimeout = window.clearTimeout,
##############################################
/src/angular.js-6562-  var cachedState, lastHistoryState,
/src/angular.js:6563:      lastBrowserUrl = location.href,
/src/angular.js-6564-      baseElement = document.find('base'),
##############################################
/src/angular.js-6580-   * GETTER:
/src/angular.js:6581:   * Without any argument, this method just returns current value of `location.href` (with a
/src/angular.js-6582-   * trailing `#` stripped of if the hash is empty).
##############################################
/src/angular.js-6586-   * If html5 history api supported, `pushState`/`replaceState` is used, otherwise
/src/angular.js:6587:   * `location.href`/`location.replace` is used.
/src/angular.js-6588-   * Returns its own instance to allow chaining.
##############################################
/src/angular.js-6605-    // Android Browser BFCache causes location, history reference to become stale.
/src/angular.js:6606:    if (location !== window.location) location = window.location;
/src/angular.js-6607-    if (history !== window.history) history = window.history;
##############################################
/src/angular.js-6638-        } else if (!sameBase) {
/src/angular.js:6639:          location.href = url;
/src/angular.js-6640-        } else {
/src/angular.js:6641:          location.hash = getHash(url);
/src/angular.js-6642-        }
/src/angular.js:6643:        if (location.href !== url) {
/src/angular.js-6644-          pendingLocation = url;
##############################################
/src/angular.js-6653-      // - pendingLocation is needed as browsers don't allow to read out
/src/angular.js:6654:      //   the new location.href if a reload happened or if there is a bug like in iOS 9 (see
/src/angular.js-6655-      //   https://openradar.appspot.com/22186109).
/src/angular.js:6656:      return trimEmptyHash(pendingLocation || location.href);
/src/angular.js-6657-    }
##############################################
/src/angular.js-7213- *
/src/angular.js:7214: * The first time a template is used, it is loaded in the template cache for quick retrieval. You
/src/angular.js-7215- * can load templates directly into the cache in a `script` tag, by using {@link $templateRequest},
##############################################
/src/angular.js-7555- * * `=` or `=attr` - set up a bidirectional binding between a local scope property and an expression
/src/angular.js:7556: *   passed via the attribute `attr`. The expression is evaluated in the context of the parent scope.
/src/angular.js-7557- *   If no `attr` name is specified then the attribute name is assumed to be the same as the local
##############################################
/src/angular.js-7569- *   equality check is done by value (using the {@link angular.equals} function). It's also possible
/src/angular.js:7570: *   to watch the evaluated value shallowly with {@link ng.$rootScope.Scope#$watchCollection
/src/angular.js-7571- *   `$watchCollection`}: use `=*` or `=*attr`
##############################################
/src/angular.js-7573-  * * `<` or `<attr` - set up a one-way (one-directional) binding between a local scope property and an
/src/angular.js:7574: *   expression passed via the attribute `attr`. The expression is evaluated in the context of the
/src/angular.js-7575- *   parent scope. If no `attr` name is specified then the attribute name is assumed to be the same as the
##############################################
/src/angular.js-7598- *   method is used for tracking changes, and the equality check is based on object identity.
/src/angular.js:7599: *   It's also possible to watch the evaluated value shallowly with
/src/angular.js-7600- *   {@link ng.$rootScope.Scope#$watchCollection `$watchCollection`}: use `<*` or `<*attr`
##############################################
/src/angular.js-8084- *   the only way to easily get the actual value because during the linking phase the interpolation
/src/angular.js:8085: *   hasn't been evaluated yet and so the value is at this time set to `undefined`.
/src/angular.js-8086- *
##############################################
/src/angular.js-8120-                 // watch the 'compile' expression for changes
/src/angular.js:8121:                return scope.$eval(attrs.compile);
/src/angular.js-8122-              },
##############################################
/src/angular.js-8516- * The `ngOn` directive adds an event listener to a DOM element via
/src/angular.js:8517: * {@link angular.element angular.element().on()}, and evaluates an expression when the event is
/src/angular.js-8518- * fired.
##############################################
/src/angular.js-9254-    var SIMPLE_ATTR_NAME = /^\w/;
/src/angular.js:9255:    var specialAttrHolder = window.document.createElement('div');
/src/angular.js-9256-
##############################################
/src/angular.js-9543-        listeners.push(fn);
/src/angular.js:9544:        $rootScope.$evalAsync(function() {
/src/angular.js-9545-          if (!listeners.$$inter && attrs.hasOwnProperty(key) && !isUndefined(attrs[key])) {
##############################################
/src/angular.js-9620-      }
/src/angular.js:9621:      return window.document.createComment(content);
/src/angular.js-9622-    };
##############################################
/src/angular.js-10275-              // collect them up, compile them and store their transclusion functions
/src/angular.js:10276:              $template = window.document.createDocumentFragment();
/src/angular.js-10277-
##############################################
/src/angular.js-10303-                  filledSlots[slotName] = true;
/src/angular.js:10304:                  slots[slotName] = slots[slotName] || window.document.createDocumentFragment();
/src/angular.js-10305-                  slots[slotName].appendChild(node);
##############################################
/src/angular.js-11016-      case 'math':
/src/angular.js:11017:        var wrapper = window.document.createElement('div');
/src/angular.js-11018-        wrapper.innerHTML = '<' + type + '>' + template + '</' + type + '>';
##############################################
/src/angular.js-11230-      // - allow a single fragment.qSA to fetch all elements being removed
/src/angular.js:11231:      var fragment = window.document.createDocumentFragment();
/src/angular.js-11232-      for (i = 0; i < removeCount; i++) {
##############################################
/src/angular.js-11633-     *    * check if a controller with given name is registered via `$controllerProvider`
/src/angular.js:11634:     *    * check if evaluating the string on the current scope returns a constructor
/src/angular.js-11635-     *
##############################################
/src/angular.js-13606-    // we can't use jQuery/jqLite here because jQuery does crazy stuff with script elements, e.g.:
/src/angular.js:13607:    // - fetches local scripts via XHR and evals them
/src/angular.js-13608-    // - adds and immediately removes script elements from the document
##############################################
/src/angular.js-13784-     * `true`, the interpolation function will return `undefined` unless all embedded expressions
/src/angular.js:13785:     * evaluate to a value other than `undefined`.
/src/angular.js-13786-     *
##############################################
/src/angular.js-13872-     * @param {boolean=} allOrNothing if `true`, then the returned function returns undefined
/src/angular.js:13873:     *    unless all embedded expressions evaluate to a value other than `undefined`.
/src/angular.js-13874-     * @returns {function(context)} an interpolation function which is used to compute the
##############################################
/src/angular.js-13876-     *
/src/angular.js:13877:     * - `context`: evaluation context for all expressions embedded in the interpolated text
/src/angular.js-13878-     */
##############################################
/src/angular.js-13920-          expressionPositions.push(concat.length);
/src/angular.js:13921:          concat.push(''); // Placeholder that will get replaced with the evaluated expression.
/src/angular.js-13922-        } else {
##############################################
/src/angular.js-14058-    var setIntervalFn = function(tick, delay, deferred) {
/src/angular.js:14059:      var id = $window.setInterval(tick, delay);
/src/angular.js-14060-      intervals[id] = deferred;
##############################################
/src/angular.js-14072-     * @description
/src/angular.js:14073:     * AngularJS's wrapper for `window.setInterval`. The `fn` function is executed every `delay`
/src/angular.js-14074-     * milliseconds.
##############################################
/src/angular.js-14257-          } else {
/src/angular.js:14258:            $rootScope.$evalAsync(callback);
/src/angular.js-14259-          }
##############################################
/src/angular.js-14884-   * @ngdoc method
/src/angular.js:14885:   * @name $location#search
/src/angular.js-14886-   *
##############################################
/src/angular.js-14896-   * // given URL http://example.com/#/some/path?foo=bar&baz=xoxo
/src/angular.js:14897:   * var searchObject = $location.search();
/src/angular.js-14898-   * // => {foo: 'bar', baz: 'xoxo'}
##############################################
/src/angular.js-14900-   * // set foo to 'yipee'
/src/angular.js:14901:   * $location.search('foo', 'yipee');
/src/angular.js:14902:   * // $location.search() => {foo: 'yipee', baz: 'xoxo'}
/src/angular.js-14903-   * ```
##############################################
/src/angular.js-14945-          throw $locationMinErr('isrcharg',
/src/angular.js:14946:              'The first argument of the `$location#search()` call must be a string or an object.');
/src/angular.js-14947-        }
##############################################
/src/angular.js-14962-   * @ngdoc method
/src/angular.js:14963:   * @name $location#hash
/src/angular.js-14964-   *
##############################################
/src/angular.js-14974-   * // given URL http://example.com/#/some/path?foo=bar&baz=xoxo#hashValue
/src/angular.js:14975:   * var hash = $location.hash();
/src/angular.js-14976-   * // => "hashValue"
##############################################
/src/angular.js-15070- * The $location service parses the URL in the browser address bar (based on the
/src/angular.js:15071: * [window.location](https://developer.mozilla.org/en/window.location)) and makes the URL
/src/angular.js-15072- * available to your application. Changes to the URL in the address bar are reflected into
##############################################
/src/angular.js-15319-        // If we are navigating outside of the app then force a reload
/src/angular.js:15320:        $window.location.href = newUrl;
/src/angular.js-15321-        return;
##############################################
/src/angular.js-15323-
/src/angular.js:15324:      $rootScope.$evalAsync(function() {
/src/angular.js-15325-        var oldUrl = $location.absUrl();
##############################################
/src/angular.js-15364-
/src/angular.js:15365:          $rootScope.$evalAsync(function() {
/src/angular.js-15366-            var newUrl = $location.absUrl();
##############################################
/src/angular.js-15389-
/src/angular.js:15390:      // we don't need to return anything because $evalAsync will make the digest loop dirty when
/src/angular.js-15391-      // there is a change
##############################################
/src/angular.js-17271- *    * `context`  `{object}`  an object against which any expressions embedded in the strings
/src/angular.js:17272: *      are evaluated against (typically a scope object).
/src/angular.js-17273- *    * `locals`  `{object=}`  local variables context object, useful for overriding values in
##############################################
/src/angular.js-17816-    return qFactory(function(callback) {
/src/angular.js:17817:      $rootScope.$evalAsync(callback);
/src/angular.js-17818-    }, $exceptionHandler, errorOnUnhandledRejections);
##############################################
/src/angular.js-18251-  // Let's make the instanceof operator work for promises, so that
/src/angular.js:18252:  // `new $q(fn) instanceof $q` would evaluate to true.
/src/angular.js-18253-  $Q.prototype = Promise.prototype;
##############################################
/src/angular.js-18623-       * After a watcher is registered with the scope, the `listener` fn is called asynchronously
/src/angular.js:18624:       * (via {@link ng.$rootScope.Scope#$evalAsync $evalAsync}) to initialize the
/src/angular.js-18625-       * watcher. In rare cases, this is undesirable because the listener is called when the result
##############################################
/src/angular.js-18689-       *
/src/angular.js:18690:       * @param {(function()|string)} watchExpression Expression that is evaluated on each
/src/angular.js-18691-       *    {@link ng.$rootScope.Scope#$digest $digest} cycle. A change in the return value triggers
##############################################
/src/angular.js-18782-          var shouldCall = true;
/src/angular.js:18783:          self.$evalAsync(function() {
/src/angular.js-18784-            if (shouldCall) listener(newValues, newValues, self);
##############################################
/src/angular.js-18804-              changeReactionScheduled = true;
/src/angular.js:18805:              self.$evalAsync(watchGroupAction);
/src/angular.js-18806-            }
##############################################
/src/angular.js-18875-       * @param {string|function(scope)} obj Evaluated as {@link guide/expression expression}. The
/src/angular.js:18876:       *    expression value should evaluate to an object or an array which is observed on each
/src/angular.js-18877-       *    {@link ng.$rootScope.Scope#$digest $digest} cycle. Any shallow change within the
##############################################
/src/angular.js-19093-          // If this is the root scope, and $applyAsync has scheduled a deferred $apply(), then
/src/angular.js:19094:          // cancel the scheduled $apply and flush the queue of expressions to be evaluated.
/src/angular.js-19095-          $browser.defer.cancel(applyAsyncId);
##############################################
/src/angular.js-19105-          // It's safe for asyncQueuePosition to be a local variable here because this loop can't
/src/angular.js:19106:          // be reentered recursively. Calling $digest from a function passed to $evalAsync would
/src/angular.js-19107-          // lead to a '$digest already in progress' error.
##############################################
/src/angular.js-19354-        // Disable listeners, watchers and apply/digest methods
/src/angular.js:19355:        this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
/src/angular.js-19356-        this.$on = this.$watch = this.$watchGroup = function() { return noop; };
##############################################
/src/angular.js-19365-       * @ngdoc method
/src/angular.js:19366:       * @name $rootScope.Scope#$eval
/src/angular.js-19367-       * @kind function
##############################################
/src/angular.js-19370-       * Executes the `expression` on the current scope and returns the result. Any exceptions in
/src/angular.js:19371:       * the expression are propagated (uncaught). This is useful when evaluating AngularJS
/src/angular.js-19372-       * expressions.
##############################################
/src/angular.js-19379-
/src/angular.js:19380:           expect(scope.$eval('a+b')).toEqual(3);
/src/angular.js:19381:           expect(scope.$eval(function(scope){ return scope.a + scope.b; })).toEqual(3);
/src/angular.js-19382-       * ```
##############################################
/src/angular.js-19389-       * @param {(object)=} locals Local variables object, useful for overriding values in scope.
/src/angular.js:19390:       * @returns {*} The result of evaluating the expression.
/src/angular.js-19391-       */
/src/angular.js:19392:      $eval: function(expr, locals) {
/src/angular.js-19393-        return $parse(expr)(this, locals);
##############################################
/src/angular.js-19397-       * @ngdoc method
/src/angular.js:19398:       * @name $rootScope.Scope#$evalAsync
/src/angular.js-19399-       * @kind function
##############################################
/src/angular.js-19403-       *
/src/angular.js:19404:       * The `$evalAsync` makes no guarantees as to when the `expression` will be executed, only
/src/angular.js-19405-       * that:
/src/angular.js-19406-       *
/src/angular.js:19407:       *   - it will execute after the function that scheduled the evaluation (preferably before DOM
/src/angular.js-19408-       *     rendering).
##############################################
/src/angular.js-19416-       * will be scheduled. However, it is encouraged to always call code that changes the model
/src/angular.js:19417:       * from within an `$apply` call. That includes code evaluated via `$evalAsync`.
/src/angular.js-19418-       *
##############################################
/src/angular.js-19425-       */
/src/angular.js:19426:      $evalAsync: function(expr, locals) {
/src/angular.js-19427-        // if we are outside of an $digest loop and this is the first time we are scheduling async
##############################################
/src/angular.js-19433-            }
/src/angular.js:19434:          }, null, '$evalAsync');
/src/angular.js-19435-        }
##############################################
/src/angular.js-19460-             try {
/src/angular.js:19461:               return $eval(expr);
/src/angular.js-19462-             } catch (e) {
##############################################
/src/angular.js-19473-       * 1. The {@link guide/expression expression} is executed using the
/src/angular.js:19474:       *    {@link ng.$rootScope.Scope#$eval $eval()} method.
/src/angular.js-19475-       * 2. Any exceptions from the execution of the expression are forwarded to the
##############################################
/src/angular.js-19485-       *
/src/angular.js:19486:       * @returns {*} The result of evaluating the expression.
/src/angular.js-19487-       */
##############################################
/src/angular.js-19491-          try {
/src/angular.js:19492:            return this.$eval(expr);
/src/angular.js-19493-          } finally {
##############################################
/src/angular.js-19517-       *
/src/angular.js:19518:       * This can be used to queue up multiple expressions which need to be evaluated in the same
/src/angular.js-19519-       * digest.
##############################################
/src/angular.js-19534-        function $applyAsyncExpression() {
/src/angular.js:19535:          scope.$eval(expr);
/src/angular.js-19536-        }
##############################################
/src/angular.js-20541- * (for `img[src]`), so that the sanitization happens (via `$sce.getTrusted...`) when the `$interpolate`
/src/angular.js:20542: * service evaluates the expressions.
/src/angular.js-20543- * </div>
##############################################
/src/angular.js-20799-     *    * `context`  `{object}`  an object against which any expressions embedded in the
/src/angular.js:20800:     *      strings are evaluated against (typically a scope object).
/src/angular.js-20801-     *    * `locals`  `{object=}`  local variables context object, useful for overriding values
##############################################
/src/angular.js-20993-     *    * `context`  `{object}`  an object against which any expressions embedded in the
/src/angular.js:20994:     *      strings are evaluated against (typically a scope object).
/src/angular.js-20995-     *    * `locals`  `{object=}`  local variables context object, useful for overriding values
##############################################
/src/angular.js-21010-     *    * `context`  `{object}`  an object against which any expressions embedded in the
/src/angular.js:21011:     *      strings are evaluated against (typically a scope object).
/src/angular.js-21012-     *    * `locals`  `{object=}`  local variables context object, useful for overriding values
##############################################
/src/angular.js-21027-     *    * `context`  `{object}`  an object against which any expressions embedded in the
/src/angular.js:21028:     *      strings are evaluated against (typically a scope object).
/src/angular.js-21029-     *    * `locals`  `{object=}`  local variables context object, useful for overriding values
##############################################
/src/angular.js-21044-     *    * `context`  `{object}`  an object against which any expressions embedded in the
/src/angular.js:21045:     *      strings are evaluated against (typically a scope object).
/src/angular.js-21046-     *    * `locals`  `{object=}`  local variables context object, useful for overriding values
##############################################
/src/angular.js-21061-     *    * `context`  `{object}`  an object against which any expressions embedded in the
/src/angular.js:21062:     *      strings are evaluated against (typically a scope object).
/src/angular.js-21063-     *    * `locals`  `{object=}`  local variables context object, useful for overriding values
##############################################
/src/angular.js-21125-        document = $document[0] || {},
/src/angular.js:21126:        bodyStyle = document.body && document.body.style,
/src/angular.js-21127-        transitions = false,
##############################################
/src/angular.js-21157-        if (isUndefined(eventSupport[event])) {
/src/angular.js:21158:          var divElm = document.createElement('div');
/src/angular.js-21159-          eventSupport[event] = 'on' + event in divElm;
##############################################
/src/angular.js-21525-     * - Pending tasks scheduled via {@link $rootScope#$applyAsync}.
/src/angular.js:21526:     * - Pending tasks scheduled via {@link $rootScope#$evalAsync}.
/src/angular.js:21527:     *   These include tasks scheduled via `$evalAsync()` indirectly (such as {@link $q} promises).
/src/angular.js-21528-     *
##############################################
/src/angular.js-21553-     * @description
/src/angular.js:21554:     * AngularJS's wrapper for `window.setTimeout`. The `fn` function is wrapped into a try/catch
/src/angular.js-21555-     * block and delegates any exceptions to
##############################################
/src/angular.js-21654-// service.
/src/angular.js:21655:var urlParsingNode = window.document.createElement('a');
/src/angular.js:21656:var originUrl = urlResolve(window.location.href);
/src/angular.js-21657-var baseUrlParsingNode;
##############################################
/src/angular.js-21761- *
/src/angular.js:21762: * Note: The base URL is usually the same as the document location (`location.href`) but can
/src/angular.js-21763- * be overriden by using the `<base>` tag.
##############################################
/src/angular.js-21829-  if (!baseUrlParsingNode) {
/src/angular.js:21830:    baseUrlParsingNode = window.document.createElement('a');
/src/angular.js-21831-    baseUrlParsingNode.href = '.';
##############################################
/src/angular.js-21851- * Expressions, like the one defined for the `ngClick` directive in the example
/src/angular.js:21852: * below, are evaluated with respect to the current scope.  Therefore, there is
/src/angular.js-21853- * no risk of inadvertently coding in a dependency on a global value in such an
##############################################
/src/angular.js-21863-             $scope.doGreeting = function(greeting) {
/src/angular.js:21864:               $window.alert(greeting);
/src/angular.js-21865-             };
##############################################
/src/angular.js-23269- * The `expression` can be a single predicate, or a list of predicates each serving as a tie-breaker
/src/angular.js:23270: * for the preceding one. The `expression` is evaluated against each item and the output is used
/src/angular.js-23271- * for comparing with other items.
##############################################
/src/angular.js-23360- *      the return value will be used for sorting.
/src/angular.js:23361: *    - `string`: An AngularJS expression. This expression will be evaluated against each item and the
/src/angular.js-23362- *      result will be used for sorting. For example, use `'label'` to sort by a property called
##############################################
/src/angular.js-24163- * e.g. `input`, `button`, `select` etc.) if the
/src/angular.js:24164: * {@link guide/expression expression} inside `ngDisabled` evaluates to truthy.
/src/angular.js-24165- *
##############################################
/src/angular.js-24350-
/src/angular.js:24351:// boolean attrs are evaluated
/src/angular.js-24352-forEach(BOOLEAN_ATTR, function(propName, attrName) {
##############################################
/src/angular.js-24382-
/src/angular.js:24383:// aliased input attrs are evaluated
/src/angular.js-24384-forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
##############################################
/src/angular.js-25227-   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
/src/angular.js:25228:   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
/src/angular.js-25229-   *    `required` when you want to data-bind to the `required` attribute.
##############################################
/src/angular.js-25238-   * @param {string=} ngPattern Sets `pattern` validation error key if the ngModel {@link ngModel.NgModelController#$viewValue $viewValue}
/src/angular.js:25239:   *    does not match a RegExp found by evaluating the AngularJS expression given in the attribute value.
/src/angular.js:25240:   *    If the expression evaluates to a RegExp object, then this is used directly.
/src/angular.js:25241:   *    If the expression evaluates to a string, then it will be converted to a RegExp
/src/angular.js-25242-   *    after wrapping it in `^` and `$` characters. For instance, `"abc"` will be converted to
##############################################
/src/angular.js-25339-     * @param {(date|string)=} ngMin Sets the `min` validation constraint to the Date / ISO date string
/src/angular.js:25340:     *   the `ngMin` expression evaluates to. Note that it does not set the `min` attribute.
/src/angular.js-25341-     * @param {(date|string)=} ngMax Sets the `max` validation constraint to the Date / ISO date string
/src/angular.js:25342:     *   the `ngMax` expression evaluates to. Note that it does not set the `max` attribute.
/src/angular.js-25343-     * @param {string=} required Sets `required` validation error key if the value is not entered.
/src/angular.js-25344-     * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
/src/angular.js:25345:     *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
/src/angular.js-25346-     *    `required` when you want to data-bind to the `required` attribute.
##############################################
/src/angular.js-25445-    * @param {(date|string)=} ngMin Sets the `min` validation error key to the Date / ISO datetime string
/src/angular.js:25446:    *   the `ngMin` expression evaluates to. Note that it does not set the `min` attribute.
/src/angular.js-25447-    * @param {(date|string)=} ngMax Sets the `max` validation error key to the Date / ISO datetime string
/src/angular.js:25448:    *   the `ngMax` expression evaluates to. Note that it does not set the `max` attribute.
/src/angular.js-25449-    * @param {string=} required Sets `required` validation error key if the value is not entered.
/src/angular.js-25450-    * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
/src/angular.js:25451:    *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
/src/angular.js-25452-    *    `required` when you want to data-bind to the `required` attribute.
##############################################
/src/angular.js-25553-   * @param {(date|string)=} ngMin Sets the `min` validation constraint to the Date / ISO time string the
/src/angular.js:25554:   *   `ngMin` expression evaluates to. Note that it does not set the `min` attribute.
/src/angular.js-25555-   * @param {(date|string)=} ngMax Sets the `max` validation constraint to the Date / ISO time string the
/src/angular.js:25556:   *   `ngMax` expression evaluates to. Note that it does not set the `max` attribute.
/src/angular.js-25557-   * @param {string=} required Sets `required` validation error key if the value is not entered.
/src/angular.js-25558-   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
/src/angular.js:25559:   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
/src/angular.js-25560-   *    `required` when you want to data-bind to the `required` attribute.
##############################################
/src/angular.js-25659-    * @param {(date|string)=} ngMin Sets the `min` validation constraint to the Date / ISO week string
/src/angular.js:25660:    *   the `ngMin` expression evaluates to. Note that it does not set the `min` attribute.
/src/angular.js-25661-    * @param {(date|string)=} ngMax Sets the `max` validation constraint to the Date / ISO week string
/src/angular.js:25662:    *   the `ngMax` expression evaluates to. Note that it does not set the `max` attribute.
/src/angular.js-25663-    * @param {string=} required Sets `required` validation error key if the value is not entered.
/src/angular.js-25664-    * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
/src/angular.js:25665:    *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
/src/angular.js-25666-    *    `required` when you want to data-bind to the `required` attribute.
##############################################
/src/angular.js-25763-   * @param {(date|string)=} ngMin Sets the `min` validation constraint to the Date / ISO week string
/src/angular.js:25764:   *   the `ngMin` expression evaluates to. Note that it does not set the `min` attribute.
/src/angular.js-25765-   * @param {(date|string)=} ngMax Sets the `max` validation constraint to the Date / ISO week string
/src/angular.js:25766:   *   the `ngMax` expression evaluates to. Note that it does not set the `max` attribute.
/src/angular.js-25767-
##############################################
/src/angular.js-25769-   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
/src/angular.js:25770:   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
/src/angular.js-25771-   *    `required` when you want to data-bind to the `required` attribute.
##############################################
/src/angular.js-25895-   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
/src/angular.js:25896:   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
/src/angular.js-25897-   *    `required` when you want to data-bind to the `required` attribute.
##############################################
/src/angular.js-25906-   * @param {string=} ngPattern Sets `pattern` validation error key if the ngModel {@link ngModel.NgModelController#$viewValue $viewValue}
/src/angular.js:25907:   *    does not match a RegExp found by evaluating the AngularJS expression given in the attribute value.
/src/angular.js:25908:   *    If the expression evaluates to a RegExp object, then this is used directly.
/src/angular.js:25909:   *    If the expression evaluates to a string, then it will be converted to a RegExp
/src/angular.js-25910-   *    after wrapping it in `^` and `$` characters. For instance, `"abc"` will be converted to
##############################################
/src/angular.js-25993-   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
/src/angular.js:25994:   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
/src/angular.js-25995-   *    `required` when you want to data-bind to the `required` attribute.
##############################################
/src/angular.js-26004-   * @param {string=} ngPattern Sets `pattern` validation error key if the ngModel {@link ngModel.NgModelController#$viewValue $viewValue}
/src/angular.js:26005:   *    does not match a RegExp found by evaluating the AngularJS expression given in the attribute value.
/src/angular.js:26006:   *    If the expression evaluates to a RegExp object, then this is used directly.
/src/angular.js:26007:   *    If the expression evaluates to a string, then it will be converted to a RegExp
/src/angular.js-26008-   *    after wrapping it in `^` and `$` characters. For instance, `"abc"` will be converted to
##############################################
/src/angular.js-26094-   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
/src/angular.js:26095:   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
/src/angular.js-26096-   *    `required` when you want to data-bind to the `required` attribute.
##############################################
/src/angular.js-26105-   * @param {string=} ngPattern Sets `pattern` validation error key if the ngModel {@link ngModel.NgModelController#$viewValue $viewValue}
/src/angular.js:26106:   *    does not match a RegExp found by evaluating the AngularJS expression given in the attribute value.
/src/angular.js:26107:   *    If the expression evaluates to a RegExp object, then this is used directly.
/src/angular.js:26108:   *    If the expression evaluates to a string, then it will be converted to a RegExp
/src/angular.js-26109-   *    after wrapping it in `^` and `$` characters. For instance, `"abc"` will be converted to
##############################################
/src/angular.js-26511-    // If a control is suffering from bad input (due to native validators), browsers discard its
/src/angular.js:26512:    // value, so it may be necessary to revalidate (by calling $setViewValue again) even if the
/src/angular.js-26513-    // control's value is the same empty value twice in a row.
##############################################
/src/angular.js-27220- * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
/src/angular.js:27221: *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
/src/angular.js-27222- *    `required` when you want to data-bind to the `required` attribute.
##############################################
/src/angular.js-27228- * @param {string=} ngPattern Sets `pattern` validation error key if the ngModel {@link ngModel.NgModelController#$viewValue $viewValue}
/src/angular.js:27229: *    does not match a RegExp found by evaluating the AngularJS expression given in the attribute value.
/src/angular.js:27230: *    If the expression evaluates to a RegExp object, then this is used directly.
/src/angular.js:27231: *    If the expression evaluates to a string, then it will be converted to a RegExp
/src/angular.js-27232- *    after wrapping it in `^` and `$` characters. For instance, `"abc"` will be converted to
##############################################
/src/angular.js-27281- * @param {string=} ngPattern Sets `pattern` validation error key if the ngModel {@link ngModel.NgModelController#$viewValue $viewValue}
/src/angular.js:27282: *    value does not match a RegExp found by evaluating the AngularJS expression given in the attribute value.
/src/angular.js:27283: *    If the expression evaluates to a RegExp object, then this is used directly.
/src/angular.js:27284: *    If the expression evaluates to a string, then it will be converted to a RegExp
/src/angular.js-27285- *    after wrapping it in `^` and `$` characters. For instance, `"abc"` will be converted to
##############################################
/src/angular.js-27532-        return function ngValueConstantLink(scope, elm, attr) {
/src/angular.js:27533:          var value = scope.$eval(attr.ngValue);
/src/angular.js-27534-          updateElementValue(elm, attr, value);
##############################################
/src/angular.js-27568- * @element ANY
/src/angular.js:27569: * @param {expression} ngBind {@link guide/expression Expression} to evaluate.
/src/angular.js-27570- *
##############################################
/src/angular.js-27628- * @param {string} ngBindTemplate template of form
/src/angular.js:27629: *   <tt>{{</tt> <tt>expression</tt> <tt>}}</tt> to eval.
/src/angular.js-27630- *
##############################################
/src/angular.js-27701- * @element ANY
/src/angular.js:27702: * @param {expression} ngBindHtml {@link guide/expression Expression} to evaluate.
/src/angular.js-27703- *
##############################################
/src/angular.js-27760- * Evaluate the given expression when the user changes the input.
/src/angular.js:27761: * The expression is evaluated immediately, unlike the JavaScript onchange event
/src/angular.js-27762- * which only triggers at the end of a change (usually, when the user leaves the
##############################################
/src/angular.js-27764- *
/src/angular.js:27765: * The `ngChange` expression is only evaluated when a change in the input value causes
/src/angular.js-27766- * a new value to be committed to the model.
/src/angular.js-27767- *
/src/angular.js:27768: * It will not be evaluated:
/src/angular.js-27769- * * if the value returned from the `$parsers` transformation pipeline has not changed
##############################################
/src/angular.js-27776- * @element ANY
/src/angular.js:27777: * @param {expression} ngChange {@link guide/expression Expression} to evaluate upon change
/src/angular.js-27778- * in input value.
##############################################
/src/angular.js-27803- *
/src/angular.js:27804: *     it('should evaluate the expression if changing from view', function() {
/src/angular.js-27805- *       expect(counter.getText()).toContain('0');
##############################################
/src/angular.js-27812- *
/src/angular.js:27813: *     it('should not evaluate the expression if changing from model', function() {
/src/angular.js-27814- *       element(by.id('ng-change-example2')).click();
##############################################
/src/angular.js-27826-    ctrl.$viewChangeListeners.push(function() {
/src/angular.js:27827:      scope.$eval(attr.ngChange);
/src/angular.js-27828-    });
##############################################
/src/angular.js-27985- * The directive operates in three different ways, depending on which of three types the expression
/src/angular.js:27986: * evaluates to:
/src/angular.js-27987- *
/src/angular.js:27988: * 1. If the expression evaluates to a string, the string should be one or more space-delimited class
/src/angular.js-27989- * names.
/src/angular.js-27990- *
/src/angular.js:27991: * 2. If the expression evaluates to an object, then for each key-value pair of the
/src/angular.js-27992- * object with a truthy value the corresponding key is used as a class name.
/src/angular.js-27993- *
/src/angular.js:27994: * 3. If the expression evaluates to an array, each element of the array should either be a string as in
/src/angular.js-27995- * type 1 or an object as in type 2. This means that you can mix strings and objects together in an array
##############################################
/src/angular.js-28022- *
/src/angular.js:28023: * @param {expression} ngClass {@link guide/expression Expression} to eval. The result
/src/angular.js:28024: *   of the evaluation can be a string representing space delimited class
/src/angular.js-28025- *   names, an array, or a map of class names to boolean values. In the case of a map, the
##############################################
/src/angular.js-28181- * @element ANY
/src/angular.js:28182: * @param {expression} ngClassOdd {@link guide/expression Expression} to eval. The result
/src/angular.js:28183: *   of the evaluation can be a string representing space delimited class names or an array.
/src/angular.js-28184- *
##############################################
/src/angular.js-28291- * @element ANY
/src/angular.js:28292: * @param {expression} ngClassEven {@link guide/expression Expression} to eval. The
/src/angular.js:28293: *   result of the evaluation can be a string representing space delimited class names or an array.
/src/angular.js-28294- *
##############################################
/src/angular.js-28466- * {@link ng.$controllerProvider $controllerProvider} or an {@link guide/expression expression}
/src/angular.js:28467: * that on the current scope evaluates to a constructor function.
/src/angular.js-28468- *
##############################################
/src/angular.js-28692- *
/src/angular.js:28693: * * The use of `eval()`, `Function(string)` and similar functions to dynamically create and execute
/src/angular.js-28694- * code from strings is forbidden. AngularJS makes use of this in the {@link $parse} service to
/src/angular.js:28695: * provide a 30% increase in the speed of evaluating AngularJS expressions. (This CSP rule can be
/src/angular.js:28696: * disabled with the CSP keyword `unsafe-eval`, but it is generally not recommended as it would
/src/angular.js-28697- * weaken the protections offered by CSP.)
##############################################
/src/angular.js-28706- * If you do not provide `ngCsp` then AngularJS tries to autodetect if CSP is blocking dynamic code
/src/angular.js:28707: * creation from strings (e.g., `unsafe-eval` not specified in CSP header) and automatically
/src/angular.js-28708- * deactivates this feature in the {@link $parse} service. This autodetection, however, triggers a
##############################################
/src/angular.js-28711- * ```
/src/angular.js:28712: * Refused to evaluate a string as JavaScript because 'unsafe-eval' is not an allowed source of
/src/angular.js-28713- * script in the following Content Security Policy directive: "default-src 'self'". Note that
##############################################
/src/angular.js-28727- *
/src/angular.js:28728: * * no-unsafe-eval: this stops AngularJS from optimizing $parse with unsafe eval of strings
/src/angular.js-28729- *
##############################################
/src/angular.js-28733- * * No declaration means that AngularJS will assume that you can do inline styles, but it will do
/src/angular.js:28734: * a runtime check for unsafe-eval. E.g. `<body>`. This is backwardly compatible with previous
/src/angular.js-28735- * versions of AngularJS.
##############################################
/src/angular.js-28737- * * A simple `ng-csp` (or `data-ng-csp`) attribute will tell AngularJS to deactivate both inline
/src/angular.js:28738: * styles and unsafe eval. E.g. `<body ng-csp>`. This is backwardly compatible with previous
/src/angular.js-28739- * versions of AngularJS.
/src/angular.js-28740- *
/src/angular.js:28741: * * Specifying only `no-unsafe-eval` tells AngularJS that we must not use eval, but that we can
/src/angular.js:28742: * inject inline styles. E.g. `<body ng-csp="no-unsafe-eval">`.
/src/angular.js-28743- *
/src/angular.js-28744- * * Specifying only `no-inline-style` tells AngularJS that we must not inject styles, but that we can
/src/angular.js:28745: * run eval - no automatic check for unsafe eval will occur. E.g. `<body ng-csp="no-inline-style">`
/src/angular.js-28746- *
/src/angular.js:28747: * * Specifying both `no-unsafe-eval` and `no-inline-style` tells AngularJS that we must not inject
/src/angular.js:28748: * styles nor use eval, which is the same as an empty: ng-csp.
/src/angular.js:28749: * E.g.`<body ng-csp="no-inline-style;no-unsafe-eval">`
/src/angular.js-28750- *
##############################################
/src/angular.js-28789-              try {
/src/angular.js:28790:                eval('1+2'); // eslint-disable-line no-eval
/src/angular.js-28791-              } catch (e) {
##############################################
/src/angular.js-28862-
/src/angular.js:28863:      it('should evaluate expressions', function() {
/src/angular.js-28864-        expect(counter.getText()).toEqual('0');
##############################################
/src/angular.js-28869-
/src/angular.js:28870:      it('should throw and report an error when using "eval"', function() {
/src/angular.js-28871-        evilBtn.click();
##############################################
/src/angular.js-28893- *
/src/angular.js:28894: * @param {expression} ngClick {@link guide/expression Expression} to evaluate upon
/src/angular.js-28895- * click. ({@link guide/expression#-event- Event object is available as `$event`})
##############################################
/src/angular.js-28922-// For events that might fire synchronously during DOM manipulation
/src/angular.js:28923:// we need to execute their event handlers asynchronously using $evalAsync,
/src/angular.js-28924-// so that they are not executed in an inconsistent state.
##############################################
/src/angular.js-28956-          } else if (forceAsync) {
/src/angular.js:28957:            scope.$evalAsync(callback);
/src/angular.js-28958-          } else {
##############################################
/src/angular.js-28980- *
/src/angular.js:28981: * @param {expression} ngDblclick {@link guide/expression Expression} to evaluate upon
/src/angular.js-28982- * a dblclick. (The Event object is available as `$event`)
##############################################
/src/angular.js-29005- *
/src/angular.js:29006: * @param {expression} ngMousedown {@link guide/expression Expression} to evaluate upon
/src/angular.js-29007- * mousedown. ({@link guide/expression#-event- Event object is available as `$event`})
##############################################
/src/angular.js-29030- *
/src/angular.js:29031: * @param {expression} ngMouseup {@link guide/expression Expression} to evaluate upon
/src/angular.js-29032- * mouseup. ({@link guide/expression#-event- Event object is available as `$event`})
##############################################
/src/angular.js-29054- *
/src/angular.js:29055: * @param {expression} ngMouseover {@link guide/expression Expression} to evaluate upon
/src/angular.js-29056- * mouseover. ({@link guide/expression#-event- Event object is available as `$event`})
##############################################
/src/angular.js-29079- *
/src/angular.js:29080: * @param {expression} ngMouseenter {@link guide/expression Expression} to evaluate upon
/src/angular.js-29081- * mouseenter. ({@link guide/expression#-event- Event object is available as `$event`})
##############################################
/src/angular.js-29104- *
/src/angular.js:29105: * @param {expression} ngMouseleave {@link guide/expression Expression} to evaluate upon
/src/angular.js-29106- * mouseleave. ({@link guide/expression#-event- Event object is available as `$event`})
##############################################
/src/angular.js-29129- *
/src/angular.js:29130: * @param {expression} ngMousemove {@link guide/expression Expression} to evaluate upon
/src/angular.js-29131- * mousemove. ({@link guide/expression#-event- Event object is available as `$event`})
##############################################
/src/angular.js-29154- *
/src/angular.js:29155: * @param {expression} ngKeydown {@link guide/expression Expression} to evaluate upon
/src/angular.js-29156- * keydown. (Event object is available as `$event` and can be interrogated for keyCode, altKey, etc.)
##############################################
/src/angular.js-29177- *
/src/angular.js:29178: * @param {expression} ngKeyup {@link guide/expression Expression} to evaluate upon
/src/angular.js-29179- * keyup. (Event object is available as `$event` and can be interrogated for keyCode, altKey, etc.)
##############################################
/src/angular.js-29204- *
/src/angular.js:29205: * @param {expression} ngKeypress {@link guide/expression Expression} to evaluate upon
/src/angular.js-29206- * keypress. ({@link guide/expression#-event- Event object is available as `$event`}
##############################################
/src/angular.js-29239- *
/src/angular.js:29240: * @param {expression} ngSubmit {@link guide/expression Expression} to eval.
/src/angular.js-29241- * ({@link guide/expression#-event- Event object is available as `$event`})
##############################################
/src/angular.js-29293- * Note: As the `focus` event is executed synchronously when calling `input.focus()`
/src/angular.js:29294: * AngularJS executes the expression using `scope.$evalAsync` if the event is fired
/src/angular.js-29295- * during an `$apply` to ensure a consistent state.
/src/angular.js-29296- *
/src/angular.js:29297: * @param {expression} ngFocus {@link guide/expression Expression} to evaluate upon
/src/angular.js-29298- * focus. ({@link guide/expression#-event- Event object is available as `$event`})
##############################################
/src/angular.js-29318- * (e.g. removing a focussed input),
/src/angular.js:29319: * AngularJS executes the expression using `scope.$evalAsync` if the event is fired
/src/angular.js-29320- * during an `$apply` to ensure a consistent state.
/src/angular.js-29321- *
/src/angular.js:29322: * @param {expression} ngBlur {@link guide/expression Expression} to evaluate upon
/src/angular.js-29323- * blur. ({@link guide/expression#-event- Event object is available as `$event`})
##############################################
/src/angular.js-29338- *
/src/angular.js:29339: * @param {expression} ngCopy {@link guide/expression Expression} to evaluate upon
/src/angular.js-29340- * copy. ({@link guide/expression#-event- Event object is available as `$event`})
##############################################
/src/angular.js-29360- *
/src/angular.js:29361: * @param {expression} ngCut {@link guide/expression Expression} to evaluate upon
/src/angular.js-29362- * cut. ({@link guide/expression#-event- Event object is available as `$event`})
##############################################
/src/angular.js-29382- *
/src/angular.js:29383: * @param {expression} ngPaste {@link guide/expression Expression} to evaluate upon
/src/angular.js-29384- * paste. ({@link guide/expression#-event- Event object is available as `$event`})
##############################################
/src/angular.js-29402- * The `ngIf` directive removes or recreates a portion of the DOM tree based on an
/src/angular.js:29403: * {expression}. If the expression assigned to `ngIf` evaluates to a false
/src/angular.js-29404- * value then the element is removed from the DOM, otherwise a clone of the
##############################################
/src/angular.js-29552- *
/src/angular.js:29553: * @param {string} ngInclude|src AngularJS expression evaluating to URL. If the source is a string constant,
/src/angular.js-29554- *                 make sure you wrap it in **single** quotes, e.g. `src="'myPartialTemplate.html'"`.
/src/angular.js:29555: * @param {string=} onload Expression to evaluate when a new partial is loaded.
/src/angular.js-29556- *                  <div class="alert alert-warning">
##############################################
/src/angular.js-29567- *                  - If the attribute is set without value, enable scrolling.
/src/angular.js:29568: *                  - Otherwise enable scrolling only if the expression evaluates to truthy value.
/src/angular.js-29569- *
##############################################
/src/angular.js-29744-            if (response !== false && isDefined(autoScrollExp) &&
/src/angular.js:29745:              (!autoScrollExp || scope.$eval(autoScrollExp))) {
/src/angular.js-29746-                $anchorScroll();
##############################################
/src/angular.js-29775-              currentScope.$emit('$includeContentLoaded', src);
/src/angular.js:29776:              scope.$eval(onloadExp);
/src/angular.js-29777-            }, function() {
##############################################
/src/angular.js-29832- *
/src/angular.js:29833: * @param {expression} ngInit {@link guide/expression Expression} to eval.
/src/angular.js-29834- *
/src/angular.js-29835- * @description
/src/angular.js:29836: * The `ngInit` directive allows you to evaluate an expression in the
/src/angular.js-29837- * current scope.
##############################################
/src/angular.js-29893-      pre: function(scope, element, attrs) {
/src/angular.js:29894:        scope.$eval(attrs.ngInit);
/src/angular.js-29895-      }
##############################################
/src/angular.js-30229-              element.on('blur keyup change', function() {
/src/angular.js:30230:                scope.$evalAsync(read);
/src/angular.js-30231-              });
##############################################
/src/angular.js-31184- *
/src/angular.js:31185: * Note: `ngModel` will try to bind to the property given by evaluating the expression on the
/src/angular.js-31186- * current scope. If the property doesn't already exist on this scope, it will be created
##############################################
/src/angular.js-31400-            if ($rootScope.$$phase) {
/src/angular.js:31401:              scope.$evalAsync(setTouched);
/src/angular.js-31402-            } else {
##############################################
/src/angular.js-31511- *
/src/angular.js:31512: * The `ngModelOptions` settings are found by evaluating the value of the attribute directive as
/src/angular.js:31513: * an AngularJS expression. This expression should evaluate to an object, whose properties contain
/src/angular.js-31514- * the settings. For example: `<div ng-model-options="{ debounce: 100 }"`.
##############################################
/src/angular.js-31819- *
/src/angular.js:31820: * The `ngModelOptions` expression is only evaluated once when the directive is linked; it is not
/src/angular.js-31821- * watched for changes. However, it is possible to override the options on a single
##############################################
/src/angular.js-31964-      var parentOptions = this.parentCtrl ? this.parentCtrl.$options : defaultModelOptions;
/src/angular.js:31965:      var modelOptionsDefinition = this.$$scope.$eval(this.$$attrs.ngModelOptions);
/src/angular.js-31966-
##############################################
/src/angular.js-32037- * The `ngOptions` attribute can be used to dynamically generate a list of `<option>`
/src/angular.js:32038: * elements for the `<select>` element using the array or object obtained by evaluating the
/src/angular.js-32039- * `ngOptions` comprehension expression.
##############################################
/src/angular.js-32128- * **`track by`** expression is also applied to the `ngModel` value. In the first example, the
/src/angular.js:32129: * `ngModel` value is `items[0]` and the **`track by`** expression evaluates to `items[0].id` with
/src/angular.js-32130- * no issue. In the second example, the `ngModel` value is `items[0].subItem` and the **`track by`**
/src/angular.js:32131: * expression evaluates to `items[0].subItem.id` (which is undefined). As a result, the model value
/src/angular.js-32132- * is not matched against any `<option>` and the `<select>` appears as having no selected value.
##############################################
/src/angular.js-32158- *
/src/angular.js:32159: *   * `array` / `object`: an expression which evaluates to an array / object to iterate over.
/src/angular.js-32160- *   * `value`: local variable which will refer to each item in the `array` or each property value
##############################################
/src/angular.js-32177- * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
/src/angular.js:32178: *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
/src/angular.js-32179- *    `required` when you want to data-bind to the `required` attribute.
##############################################
/src/angular.js-32433-  // to create it in <select> and IE barfs otherwise.
/src/angular.js:32434:  var optionTemplate = window.document.createElement('option'),
/src/angular.js:32435:      optGroupTemplate = window.document.createElement('optgroup');
/src/angular.js-32436-
##############################################
/src/angular.js-32767- * The value of the `count` attribute can be either a string or an {@link guide/expression
/src/angular.js:32768: * AngularJS expression}; these are evaluated on the current scope for its bound value.
/src/angular.js-32769- *
##############################################
/src/angular.js-32923-          offset = attr.offset || 0,
/src/angular.js:32924:          whens = scope.$eval(whenExp) || {},
/src/angular.js-32925-          whensExpFns = {},
##############################################
/src/angular.js-33030- *        var toggle = element(by.buttonText('Toggle'));
/src/angular.js:33031: *        expect(toggle.evaluate('myToggle.isOpen()')).toEqual(false);
/src/angular.js-33032- *        toggle.click();
/src/angular.js:33033: *        expect(toggle.evaluate('myToggle.isOpen()')).toEqual(true);
/src/angular.js-33034- *      });
##############################################
/src/angular.js-33509- *
/src/angular.js:33510: * And with an input of {@type ['A','B']} for the items variable in the example above, the output will evaluate to:
/src/angular.js-33511- * ```html
##############################################
/src/angular.js-33959- *
/src/angular.js:33960: * When the `ngShow` expression evaluates to a falsy value then the `.ng-hide` CSS class is added
/src/angular.js-33961- * to the class attribute on the element causing it to become hidden. When truthy, the `.ng-hide`
##############################################
/src/angular.js-33998- * |-----------------------------------------------------|---------------------------------------------------------------------------------------------------------------|
/src/angular.js:33999: * | {@link $animate#addClass addClass} `.ng-hide`       | After the `ngShow` expression evaluates to a non truthy value and just before the contents are set to hidden. |
/src/angular.js:34000: * | {@link $animate#removeClass removeClass} `.ng-hide` | After the `ngShow` expression evaluates to a truthy value and just before contents are set to visible.        |
/src/angular.js-34001- *
##############################################
/src/angular.js-34178- *
/src/angular.js:34179: * When the `ngHide` expression evaluates to a truthy value then the `.ng-hide` CSS class is added
/src/angular.js-34180- * to the class attribute on the element causing it to become hidden. When falsy, the `.ng-hide`
##############################################
/src/angular.js-34217- * |-----------------------------------------------------|------------------------------------------------------------------------------------------------------------|
/src/angular.js:34218: * | {@link $animate#addClass addClass} `.ng-hide`       | After the `ngHide` expression evaluates to a truthy value and just before the contents are set to hidden.  |
/src/angular.js:34219: * | {@link $animate#removeClass removeClass} `.ng-hide` | After the `ngHide` expression evaluates to a non truthy value and just before contents are set to visible. |
/src/angular.js-34220- *
##############################################
/src/angular.js-34388- *
/src/angular.js:34389: * {@link guide/expression Expression} which evals to an
/src/angular.js-34390- * object whose keys are CSS style names and values are corresponding values for those CSS
##############################################
/src/angular.js-34451- * from the template cache), `ngSwitch` simply chooses one of the nested elements and makes it visible based on which element
/src/angular.js:34452: * matches the value obtained from the evaluated expression. In other words, you define a container element
/src/angular.js-34453- * (where you place the directive), place an expression on the **`on="..."` attribute**
##############################################
/src/angular.js-34455- * a when attribute per element. The when attribute is used to inform ngSwitch which element to display when the on
/src/angular.js:34456: * expression is evaluated. If a matching expression is not found via a when attribute then an element with the default
/src/angular.js-34457- * attribute is displayed.
##############################################
/src/angular.js-34493- *   the `ngSwitchWhen` attribute into multiple tokens, and the element will show
/src/angular.js:34494: *   if any of the `ngSwitch` evaluates to any of these tokens.
/src/angular.js-34495- * * `ngSwitchDefault`: the default case when no other case match. If there
##############################################
/src/angular.js-35106-  // to create it in <select> and IE barfs otherwise.
/src/angular.js:35107:  self.unknownOption = jqLite(window.document.createElement('option'));
/src/angular.js-35108-
##############################################
/src/angular.js-35441- *
/src/angular.js:35442: * In general, the match between the model and an option is evaluated by strictly comparing the model
/src/angular.js-35443- * value against the value of the available options.
##############################################
/src/angular.js-35482- * @param {string=} ngRequired Adds required attribute and required validation constraint to
/src/angular.js:35483: * the element when the ngRequired expression evaluates to true. Use ngRequired instead of required
/src/angular.js-35484- * when you want to data-bind to the required attribute.
##############################################
/src/angular.js-35837- *
/src/angular.js:35838: * @param {expression} ngRequired AngularJS expression. If it evaluates to `true`, it sets the
/src/angular.js-35839- *                                `required` attribute to the element and adds the `required`
##############################################
/src/angular.js-35848- * The directive sets the `required` attribute on the element if the AngularJS expression inside
/src/angular.js:35849: * `ngRequired` evaluates to true. A special directive for setting `required` is necessary because we
/src/angular.js-35850- * cannot use interpolation inside `required`. See the {@link guide/interpolation interpolation guide}
##############################################
/src/angular.js-35930- *
/src/angular.js:35931: * @param {expression|RegExp} ngPattern AngularJS expression that must evaluate to a `RegExp` or a `String`
/src/angular.js-35932- *                                      parsable into a `RegExp`, or a `RegExp` literal. See above for
##############################################
/src/angular.js-35942- * - the value is an AngularJS expression:
/src/angular.js:35943: *   - If the expression evaluates to a RegExp object, then this is used directly.
/src/angular.js:35944: *   - If the expression evaluates to a string, then it will be converted to a RegExp after wrapping it
/src/angular.js-35945- *     in `^` and `$` characters. For instance, `"abc"` will be converted to `new RegExp('^abc$')`.
##############################################
/src/angular.js-36065- *
/src/angular.js:36066: * @param {expression} ngMaxlength AngularJS expression that must evaluate to a `Number` or `String`
/src/angular.js-36067- *                                 parsable into a `Number`. Used as value for the `maxlength`
##############################################
/src/angular.js-36075- * The validator sets the `maxlength` error key if the {@link ngModel.NgModelController#$viewValue `ngModel.$viewValue`}
/src/angular.js:36076: * is longer than the integer obtained by evaluating the AngularJS expression given in the
/src/angular.js-36077- * `ngMaxlength` attribute value.
##############################################
/src/angular.js-36160- *
/src/angular.js:36161: * @param {expression} ngMinlength AngularJS expression that must evaluate to a `Number` or `String`
/src/angular.js-36162- *                                 parsable into a `Number`. Used as value for the `minlength`
##############################################
/src/angular.js-36170- * The validator sets the `minlength` error key if the {@link ngModel.NgModelController#$viewValue `ngModel.$viewValue`}
/src/angular.js:36171: * is shorter than the integer obtained by evaluating the AngularJS expression given in the
/src/angular.js-36172- * `ngMinlength` attribute value.
##############################################
/src/angular.min.js-10-10)}function ac(a,b){return S(Object.create(a),b)}function E(){}function Ta(a){return a}function ia(a){return function(){return a}}function bc(a){return B(a.toString)&&a.toString!==la}function z(a){return"undefined"===typeof a}function w(a){return"undefined"!==typeof a}function D(a){return null!==a&&"object"===typeof a}function Nc(a){return null!==a&&"object"===typeof a&&!Pc(a)}function A(a){return"string"===typeof a}function W(a){return"number"===typeof a}function ha(a){return"[object Date]"===la.call(a)}
/src/angular.min.js:11:function H(a){return Array.isArray(a)||a instanceof Array}function cc(a){switch(la.call(a)){case "[object Error]":return!0;case "[object Exception]":return!0;case "[object DOMException]":return!0;default:return a instanceof Error}}function B(a){return"function"===typeof a}function ab(a){return"[object RegExp]"===la.call(a)}function $a(a){return a&&a.window===a}function bb(a){return a&&a.$evalAsync&&a.$watch}function Ga(a){return"boolean"===typeof a}function ue(a){return a&&W(a.length)&&ve.test(la.call(a))}
/src/angular.min.js-12-function $b(a){return!(!a||!(a.nodeName||a.prop&&a.attr&&a.find))}function we(a){var b={};a=a.split(",");var d;for(d=0;d<a.length;d++)b[a[d]]=!0;return b}function ua(a){return K(a.nodeName||a[0]&&a[0].nodeName)}function cb(a,b){var d=a.indexOf(b);0<=d&&a.splice(d,1);return d}function Ia(a,b,d){function c(a,b,c){c--;if(0>c)return"...";var d=b.$$hashKey,f;if(H(a)){f=0;for(var g=a.length;f<g;f++)b.push(e(a[f],c))}else if(Nc(a))for(f in a)b[f]=e(a[f],c);else if(a&&"function"===typeof a.hasOwnProperty)for(f in a)a.hasOwnProperty(f)&&
##############################################
/src/angular.min.js-20-b){return encodeURIComponent(a).replace(/%40/gi,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%3B/gi,";").replace(/%20/g,b?"%20":"+")}function ze(a,b){var d,c,e=Qa.length;for(c=0;c<e;++c)if(d=Qa[c]+b,A(d=a.getAttribute(d)))return d;return null}function Ae(a,b){var d,c,e={};r(Qa,function(b){b+="app";!d&&a.hasAttribute&&a.hasAttribute(b)&&(d=a,c=a.getAttribute(b))});r(Qa,function(b){b+="app";var e;!d&&(e=a.querySelector("["+b.replace(":","\\:")+"]"))&&(d=e,c=e.getAttribute(b))});
/src/angular.min.js:21:d&&(Be?(e.strictDi=null!==ze(d,"strict-di"),b(d,c?[c]:[],e)):C.console.error("AngularJS: disabling automatic bootstrap. <script> protocol indicates an extension, document.location.href does not match."))}function Uc(a,b,d){D(d)||(d={});d=S({strictDi:!1},d);var c=function(){a=x(a);if(a.injector()){var c=a[0]===C.document?"document":za(a);throw pa("btstrpd",c.replace(/</,"&lt;").replace(/>/,"&gt;"));}b=b||[];b.unshift(["$provide",function(b){b.value("$rootElement",a)}]);d.debugInfoEnabled&&b.push(["$compileProvider",
/src/angular.min.js-22-function(a){a.debugInfoEnabled(!0)}]);b.unshift("ng");c=fb(b,d.strictDi);c.invoke(["$rootScope","$rootElement","$compile","$injector",function(a,b,c,d){a.$apply(function(){b.data("$injector",d);c(b)(a)})}]);return c},e=/^NG_ENABLE_DEBUG_INFO!/,f=/^NG_DEFER_BOOTSTRAP!/;C&&e.test(C.name)&&(d.debugInfoEnabled=!0,C.name=C.name.replace(e,""));if(C&&!f.test(C.name))return c();C.name=C.name.replace(f,"");ca.resumeBootstrap=function(a){r(a,function(a){b.push(a)});return c()};B(ca.resumeDeferredBootstrap)&&
##############################################
/src/angular.min.js-47-function(a){a&&t.invoke(a)});t.loadNewModules=function(a){r(g(a),function(a){a&&t.invoke(a)})};return t}function wf(){var a=!0;this.disableAutoScrolling=function(){a=!1};this.$get=["$window","$location","$rootScope",function(b,d,c){function e(a){var b=null;Array.prototype.some.call(a,function(a){if("a"===ua(a))return b=a,!0});return b}function f(a){if(a){a.scrollIntoView();var c;c=g.yOffset;B(c)?c=c():$b(c)?(c=c[0],c="fixed"!==b.getComputedStyle(c).position?0:c.getBoundingClientRect().bottom):W(c)||
/src/angular.min.js:48:(c=0);c&&(a=a.getBoundingClientRect().top,b.scrollBy(0,a-c))}else b.scrollTo(0,0)}function g(a){a=A(a)?a:W(a)?a.toString():d.hash();var b;a?(b=k.getElementById(a))?f(b):(b=e(k.getElementsByName(a)))?f(b):"top"===a&&f(null):f(null)}var k=b.document;a&&c.$watch(function(){return d.hash()},function(a,b){a===b&&""===a||qg(function(){c.$evalAsync(g)})});return g}]}function hb(a,b){if(!a&&!b)return"";if(!a)return b;if(!b)return a;H(a)&&(a=a.join(" "));H(b)&&(b=b.join(" "));return a+" "+b}function zg(a){A(a)&&
/src/angular.min.js-49-(a=a.split(" "));var b=T();r(a,function(a){a.length&&(b[a]=!0)});return b}function ra(a){return D(a)?a:{}}function Ag(a,b,d,c,e){function f(){qa=null;k()}function g(){t=y();t=z(t)?null:t;va(t,P)&&(t=P);N=P=t}function k(){var a=N;g();if(v!==h.url()||a!==t)v=h.url(),N=t,r(J,function(a){a(h.url(),t)})}var h=this,l=a.location,m=a.history,p=a.setTimeout,n=a.clearTimeout,s={},G=e(d);h.isMock=!1;h.$$completeOutstandingRequest=G.completeTask;h.$$incOutstandingRequestCount=G.incTaskCount;h.notifyWhenNoOutstandingRequests=
##############################################
/src/angular.min.js-74-M,R=e,q,ma=!1,Ib=!1,O,sa=0,A=a.length;sa<A;sa++){u=a[sa];var E=u.$$start,ib=u.$$end;E&&(y=V(b,E,ib));M=void 0;if(n>u.priority)break;if(O=u.scope)u.templateUrl||(D(O)?(ba("new/isolated scope",s||t,u,y),s=u):ba("new/isolated scope",s,u,y)),t=t||u;Q=u.name;if(!ma&&(u.replace&&(u.templateUrl||u.template)||u.transclude&&!u.$$tlb)){for(O=sa+1;ma=a[O++];)if(ma.transclude&&!ma.$$tlb||ma.replace&&(ma.templateUrl||ma.template)){Ib=!0;break}ma=!0}!u.templateUrl&&u.controller&&(J=J||T(),ba("'"+Q+"' controller",
/src/angular.min.js:75:J[Q],u,y),J[Q]=u);if(O=u.transclude)if(G=!0,u.$$tlb||(ba("transclusion",L,u,y),L=u),"element"===O)N=!0,n=u.priority,M=y,y=d.$$element=x(da.$$createComment(Q,d[Q])),b=y[0],pa(f,Ha.call(M,0),b),R=Z(Ib,M,e,n,g&&g.name,{nonTlbTranscludeDirective:L});else{var ka=T();if(D(O)){M=C.document.createDocumentFragment();var Xa=T(),F=T();r(O,function(a,b){var c="?"===a.charAt(0);a=c?a.substring(1):a;Xa[a]=b;ka[b]=null;F[b]=c});r(y.contents(),function(a){var b=Xa[wa(ua(a))];b?(F[b]=!0,ka[b]=ka[b]||C.document.createDocumentFragment(),
/src/angular.min.js-76-ka[b].appendChild(a)):M.appendChild(a)});r(F,function(a,b){if(!a)throw $("reqslot",b);});for(var K in ka)ka[K]&&(R=x(ka[K].childNodes),ka[K]=Z(Ib,R,e));M=x(M.childNodes)}else M=x(pc(b)).contents();y.empty();R=Z(Ib,M,e,void 0,void 0,{needsNewScope:u.$$isolateScope||u.$$newScope});R.$$slots=ka}if(u.template)if(P=!0,ba("template",v,u,y),v=u,O=B(u.template)?u.template(y,d):u.template,O=Na(O),u.replace){g=u;M=mc.test(O)?rd(ja(u.templateNamespace,U(O))):[];b=M[0];if(1!==M.length||1!==b.nodeType)throw $("tplrt",
##############################################
/src/angular.min.js-84-c,d,a):(p.transcludeOnThisElement&&(a=ka(b,p.transclude,e)),p(n,b,c,d,a)))}}function ia(a,b){var c=b.priority-a.priority;return 0!==c?c:a.name!==b.name?a.name<b.name?-1:1:a.index-b.index}function ba(a,b,c,d){function e(a){return a?" (module: "+a+")":""}if(b)throw $("multidir",b.name,e(b.$$moduleName),c.name,e(c.$$moduleName),a,za(d));}function na(a,c){var d=b(c,!0);d&&a.push({priority:0,compile:function(a){a=a.parent();var b=!!a.length;b&&da.$$addBindingClass(a);return function(a,c){var e=c.parent();
/src/angular.min.js:85:b||da.$$addBindingClass(e);da.$$addBindingInfo(e,d.expressions);a.$watch(d,function(a){c[0].nodeValue=a})}}})}function ja(a,b){a=K(a||"html");switch(a){case "svg":case "math":var c=C.document.createElement("div");c.innerHTML="<"+a+">"+b+"</"+a+">";return c.childNodes[0].childNodes;default:return b}}function oa(a,b){if("srcdoc"===b)return u.HTML;if("src"===b||"ngSrc"===b)return-1===["img","video","audio","source","track"].indexOf(a)?u.RESOURCE_URL:u.MEDIA_URL;if("xlinkHref"===b)return"image"===a?u.MEDIA_URL:
/src/angular.min.js-86-"a"===a?u.URL:u.RESOURCE_URL;if("form"===a&&"action"===b||"base"===a&&"href"===b||"link"===a&&"href"===b)return u.RESOURCE_URL;if("a"===a&&("href"===b||"ngHref"===b))return u.URL}function xa(a,b){var c=b.toLowerCase();return v[a+"|"+c]||v["*|"+c]}function ya(a){return ma(u.valueOf(a),"ng-prop-srcset")}function Ea(a,b,c,d){if(m.test(d))throw $("nodomevents");a=ua(a);var e=xa(a,d),f=Ta;"srcset"!==d||"img"!==a&&"source"!==a?e&&(f=u.getTrusted.bind(u,e)):f=ya;b.push({priority:100,compile:function(a,b){var e=
/src/angular.min.js-87-p(b[c]),g=p(b[c],function(a){return u.valueOf(a)});return{pre:function(a,b){function c(){var g=e(a);b[0][d]=f(g)}c();a.$watch(g,c)}}}})}function Ia(a,c,d,e,f){var g=ua(a),k=oa(g,e),l=h[e]||f,p=b(d,!f,k,l);if(p){if("multiple"===e&&"select"===g)throw $("selmulti",za(a));if(m.test(e))throw $("nodomevents");c.push({priority:100,compile:function(){return{pre:function(a,c,f){c=f.$$observers||(f.$$observers=T());var g=f[e];g!==d&&(p=g&&b(g,!0,k,l),d=g);p&&(f[e]=p(a),(c[e]||(c[e]=[])).$$inter=!0,(f.$$observers&&
/src/angular.min.js:88:f.$$observers[e].$$scope||a).$watch(p,function(a,b){"class"===e&&a!==b?f.$updateClass(a,b):f.$set(e,a)}))}}}})}}function pa(a,b,c){var d=b[0],e=b.length,f=d.parentNode,g,h;if(a)for(g=0,h=a.length;g<h;g++)if(a[g]===d){a[g++]=c;h=g+e-1;for(var k=a.length;g<k;g++,h++)h<k?a[g]=a[h]:delete a[g];a.length-=e-1;a.context===d&&(a.context=c);break}f&&f.replaceChild(c,d);a=C.document.createDocumentFragment();for(g=0;g<e;g++)a.appendChild(b[g]);x.hasData(d)&&(x.data(c,x.data(d)),x(d).off("$destroy"));x.cleanData(a.querySelectorAll("*"));
/src/angular.min.js-89-for(g=1;g<e;g++)delete b[g];b[0]=c;b.length=1}function Aa(a,b){return S(function(){return a.apply(null,arguments)},a,b)}function Ba(a,b,d,e,f,g){try{a(b,d,e,f,g)}catch(h){c(h,za(d))}}function ra(a,b){if(s)throw $("missingattr",a,b);}function Da(a,c,d,e,f){function g(b,c,e){B(d.$onChanges)&&!dc(c,e)&&(Ua||(a.$$postDigest(q),Ua=[]),m||(m={},Ua.push(h)),m[b]&&(e=m[b].previousValue),m[b]=new Jb(e,c))}function h(){d.$onChanges(m);m=void 0}var k=[],l={},m;r(e,function(e,h){var m=e.attrName,n=e.optional,
##############################################
/src/angular.min.js-91-b};n.$stateful=!0;n=e.collection?a.$watchCollection(c[m],n):a.$watch(p(c[m],n),null,t.literal);k.push(n);break;case "<":if(!ta.call(c,m)){if(n)break;ra(m,f.name);c[m]=void 0}if(n&&!c[m])break;t=p(c[m]);var v=t.literal,L=d[h]=t(a);l[h]=new Jb(tc,d[h]);n=a[e.collection?"$watchCollection":"$watch"](t,function(a,b){if(b===a){if(b===L||v&&va(b,L))return;b=L}g(h,a,b);d[h]=a});k.push(n);break;case "&":n||ta.call(c,m)||ra(m,f.name);t=c.hasOwnProperty(m)?p(c[m]):E;if(t===E&&n)break;d[h]=function(b){return t(a,
/src/angular.min.js:92:b)}}});return{initialChanges:l,removeWatches:k.length&&function(){for(var a=0,b=k.length;a<b;++a)k[a]()}}}var Ma=/^\w/,Fa=C.document.createElement("div"),Oa=t,Qa=N,Ja=G,Ua;w.prototype={$normalize:wa,$addClass:function(a){a&&0<a.length&&R.addClass(this.$$element,a)},$removeClass:function(a){a&&0<a.length&&R.removeClass(this.$$element,a)},$updateClass:function(a,b){var c=sd(a,b);c&&c.length&&R.addClass(this.$$element,c);(c=sd(b,a))&&c.length&&R.removeClass(this.$$element,c)},$set:function(a,b,d,e){var f=
/src/angular.min.js-93-ld(this.$$element[0],a),g=td[a],h=a;f?(this.$$element.prop(a,b),e=f):g&&(this[g]=b,h=g);this[a]=b;e?this.$attr[a]=e:(e=this.$attr[a])||(this.$attr[a]=e=Vc(a,"-"));"img"===ua(this.$$element)&&"srcset"===a&&(this[a]=b=ma(b,"$set('srcset', value)"));!1!==d&&(null===b||z(b)?this.$$element.removeAttr(e):Ma.test(e)?f&&!1===b?this.$$element.removeAttr(e):this.$$element.attr(e,b):O(this.$$element[0],e,b));(a=this.$$observers)&&r(a[h],function(a){try{a(b)}catch(d){c(d)}})},$observe:function(a,b){var c=this,
/src/angular.min.js:94:d=c.$$observers||(c.$$observers=T()),e=d[a]||(d[a]=[]);e.push(b);L.$evalAsync(function(){e.$$inter||!c.hasOwnProperty(a)||z(c[a])||b(c[a])});return function(){cb(e,b)}}};var Ka=b.startSymbol(),La=b.endSymbol(),Na="{{"===Ka&&"}}"===La?Ta:function(a){return a.replace(/\{\{/g,Ka).replace(/}}/g,La)},Ra=/^ng(Attr|Prop|On)([A-Z].*)$/,Sa=/^(.+)Start$/;da.$$addBindingInfo=n?function(a,b){var c=a.data("$binding")||[];H(b)?c=c.concat(b):c.push(b);a.data("$binding",c)}:E;da.$$addBindingClass=n?function(a){sa(a,
/src/angular.min.js:95:"ng-binding")}:E;da.$$addScopeInfo=n?function(a,b,c,d){a.data(c?d?"$isolateScopeNoTemplate":"$isolateScope":"$scope",b)}:E;da.$$addScopeClass=n?function(a,b){sa(a,b?"ng-isolate-scope":"ng-scope")}:E;da.$$createComment=function(a,b){var c="";n&&(c=" "+(a||"")+": ",b&&(c+=b+" "));return C.document.createComment(c)};return da}]}function Jb(a,b){this.previousValue=a;this.currentValue=b}function wa(a){return a.replace(pd,"").replace(Eg,function(a,d,c){return c?d.toUpperCase():d})}function sd(a,b){var d=
/src/angular.min.js-96-"",c=a.split(/\s+/),e=b.split(/\s+/),f=0;a:for(;f<c.length;f++){for(var g=c[f],k=0;k<e.length;k++)if(g===e[k])continue a;d+=(0<d.length?" ":"")+g}return d}function rd(a){a=x(a);var b=a.length;if(1>=b)return a;for(;b--;){var d=a[b];(8===d.nodeType||d.nodeType===Pa&&""===d.nodeValue.trim())&&Fg.call(a,b,1)}return a}function Bg(a,b){if(b&&A(b))return b;if(A(a)){var d=ud.exec(a);if(d)return d[3]}}function Ff(){var a={};this.has=function(b){return a.hasOwnProperty(b)};this.register=function(b,d){Ja(b,
##############################################
/src/angular.min.js-116-b){var c;return a.$watchGroup(P,function(d,e){var f=x(d);b.call(this,f,d!==e?c:f,a);c=f})}})}}var l=a.length,m=b.length,p=new RegExp(a.replace(/./g,f),"g"),n=new RegExp(b.replace(/./g,f),"g");h.startSymbol=function(){return a};h.endSymbol=function(){return b};return h}]}function Lf(){this.$get=["$$intervalFactory","$window",function(a,b){var d={},c=function(a){b.clearInterval(a);delete d[a]},e=a(function(a,c,e){a=b.setInterval(a,c);d[a]=e;return a},c);e.cancel=function(a){if(!a)return!1;if(!a.hasOwnProperty("$$intervalId"))throw Lg("badprom");
/src/angular.min.js:117:if(!d.hasOwnProperty(a.$$intervalId))return!1;a=a.$$intervalId;var b=d[a],e=b.promise;e.$$state&&(e.$$state.pur=!0);b.reject("canceled");c(a);return!0};return e}]}function Mf(){this.$get=["$browser","$q","$$q","$rootScope",function(a,b,d,c){return function(e,f){return function(g,k,h,l){function m(){p?g.apply(null,n):g(s)}var p=4<arguments.length,n=p?Ha.call(arguments,4):[],s=0,G=w(l)&&!l,t=(G?d:b).defer(),r=t.promise;h=w(h)?h:0;r.$$intervalId=e(function(){G?a.defer(m):c.$evalAsync(m);t.notify(s++);
/src/angular.min.js-118-0<h&&s>=h&&(t.resolve(s),f(r.$$intervalId));G||c.$apply()},k,t,G);return r}}}]}function Ad(a,b){var d=ga(a);b.$$protocol=d.protocol;b.$$host=d.hostname;b.$$port=fa(d.port)||Mg[d.protocol]||null}function Bd(a,b,d){if(Ng.test(a))throw jb("badpath",a);var c="/"!==a.charAt(0);c&&(a="/"+a);a=ga(a);for(var c=(c&&"/"===a.pathname.charAt(0)?a.pathname.substring(1):a.pathname).split("/"),e=c.length;e--;)c[e]=decodeURIComponent(c[e]),d&&(c[e]=c[e].replace(/\//g,"%2F"));d=c.join("/");b.$$path=d;b.$$search=gc(a.search);
##############################################
/src/angular.min.js-124-Da(s).lastIndexOf("/")+1);m=new p(s,r,"#"+a);m.$$parseLinkUrl(n,n);m.$$state=c.state();var t=/^\s*(javascript|mailto):/i;f.on("click",function(a){var e=b.rewriteLinks;if(e&&!a.ctrlKey&&!a.metaKey&&!a.shiftKey&&2!==a.which&&2!==a.button){for(var g=x(a.target);"a"!==ua(g[0]);)if(g[0]===f[0]||!(g=g.parent())[0])return;if(!A(e)||!z(g.attr(e))){var e=g.prop("href"),h=g.attr("href")||g.attr("xlink:href");D(e)&&"[object SVGAnimatedString]"===e.toString()&&(e=ga(e.animVal).href);t.test(e)||!e||g.attr("target")||
/src/angular.min.js:125:a.isDefaultPrevented()||!m.$$parseLinkUrl(e,h)||(a.preventDefault(),m.absUrl()!==c.url()&&d.$apply())}}});m.absUrl()!==n&&c.url(m.absUrl(),!0);var N=!0;c.onUrlChange(function(a,b){xc(a,r)?(d.$evalAsync(function(){var c=m.absUrl(),e=m.$$state,f;m.$$parse(a);m.$$state=b;f=d.$broadcast("$locationChangeStart",a,c,b,e).defaultPrevented;m.absUrl()===a&&(f?(m.$$parse(c),m.$$state=e,h(c,!1,e)):(N=!1,l(c,e)))}),d.$$phase||d.$digest()):g.location.href=a});d.$watch(function(){if(N||m.$$urlUpdatedByLocation){m.$$urlUpdatedByLocation=
/src/angular.min.js:126:!1;var a=c.url(),b=m.absUrl(),f=c.state(),g=m.$$replace,n=!k(a,b)||m.$$html5&&e.history&&f!==m.$$state;if(N||n)N=!1,d.$evalAsync(function(){var b=m.absUrl(),c=d.$broadcast("$locationChangeStart",b,a,m.$$state,f).defaultPrevented;m.absUrl()===b&&(c?(m.$$parse(a),m.$$state=f):(n&&h(b,g,f===m.$$state?null:m.$$state),l(a,f)))})}m.$$replace=!1});return m}]}function Uf(){var a=!0,b=this;this.debugEnabled=function(b){return w(b)?(a=b,this):a};this.$get=["$window",function(d){function c(a){cc(a)&&(a.stack&&
/src/angular.min.js-127-f?a=a.message&&-1===a.stack.indexOf(a.message)?"Error: "+a.message+"\n"+a.stack:a.stack:a.sourceURL&&(a=a.message+"\n"+a.sourceURL+":"+a.line));return a}function e(a){var b=d.console||{},e=b[a]||b.log||E;return function(){var a=[];r(arguments,function(b){a.push(c(b))});return Function.prototype.apply.call(e,b,a)}}var f=Ca||/\bEdge\//.test(d.navigator&&d.navigator.userAgent);return{log:e("log"),info:e("info"),warn:e("warn"),error:e("error"),debug:function(){var c=e("debug");return function(){a&&c.apply(b,
##############################################
/src/angular.min.js-136-function m(a,b,c,d){var e=a.$watch(function(a){e();return d(a)},b,c);return e}function p(a){a.constant?a.$$watchDelegate=m:a.oneTime?a.$$watchDelegate=h:a.inputs&&(a.$$watchDelegate=k);return a}function n(a,b){function c(d){return b(a(d))}c.$stateful=a.$stateful||b.$stateful;c.$$pure=a.$$pure&&b.$$pure;return c}function s(a,b){if(!b)return a;a.$$interceptor&&(b=n(a.$$interceptor,b),a=a.$$intercepted);var c=!1,d=function(d,e,f,g){d=c&&g?g[0]:a(d,e,f,g);return b(d)};d.$$intercepted=a;d.$$interceptor=
/src/angular.min.js:137:b;d.literal=a.literal;d.oneTime=a.oneTime;d.constant=a.constant;b.$stateful||(c=!a.inputs,d.inputs=a.inputs?a.inputs:[a],b.$$pure||(d.inputs=d.inputs.map(function(a){return a.isPure===Fd?function(b){return a(b)}:a})));return p(d)}var G={csp:Aa().noUnsafeEval,literals:Ia(b),isIdentifierStart:B(d)&&d,isIdentifierContinue:B(c)&&c};f.$$getAst=function(a){var b=new Nb(G);return(new Mb(b,e,G)).getAst(a).ast};return f}]}function Xf(){var a=!0;this.$get=["$rootScope","$exceptionHandler",function(b,d){return Ld(function(a){b.$evalAsync(a)},
/src/angular.min.js-138-d,a)}];this.errorOnUnhandledRejections=function(b){return w(b)?(a=b,this):a}}function Yf(){var a=!0;this.$get=["$browser","$exceptionHandler",function(b,d){return Ld(function(a){b.defer(a)},d,a)}];this.errorOnUnhandledRejections=function(b){return w(b)?(a=b,this):a}}function Ld(a,b,d){function c(){return new e}function e(){var a=this.promise=new f;this.resolve=function(b){h(a,b)};this.reject=function(b){m(a,b)};this.notify=function(b){n(a,b)}}function f(){this.$$state={status:0}}function g(){for(;!w&&
##############################################
/src/angular.min.js-147-null,"$applyAsync"))}m.prototype={constructor:m,$new:function(b,c){var d;c=c||this;b?(d=new m,d.$root=this.$root):(this.$$ChildScope||(this.$$ChildScope=a(this)),d=new this.$$ChildScope);d.$parent=c;d.$$prevSibling=c.$$childTail;c.$$childHead?(c.$$childTail.$$nextSibling=d,c.$$childTail=d):c.$$childHead=c.$$childTail=d;(b||c!==this)&&d.$on("$destroy",h);return d},$watch:function(a,b,d,e){var f=g(a);b=B(b)?b:E;if(f.$$watchDelegate)return f.$$watchDelegate(this,b,d,f,a);var h=this,k=h.$$watchers,l=
/src/angular.min.js:148:{fn:b,last:G,get:f,exp:e||a,eq:!!d};c=null;k||(k=h.$$watchers=[],k.$$digestWatchIndex=-1);k.unshift(l);k.$$digestWatchIndex++;n(this,1);return function(){var a=cb(k,l);0<=a&&(n(h,-1),a<k.$$digestWatchIndex&&k.$$digestWatchIndex--);c=null}},$watchGroup:function(a,b){function c(){h=!1;try{k?(k=!1,b(e,e,g)):b(e,d,g)}finally{for(var f=0;f<a.length;f++)d[f]=e[f]}}var d=Array(a.length),e=Array(a.length),f=[],g=this,h=!1,k=!0;if(!a.length){var l=!0;g.$evalAsync(function(){l&&b(e,e,g)});return function(){l=
/src/angular.min.js:149:!1}}if(1===a.length)return this.$watch(a[0],function(a,c,f){e[0]=a;d[0]=c;b(e,a===c?e:d,f)});r(a,function(a,b){var d=g.$watch(a,function(a){e[b]=a;h||(h=!0,g.$evalAsync(c))});f.push(d)});return function(){for(;f.length;)f.shift()()}},$watchCollection:function(a,b){function c(a){e=a;var b,d,g,h;if(!z(e)){if(D(e))if(ya(e))for(f!==n&&(f=n,t=f.length=0,l++),a=e.length,t!==a&&(l++,f.length=t=a),b=0;b<a;b++)h=f[b],g=e[b],d=h!==h&&g!==g,d||h===g||(l++,f[b]=g);else{f!==p&&(f=p={},t=0,l++);a=0;for(b in e)ta.call(e,
/src/angular.min.js-150-b)&&(a++,g=e[b],h=f[b],b in f?(d=h!==h&&g!==g,d||h===g||(l++,f[b]=g)):(t++,f[b]=g,l++));if(t>a)for(b in l++,f)ta.call(e,b)||(t--,delete f[b])}else f!==e&&(f=e,l++);return l}}c.$$pure=g(a).literal;c.$stateful=!c.$$pure;var d=this,e,f,h,k=1<b.length,l=0,m=g(a,c),n=[],p={},s=!0,t=0;return this.$watch(m,function(){s?(s=!1,b(e,e,d)):b(e,h,d);if(k)if(D(e))if(ya(e)){h=Array(e.length);for(var a=0;a<e.length;a++)h[a]=e[a]}else for(a in h={},e)ta.call(e,a)&&(h[a]=e[a]);else h=e})},$digest:function(){var a,
##############################################
/src/angular.min.js-153-$resume:function(){this.$$suspended=!1},$destroy:function(){if(!this.$$destroyed){var a=this.$parent;this.$broadcast("$destroy");this.$$destroyed=!0;this===v&&k.$$applicationDestroyed();n(this,-this.$$watchersCount);for(var b in this.$$listenerCount)s(this,this.$$listenerCount[b],b);a&&a.$$childHead===this&&(a.$$childHead=this.$$nextSibling);a&&a.$$childTail===this&&(a.$$childTail=this.$$prevSibling);this.$$prevSibling&&(this.$$prevSibling.$$nextSibling=this.$$nextSibling);this.$$nextSibling&&(this.$$nextSibling.$$prevSibling=
/src/angular.min.js:154:this.$$prevSibling);this.$destroy=this.$digest=this.$apply=this.$evalAsync=this.$applyAsync=E;this.$on=this.$watch=this.$watchGroup=function(){return E};this.$$listeners={};this.$$nextSibling=null;l(this)}},$eval:function(a,b){return g(a)(this,b)},$evalAsync:function(a,b){v.$$phase||w.length||k.defer(function(){w.length&&v.$digest()},null,"$evalAsync");w.push({scope:this,fn:g(a),locals:b})},$$postDigest:function(a){x.push(a)},$apply:function(a){try{p("$apply");try{return this.$eval(a)}finally{v.$$phase=
/src/angular.min.js:155:null}}catch(b){f(b)}finally{try{v.$digest()}catch(c){throw f(c),c;}}},$applyAsync:function(a){function b(){c.$eval(a)}var c=this;a&&y.push(b);a=g(a);q()},$on:function(a,b){var c=this.$$listeners[a];c||(this.$$listeners[a]=c=[]);c.push(b);var d=this;do d.$$listenerCount[a]||(d.$$listenerCount[a]=0),d.$$listenerCount[a]++;while(d=d.$parent);var e=this;return function(){var d=c.indexOf(b);-1!==d&&(delete c[d],s(e,1,a))}},$emit:function(a,b){var c=[],d,e=this,g=!1,h={name:a,targetScope:e,stopPropagation:function(){g=
/src/angular.min.js-156-!0},preventDefault:function(){h.defaultPrevented=!0},defaultPrevented:!1},k=db([h],arguments,1),l,m;do{d=e.$$listeners[a]||c;h.currentScope=e;l=0;for(m=d.length;l<m;l++)if(d[l])try{d[l].apply(null,k)}catch(n){f(n)}else d.splice(l,1),l--,m--;if(g)break;e=e.$parent}while(e);h.currentScope=null;return h},$broadcast:function(a,b){var c=this,d=this,e={name:a,targetScope:this,preventDefault:function(){e.defaultPrevented=!0},defaultPrevented:!1};if(!this.$$listenerCount[a])return e;for(var g=db([e],arguments,
##############################################
/src/angular.min.js-158-this.aHrefSanitizationWhitelist=function(b){return w(b)?(a=b,this):a};this.imgSrcSanitizationWhitelist=function(a){return w(a)?(b=a,this):b};this.$get=function(){return function(d,c){var e=c?b:a,f=ga(d&&d.trim()).href;return""===f||f.match(e)?d:"unsafe:"+f}}}function Sg(a){if("self"===a)return a;if(A(a)){if(-1<a.indexOf("***"))throw Ea("iwcard",a);a=Md(a).replace(/\\\*\\\*/g,".*").replace(/\\\*/g,"[^:/.?&;]*");return new RegExp("^"+a+"$")}if(ab(a))return new RegExp("^"+a.source+"$");throw Ea("imatcher");
/src/angular.min.js:159:}function Nd(a){var b=[];w(a)&&r(a,function(a){b.push(Sg(a))});return b}function $f(){this.SCE_CONTEXTS=V;var a=["self"],b=[];this.resourceUrlWhitelist=function(b){arguments.length&&(a=Nd(b));return a};this.resourceUrlBlacklist=function(a){arguments.length&&(b=Nd(a));return b};this.$get=["$injector","$$sanitizeUri",function(d,c){function e(a,b){var c;"self"===a?(c=Bc(b,Od))||(C.document.baseURI?c=C.document.baseURI:(Na||(Na=C.document.createElement("a"),Na.href=".",Na=Na.cloneNode(!1)),c=Na.href),
/src/angular.min.js-160-c=Bc(b,c)):c=!!a.exec(b.href);return c}function f(a){var b=function(a){this.$$unwrapTrustedValue=function(){return a}};a&&(b.prototype=new a);b.prototype.valueOf=function(){return this.$$unwrapTrustedValue()};b.prototype.toString=function(){return this.$$unwrapTrustedValue().toString()};return b}var g=function(a){throw Ea("unsafe");};d.has("$sanitize")&&(g=d.get("$sanitize"));var k=f(),h={};h[V.HTML]=f(k);h[V.CSS]=f(k);h[V.MEDIA_URL]=f(k);h[V.URL]=f(h[V.MEDIA_URL]);h[V.JS]=f(k);h[V.RESOURCE_URL]=
##############################################
/src/angular.min.js-197-b){var c=s,c=l(c&&c.split(" "),1);h.$addClass(c)}else c=s,c=l(c&&c.split(" "),-1),h.$removeClass(c);n=a}var p=k.data("$classCounts"),n=!0,s;p||(p=T(),k.data("$classCounts",p));"ngClass"!==a&&(e||(e=f("$index",function(a){return a&1})),g.$watch(e,m));g.$watch(f(h[a],c),function(a){if(n===b){var c=s&&s.split(" "),e=a&&a.split(" "),f=d(c,e),c=d(e,c),f=l(f,-1),c=l(c,1);h.$addClass(c);h.$removeClass(f)}s=a})}}}]}function qd(a,b,d,c,e,f){return{restrict:"A",compile:function(g,k){var h=a(k[c]);return function(a,
/src/angular.min.js:198:c){c.on(e,function(c){var e=function(){h(a,{$event:c})};if(b.$$phase)if(f)a.$evalAsync(e);else try{e()}catch(g){d(g)}else a.$apply(e)})}}}}function Rb(a,b,d,c,e,f,g,k,h){this.$modelValue=this.$viewValue=Number.NaN;this.$$rawModelValue=void 0;this.$validators={};this.$asyncValidators={};this.$parsers=[];this.$formatters=[];this.$viewChangeListeners=[];this.$untouched=!0;this.$touched=!1;this.$pristine=!0;this.$dirty=!1;this.$valid=!0;this.$invalid=!1;this.$error={};this.$$success={};this.$pending=
/src/angular.min.js-199-void 0;this.$name=h(d.name||"",!1)(a);this.$$parentForm=lb;this.$options=Sb;this.$$updateEvents="";this.$$updateEventHandler=this.$$updateEventHandler.bind(this);this.$$parsedNgModel=e(d.ngModel);this.$$parsedNgModelAssign=this.$$parsedNgModel.assign;this.$$ngModelGet=this.$$parsedNgModel;this.$$ngModelSet=this.$$parsedNgModelAssign;this.$$pendingDebounce=null;this.$$parserValid=void 0;this.$$parserName="parse";this.$$currentValidationRunId=0;this.$$scope=a;this.$$rootScope=a.$root;this.$$attr=d;
##############################################
/src/angular.min.js-201-b,a,za(d));return a}}function Tb(a){a=fa(a);return X(a)?-1:a}var Wb={objectMaxDepth:5,urlErrorParamsEnabled:!0},ie=/^\/(.+)\/([a-z]*)$/,ta=Object.prototype.hasOwnProperty,K=function(a){return A(a)?a.toLowerCase():a},ub=function(a){return A(a)?a.toUpperCase():a},Ca,x,rb,Ha=[].slice,Fg=[].splice,kh=[].push,la=Object.prototype.toString,Pc=Object.getPrototypeOf,pa=F("ng"),ca=C.angular||(C.angular={}),kc,pb=0;Ca=C.document.documentMode;var X=Number.isNaN||function(a){return a!==a};E.$inject=[];Ta.$inject=
/src/angular.min.js:202:[];var ve=/^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array]$/,U=function(a){return A(a)?a.trim():a},Md=function(a){return a.replace(/([-()[\]{}+?*.$^|,:#<!\\])/g,"\\$1").replace(/\x08/g,"\\x08")},Aa=function(){if(!w(Aa.rules)){var a=C.document.querySelector("[ng-csp]")||C.document.querySelector("[data-ng-csp]");if(a){var b=a.getAttribute("ng-csp")||a.getAttribute("data-ng-csp");Aa.rules={noUnsafeEval:!b||-1!==b.indexOf("no-unsafe-eval"),noInlineStyle:!b||-1!==
/src/angular.min.js-203-b.indexOf("no-inline-style")}}else{a=Aa;try{new Function(""),b=!1}catch(d){b=!0}a.rules={noUnsafeEval:b,noInlineStyle:!1}}}return Aa.rules},qb=function(){if(w(qb.name_))return qb.name_;var a,b,d=Qa.length,c,e;for(b=0;b<d;++b)if(c=Qa[b],a=C.document.querySelector("["+c.replace(":","\\:")+"jq]")){e=a.getAttribute(c+"jq");break}return qb.name_=e},xe=/:/g,Qa=["ng-","data-ng-","ng:","x-ng-"],Be=function(a){var b=a.currentScript;if(!b)return!0;if(!(b instanceof C.HTMLScriptElement||b instanceof C.SVGScriptElement))return!1;
##############################################
/src/angular.min.js-275-this.astCompiler.compile(a.ast),d=a.ast;b.literal=0===d.body.length||1===d.body.length&&(d.body[0].expression.type===q.Literal||d.body[0].expression.type===q.ArrayExpression||d.body[0].expression.type===q.ObjectExpression);b.constant=a.ast.constant;b.oneTime=a.oneTime;return b},getAst:function(a){var b=!1;a=a.trim();":"===a.charAt(0)&&":"===a.charAt(1)&&(b=!0,a=a.substring(2));return{ast:this.ast.ast(a),oneTime:b}}};var Ea=F("$sce"),V={HTML:"html",CSS:"css",MEDIA_URL:"mediaUrl",URL:"url",RESOURCE_URL:"resourceUrl",
/src/angular.min.js:276:JS:"js"},Cc=/_([a-z])/g,Ug=F("$templateRequest"),Vg=F("$timeout"),aa=C.document.createElement("a"),Od=ga(C.location.href),Na;aa.href="http://[::1]";var Wg="[::1]"===aa.hostname;Pd.$inject=["$document"];dd.$inject=["$provide"];var Wd=22,Vd=".",Ec="0";Qd.$inject=["$locale"];Sd.$inject=["$locale"];var gh={yyyy:ea("FullYear",4,0,!1,!0),yy:ea("FullYear",2,0,!0,!0),y:ea("FullYear",1,0,!1,!0),MMMM:kb("Month"),MMM:kb("Month",!0),MM:ea("Month",2,1),M:ea("Month",1,1),LLLL:kb("Month",!1,!0),dd:ea("Date",2),
/src/angular.min.js-277-d:ea("Date",1),HH:ea("Hours",2),H:ea("Hours",1),hh:ea("Hours",2,-12),h:ea("Hours",1,-12),mm:ea("Minutes",2),m:ea("Minutes",1),ss:ea("Seconds",2),s:ea("Seconds",1),sss:ea("Milliseconds",3),EEEE:kb("Day"),EEE:kb("Day",!0),a:function(a,b){return 12>a.getHours()?b.AMPMS[0]:b.AMPMS[1]},Z:function(a,b,d){a=-1*d;return a=(0<=a?"+":"")+(Ob(Math[0<a?"floor":"ceil"](a/60),2)+Ob(Math.abs(a%60),2))},ww:Yd(2),w:Yd(1),G:Fc,GG:Fc,GGG:Fc,GGGG:function(a,b){return 0>=a.getFullYear()?b.ERANAMES[0]:b.ERANAMES[1]}},
##############################################
/src/angular.min.js-294-"$filter","$parse",function(a,b,d,c){return{restrict:"E",require:["?ngModel"],link:{pre:function(e,f,g,k){k[0]&&(pe[K(g.type)]||pe.text)(e,f,g,k[0],b,a,d,c)}}}}],vf=function(){var a={configurable:!0,enumerable:!1,get:function(){return this.getAttribute("value")||""},set:function(a){this.setAttribute("value",a)}};return{restrict:"E",priority:200,compile:function(b,d){if("hidden"===K(d.type))return{pre:function(b,d,f,g){b=d[0];b.parentNode&&b.parentNode.insertBefore(b,b.nextSibling);Object.defineProperty&&
/src/angular.min.js:295:Object.defineProperty(b,"value",a)}}}}},uh=/^(true|false|\d+)$/,sf=function(){function a(a,d,c){var e=w(c)?c:9===Ca?"":null;a.prop("value",e);d.$set("value",c)}return{restrict:"A",priority:100,compile:function(b,d){return uh.test(d.ngValue)?function(b,d,f){b=b.$eval(f.ngValue);a(d,f,b)}:function(b,d,f){b.$watch(f.ngValue,function(b){a(d,f,b)})}}}},Re=["$compile",function(a){return{restrict:"AC",compile:function(b){a.$$addBindingClass(b);return function(b,c,e){a.$$addBindingInfo(c,e.ngBind);c=c[0];
/src/angular.min.js-296-b.$watch(e.ngBind,function(a){c.textContent=ic(a)})}}}}],Te=["$interpolate","$compile",function(a,b){return{compile:function(d){b.$$addBindingClass(d);return function(c,d,f){c=a(d.attr(f.$attr.ngBindTemplate));b.$$addBindingInfo(d,c.expressions);d=d[0];f.$observe("ngBindTemplate",function(a){d.textContent=z(a)?"":a})}}}}],Se=["$sce","$parse","$compile",function(a,b,d){return{restrict:"A",compile:function(c,e){var f=b(e.ngBindHtml),g=b(e.ngBindHtml,function(b){return a.valueOf(b)});d.$$addBindingClass(c);
/src/angular.min.js:297:return function(b,c,e){d.$$addBindingInfo(c,e.ngBindHtml);b.$watch(g,function(){var d=f(b);c.html(a.getTrustedHtml(d)||"")})}}}}],rf=ia({restrict:"A",require:"ngModel",link:function(a,b,d,c){c.$viewChangeListeners.push(function(){a.$eval(d.ngChange)})}}),Ue=Kc("",!0),We=Kc("Odd",0),Ve=Kc("Even",1),Xe=Ra({compile:function(a,b){b.$set("ngCloak",void 0);a.removeClass("ng-cloak")}}),Ye=[function(){return{restrict:"A",scope:!0,controller:"@",priority:500}}],cd={},vh={blur:!0,focus:!0};r("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "),
/src/angular.min.js-298-function(a){var b=wa("ng-"+a);cd[b]=["$parse","$rootScope","$exceptionHandler",function(d,c,e){return qd(d,c,e,b,a,vh[a])}]});var af=["$animate","$compile",function(a,b){return{multiElement:!0,transclude:"element",priority:600,terminal:!0,restrict:"A",$$tlb:!0,link:function(d,c,e,f,g){var k,h,l;d.$watch(e.ngIf,function(d){d?h||g(function(d,f){h=f;d[d.length++]=b.$$createComment("end ngIf",e.ngIf);k={clone:d};a.enter(d,c.parent(),c)}):(l&&(l.remove(),l=null),h&&(h.$destroy(),h=null),k&&(l=tb(k.clone),
/src/angular.min.js-299-a.leave(l).done(function(a){!1!==a&&(l=null)}),k=null))})}}}],bf=["$templateRequest","$anchorScroll","$animate",function(a,b,d){return{restrict:"ECA",priority:400,terminal:!0,transclude:"element",controller:ca.noop,compile:function(c,e){var f=e.ngInclude||e.src,g=e.onload||"",k=e.autoscroll;return function(c,e,m,p,n){var r=0,q,t,x,v=function(){t&&(t.remove(),t=null);q&&(q.$destroy(),q=null);x&&(d.leave(x).done(function(a){!1!==a&&(t=null)}),t=x,x=null)};c.$watch(f,function(f){var m=function(a){!1===
/src/angular.min.js:300:a||!w(k)||k&&!c.$eval(k)||b()},t=++r;f?(a(f,!0).then(function(a){if(!c.$$destroyed&&t===r){var b=c.$new();p.template=a;a=n(b,function(a){v();d.enter(a,null,e).done(m)});q=b;x=a;q.$emit("$includeContentLoaded",f);c.$eval(g)}},function(){c.$$destroyed||t!==r||(v(),c.$emit("$includeContentError",f))}),c.$emit("$includeContentRequested",f)):(v(),p.template=null)})}}}}],uf=["$compile",function(a){return{restrict:"ECA",priority:-400,require:"ngInclude",link:function(b,d,c,e){la.call(d[0]).match(/SVG/)?
/src/angular.min.js:301:(d.empty(),a(ed(e.template,C.document).childNodes)(b,function(a){d.append(a)},{futureParentElement:d})):(d.html(e.template),a(d.contents())(b))}}}],cf=Ra({priority:450,compile:function(){return{pre:function(a,b,d){a.$eval(d.ngInit)}}}}),qf=function(){return{restrict:"A",priority:100,require:"ngModel",link:function(a,b,d,c){var e=d.ngList||", ",f="false"!==d.ngTrim,g=f?U(e):e;c.$parsers.push(function(a){if(!z(a)){var b=[];a&&r(a.split(g),function(a){a&&b.push(f?U(a):a)});return b}});c.$formatters.push(function(a){if(H(a))return a.join(e)});
/src/angular.min.js-302-c.$isEmpty=function(a){return!a||!a.length}}}},mb="ng-valid",$d="ng-invalid",Za="ng-pristine",Vb="ng-dirty",ob=F("ngModel");Rb.$inject="$scope $exceptionHandler $attrs $element $parse $animate $timeout $q $interpolate".split(" ");Rb.prototype={$$initGetterSetters:function(){if(this.$options.getOption("getterSetter")){var a=this.$$parse(this.$$attr.ngModel+"()"),b=this.$$parse(this.$$attr.ngModel+"($$$p)");this.$$ngModelGet=function(b){var c=this.$$parsedNgModel(b);B(c)&&(c=a(b));return c};this.$$ngModelSet=
##############################################
/src/angular.min.js-313-"^?form","^?ngModelOptions"],controller:Rb,priority:1,compile:function(b){b.addClass(Za).addClass("ng-untouched").addClass(mb);return{pre:function(a,b,e,f){var g=f[0];b=f[1]||g.$$parentForm;if(f=f[2])g.$options=f.$options;g.$$initGetterSetters();b.$addControl(g);e.$observe("name",function(a){g.$name!==a&&g.$$parentForm.$$renameControl(g,a)});a.$on("$destroy",function(){g.$$parentForm.$removeControl(g)})},post:function(b,c,e,f){function g(){k.$setTouched()}var k=f[0];k.$$setUpdateOnEvents();c.on("blur",
/src/angular.min.js:314:function(){k.$touched||(a.$$phase?b.$evalAsync(g):b.$apply(g))})}}}}}],Sb,wh=/(\s+|^)default(\s+|$)/;Lc.prototype={getOption:function(a){return this.$$options[a]},createChild:function(a){var b=!1;a=S({},a);r(a,function(d,c){"$inherit"===d?"*"===c?b=!0:(a[c]=this.$$options[c],"updateOn"===c&&(a.updateOnDefault=this.$$options.updateOnDefault)):"updateOn"===c&&(a.updateOnDefault=!1,a[c]=U(d.replace(wh,function(){a.updateOnDefault=!0;return" "})))},this);b&&(delete a["*"],ge(a,this.$$options));ge(a,Sb.$$options);
/src/angular.min.js:315:return new Lc(a)}};Sb=new Lc({updateOn:"",updateOnDefault:!0,debounce:0,getterSetter:!1,allowInvalid:!1,timezone:null});var tf=function(){function a(a,d){this.$$attrs=a;this.$$scope=d}a.$inject=["$attrs","$scope"];a.prototype={$onInit:function(){var a=this.parentCtrl?this.parentCtrl.$options:Sb,d=this.$$scope.$eval(this.$$attrs.ngModelOptions);this.$options=a.createChild(d)}};return{restrict:"A",priority:10,require:{parentCtrl:"?^^ngModelOptions"},bindToController:!0,controller:a}},df=Ra({terminal:!0,
/src/angular.min.js-316-priority:1E3}),xh=F("ngOptions"),yh=/^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([$\w][$\w]*)|(?:\(\s*([$\w][$\w]*)\s*,\s*([$\w][$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/,nf=["$compile","$document","$parse",function(a,b,d){function c(a,b,c){function e(a,b,c,d,f){this.selectValue=a;this.viewValue=b;this.label=c;this.group=d;this.disabled=f}function f(a){var b;if(!r&&ya(a))b=a;else{b=[];for(var c in a)a.hasOwnProperty(c)&&
##############################################
/src/angular.min.js-318-f(a),e=d.length,g=0;g<e;g++){var k=a===d?g:d[g],l=a[k],k=A(l,k),l=v(l,k);b.push(l);if(p[2]||p[1])l=z(c,k),b.push(l);p[4]&&(k=J(c,k),b.push(k))}return b}),getOptions:function(){for(var a=[],b={},d=I(c)||[],g=f(d),k=g.length,n=0;n<k;n++){var p=d===g?n:g[n],r=A(d[p],p),s=t(c,r),p=v(s,r),w=z(c,r),B=y(c,r),r=J(c,r),s=new e(p,s,w,B,r);a.push(s);b[p]=s}return{items:a,selectValueMap:b,getOptionFromViewValue:function(a){return b[x(a)]},getViewValueFromOption:function(a){return q?Ia(a.viewValue):a.viewValue}}}}}
/src/angular.min.js:319:var e=C.document.createElement("option"),f=C.document.createElement("optgroup");return{restrict:"A",terminal:!0,require:["select","ngModel"],link:{pre:function(a,b,c,d){d[0].registerOption=E},post:function(d,k,h,l){function m(a){var b=(a=v.getOptionFromViewValue(a))&&a.element;b&&!b.selected&&(b.selected=!0);return a}function p(a,b){a.element=b;b.disabled=a.disabled;a.label!==b.label&&(b.label=a.label,b.textContent=a.label);b.value=a.selectValue}var n=l[0],q=l[1],z=h.multiple;l=0;for(var t=k.children(),
/src/angular.min.js-320-B=t.length;l<B;l++)if(""===t[l].value){n.hasEmptyOption=!0;n.emptyOption=t.eq(l);break}k.empty();l=!!n.emptyOption;x(e.cloneNode(!1)).val("?");var v,A=c(h.ngOptions,k,d),C=b[0].createDocumentFragment();n.generateUnknownOptionValue=function(a){return"?"};z?(n.writeValue=function(a){if(v){var b=a&&a.map(m)||[];v.items.forEach(function(a){a.element.selected&&-1===Array.prototype.indexOf.call(b,a)&&(a.element.selected=!1)})}},n.readValue=function(){var a=k.val()||[],b=[];r(a,function(a){(a=v.selectValueMap[a])&&
##############################################
/src/angular.min.js-323-function(){var a=n.$isEmptyOptionSelected();n.hasEmptyOption=!1;n.emptyOption=void 0;a&&q.$render()}))}):n.emptyOption.removeClass("ng-scope"));d.$watchCollection(A.getWatchables,function(){var a=v&&n.readValue();if(v)for(var b=v.items.length-1;0<=b;b--){var c=v.items[b];w(c.group)?Fb(c.element.parentNode):Fb(c.element)}v=A.getOptions();var d={};v.items.forEach(function(a){var b;if(w(a.group)){b=d[a.group];b||(b=f.cloneNode(!1),C.appendChild(b),b.label=null===a.group?"null":a.group,d[a.group]=b);
/src/angular.min.js:324:var c=e.cloneNode(!1);b.appendChild(c);p(a,c)}else b=e.cloneNode(!1),C.appendChild(b),p(a,b)});k[0].appendChild(C);q.$render();q.$isEmpty(a)||(b=n.readValue(),(A.trackBy||z?va(a,b):a===b)||(q.$setViewValue(b),q.$render()))})}}}}],ef=["$locale","$interpolate","$log",function(a,b,d){var c=/{}/g,e=/^when(Minus)?(.+)$/;return{link:function(f,g,k){function h(a){g.text(a||"")}var l=k.count,m=k.$attr.when&&g.attr(k.$attr.when),p=k.offset||0,n=f.$eval(m)||{},q={},w=b.startSymbol(),t=b.endSymbol(),x=w+l+"-"+
/src/angular.min.js-325-p+t,v=ca.noop,A;r(k,function(a,b){var c=e.exec(b);c&&(c=(c[1]?"-":"")+K(c[2]),n[c]=g.attr(k.$attr[b]))});r(n,function(a,d){q[d]=b(a.replace(c,x))});f.$watch(l,function(b){var c=parseFloat(b),e=X(c);e||c in n||(c=a.pluralCat(c-p));c===A||e&&X(A)||(v(),e=q[c],z(e)?(null!=b&&d.debug("ngPluralize: no rule defined for '"+c+"' in "+m),v=E,h()):v=f.$watch(e,h),A=c)})}}}],qe=F("ngRef"),ff=["$parse",function(a){return{priority:-1,restrict:"A",compile:function(b,d){var c=wa(ua(b)),e=a(d.ngRef),f=e.assign||
##############################################
/src/angular.min.js-334-za(b));f.ngTransclude===f.$attr.ngTransclude&&(f.ngTransclude="");f=f.ngTransclude||f.ngTranscludeSlot;k(function(a,c){var d;if(d=a.length)a:{d=0;for(var f=a.length;d<f;d++){var g=a[d];if(g.nodeType!==Pa||g.nodeValue.trim()){d=!0;break a}}d=void 0}d?b.append(a):(h(),c.$destroy())},null,f);f&&!k.isSlotFilled(f)&&h()}}}}],Oe=["$templateCache",function(a){return{restrict:"E",terminal:!0,compile:function(b,d){"text/ng-template"===d.type&&a.put(d.id,b[0].text)}}}],Ah={$setViewValue:E,$render:E},Bh=["$element",
/src/angular.min.js:335:"$scope",function(a,b){function d(){g||(g=!0,b.$$postDigest(function(){g=!1;e.ngModelCtrl.$render()}))}function c(a){k||(k=!0,b.$$postDigest(function(){b.$$destroyed||(k=!1,e.ngModelCtrl.$setViewValue(e.readValue()),a&&e.ngModelCtrl.$render())}))}var e=this,f=new Hb;e.selectValueMap={};e.ngModelCtrl=Ah;e.multiple=!1;e.unknownOption=x(C.document.createElement("option"));e.hasEmptyOption=!1;e.emptyOption=void 0;e.renderUnknownOption=function(b){b=e.generateUnknownOptionValue(b);e.unknownOption.val(b);
/src/angular.min.js-336-a.prepend(e.unknownOption);Oa(e.unknownOption,!0);a.val(b)};e.updateUnknownOption=function(b){b=e.generateUnknownOptionValue(b);e.unknownOption.val(b);Oa(e.unknownOption,!0);a.val(b)};e.generateUnknownOptionValue=function(a){return"? "+La(a)+" ?"};e.removeUnknownOption=function(){e.unknownOption.parent()&&e.unknownOption.remove()};e.selectEmptyOption=function(){e.emptyOption&&(a.val(""),Oa(e.emptyOption,!0))};e.unselectEmptyOption=function(){e.hasEmptyOption&&Oa(e.emptyOption,!1)};b.$on("$destroy",

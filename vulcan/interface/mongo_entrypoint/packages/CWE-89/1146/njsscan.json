{
  "errors": [
    {
      "data": {
        "check_id": "ParseError",
        "end": {
          "col": 12,
          "line": 1
        },
        "extra": {
          "line": "MIT License",
          "message": "Syntax error"
        },
        "path": "/src/LICENSE",
        "start": {
          "col": 5,
          "line": 1
        }
      },
      "message": "SemgrepCoreRuntimeErrors"
    },
    {
      "data": {
        "check_id": "ParseError",
        "end": {
          "col": 37,
          "line": 1417
        },
        "extra": {
          "line": "    const clone = class extends this {};",
          "message": "Syntax error"
        },
        "path": "/src/lib/model.js",
        "start": {
          "col": 33,
          "line": 1417
        }
      },
      "message": "SemgrepCoreRuntimeErrors"
    }
  ],
  "nodejs": {
    "generic_header_injection": {
      "files": [
        {
          "file_path": "/src/lib/associations/has-one.js",
          "match_lines": [
            225,
            225
          ],
          "match_position": [
            9,
            91
          ],
          "match_string": "        associatedInstance.set(this.foreignKey, sourceInstance.get(this.sourceKeyAttribute));"
        }
      ],
      "metadata": {
        "cwe": "CWE-644: Improper Neutralization of HTTP Headers for Scripting Syntax",
        "description": "Untrusted user input in response header will result in HTTP Header Injection or Response Splitting Attacks.",
        "owasp": "A1: Injection",
        "severity": "ERROR"
      }
    },
    "node_sqli_injection": {
      "files": [
        {
          "file_path": "/src/lib/dialects/mssql/query-interface.js",
          "match_lines": [
            26,
            62
          ],
          "match_position": [
            3,
            51
          ],
          "match_string": "  const findConstraintSql = qi.QueryGenerator.getDefaultConstraintQuery(tableName, attributeName);\n\n  return qi.sequelize.query(findConstraintSql, options)\n\n    .then(([results]) => {\n\n      if (!results.length) {\n\n        // No default constraint found -- we can cleanly remove the column\n\n        return;\n\n      }\n\n      const dropConstraintSql = qi.QueryGenerator.dropConstraintQuery(tableName, results[0].name);\n\n      return qi.sequelize.query(dropConstraintSql, options);\n\n    })\n\n    .then(() => {\n\n      const findForeignKeySql = qi.QueryGenerator.getForeignKeyQuery(tableName, attributeName);\n\n      return qi.sequelize.query(findForeignKeySql, options);\n\n    })\n\n    .then(([results]) => {\n\n      if (!results.length) {\n\n        // No foreign key constraints found, so we can remove the column\n\n        return;\n\n      }\n\n      const dropForeignKeySql = qi.QueryGenerator.dropForeignKeyQuery(tableName, results[0].constraint_name);\n\n      return qi.sequelize.query(dropForeignKeySql, options);\n\n    })\n\n    .then(() => {\n\n      //Check if the current column is a primaryKey\n\n      const primaryKeyConstraintSql = qi.QueryGenerator.getPrimaryKeyConstraintQuery(tableName, attributeName);\n\n      return qi.sequelize.query(primaryKeyConstraintSql, options);\n\n    })\n\n    .then(([result]) => {\n\n      if (!result.length) {\n\n        return;\n\n      }\n\n      const dropConstraintSql = qi.QueryGenerator.dropConstraintQuery(tableName, result[0].constraintName);\n\n      return qi.sequelize.query(dropConstraintSql, options);\n\n    })\n\n    .then(() => {\n\n      const removeSql = qi.QueryGenerator.removeColumnQuery(tableName, attributeName);\n\n      return qi.sequelize.query(removeSql, options);"
        },
        {
          "file_path": "/src/lib/dialects/mssql/query-interface.js",
          "match_lines": [
            33,
            34
          ],
          "match_position": [
            7,
            59
          ],
          "match_string": "      const dropConstraintSql = qi.QueryGenerator.dropConstraintQuery(tableName, results[0].name);\n\n      return qi.sequelize.query(dropConstraintSql, options);"
        },
        {
          "file_path": "/src/lib/dialects/mssql/query-interface.js",
          "match_lines": [
            37,
            38
          ],
          "match_position": [
            7,
            59
          ],
          "match_string": "      const findForeignKeySql = qi.QueryGenerator.getForeignKeyQuery(tableName, attributeName);\n\n      return qi.sequelize.query(findForeignKeySql, options);"
        },
        {
          "file_path": "/src/lib/dialects/mssql/query-interface.js",
          "match_lines": [
            45,
            46
          ],
          "match_position": [
            7,
            59
          ],
          "match_string": "      const dropForeignKeySql = qi.QueryGenerator.dropForeignKeyQuery(tableName, results[0].constraint_name);\n\n      return qi.sequelize.query(dropForeignKeySql, options);"
        },
        {
          "file_path": "/src/lib/dialects/mssql/query-interface.js",
          "match_lines": [
            50,
            51
          ],
          "match_position": [
            7,
            65
          ],
          "match_string": "      const primaryKeyConstraintSql = qi.QueryGenerator.getPrimaryKeyConstraintQuery(tableName, attributeName);\n\n      return qi.sequelize.query(primaryKeyConstraintSql, options);"
        },
        {
          "file_path": "/src/lib/dialects/mssql/query-interface.js",
          "match_lines": [
            57,
            58
          ],
          "match_position": [
            7,
            59
          ],
          "match_string": "      const dropConstraintSql = qi.QueryGenerator.dropConstraintQuery(tableName, result[0].constraintName);\n\n      return qi.sequelize.query(dropConstraintSql, options);"
        },
        {
          "file_path": "/src/lib/dialects/mssql/query-interface.js",
          "match_lines": [
            61,
            62
          ],
          "match_position": [
            7,
            51
          ],
          "match_string": "      const removeSql = qi.QueryGenerator.removeColumnQuery(tableName, attributeName);\n\n      return qi.sequelize.query(removeSql, options);"
        },
        {
          "file_path": "/src/lib/dialects/mysql/connection-manager.js",
          "match_lines": [
            109,
            112
          ],
          "match_position": [
            13,
            66
          ],
          "match_string": "            let tzOffset = this.sequelize.options.timezone;\n\n            tzOffset = /\\//.test(tzOffset) ? momentTz.tz(tzOffset).format('Z') : tzOffset;\n\n            return connection.query(`SET time_zone = '${tzOffset}'`, err => {\n\n              if (err) { reject(err); } else { resolve(connection); }"
        },
        {
          "file_path": "/src/lib/dialects/mysql/connection-manager.js",
          "match_lines": [
            110,
            112
          ],
          "match_position": [
            13,
            66
          ],
          "match_string": "            tzOffset = /\\//.test(tzOffset) ? momentTz.tz(tzOffset).format('Z') : tzOffset;\n\n            return connection.query(`SET time_zone = '${tzOffset}'`, err => {\n\n              if (err) { reject(err); } else { resolve(connection); }"
        },
        {
          "file_path": "/src/lib/dialects/mysql/query-interface.js",
          "match_lines": [
            27,
            32
          ],
          "match_position": [
            10,
            41
          ],
          "match_string": "  return qi.sequelize.query(\n\n    qi.QueryGenerator.getForeignKeyQuery(tableName.tableName ? tableName : {\n\n      tableName,\n\n      schema: qi.sequelize.config.database\n\n    }, columnName),\n\n    Object.assign({ raw: true }, options)"
        },
        {
          "file_path": "/src/lib/dialects/mysql/query-interface.js",
          "match_lines": [
            40,
            42
          ],
          "match_position": [
            49,
            45
          ],
          "match_string": "      return Promise.map(results, constraint => qi.sequelize.query(\n\n        qi.QueryGenerator.dropForeignKeyQuery(tableName, constraint.constraint_name),\n\n        Object.assign({ raw: true }, options)"
        },
        {
          "file_path": "/src/lib/dialects/mysql/query-interface.js",
          "match_lines": [
            45,
            47
          ],
          "match_position": [
            17,
            43
          ],
          "match_string": "    .then(() => qi.sequelize.query(\n\n      qi.QueryGenerator.removeColumnQuery(tableName, columnName),\n\n      Object.assign({ raw: true }, options)"
        },
        {
          "file_path": "/src/lib/dialects/mysql/query-interface.js",
          "match_lines": [
            60,
            86
          ],
          "match_position": [
            3,
            47
          ],
          "match_string": "  const sql = qi.QueryGenerator.showConstraintsQuery(\n\n    tableName.tableName ? tableName : {\n\n      tableName,\n\n      schema: qi.sequelize.config.database\n\n    }, constraintName);\n\n\n\n  return qi.sequelize.query(sql, Object.assign({}, options,\n\n    { type: qi.sequelize.QueryTypes.SHOWCONSTRAINTS }))\n\n    .then(constraints => {\n\n      const constraint = constraints[0];\n\n      let query;\n\n      if (!constraint || !constraint.constraintType) {\n\n        throw new sequelizeErrors.UnknownConstraintError(\n\n          {\n\n            message: `Constraint ${constraintName} on table ${tableName} does not exist`,\n\n            constraint: constraintName,\n\n            table: tableName\n\n          });\n\n      }\n\n\n\n      if (constraint.constraintType === 'FOREIGN KEY') {\n\n        query = qi.QueryGenerator.dropForeignKeyQuery(tableName, constraintName);\n\n      } else {\n\n        query = qi.QueryGenerator.removeIndexQuery(constraint.tableName, constraint.constraintName);\n\n      }\n\n\n\n      return qi.sequelize.query(query, options);"
        },
        {
          "file_path": "/src/lib/dialects/postgres/query-interface.js",
          "match_lines": [
            30,
            48
          ],
          "match_position": [
            3,
            87
          ],
          "match_string": "  const keys = Object.keys(attributes);\n\n  const keyLen = keys.length;\n\n\n\n  let sql = '';\n\n  let promises = [];\n\n  let i = 0;\n\n\n\n  for (i = 0; i < keyLen; i++) {\n\n    const attribute = attributes[keys[i]];\n\n    const type = attribute.type;\n\n\n\n    if (\n\n      type instanceof DataTypes.ENUM ||\n\n      type instanceof DataTypes.ARRAY && type.type instanceof DataTypes.ENUM //ARRAY sub type is ENUM\n\n    ) {\n\n      sql = qi.QueryGenerator.pgListEnums(tableName, attribute.field || keys[i], options);\n\n      promises.push(qi.sequelize.query(\n\n        sql,\n\n        Object.assign({}, options, { plain: true, raw: true, type: QueryTypes.SELECT })"
        },
        {
          "file_path": "/src/lib/dialects/postgres/query-interface.js",
          "match_lines": [
            30,
            150
          ],
          "match_position": [
            3,
            76
          ],
          "match_string": "  const keys = Object.keys(attributes);\n\n  const keyLen = keys.length;\n\n\n\n  let sql = '';\n\n  let promises = [];\n\n  let i = 0;\n\n\n\n  for (i = 0; i < keyLen; i++) {\n\n    const attribute = attributes[keys[i]];\n\n    const type = attribute.type;\n\n\n\n    if (\n\n      type instanceof DataTypes.ENUM ||\n\n      type instanceof DataTypes.ARRAY && type.type instanceof DataTypes.ENUM //ARRAY sub type is ENUM\n\n    ) {\n\n      sql = qi.QueryGenerator.pgListEnums(tableName, attribute.field || keys[i], options);\n\n      promises.push(qi.sequelize.query(\n\n        sql,\n\n        Object.assign({}, options, { plain: true, raw: true, type: QueryTypes.SELECT })\n\n      ));\n\n    }\n\n  }\n\n\n\n  return Promise.all(promises).then(results => {\n\n    promises = [];\n\n    let enumIdx = 0;\n\n\n\n    // This little function allows us to re-use the same code that prepends or appends new value to enum array\n\n    const addEnumValue = (field, value, relativeValue, position = 'before', spliceStart = promises.length) => {\n\n      const valueOptions = _.clone(options);\n\n      valueOptions.before = null;\n\n      valueOptions.after = null;\n\n\n\n      switch (position) {\n\n        case 'after':\n\n          valueOptions.after = relativeValue;\n\n          break;\n\n        case 'before':\n\n        default:\n\n          valueOptions.before = relativeValue;\n\n          break;\n\n      }\n\n\n\n      promises.splice(spliceStart, 0, () => {\n\n        return qi.sequelize.query(qi.QueryGenerator.pgEnumAdd(\n\n          tableName, field, value, valueOptions\n\n        ), valueOptions);\n\n      });\n\n    };\n\n\n\n    for (i = 0; i < keyLen; i++) {\n\n      const attribute = attributes[keys[i]];\n\n      const type = attribute.type;\n\n      const enumType = type.type || type;\n\n      const field = attribute.field || keys[i];\n\n\n\n      if (\n\n        type instanceof DataTypes.ENUM ||\n\n        type instanceof DataTypes.ARRAY && enumType instanceof DataTypes.ENUM //ARRAY sub type is ENUM\n\n      ) {\n\n        // If the enum type doesn't exist then create it\n\n        if (!results[enumIdx]) {\n\n          promises.push(() => {\n\n            return qi.sequelize.query(qi.QueryGenerator.pgEnum(tableName, field, enumType, options), Object.assign({}, options, { raw: true }));\n\n          });\n\n        } else if (!!results[enumIdx] && !!model) {\n\n          const enumVals = qi.QueryGenerator.fromArray(results[enumIdx].enum_value);\n\n          const vals = enumType.values;\n\n\n\n          // Going through already existing values allows us to make queries that depend on those values\n\n          // We will prepend all new values between the old ones, but keep in mind - we can't change order of already existing values\n\n          // Then we append the rest of new values AFTER the latest already existing value\n\n          // E.g.: [1,2] -> [0,2,1] ==> [1,0,2]\n\n          // E.g.: [1,2,3] -> [2,1,3,4] ==> [1,2,3,4]\n\n          // E.g.: [1] -> [0,2,3] ==> [1,0,2,3]\n\n          let lastOldEnumValue;\n\n          let rightestPosition = -1;\n\n          for (let oldIndex = 0; oldIndex < enumVals.length; oldIndex++) {\n\n            const enumVal = enumVals[oldIndex];\n\n            const newIdx = vals.indexOf(enumVal);\n\n            lastOldEnumValue = enumVal;\n\n\n\n            if (newIdx === -1) {\n\n              continue;\n\n            }\n\n\n\n            const newValuesBefore = vals.slice(0, newIdx);\n\n            const promisesLength = promises.length;\n\n            // we go in reverse order so we could stop when we meet old value\n\n            for (let reverseIdx = newValuesBefore.length - 1; reverseIdx >= 0; reverseIdx--) {\n\n              if (~enumVals.indexOf(newValuesBefore[reverseIdx])) {\n\n                break;\n\n              }\n\n\n\n              addEnumValue(field, newValuesBefore[reverseIdx], lastOldEnumValue, 'before', promisesLength);\n\n            }\n\n\n\n            // we detect the most 'right' position of old value in new enum array so we can append new values to it\n\n            if (newIdx > rightestPosition) {\n\n              rightestPosition = newIdx;\n\n            }\n\n          }\n\n\n\n          if (lastOldEnumValue && rightestPosition < vals.length - 1) {\n\n            const remainingEnumValues = vals.slice(rightestPosition + 1);\n\n            for (let reverseIdx = remainingEnumValues.length - 1; reverseIdx >= 0; reverseIdx--) {\n\n              addEnumValue(field, remainingEnumValues[reverseIdx], lastOldEnumValue, 'after');\n\n            }\n\n          }\n\n\n\n          enumIdx++;\n\n        }\n\n      }\n\n    }\n\n\n\n    return promises\n\n      .reduce((promise, asyncFunction) => promise.then(asyncFunction), Promise.resolve())\n\n      .tap(() => {\n\n        // If ENUM processed, then refresh OIDs\n\n        if (promises.length) {\n\n          return qi.sequelize.dialect.connectionManager._refreshDynamicOIDs();"
        },
        {
          "file_path": "/src/lib/dialects/postgres/query-interface.js",
          "match_lines": [
            45,
            48
          ],
          "match_position": [
            7,
            87
          ],
          "match_string": "      sql = qi.QueryGenerator.pgListEnums(tableName, attribute.field || keys[i], options);\n\n      promises.push(qi.sequelize.query(\n\n        sql,\n\n        Object.assign({}, options, { plain: true, raw: true, type: QueryTypes.SELECT })"
        },
        {
          "file_path": "/src/lib/dialects/postgres/query-interface.js",
          "match_lines": [
            59,
            76
          ],
          "match_position": [
            7,
            24
          ],
          "match_string": "      const valueOptions = _.clone(options);\n\n      valueOptions.before = null;\n\n      valueOptions.after = null;\n\n\n\n      switch (position) {\n\n        case 'after':\n\n          valueOptions.after = relativeValue;\n\n          break;\n\n        case 'before':\n\n        default:\n\n          valueOptions.before = relativeValue;\n\n          break;\n\n      }\n\n\n\n      promises.splice(spliceStart, 0, () => {\n\n        return qi.sequelize.query(qi.QueryGenerator.pgEnumAdd(\n\n          tableName, field, value, valueOptions\n\n        ), valueOptions);"
        },
        {
          "file_path": "/src/lib/dialects/postgres/query-interface.js",
          "match_lines": [
            74,
            76
          ],
          "match_position": [
            16,
            24
          ],
          "match_string": "        return qi.sequelize.query(qi.QueryGenerator.pgEnumAdd(\n\n          tableName, field, value, valueOptions\n\n        ), valueOptions);"
        },
        {
          "file_path": "/src/lib/dialects/postgres/query-interface.js",
          "match_lines": [
            82,
            140
          ],
          "match_position": [
            7,
            20
          ],
          "match_string": "      const type = attribute.type;\n\n      const enumType = type.type || type;\n\n      const field = attribute.field || keys[i];\n\n\n\n      if (\n\n        type instanceof DataTypes.ENUM ||\n\n        type instanceof DataTypes.ARRAY && enumType instanceof DataTypes.ENUM //ARRAY sub type is ENUM\n\n      ) {\n\n        // If the enum type doesn't exist then create it\n\n        if (!results[enumIdx]) {\n\n          promises.push(() => {\n\n            return qi.sequelize.query(qi.QueryGenerator.pgEnum(tableName, field, enumType, options), Object.assign({}, options, { raw: true }));\n\n          });\n\n        } else if (!!results[enumIdx] && !!model) {\n\n          const enumVals = qi.QueryGenerator.fromArray(results[enumIdx].enum_value);\n\n          const vals = enumType.values;\n\n\n\n          // Going through already existing values allows us to make queries that depend on those values\n\n          // We will prepend all new values between the old ones, but keep in mind - we can't change order of already existing values\n\n          // Then we append the rest of new values AFTER the latest already existing value\n\n          // E.g.: [1,2] -> [0,2,1] ==> [1,0,2]\n\n          // E.g.: [1,2,3] -> [2,1,3,4] ==> [1,2,3,4]\n\n          // E.g.: [1] -> [0,2,3] ==> [1,0,2,3]\n\n          let lastOldEnumValue;\n\n          let rightestPosition = -1;\n\n          for (let oldIndex = 0; oldIndex < enumVals.length; oldIndex++) {\n\n            const enumVal = enumVals[oldIndex];\n\n            const newIdx = vals.indexOf(enumVal);\n\n            lastOldEnumValue = enumVal;\n\n\n\n            if (newIdx === -1) {\n\n              continue;\n\n            }\n\n\n\n            const newValuesBefore = vals.slice(0, newIdx);\n\n            const promisesLength = promises.length;\n\n            // we go in reverse order so we could stop when we meet old value\n\n            for (let reverseIdx = newValuesBefore.length - 1; reverseIdx >= 0; reverseIdx--) {\n\n              if (~enumVals.indexOf(newValuesBefore[reverseIdx])) {\n\n                break;\n\n              }\n\n\n\n              addEnumValue(field, newValuesBefore[reverseIdx], lastOldEnumValue, 'before', promisesLength);\n\n            }\n\n\n\n            // we detect the most 'right' position of old value in new enum array so we can append new values to it\n\n            if (newIdx > rightestPosition) {\n\n              rightestPosition = newIdx;\n\n            }\n\n          }\n\n\n\n          if (lastOldEnumValue && rightestPosition < vals.length - 1) {\n\n            const remainingEnumValues = vals.slice(rightestPosition + 1);\n\n            for (let reverseIdx = remainingEnumValues.length - 1; reverseIdx >= 0; reverseIdx--) {\n\n              addEnumValue(field, remainingEnumValues[reverseIdx], lastOldEnumValue, 'after');\n\n            }\n\n          }\n\n\n\n          enumIdx++;"
        },
        {
          "file_path": "/src/lib/dialects/postgres/query-interface.js",
          "match_lines": [
            83,
            140
          ],
          "match_position": [
            7,
            20
          ],
          "match_string": "      const enumType = type.type || type;\n\n      const field = attribute.field || keys[i];\n\n\n\n      if (\n\n        type instanceof DataTypes.ENUM ||\n\n        type instanceof DataTypes.ARRAY && enumType instanceof DataTypes.ENUM //ARRAY sub type is ENUM\n\n      ) {\n\n        // If the enum type doesn't exist then create it\n\n        if (!results[enumIdx]) {\n\n          promises.push(() => {\n\n            return qi.sequelize.query(qi.QueryGenerator.pgEnum(tableName, field, enumType, options), Object.assign({}, options, { raw: true }));\n\n          });\n\n        } else if (!!results[enumIdx] && !!model) {\n\n          const enumVals = qi.QueryGenerator.fromArray(results[enumIdx].enum_value);\n\n          const vals = enumType.values;\n\n\n\n          // Going through already existing values allows us to make queries that depend on those values\n\n          // We will prepend all new values between the old ones, but keep in mind - we can't change order of already existing values\n\n          // Then we append the rest of new values AFTER the latest already existing value\n\n          // E.g.: [1,2] -> [0,2,1] ==> [1,0,2]\n\n          // E.g.: [1,2,3] -> [2,1,3,4] ==> [1,2,3,4]\n\n          // E.g.: [1] -> [0,2,3] ==> [1,0,2,3]\n\n          let lastOldEnumValue;\n\n          let rightestPosition = -1;\n\n          for (let oldIndex = 0; oldIndex < enumVals.length; oldIndex++) {\n\n            const enumVal = enumVals[oldIndex];\n\n            const newIdx = vals.indexOf(enumVal);\n\n            lastOldEnumValue = enumVal;\n\n\n\n            if (newIdx === -1) {\n\n              continue;\n\n            }\n\n\n\n            const newValuesBefore = vals.slice(0, newIdx);\n\n            const promisesLength = promises.length;\n\n            // we go in reverse order so we could stop when we meet old value\n\n            for (let reverseIdx = newValuesBefore.length - 1; reverseIdx >= 0; reverseIdx--) {\n\n              if (~enumVals.indexOf(newValuesBefore[reverseIdx])) {\n\n                break;\n\n              }\n\n\n\n              addEnumValue(field, newValuesBefore[reverseIdx], lastOldEnumValue, 'before', promisesLength);\n\n            }\n\n\n\n            // we detect the most 'right' position of old value in new enum array so we can append new values to it\n\n            if (newIdx > rightestPosition) {\n\n              rightestPosition = newIdx;\n\n            }\n\n          }\n\n\n\n          if (lastOldEnumValue && rightestPosition < vals.length - 1) {\n\n            const remainingEnumValues = vals.slice(rightestPosition + 1);\n\n            for (let reverseIdx = remainingEnumValues.length - 1; reverseIdx >= 0; reverseIdx--) {\n\n              addEnumValue(field, remainingEnumValues[reverseIdx], lastOldEnumValue, 'after');\n\n            }\n\n          }\n\n\n\n          enumIdx++;"
        },
        {
          "file_path": "/src/lib/dialects/postgres/query-interface.js",
          "match_lines": [
            84,
            140
          ],
          "match_position": [
            7,
            20
          ],
          "match_string": "      const field = attribute.field || keys[i];\n\n\n\n      if (\n\n        type instanceof DataTypes.ENUM ||\n\n        type instanceof DataTypes.ARRAY && enumType instanceof DataTypes.ENUM //ARRAY sub type is ENUM\n\n      ) {\n\n        // If the enum type doesn't exist then create it\n\n        if (!results[enumIdx]) {\n\n          promises.push(() => {\n\n            return qi.sequelize.query(qi.QueryGenerator.pgEnum(tableName, field, enumType, options), Object.assign({}, options, { raw: true }));\n\n          });\n\n        } else if (!!results[enumIdx] && !!model) {\n\n          const enumVals = qi.QueryGenerator.fromArray(results[enumIdx].enum_value);\n\n          const vals = enumType.values;\n\n\n\n          // Going through already existing values allows us to make queries that depend on those values\n\n          // We will prepend all new values between the old ones, but keep in mind - we can't change order of already existing values\n\n          // Then we append the rest of new values AFTER the latest already existing value\n\n          // E.g.: [1,2] -> [0,2,1] ==> [1,0,2]\n\n          // E.g.: [1,2,3] -> [2,1,3,4] ==> [1,2,3,4]\n\n          // E.g.: [1] -> [0,2,3] ==> [1,0,2,3]\n\n          let lastOldEnumValue;\n\n          let rightestPosition = -1;\n\n          for (let oldIndex = 0; oldIndex < enumVals.length; oldIndex++) {\n\n            const enumVal = enumVals[oldIndex];\n\n            const newIdx = vals.indexOf(enumVal);\n\n            lastOldEnumValue = enumVal;\n\n\n\n            if (newIdx === -1) {\n\n              continue;\n\n            }\n\n\n\n            const newValuesBefore = vals.slice(0, newIdx);\n\n            const promisesLength = promises.length;\n\n            // we go in reverse order so we could stop when we meet old value\n\n            for (let reverseIdx = newValuesBefore.length - 1; reverseIdx >= 0; reverseIdx--) {\n\n              if (~enumVals.indexOf(newValuesBefore[reverseIdx])) {\n\n                break;\n\n              }\n\n\n\n              addEnumValue(field, newValuesBefore[reverseIdx], lastOldEnumValue, 'before', promisesLength);\n\n            }\n\n\n\n            // we detect the most 'right' position of old value in new enum array so we can append new values to it\n\n            if (newIdx > rightestPosition) {\n\n              rightestPosition = newIdx;\n\n            }\n\n          }\n\n\n\n          if (lastOldEnumValue && rightestPosition < vals.length - 1) {\n\n            const remainingEnumValues = vals.slice(rightestPosition + 1);\n\n            for (let reverseIdx = remainingEnumValues.length - 1; reverseIdx >= 0; reverseIdx--) {\n\n              addEnumValue(field, remainingEnumValues[reverseIdx], lastOldEnumValue, 'after');\n\n            }\n\n          }\n\n\n\n          enumIdx++;"
        },
        {
          "file_path": "/src/lib/dialects/postgres/query-interface.js",
          "match_lines": [
            93,
            93
          ],
          "match_position": [
            20,
            142
          ],
          "match_string": "            return qi.sequelize.query(qi.QueryGenerator.pgEnum(tableName, field, enumType, options), Object.assign({}, options, { raw: true }));"
        },
        {
          "file_path": "/src/lib/dialects/sqlite/query-interface.js",
          "match_lines": [
            162,
            179
          ],
          "match_position": [
            3,
            122
          ],
          "match_string": "  const describeCreateTableSql = qi.QueryGenerator.describeCreateTableQuery(tableName);\n\n  let createTableSql;\n\n\n\n  return qi.sequelize.query(describeCreateTableSql, Object.assign({}, options, { type: QueryTypes.SELECT, raw: true }))\n\n    .then(constraints => {\n\n      const sql = constraints[0].sql;\n\n      const index = sql.length - 1;\n\n      //Replace ending ')' with constraint snippet - Simulates String.replaceAt\n\n      //http://stackoverflow.com/questions/1431094\n\n      createTableSql = `${sql.substr(0, index)}, ${constraintSnippet})${sql.substr(index + 1)};`;\n\n\n\n      return qi.describeTable(tableName, options);\n\n    })\n\n    .then(fields => {\n\n      const sql = qi.QueryGenerator._alterConstraintQuery(tableName, fields, createTableSql);\n\n      const subQueries = sql.split(';').filter(q => q !== '');\n\n\n\n      return Promise.each(subQueries, subQuery => qi.sequelize.query(`${subQuery};`, Object.assign({ raw: true }, options)));"
        },
        {
          "file_path": "/src/lib/dialects/sqlite/query-interface.js",
          "match_lines": [
            193,
            204
          ],
          "match_position": [
            3,
            8
          ],
          "match_string": "  const database = qi.sequelize.config.database;\n\n  const query = qi.QueryGenerator.getForeignKeysQuery(tableName, database);\n\n  return qi.sequelize.query(query, options)\n\n    .then(result => {\n\n      return result.map(row => ({\n\n        tableName,\n\n        columnName: row.from,\n\n        referencedTableName: row.table,\n\n        referencedColumnName: row.to,\n\n        tableCatalog: database,\n\n        referencedTableCatalog: database\n\n      }));"
        },
        {
          "file_path": "/src/lib/dialects/sqlite/query-interface.js",
          "match_lines": [
            194,
            204
          ],
          "match_position": [
            3,
            8
          ],
          "match_string": "  const query = qi.QueryGenerator.getForeignKeysQuery(tableName, database);\n\n  return qi.sequelize.query(query, options)\n\n    .then(result => {\n\n      return result.map(row => ({\n\n        tableName,\n\n        columnName: row.from,\n\n        referencedTableName: row.table,\n\n        referencedColumnName: row.to,\n\n        tableCatalog: database,\n\n        referencedTableCatalog: database\n\n      }));"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            42,
            43
          ],
          "match_position": [
            5,
            45
          ],
          "match_string": "    const sql = this.QueryGenerator.createDatabaseQuery(database, options);\n\n    return this.sequelize.query(sql, options);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            56,
            57
          ],
          "match_position": [
            5,
            45
          ],
          "match_string": "    const sql = this.QueryGenerator.dropDatabaseQuery(database);\n\n    return this.sequelize.query(sql, options);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            70,
            71
          ],
          "match_position": [
            5,
            45
          ],
          "match_string": "    const sql = this.QueryGenerator.createSchema(schema);\n\n    return this.sequelize.query(sql, options);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            84,
            85
          ],
          "match_position": [
            5,
            45
          ],
          "match_string": "    const sql = this.QueryGenerator.dropSchema(schema);\n\n    return this.sequelize.query(sql, options);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            112,
            120
          ],
          "match_position": [
            5,
            77
          ],
          "match_string": "    options = Object.assign({}, options, {\n\n      raw: true,\n\n      type: this.sequelize.QueryTypes.SELECT\n\n    });\n\n\n\n    const showSchemasSql = this.QueryGenerator.showSchemasQuery(options);\n\n\n\n    return this.sequelize.query(showSchemasSql, options).then(schemaNames => _.flatten(\n\n      schemaNames.map(value => value.schema_name ? value.schema_name : value)"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            117,
            120
          ],
          "match_position": [
            5,
            77
          ],
          "match_string": "    const showSchemasSql = this.QueryGenerator.showSchemasQuery(options);\n\n\n\n    return this.sequelize.query(showSchemasSql, options).then(schemaNames => _.flatten(\n\n      schemaNames.map(value => value.schema_name ? value.schema_name : value)"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            134,
            136
          ],
          "match_position": [
            12,
            62
          ],
          "match_string": "    return this.sequelize.query(\n\n      this.QueryGenerator.versionQuery(),\n\n      Object.assign({}, options, { type: QueryTypes.VERSION })"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            197,
            236
          ],
          "match_position": [
            5,
            64
          ],
          "match_string": "    options = _.clone(options) || {};\n\n\n\n    if (options && options.uniqueKeys) {\n\n      _.forOwn(options.uniqueKeys, uniqueKey => {\n\n        if (uniqueKey.customIndex === undefined) {\n\n          uniqueKey.customIndex = true;\n\n        }\n\n      });\n\n    }\n\n\n\n    if (model) {\n\n      options.uniqueKeys = options.uniqueKeys || model.uniqueKeys;\n\n    }\n\n\n\n    attributes = _.mapValues(\n\n      attributes,\n\n      attribute => this.sequelize.normalizeAttribute(attribute)\n\n    );\n\n\n\n    // Postgres requires special SQL commands for ENUM/ENUM[]\n\n    if (this.sequelize.options.dialect === 'postgres') {\n\n      promise = PostgresQueryInterface.ensureEnums(this, tableName, attributes, options, model);\n\n    } else {\n\n      promise = Promise.resolve();\n\n    }\n\n\n\n    if (\n\n      !tableName.schema &&\n\n      (options.schema || !!model && model._schema)\n\n    ) {\n\n      tableName = this.QueryGenerator.addSchema({\n\n        tableName,\n\n        _schema: !!model && model._schema || options.schema\n\n      });\n\n    }\n\n\n\n    attributes = this.QueryGenerator.attributesToSQL(attributes, { table: tableName, context: 'createTable' });\n\n    sql = this.QueryGenerator.createTableQuery(tableName, attributes, options);\n\n\n\n    return promise.then(() => this.sequelize.query(sql, options));"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            211,
            236
          ],
          "match_position": [
            5,
            64
          ],
          "match_string": "    attributes = _.mapValues(\n\n      attributes,\n\n      attribute => this.sequelize.normalizeAttribute(attribute)\n\n    );\n\n\n\n    // Postgres requires special SQL commands for ENUM/ENUM[]\n\n    if (this.sequelize.options.dialect === 'postgres') {\n\n      promise = PostgresQueryInterface.ensureEnums(this, tableName, attributes, options, model);\n\n    } else {\n\n      promise = Promise.resolve();\n\n    }\n\n\n\n    if (\n\n      !tableName.schema &&\n\n      (options.schema || !!model && model._schema)\n\n    ) {\n\n      tableName = this.QueryGenerator.addSchema({\n\n        tableName,\n\n        _schema: !!model && model._schema || options.schema\n\n      });\n\n    }\n\n\n\n    attributes = this.QueryGenerator.attributesToSQL(attributes, { table: tableName, context: 'createTable' });\n\n    sql = this.QueryGenerator.createTableQuery(tableName, attributes, options);\n\n\n\n    return promise.then(() => this.sequelize.query(sql, options));"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            233,
            236
          ],
          "match_position": [
            5,
            64
          ],
          "match_string": "    attributes = this.QueryGenerator.attributesToSQL(attributes, { table: tableName, context: 'createTable' });\n\n    sql = this.QueryGenerator.createTableQuery(tableName, attributes, options);\n\n\n\n    return promise.then(() => this.sequelize.query(sql, options));"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            234,
            236
          ],
          "match_position": [
            5,
            64
          ],
          "match_string": "    sql = this.QueryGenerator.createTableQuery(tableName, attributes, options);\n\n\n\n    return promise.then(() => this.sequelize.query(sql, options));"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            249,
            278
          ],
          "match_position": [
            5,
            41
          ],
          "match_string": "    options = _.clone(options) || {};\n\n    options.cascade = options.cascade || options.force || false;\n\n\n\n    let sql = this.QueryGenerator.dropTableQuery(tableName, options);\n\n\n\n    return this.sequelize.query(sql, options).then(() => {\n\n      const promises = [];\n\n\n\n      // Since postgres has a special case for enums, we should drop the related\n\n      // enum type within the table and attribute\n\n      if (this.sequelize.options.dialect === 'postgres') {\n\n        const instanceTable = this.sequelize.modelManager.getModel(tableName, { attribute: 'tableName' });\n\n\n\n        if (instanceTable) {\n\n          const getTableName = (!options || !options.schema || options.schema === 'public' ? '' : `${options.schema}_`) + tableName;\n\n\n\n          const keys = Object.keys(instanceTable.rawAttributes);\n\n          const keyLen = keys.length;\n\n\n\n          for (let i = 0; i < keyLen; i++) {\n\n            if (instanceTable.rawAttributes[keys[i]].type instanceof DataTypes.ENUM) {\n\n              sql = this.QueryGenerator.pgEnumDrop(getTableName, keys[i]);\n\n              options.supportsSearchPath = false;\n\n              promises.push(this.sequelize.query(sql, Object.assign({}, options, { raw: true })));\n\n            }\n\n          }\n\n        }\n\n      }\n\n\n\n      return Promise.all(promises).get(0);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            252,
            278
          ],
          "match_position": [
            5,
            41
          ],
          "match_string": "    let sql = this.QueryGenerator.dropTableQuery(tableName, options);\n\n\n\n    return this.sequelize.query(sql, options).then(() => {\n\n      const promises = [];\n\n\n\n      // Since postgres has a special case for enums, we should drop the related\n\n      // enum type within the table and attribute\n\n      if (this.sequelize.options.dialect === 'postgres') {\n\n        const instanceTable = this.sequelize.modelManager.getModel(tableName, { attribute: 'tableName' });\n\n\n\n        if (instanceTable) {\n\n          const getTableName = (!options || !options.schema || options.schema === 'public' ? '' : `${options.schema}_`) + tableName;\n\n\n\n          const keys = Object.keys(instanceTable.rawAttributes);\n\n          const keyLen = keys.length;\n\n\n\n          for (let i = 0; i < keyLen; i++) {\n\n            if (instanceTable.rawAttributes[keys[i]].type instanceof DataTypes.ENUM) {\n\n              sql = this.QueryGenerator.pgEnumDrop(getTableName, keys[i]);\n\n              options.supportsSearchPath = false;\n\n              promises.push(this.sequelize.query(sql, Object.assign({}, options, { raw: true })));\n\n            }\n\n          }\n\n        }\n\n      }\n\n\n\n      return Promise.all(promises).get(0);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            263,
            272
          ],
          "match_position": [
            11,
            95
          ],
          "match_string": "          const getTableName = (!options || !options.schema || options.schema === 'public' ? '' : `${options.schema}_`) + tableName;\n\n\n\n          const keys = Object.keys(instanceTable.rawAttributes);\n\n          const keyLen = keys.length;\n\n\n\n          for (let i = 0; i < keyLen; i++) {\n\n            if (instanceTable.rawAttributes[keys[i]].type instanceof DataTypes.ENUM) {\n\n              sql = this.QueryGenerator.pgEnumDrop(getTableName, keys[i]);\n\n              options.supportsSearchPath = false;\n\n              promises.push(this.sequelize.query(sql, Object.assign({}, options, { raw: true })));"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            265,
            272
          ],
          "match_position": [
            11,
            95
          ],
          "match_string": "          const keys = Object.keys(instanceTable.rawAttributes);\n\n          const keyLen = keys.length;\n\n\n\n          for (let i = 0; i < keyLen; i++) {\n\n            if (instanceTable.rawAttributes[keys[i]].type instanceof DataTypes.ENUM) {\n\n              sql = this.QueryGenerator.pgEnumDrop(getTableName, keys[i]);\n\n              options.supportsSearchPath = false;\n\n              promises.push(this.sequelize.query(sql, Object.assign({}, options, { raw: true })));"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            270,
            272
          ],
          "match_position": [
            15,
            95
          ],
          "match_string": "              sql = this.QueryGenerator.pgEnumDrop(getTableName, keys[i]);\n\n              options.supportsSearchPath = false;\n\n              promises.push(this.sequelize.query(sql, Object.assign({}, options, { raw: true })));"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            350,
            352
          ],
          "match_position": [
            12,
            47
          ],
          "match_string": "    return this.sequelize.query(\n\n      this.QueryGenerator.pgEnumDrop(null, null, this.QueryGenerator.pgEscapeAndQuote(enumName)),\n\n      Object.assign({}, options, { raw: true })"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            371,
            373
          ],
          "match_position": [
            58,
            47
          ],
          "match_string": "    return this.pgListEnums(null, options).map(result => this.sequelize.query(\n\n      this.QueryGenerator.pgEnumDrop(null, null, this.QueryGenerator.pgEscapeAndQuote(result.enum_name)),\n\n      Object.assign({}, options, { raw: true })"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            388,
            389
          ],
          "match_position": [
            5,
            117
          ],
          "match_string": "    const sql = this.QueryGenerator.pgListEnums(tableName);\n\n    return this.sequelize.query(sql, Object.assign({}, options, { plain: false, raw: true, type: QueryTypes.SELECT }));"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            403,
            404
          ],
          "match_position": [
            5,
            45
          ],
          "match_string": "    const sql = this.QueryGenerator.renameTableQuery(before, after);\n\n    return this.sequelize.query(sql, options);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            423,
            424
          ],
          "match_position": [
            5,
            96
          ],
          "match_string": "    const showTablesSql = this.QueryGenerator.showTablesQuery();\n\n    return this.sequelize.query(showTablesSql, options).then(tableNames => _.flatten(tableNames));"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            468,
            487
          ],
          "match_position": [
            5,
            14
          ],
          "match_string": "    const sql = this.QueryGenerator.describeTableQuery(tableName, schema, schemaDelimiter);\n\n    options = Object.assign({}, options, { type: QueryTypes.DESCRIBE });\n\n\n\n    return this.sequelize.query(sql, options).then(data => {\n\n      /*\n\n       * If no data is returned from the query, then the table name may be wrong.\n\n       * Query generators that use information_schema for retrieving table info will just return an empty result set,\n\n       * it will not throw an error like built-ins do (e.g. DESCRIBE on MySql).\n\n       */\n\n      if (_.isEmpty(data)) {\n\n        throw new Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n\n      }\n\n\n\n      return data;\n\n    }).catch(e => {\n\n      if (e.original && e.original.code === 'ER_NO_SUCH_TABLE') {\n\n        throw Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n\n      }\n\n\n\n      throw e;"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            513,
            514
          ],
          "match_position": [
            5,
            99
          ],
          "match_string": "    attribute = this.sequelize.normalizeAttribute(attribute);\n\n    return this.sequelize.query(this.QueryGenerator.addColumnQuery(table, key, attribute), options);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            514,
            514
          ],
          "match_position": [
            12,
            99
          ],
          "match_string": "    return this.sequelize.query(this.QueryGenerator.addColumnQuery(table, key, attribute), options);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            540,
            540
          ],
          "match_position": [
            16,
            109
          ],
          "match_string": "        return this.sequelize.query(this.QueryGenerator.removeColumnQuery(tableName, attributeName), options);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            570,
            576
          ],
          "match_position": [
            5,
            45
          ],
          "match_string": "    const query = this.QueryGenerator.attributesToSQL(attributes, {\n\n      context: 'changeColumn',\n\n      table: tableName\n\n    });\n\n    const sql = this.QueryGenerator.changeColumnQuery(tableName, query);\n\n\n\n    return this.sequelize.query(sql, options);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            574,
            576
          ],
          "match_position": [
            5,
            45
          ],
          "match_string": "    const sql = this.QueryGenerator.changeColumnQuery(tableName, query);\n\n\n\n    return this.sequelize.query(sql, options);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            616,
            621
          ],
          "match_position": [
            7,
            47
          ],
          "match_string": "      const sql = this.QueryGenerator.renameColumnQuery(\n\n        tableName,\n\n        attrNameBefore,\n\n        this.QueryGenerator.attributesToSQL(_options)\n\n      );\n\n      return this.sequelize.query(sql, options);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            656,
            659
          ],
          "match_position": [
            5,
            94
          ],
          "match_string": "    options = Utils.cloneDeep(options);\n\n    options.fields = attributes;\n\n    const sql = this.QueryGenerator.addIndexQuery(tableName, options, rawTablename);\n\n    return this.sequelize.query(sql, Object.assign({}, options, { supportsSearchPath: false }));"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            658,
            659
          ],
          "match_position": [
            5,
            94
          ],
          "match_string": "    const sql = this.QueryGenerator.addIndexQuery(tableName, options, rawTablename);\n\n    return this.sequelize.query(sql, Object.assign({}, options, { supportsSearchPath: false }));"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            672,
            673
          ],
          "match_position": [
            5,
            97
          ],
          "match_string": "    const sql = this.QueryGenerator.showIndexesQuery(tableName, options);\n\n    return this.sequelize.query(sql, Object.assign({}, options, { type: QueryTypes.SHOWINDEXES }));"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            684,
            684
          ],
          "match_position": [
            7,
            119
          ],
          "match_string": "      this.sequelize.query(this.QueryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.database), options)"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            721,
            739
          ],
          "match_position": [
            5,
            56
          ],
          "match_string": "    const catalogName = this.sequelize.config.database;\n\n    switch (this.sequelize.options.dialect) {\n\n      case 'sqlite':\n\n        // sqlite needs some special treatment.\n\n        return SQLiteQueryInterface.getForeignKeyReferencesForTable(this, tableName, queryOptions);\n\n      case 'postgres':\n\n      {\n\n        // postgres needs some special treatment as those field names returned are all lowercase\n\n        // in order to keep same result with other dialects.\n\n        const query = this.QueryGenerator.getForeignKeyReferencesQuery(tableName, catalogName);\n\n        return this.sequelize.query(query, queryOptions)\n\n          .then(result => result.map(Utils.camelizeObjectKeys));\n\n      }\n\n      case 'mssql':\n\n      case 'mysql':\n\n      case 'mariadb':\n\n      default: {\n\n        const query = this.QueryGenerator.getForeignKeysQuery(tableName, catalogName);\n\n        return this.sequelize.query(query, queryOptions);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            730,
            732
          ],
          "match_position": [
            9,
            62
          ],
          "match_string": "        const query = this.QueryGenerator.getForeignKeyReferencesQuery(tableName, catalogName);\n\n        return this.sequelize.query(query, queryOptions)\n\n          .then(result => result.map(Utils.camelizeObjectKeys));"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            738,
            739
          ],
          "match_position": [
            9,
            56
          ],
          "match_string": "        const query = this.QueryGenerator.getForeignKeysQuery(tableName, catalogName);\n\n        return this.sequelize.query(query, queryOptions);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            755,
            756
          ],
          "match_position": [
            5,
            45
          ],
          "match_string": "    const sql = this.QueryGenerator.removeIndexQuery(tableName, indexNameOrAttributes);\n\n    return this.sequelize.query(sql, options);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            837,
            844
          ],
          "match_position": [
            5,
            45
          ],
          "match_string": "    options = Utils.cloneDeep(options);\n\n    options.fields = attributes;\n\n\n\n    if (this.sequelize.dialect.name === 'sqlite') {\n\n      return SQLiteQueryInterface.addConstraint(this, tableName, options, rawTablename);\n\n    }\n\n    const sql = this.QueryGenerator.addConstraintQuery(tableName, options, rawTablename);\n\n    return this.sequelize.query(sql, options);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            843,
            844
          ],
          "match_position": [
            5,
            45
          ],
          "match_string": "    const sql = this.QueryGenerator.addConstraintQuery(tableName, options, rawTablename);\n\n    return this.sequelize.query(sql, options);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            848,
            849
          ],
          "match_position": [
            5,
            101
          ],
          "match_string": "    const sql = this.QueryGenerator.showConstraintsQuery(tableName, constraintName);\n\n    return this.sequelize.query(sql, Object.assign({}, options, { type: QueryTypes.SHOWCONSTRAINTS }));"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            872,
            873
          ],
          "match_position": [
            9,
            49
          ],
          "match_string": "        const sql = this.QueryGenerator.removeConstraintQuery(tableName, constraintName);\n\n        return this.sequelize.query(sql, options);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            878,
            887
          ],
          "match_position": [
            5,
            21
          ],
          "match_string": "    options = Utils.cloneDeep(options);\n\n    options.hasTrigger = instance && instance.constructor.options.hasTrigger;\n\n    const sql = this.QueryGenerator.insertQuery(tableName, values, instance && instance.constructor.rawAttributes, options);\n\n\n\n    options.type = QueryTypes.INSERT;\n\n    options.instance = instance;\n\n\n\n    return this.sequelize.query(sql, options).then(results => {\n\n      if (instance) results[0].isNewRecord = false;\n\n      return results;"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            880,
            887
          ],
          "match_position": [
            5,
            21
          ],
          "match_string": "    const sql = this.QueryGenerator.insertQuery(tableName, values, instance && instance.constructor.rawAttributes, options);\n\n\n\n    options.type = QueryTypes.INSERT;\n\n    options.instance = instance;\n\n\n\n    return this.sequelize.query(sql, options).then(results => {\n\n      if (instance) results[0].isNewRecord = false;\n\n      return results;"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            909,
            967
          ],
          "match_position": [
            5,
            37
          ],
          "match_string": "    options = _.clone(options);\n\n\n\n    if (!Utils.isWhereEmpty(where)) {\n\n      wheres.push(where);\n\n    }\n\n\n\n    // Lets combine unique keys and indexes into one\n\n    indexes = _.map(model.uniqueKeys, value => {\n\n      return value.fields;\n\n    });\n\n\n\n    model._indexes.forEach(value => {\n\n      if (value.unique) {\n\n        // fields in the index may both the strings or objects with an attribute property - lets sanitize that\n\n        indexFields = value.fields.map(field => {\n\n          if (_.isPlainObject(field)) {\n\n            return field.attribute;\n\n          }\n\n          return field;\n\n        });\n\n        indexes.push(indexFields);\n\n      }\n\n    });\n\n\n\n    for (const index of indexes) {\n\n      if (_.intersection(attributes, index).length === index.length) {\n\n        where = {};\n\n        for (const field of index) {\n\n          where[field] = insertValues[field];\n\n        }\n\n        wheres.push(where);\n\n      }\n\n    }\n\n\n\n    where = { [Op.or]: wheres };\n\n\n\n    options.type = QueryTypes.UPSERT;\n\n    options.raw = true;\n\n\n\n    const sql = this.QueryGenerator.upsertQuery(tableName, insertValues, updateValues, where, model, options);\n\n    return this.sequelize.query(sql, options).then(result => {\n\n      switch (this.sequelize.options.dialect) {\n\n        case 'postgres':\n\n          return [result.created, result.primary_key];\n\n\n\n        case 'mssql':\n\n          return [\n\n            result.$action === 'INSERT',\n\n            result[model.primaryKeyField]\n\n          ];\n\n\n\n        // MySQL returns 1 for inserted, 2 for updated\n\n        // http://dev.mysql.com/doc/refman/5.0/en/insert-on-duplicate.html.\n\n        case 'mysql':\n\n        case 'mariadb':\n\n          return [result === 1, undefined];\n\n\n\n        default:\n\n          return [result, undefined];"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            948,
            967
          ],
          "match_position": [
            5,
            37
          ],
          "match_string": "    const sql = this.QueryGenerator.upsertQuery(tableName, insertValues, updateValues, where, model, options);\n\n    return this.sequelize.query(sql, options).then(result => {\n\n      switch (this.sequelize.options.dialect) {\n\n        case 'postgres':\n\n          return [result.created, result.primary_key];\n\n\n\n        case 'mssql':\n\n          return [\n\n            result.$action === 'INSERT',\n\n            result[model.primaryKeyField]\n\n          ];\n\n\n\n        // MySQL returns 1 for inserted, 2 for updated\n\n        // http://dev.mysql.com/doc/refman/5.0/en/insert-on-duplicate.html.\n\n        case 'mysql':\n\n        case 'mariadb':\n\n          return [result === 1, undefined];\n\n\n\n        default:\n\n          return [result, undefined];"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            994,
            1000
          ],
          "match_position": [
            5,
            32
          ],
          "match_string": "    options = _.clone(options) || {};\n\n    options.type = QueryTypes.INSERT;\n\n\n\n    return this.sequelize.query(\n\n      this.QueryGenerator.bulkInsertQuery(tableName, records, options, attributes),\n\n      options\n\n    ).then(results => results[0]);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            997,
            999
          ],
          "match_position": [
            12,
            14
          ],
          "match_string": "    return this.sequelize.query(\n\n      this.QueryGenerator.bulkInsertQuery(tableName, records, options, attributes),\n\n      options"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            1004,
            1012
          ],
          "match_position": [
            5,
            45
          ],
          "match_string": "    options = _.clone(options || {});\n\n    options.hasTrigger = !!(instance && instance._modelOptions && instance._modelOptions.hasTrigger);\n\n\n\n    const sql = this.QueryGenerator.updateQuery(tableName, values, identifier, options, instance.constructor.rawAttributes);\n\n\n\n    options.type = QueryTypes.UPDATE;\n\n\n\n    options.instance = instance;\n\n    return this.sequelize.query(sql, options);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            1007,
            1012
          ],
          "match_position": [
            5,
            45
          ],
          "match_string": "    const sql = this.QueryGenerator.updateQuery(tableName, values, identifier, options, instance.constructor.rawAttributes);\n\n\n\n    options.type = QueryTypes.UPDATE;\n\n\n\n    options.instance = instance;\n\n    return this.sequelize.query(sql, options);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            1035,
            1043
          ],
          "match_position": [
            5,
            45
          ],
          "match_string": "    options = Utils.cloneDeep(options);\n\n    if (typeof identifier === 'object') identifier = Utils.cloneDeep(identifier);\n\n\n\n    const sql = this.QueryGenerator.updateQuery(tableName, values, identifier, options, attributes);\n\n    const table = _.isObject(tableName) ? tableName : { tableName };\n\n    const model = _.find(this.sequelize.modelManager.models, { tableName: table.tableName });\n\n\n\n    options.model = model;\n\n    return this.sequelize.query(sql, options);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            1038,
            1043
          ],
          "match_position": [
            5,
            45
          ],
          "match_string": "    const sql = this.QueryGenerator.updateQuery(tableName, values, identifier, options, attributes);\n\n    const table = _.isObject(tableName) ? tableName : { tableName };\n\n    const model = _.find(this.sequelize.modelManager.models, { tableName: table.tableName });\n\n\n\n    options.model = model;\n\n    return this.sequelize.query(sql, options);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            1048,
            1081
          ],
          "match_position": [
            5,
            47
          ],
          "match_string": "    const sql = this.QueryGenerator.deleteQuery(tableName, identifier, {}, instance.constructor);\n\n\n\n    options = _.clone(options) || {};\n\n\n\n    // Check for a restrict field\n\n    if (!!instance.constructor && !!instance.constructor.associations) {\n\n      const keys = Object.keys(instance.constructor.associations);\n\n      const length = keys.length;\n\n      let association;\n\n\n\n      for (let i = 0; i < length; i++) {\n\n        association = instance.constructor.associations[keys[i]];\n\n        if (association.options && association.options.onDelete &&\n\n          association.options.onDelete.toLowerCase() === 'cascade' &&\n\n          association.options.useHooks === true) {\n\n          cascades.push(association.accessors.get);\n\n        }\n\n      }\n\n    }\n\n\n\n    return Promise.each(cascades, cascade => {\n\n      return instance[cascade](options).then(instances => {\n\n        // Check for hasOne relationship with non-existing associate (\"has zero\")\n\n        if (!instances) {\n\n          return Promise.resolve();\n\n        }\n\n\n\n        if (!Array.isArray(instances)) instances = [instances];\n\n\n\n        return Promise.each(instances, instance => instance.destroy(options));\n\n      });\n\n    }).then(() => {\n\n      options.instance = instance;\n\n      return this.sequelize.query(sql, options);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            1097,
            1111
          ],
          "match_position": [
            5,
            14
          ],
          "match_string": "    options = Utils.cloneDeep(options);\n\n    options = _.defaults(options, { limit: null });\n\n\n\n    if (options.truncate === true) {\n\n      return this.sequelize.query(\n\n        this.QueryGenerator.truncateTableQuery(tableName, options),\n\n        options\n\n      );\n\n    }\n\n\n\n    if (typeof identifier === 'object') where = Utils.cloneDeep(where);\n\n\n\n    return this.sequelize.query(\n\n      this.QueryGenerator.deleteQuery(tableName, where, options, model),\n\n      options"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            1098,
            1111
          ],
          "match_position": [
            5,
            14
          ],
          "match_string": "    options = _.defaults(options, { limit: null });\n\n\n\n    if (options.truncate === true) {\n\n      return this.sequelize.query(\n\n        this.QueryGenerator.truncateTableQuery(tableName, options),\n\n        options\n\n      );\n\n    }\n\n\n\n    if (typeof identifier === 'object') where = Utils.cloneDeep(where);\n\n\n\n    return this.sequelize.query(\n\n      this.QueryGenerator.deleteQuery(tableName, where, options, model),\n\n      options"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            1101,
            1103
          ],
          "match_position": [
            14,
            16
          ],
          "match_string": "      return this.sequelize.query(\n\n        this.QueryGenerator.truncateTableQuery(tableName, options),\n\n        options"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            1109,
            1111
          ],
          "match_position": [
            12,
            14
          ],
          "match_string": "    return this.sequelize.query(\n\n      this.QueryGenerator.deleteQuery(tableName, where, options, model),\n\n      options"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            1116,
            1120
          ],
          "match_position": [
            5,
            14
          ],
          "match_string": "    const options = Object.assign({}, optionsArg, { type: QueryTypes.SELECT, model });\n\n\n\n    return this.sequelize.query(\n\n      this.QueryGenerator.selectQuery(tableName, options, model),\n\n      options"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            1118,
            1120
          ],
          "match_position": [
            12,
            14
          ],
          "match_string": "    return this.sequelize.query(\n\n      this.QueryGenerator.selectQuery(tableName, options, model),\n\n      options"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            1125,
            1132
          ],
          "match_position": [
            5,
            45
          ],
          "match_string": "    options = Utils.cloneDeep(options);\n\n\n\n    const sql = this.QueryGenerator.arithmeticQuery('+', tableName, values, identifier, options, options.attributes);\n\n\n\n    options.type = QueryTypes.UPDATE;\n\n    options.model = model;\n\n\n\n    return this.sequelize.query(sql, options);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            1127,
            1132
          ],
          "match_position": [
            5,
            45
          ],
          "match_string": "    const sql = this.QueryGenerator.arithmeticQuery('+', tableName, values, identifier, options, options.attributes);\n\n\n\n    options.type = QueryTypes.UPDATE;\n\n    options.model = model;\n\n\n\n    return this.sequelize.query(sql, options);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            1136,
            1143
          ],
          "match_position": [
            5,
            45
          ],
          "match_string": "    options = Utils.cloneDeep(options);\n\n\n\n    const sql = this.QueryGenerator.arithmeticQuery('-', tableName, values, identifier, options, options.attributes);\n\n\n\n    options.type = QueryTypes.UPDATE;\n\n    options.model = model;\n\n\n\n    return this.sequelize.query(sql, options);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            1138,
            1143
          ],
          "match_position": [
            5,
            45
          ],
          "match_string": "    const sql = this.QueryGenerator.arithmeticQuery('-', tableName, values, identifier, options, options.attributes);\n\n\n\n    options.type = QueryTypes.UPDATE;\n\n    options.model = model;\n\n\n\n    return this.sequelize.query(sql, options);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            1147,
            1186
          ],
          "match_position": [
            5,
            20
          ],
          "match_string": "    options = Utils.cloneDeep(options);\n\n    options = _.defaults(options, {\n\n      raw: true,\n\n      plain: true,\n\n      type: QueryTypes.SELECT\n\n    });\n\n\n\n    const sql = this.QueryGenerator.selectQuery(tableName, options, Model);\n\n\n\n    if (attributeSelector === undefined) {\n\n      throw new Error('Please pass an attribute selector!');\n\n    }\n\n\n\n    return this.sequelize.query(sql, options).then(data => {\n\n      if (!options.plain) {\n\n        return data;\n\n      }\n\n\n\n      const result = data ? data[attributeSelector] : null;\n\n\n\n      if (!options || !options.dataType) {\n\n        return result;\n\n      }\n\n\n\n      const dataType = options.dataType;\n\n\n\n      if (dataType instanceof DataTypes.DECIMAL || dataType instanceof DataTypes.FLOAT) {\n\n        if (result !== null) {\n\n          return parseFloat(result);\n\n        }\n\n      }\n\n      if (dataType instanceof DataTypes.INTEGER || dataType instanceof DataTypes.BIGINT) {\n\n        return parseInt(result, 10);\n\n      }\n\n      if (dataType instanceof DataTypes.DATE) {\n\n        if (result !== null && !(result instanceof Date)) {\n\n          return new Date(result);\n\n        }\n\n      }\n\n      return result;"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            1148,
            1186
          ],
          "match_position": [
            5,
            20
          ],
          "match_string": "    options = _.defaults(options, {\n\n      raw: true,\n\n      plain: true,\n\n      type: QueryTypes.SELECT\n\n    });\n\n\n\n    const sql = this.QueryGenerator.selectQuery(tableName, options, Model);\n\n\n\n    if (attributeSelector === undefined) {\n\n      throw new Error('Please pass an attribute selector!');\n\n    }\n\n\n\n    return this.sequelize.query(sql, options).then(data => {\n\n      if (!options.plain) {\n\n        return data;\n\n      }\n\n\n\n      const result = data ? data[attributeSelector] : null;\n\n\n\n      if (!options || !options.dataType) {\n\n        return result;\n\n      }\n\n\n\n      const dataType = options.dataType;\n\n\n\n      if (dataType instanceof DataTypes.DECIMAL || dataType instanceof DataTypes.FLOAT) {\n\n        if (result !== null) {\n\n          return parseFloat(result);\n\n        }\n\n      }\n\n      if (dataType instanceof DataTypes.INTEGER || dataType instanceof DataTypes.BIGINT) {\n\n        return parseInt(result, 10);\n\n      }\n\n      if (dataType instanceof DataTypes.DATE) {\n\n        if (result !== null && !(result instanceof Date)) {\n\n          return new Date(result);\n\n        }\n\n      }\n\n      return result;"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            1154,
            1186
          ],
          "match_position": [
            5,
            20
          ],
          "match_string": "    const sql = this.QueryGenerator.selectQuery(tableName, options, Model);\n\n\n\n    if (attributeSelector === undefined) {\n\n      throw new Error('Please pass an attribute selector!');\n\n    }\n\n\n\n    return this.sequelize.query(sql, options).then(data => {\n\n      if (!options.plain) {\n\n        return data;\n\n      }\n\n\n\n      const result = data ? data[attributeSelector] : null;\n\n\n\n      if (!options || !options.dataType) {\n\n        return result;\n\n      }\n\n\n\n      const dataType = options.dataType;\n\n\n\n      if (dataType instanceof DataTypes.DECIMAL || dataType instanceof DataTypes.FLOAT) {\n\n        if (result !== null) {\n\n          return parseFloat(result);\n\n        }\n\n      }\n\n      if (dataType instanceof DataTypes.INTEGER || dataType instanceof DataTypes.BIGINT) {\n\n        return parseInt(result, 10);\n\n      }\n\n      if (dataType instanceof DataTypes.DATE) {\n\n        if (result !== null && !(result instanceof Date)) {\n\n          return new Date(result);\n\n        }\n\n      }\n\n      return result;"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            1191,
            1194
          ],
          "match_position": [
            5,
            47
          ],
          "match_string": "    const sql = this.QueryGenerator.createTrigger(tableName, triggerName, timingType, fireOnArray, functionName, functionParams, optionsArray);\n\n    options = options || {};\n\n    if (sql) {\n\n      return this.sequelize.query(sql, options);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            1200,
            1204
          ],
          "match_position": [
            5,
            47
          ],
          "match_string": "    const sql = this.QueryGenerator.dropTrigger(tableName, triggerName);\n\n    options = options || {};\n\n\n\n    if (sql) {\n\n      return this.sequelize.query(sql, options);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            1210,
            1214
          ],
          "match_position": [
            5,
            47
          ],
          "match_string": "    const sql = this.QueryGenerator.renameTrigger(tableName, oldTriggerName, newTriggerName);\n\n    options = options || {};\n\n\n\n    if (sql) {\n\n      return this.sequelize.query(sql, options);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            1257,
            1261
          ],
          "match_position": [
            5,
            47
          ],
          "match_string": "    const sql = this.QueryGenerator.createFunction(functionName, params, returnType, language, body, optionsArray, options);\n\n    options = options || {};\n\n\n\n    if (sql) {\n\n      return this.sequelize.query(sql, options);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            1285,
            1289
          ],
          "match_position": [
            5,
            47
          ],
          "match_string": "    const sql = this.QueryGenerator.dropFunction(functionName, params);\n\n    options = options || {};\n\n\n\n    if (sql) {\n\n      return this.sequelize.query(sql, options);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            1315,
            1319
          ],
          "match_position": [
            5,
            47
          ],
          "match_string": "    const sql = this.QueryGenerator.renameFunction(oldFunctionName, params, newFunctionName);\n\n    options = options || {};\n\n\n\n    if (sql) {\n\n      return this.sequelize.query(sql, options);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            1379,
            1385
          ],
          "match_position": [
            5,
            45
          ],
          "match_string": "    const sql = this.QueryGenerator.setIsolationLevelQuery(value, {\n\n      parent: transaction.parent\n\n    });\n\n\n\n    if (!sql) return Promise.resolve();\n\n\n\n    return this.sequelize.query(sql, options);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            1397,
            1399
          ],
          "match_position": [
            5,
            45
          ],
          "match_string": "    const sql = this.QueryGenerator.startTransactionQuery(transaction);\n\n\n\n    return this.sequelize.query(sql, options);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            1403,
            1410
          ],
          "match_position": [
            5,
            47
          ],
          "match_string": "    options = Object.assign({}, options, {\n\n      transaction: transaction.parent || transaction\n\n    });\n\n\n\n    const sql = this.QueryGenerator.deferConstraintsQuery(options);\n\n\n\n    if (sql) {\n\n      return this.sequelize.query(sql, options);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            1407,
            1410
          ],
          "match_position": [
            5,
            47
          ],
          "match_string": "    const sql = this.QueryGenerator.deferConstraintsQuery(options);\n\n\n\n    if (sql) {\n\n      return this.sequelize.query(sql, options);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            1431,
            1432
          ],
          "match_position": [
            5,
            54
          ],
          "match_string": "    const sql = this.QueryGenerator.commitTransactionQuery(transaction);\n\n    const promise = this.sequelize.query(sql, options);"
        },
        {
          "file_path": "/src/lib/query-interface.js",
          "match_lines": [
            1450,
            1451
          ],
          "match_position": [
            5,
            54
          ],
          "match_string": "    const sql = this.QueryGenerator.rollbackTransactionQuery(transaction);\n\n    const promise = this.sequelize.query(sql, options);"
        }
      ],
      "metadata": {
        "cwe": "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')",
        "description": "Untrusted input concatinated with raw SQL query can result in SQL Injection.",
        "owasp": "A1: Injection",
        "severity": "ERROR"
      }
    },
    "regex_dos": {
      "files": [
        {
          "file_path": "/src/lib/dialects/mysql/query-generator.js",
          "match_lines": [
            254,
            254
          ],
          "match_position": [
            11,
            38
          ],
          "match_string": "      if (/timestamp/i.test(smth.type)) {"
        },
        {
          "file_path": "/src/lib/dialects/mysql/query-generator.js",
          "match_lines": [
            256,
            256
          ],
          "match_position": [
            31,
            56
          ],
          "match_string": "      } else if (smth.json && /boolean/i.test(smth.type)) {"
        },
        {
          "file_path": "/src/lib/dialects/mysql/query-generator.js",
          "match_lines": [
            259,
            259
          ],
          "match_position": [
            18,
            52
          ],
          "match_string": "      } else if (/double precision/i.test(smth.type) || /boolean/i.test(smth.type) || /integer/i.test(smth.type)) {"
        },
        {
          "file_path": "/src/lib/dialects/mysql/query-generator.js",
          "match_lines": [
            259,
            259
          ],
          "match_position": [
            57,
            82
          ],
          "match_string": "      } else if (/double precision/i.test(smth.type) || /boolean/i.test(smth.type) || /integer/i.test(smth.type)) {"
        },
        {
          "file_path": "/src/lib/dialects/mysql/query-generator.js",
          "match_lines": [
            259,
            259
          ],
          "match_position": [
            87,
            112
          ],
          "match_string": "      } else if (/double precision/i.test(smth.type) || /boolean/i.test(smth.type) || /integer/i.test(smth.type)) {"
        },
        {
          "file_path": "/src/lib/dialects/mysql/query-generator.js",
          "match_lines": [
            261,
            261
          ],
          "match_position": [
            18,
            40
          ],
          "match_string": "      } else if (/text/i.test(smth.type)) {"
        },
        {
          "file_path": "/src/lib/dialects/sqlite/query-generator.js",
          "match_lines": [
            180,
            180
          ],
          "match_position": [
            11,
            38
          ],
          "match_string": "      if (/timestamp/i.test(smth.type)) {"
        },
        {
          "file_path": "/src/lib/dialects/sqlite/query.js",
          "match_lines": [
            222,
            295
          ],
          "match_position": [
            5,
            26
          ],
          "match_string": "    this.sql = sql;\n\n    const method = this.getDatabaseMethod();\n\n    if (method === 'exec') {\n\n      // exec does not support bind parameter\n\n      sql = AbstractQuery.formatBindParameters(sql, this.options.bind, this.options.dialect || 'sqlite', { skipUnescape: true })[0];\n\n      this.sql = sql;\n\n    }\n\n\n\n    const complete = this._logQuery(sql, debug);\n\n\n\n    return new Promise(resolve => {\n\n      const columnTypes = {};\n\n      conn.serialize(() => {\n\n        const executeSql = () => {\n\n          if (sql.startsWith('-- ')) {\n\n            return resolve();\n\n          }\n\n          resolve(new Promise((resolve, reject) => {\n\n            const query = this;\n\n            // cannot use arrow function here because the function is bound to the statement\n\n            function afterExecute(executionError, results) {\n\n              try {\n\n                complete();\n\n                // `this` is passed from sqlite, we have no control over this.\n\n                // eslint-disable-next-line no-invalid-this\n\n                resolve(query._handleQueryResponse(this, columnTypes, executionError, results));\n\n                return;\n\n              } catch (error) {\n\n                reject(error);\n\n              }\n\n            }\n\n\n\n            if (method === 'exec') {\n\n              // exec does not support bind parameter\n\n              conn[method](sql, afterExecute);\n\n            } else {\n\n              if (!parameters) parameters = [];\n\n              conn[method](sql, parameters, afterExecute);\n\n            }\n\n          }));\n\n          return null;\n\n        };\n\n\n\n        if (this.getDatabaseMethod() === 'all') {\n\n          let tableNames = [];\n\n          if (this.options && this.options.tableNames) {\n\n            tableNames = this.options.tableNames;\n\n          } else if (/FROM `(.*?)`/i.exec(this.sql)) {\n\n            tableNames.push(/FROM `(.*?)`/i.exec(this.sql)[1]);\n\n          }\n\n\n\n          // If we already have the metadata for the table, there's no need to ask for it again\n\n          tableNames = tableNames.filter(tableName => !(tableName in columnTypes) && tableName !== 'sqlite_master');\n\n\n\n          if (!tableNames.length) {\n\n            return executeSql();\n\n          }\n\n          return Promise.map(tableNames, tableName =>\n\n            new Promise(resolve => {\n\n              tableName = tableName.replace(/`/g, '');\n\n              columnTypes[tableName] = {};\n\n\n\n              conn.all(`PRAGMA table_info(\\`${tableName}\\`)`, (err, results) => {\n\n                if (!err) {\n\n                  for (const result of results) {\n\n                    columnTypes[tableName][result.name] = result.type;\n\n                  }\n\n                }\n\n                resolve();\n\n              });\n\n            })\n\n          ).then(executeSql);\n\n        }\n\n        return executeSql();"
        }
      ],
      "metadata": {
        "cwe": "CWE-185: Incorrect Regular Expression",
        "description": "Ensure that the regex used to compare with user supplied input is safe from regular expression denial of service.",
        "owasp": "A6: Security Misconfiguration",
        "severity": "WARNING"
      }
    }
  },
  "templates": {}
}

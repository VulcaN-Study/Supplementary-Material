/src/dist/realms-shim.umd.min.js.map:1:{"version":3,"file":"realms-shim.umd.min.js","sources":["../src/utilities.js","../src/realmFacade.js","../src/callAndWrapError.js","../src/stdlib.js","../src/repair/accessors.js","../src/repair/functions.js","../src/unsafeRec.js","../src/optimizer.js","../src/scopeHandlerFacade.js","../src/safeEvalFacade.js","../src/safeFunctionFacade.js","../src/sourceParser.js","../src/evaluators.js","../src/realm.js","../src/commons.js"],"sourcesContent":["// we'd like to abandon, but we can't, so just scream and break a lot of\n// stuff. However, since we aren't really aborting the process, be careful to\n// not throw an Error object which could be captured by child-Realm code and\n// used to access the (too-powerful) primal-realm Error object.\n\nexport function throwTantrum(s, err = undefined) {\n  const msg = `please report internal shim error: ${s}`;\n\n  // we want to log these 'should never happen' things.\n  // eslint-disable-next-line no-console\n  console.error(msg);\n  if (err) {\n    // eslint-disable-next-line no-console\n    console.error(`${err}`);\n    // eslint-disable-next-line no-console\n    console.error(`${err.stack}`);\n  }\n\n  // eslint-disable-next-line no-debugger\n  debugger;\n  throw msg;\n}\n\nexport function assert(condition, message) {\n  if (!condition) {\n    throwTantrum(message);\n  }\n}\n\n/**\n * cleanupSource()\n * Remove code modifications introduced by ems and nyx in\n * test mode which intefere with Function.toString().\n *\n * Becuase this change is not required at runtime, the\n * body of this function is hollowed-out during the build\n * process by rollup-plugin-strip-code. As configured in\n * in rollup.config.jj, all code between the custom tags\n * START_TESTS_ONLY and END_TESTS_ONLY, and including those\n * tags, is stripped, turning this function into a noop.\n */\nexport function cleanupSource(src) {\n  // Restore eval which is modified by esm module.\n  // (0, eval) => (0, _<something>.e)\n  src = src.replace(/\\(0,\\s*_[^.]+\\.e\\)/g, '(0, eval)');\n\n  // Restore Reflect which is modified by esm module.\n  // Reflect => _<something>.e.Reflect\n  src = src.replace(/_[^.]+\\.g\\.Reflect/g, 'Reflect');\n\n  // Remove code coverage which is injected by nyc module.\n  src = src.replace(/cov_[^+]+\\+\\+[;,]/g, '');\n\n  return src;\n}\n","import { cleanupSource } from './utilities';\n\n// buildChildRealm is immediately turned into a string, and this function is\n// never referenced again, because it closes over the wrong intrinsics\n\nexport function buildChildRealm(unsafeRec, BaseRealm) {\n  const { callAndWrapError } = unsafeRec;\n  const {\n    initRootRealm,\n    initCompartment,\n    getRealmGlobal,\n    realmEvaluate\n  } = BaseRealm;\n\n  const { create, defineProperties } = Object;\n\n  class Realm {\n    constructor() {\n      // The Realm constructor is not intended to be used with the new operator\n      // or to be subclassed. It may be used as the value of an extends clause\n      // of a class definition but a super call to the Realm constructor will\n      // cause an exception.\n\n      // When Realm is called as a function, an exception is also raised because\n      // a class constructor cannot be invoked without 'new'.\n      throw new TypeError('Realm is not a constructor');\n    }\n\n    static makeRootRealm(options = {}) {\n      // This is the exposed interface.\n\n      // Bypass the constructor.\n      const r = create(Realm.prototype);\n      callAndWrapError(initRootRealm, [unsafeRec, r, options]);\n      return r;\n    }\n\n    static makeCompartment(options = {}) {\n      // Bypass the constructor.\n      const r = create(Realm.prototype);\n      callAndWrapError(initCompartment, [unsafeRec, r, options]);\n      return r;\n    }\n\n    // we omit the constructor because it is empty. All the personalization\n    // takes place in one of the two static methods,\n    // makeRootRealm/makeCompartment\n\n    get global() {\n      // this is safe against being called with strange 'this' because\n      // baseGetGlobal immediately does a trademark check (it fails unless\n      // this 'this' is present in a weakmap that is only populated with\n      // legitimate Realm instances)\n      return callAndWrapError(getRealmGlobal, [this]);\n    }\n\n    evaluate(x, endowments, options = {}) {\n      // safe against strange 'this', as above\n      return callAndWrapError(realmEvaluate, [this, x, endowments, options]);\n    }\n  }\n\n  defineProperties(Realm, {\n    toString: {\n      value: () => 'function Realm() { [shim code] }',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  defineProperties(Realm.prototype, {\n    toString: {\n      value: () => '[object Realm]',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  return Realm;\n}\n\n// The parentheses means we don't bind the 'buildChildRealm' name inside the\n// child's namespace. this would accept an anonymous function declaration.\n// function expression (not a declaration) so it has a completion value.\nconst buildChildRealmString = cleanupSource(\n  `'use strict'; (${buildChildRealm})`\n);\n\nexport function createRealmFacade(unsafeRec, BaseRealm) {\n  const { unsafeEval } = unsafeRec;\n  // The BaseRealm is the Realm class created by\n  // the shim. It's only valid for the context where\n  // it was parsed.\n\n  // The Realm facade is a lightweight class built in the\n  // context a different context, that provide a fully\n  // functional Realm class using the intrisics\n  // of that context.\n\n  // This process is simplified because all methods\n  // and properties on a realm instance already return\n  // values using the intrinsics of the realm's context.\n\n  // Invoke the BaseRealm constructor with Realm as the prototype.\n  return unsafeEval(buildChildRealmString)(unsafeRec, BaseRealm);\n}\n","import { cleanupSource } from './utilities';\n\nfunction buildCallAndWrapError() {\n  // This Object and Reflect are brand new, from a new unsafeRec, so no user\n  // code has been run or had a chance to manipulate them. Don't ever run this\n  // function *after* user code has had a chance to pollute its environment,\n  // or it could be used to gain access to BaseRealm and primal-realm Error\n  // objects.\n  const { getPrototypeOf } = Object;\n  const { apply } = Reflect;\n  const uncurryThis = fn => (thisArg, ...args) => apply(fn, thisArg, args);\n  const mapGet = uncurryThis(Map.prototype.get);\n  const setHas = uncurryThis(Set.prototype.has);\n\n  const errorNameToErrorConstructor = new Map([\n    ['EvalError', EvalError],\n    ['RangeError', RangeError],\n    ['ReferenceError', ReferenceError],\n    ['SyntaxError', SyntaxError],\n    ['TypeError', TypeError],\n    ['URIError', URIError]\n  ]);\n  const errorConstructors = new Set([\n    EvalError.prototype,\n    RangeError.prototype,\n    ReferenceError.prototype,\n    SyntaxError.prototype,\n    TypeError.prototype,\n    URIError.prototype,\n    Error.prototype\n  ]);\n\n  function callAndWrapError(target, args) {\n    try {\n      return apply(target, undefined, args);\n    } catch (err) {\n      // 1. Thrown primitives\n      if (Object(err) !== err) {\n        // err is a primitive value, which is safe to rethrow\n        throw err;\n      }\n\n      // 2. Current realm errors\n      if (setHas(errorConstructors, getPrototypeOf(err))) {\n        // err is a from the current realm, which is safe to rethrow.\n        // Object instances (normally) only contain intrinsics from the\n        // same realm. An error containing intrinsics from different\n        // realms would have to be manually constucted, which imply that\n        // such intrinsics were available, and confinement was already lost.\n        throw err;\n      }\n\n      // 3. Other realm errors\n      let eName, eMessage, eStack;\n      try {\n        // The other environment might seek to use 'err' to reach the\n        // parent's intrinsics and corrupt them. In addition, exceptions\n        // raised in the primal realm need to be converted to the current\n        // realm.\n\n        // `${err.name}` will cause string coercion of 'err.name'.\n        // If err.name is an object (probably a String of another Realm),\n        // the coercion uses err.name.toString(), which is under the control\n        // of the other realm. If err.name were a primitive (e.g. a number),\n        // it would use Number.toString(err.name), using the child's version\n        // of Number (which the child could modify to capture its argument for\n        // later use), however primitives don't have properties like .prototype\n        // so they aren't useful for an attack.\n        eName = `${err.name}`;\n        eMessage = `${err.message}`;\n        eStack = `${err.stack || eMessage}`;\n        // eName/eMessage/eStack are now realm-independent primitive strings, and\n        // safe to expose.\n      } catch (ignored) {\n        // if err.name.toString() throws, keep the (parent realm) Error away.\n        throw new Error('unknown error');\n      }\n      const ErrorConstructor =\n        mapGet(errorNameToErrorConstructor, eName) || Error;\n      try {\n        throw new ErrorConstructor(eMessage);\n      } catch (err2) {\n        err2.stack = eStack; // replace with the captured inner stack\n        throw err2;\n      }\n    }\n  }\n\n  return callAndWrapError;\n}\n\nconst buildCallAndWrapErrorString = cleanupSource(\n  `'use strict'; (${buildCallAndWrapError})`\n);\nexport function createCallAndWrapError(unsafeEval) {\n  return unsafeEval(buildCallAndWrapErrorString)();\n}\n","import { getOwnPropertyDescriptor } from './commons';\nimport { assert } from './utilities';\n\n// These value properties of the global object are non-writable,\n// non-configurable data properties.\nconst frozenGlobalPropertyNames = [\n  // *** 18.1 Value Properties of the Global Object\n\n  'Infinity',\n  'NaN',\n  'undefined'\n];\n\n// All the following stdlib items have the same name on both our intrinsics\n// object and on the global object. Unlike Infinity/NaN/undefined, these\n// should all be writable and configurable. This is divided into two\n// sets. The stable ones are those the shim can freeze early because\n// we don't expect anyone will want to mutate them. The unstable ones\n// are the ones that we correctly initialize to writable and\n// configurable so that they can still be replaced or removed.\nconst stableGlobalPropertyNames = [\n  // *** 18.2 Function Properties of the Global Object\n\n  // 'eval', // comes from safeEval instead\n  'isFinite',\n  'isNaN',\n  'parseFloat',\n  'parseInt',\n\n  'decodeURI',\n  'decodeURIComponent',\n  'encodeURI',\n  'encodeURIComponent',\n\n  // *** 18.3 Constructor Properties of the Global Object\n\n  'Array',\n  'ArrayBuffer',\n  'Boolean',\n  'DataView',\n  // 'Date',  // Unstable\n  // 'Error',  // Unstable\n  'EvalError',\n  'Float32Array',\n  'Float64Array',\n  // 'Function',  // comes from safeFunction instead\n  'Int8Array',\n  'Int16Array',\n  'Int32Array',\n  'Map',\n  'Number',\n  'Object',\n  // 'Promise',  // Unstable\n  // 'Proxy',  // Unstable\n  'RangeError',\n  'ReferenceError',\n  // 'RegExp',  // Unstable\n  'Set',\n  // 'SharedArrayBuffer'  // removed on Jan 5, 2018\n  'String',\n  'Symbol',\n  'SyntaxError',\n  'TypeError',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Uint16Array',\n  'Uint32Array',\n  'URIError',\n  'WeakMap',\n  'WeakSet',\n\n  // *** 18.4 Other Properties of the Global Object\n\n  // 'Atomics', // removed on Jan 5, 2018\n  'JSON',\n  'Math',\n  'Reflect',\n\n  // *** Annex B\n\n  'escape',\n  'unescape'\n\n  // *** ECMA-402\n\n  // 'Intl'  // Unstable\n\n  // *** ESNext\n\n  // 'Realm' // Comes from createRealmGlobalObject()\n];\n\nconst unstableGlobalPropertyNames = [\n  'Date',\n  'Error',\n  'Promise',\n  'Proxy',\n  'RegExp',\n  'Intl'\n];\n\nexport function getSharedGlobalDescs(unsafeGlobal) {\n  const descriptors = {};\n\n  function describe(names, writable, enumerable, configurable) {\n    for (const name of names) {\n      const desc = getOwnPropertyDescriptor(unsafeGlobal, name);\n      if (desc) {\n        // Abort if an accessor is found on the unsafe global object\n        // instead of a data property. We should never get into this\n        // non standard situation.\n        assert(\n          'value' in desc,\n          `unexpected accessor on global property: ${name}`\n        );\n\n        descriptors[name] = {\n          value: desc.value,\n          writable,\n          enumerable,\n          configurable\n        };\n      }\n    }\n  }\n\n  describe(frozenGlobalPropertyNames, false, false, false);\n  // The following is correct but expensive.\n  // describe(stableGlobalPropertyNames, true, false, true);\n  // Instead, for now, we let these get optimized.\n  //\n  // TODO: We should provide an option to turn this optimization off,\n  // by feeding \"true, false, true\" here instead.\n  describe(stableGlobalPropertyNames, false, false, false);\n  // These we keep replaceable and removable, because we expect\n  // others, e.g., SES, may want to do so.\n  describe(unstableGlobalPropertyNames, true, false, true);\n\n  return descriptors;\n}\n","// Adapted from SES/Caja - Copyright (C) 2011 Google Inc.\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js\n\n/**\n * Replace the legacy accessors of Object to comply with strict mode\n * and ES2016 semantics, we do this by redefining them while in 'use strict'.\n *\n * todo: list the issues resolved\n *\n * This function can be used in two ways: (1) invoked directly to fix the primal\n * realm's Object.prototype, and (2) converted to a string to be executed\n * inside each new RootRealm to fix their Object.prototypes. Evaluation requires\n * the function to have no dependencies, so don't import anything from\n * the outside.\n */\n\n// todo: this file should be moved out to a separate repo and npm module.\nexport function repairAccessors() {\n  const {\n    defineProperty,\n    defineProperties,\n    getOwnPropertyDescriptor,\n    getPrototypeOf,\n    prototype: objectPrototype\n  } = Object;\n\n  // On some platforms, the implementation of these functions act as\n  // if they are in sloppy mode: if they're invoked badly, they will\n  // expose the global object, so we need to repair these for\n  // security. Thus it is our responsibility to fix this, and we need\n  // to include repairAccessors. E.g. Chrome in 2016.\n\n  try {\n    // Verify that the method is not callable.\n    // eslint-disable-next-line no-restricted-properties, no-underscore-dangle\n    (0, objectPrototype.__lookupGetter__)('x');\n  } catch (ignore) {\n    // Throws, no need to patch.\n    return;\n  }\n\n  function toObject(obj) {\n    if (obj === undefined || obj === null) {\n      throw new TypeError(`can't convert undefined or null to object`);\n    }\n    return Object(obj);\n  }\n\n  function asPropertyName(obj) {\n    if (typeof obj === 'symbol') {\n      return obj;\n    }\n    return `${obj}`;\n  }\n\n  function aFunction(obj, accessor) {\n    if (typeof obj !== 'function') {\n      throw TypeError(`invalid ${accessor} usage`);\n    }\n    return obj;\n  }\n\n  defineProperties(objectPrototype, {\n    __defineGetter__: {\n      value: function __defineGetter__(prop, func) {\n        const O = toObject(this);\n        defineProperty(O, prop, {\n          get: aFunction(func, 'getter'),\n          enumerable: true,\n          configurable: true\n        });\n      }\n    },\n    __defineSetter__: {\n      value: function __defineSetter__(prop, func) {\n        const O = toObject(this);\n        defineProperty(O, prop, {\n          set: aFunction(func, 'setter'),\n          enumerable: true,\n          configurable: true\n        });\n      }\n    },\n    __lookupGetter__: {\n      value: function __lookupGetter__(prop) {\n        let O = toObject(this);\n        prop = asPropertyName(prop);\n        let desc;\n        while (O && !(desc = getOwnPropertyDescriptor(O, prop))) {\n          O = getPrototypeOf(O);\n        }\n        return desc && desc.get;\n      }\n    },\n    __lookupSetter__: {\n      value: function __lookupSetter__(prop) {\n        let O = toObject(this);\n        prop = asPropertyName(prop);\n        let desc;\n        while (O && !(desc = getOwnPropertyDescriptor(O, prop))) {\n          O = getPrototypeOf(O);\n        }\n        return desc && desc.set;\n      }\n    }\n  });\n}\n","// Adapted from SES/Caja\n// Copyright (C) 2011 Google Inc.\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js\n\n/**\n * This block replaces the original Function constructor, and the original\n * %GeneratorFunction% %AsyncFunction% and %AsyncGeneratorFunction%, with\n * safe replacements that throw if invoked.\n *\n * These are all reachable via syntax, so it isn't sufficient to just\n * replace global properties with safe versions. Our main goal is to prevent\n * access to the Function constructor through these starting points.\n\n * After this block is done, the originals must no longer be reachable, unless\n * a copy has been made, and funtions can only be created by syntax (using eval)\n * or by invoking a previously saved reference to the originals.\n */\n\n// todo: this file should be moved out to a separate repo and npm module.\nexport function repairFunctions() {\n  const { defineProperties, getPrototypeOf, setPrototypeOf } = Object;\n\n  /**\n   * The process to repair constructors:\n   * 1. Create an instance of the function by evaluating syntax\n   * 2. Obtain the prototype from the instance\n   * 3. Create a substitute tamed constructor\n   * 4. Replace the original constructor with the tamed constructor\n   * 5. Replace tamed constructor prototype property with the original one\n   * 6. Replace its [[Prototype]] slot with the tamed constructor of Function\n   */\n  function repairFunction(name, declaration) {\n    let FunctionInstance;\n    try {\n      // eslint-disable-next-line no-new-func\n      FunctionInstance = (0, eval)(declaration);\n    } catch (e) {\n      if (e instanceof SyntaxError) {\n        // Prevent failure on platforms where async and/or generators\n        // are not supported.\n        return;\n      }\n      // Re-throw\n      throw e;\n    }\n    const FunctionPrototype = getPrototypeOf(FunctionInstance);\n\n    // Prevents the evaluation of source when calling constructor on the\n    // prototype of functions.\n    const TamedFunction = function() {\n      throw new TypeError('Not available');\n    };\n    defineProperties(TamedFunction, { name: { value: name } });\n\n    // (new Error()).constructors does not inherit from Function, because Error\n    // was defined before ES6 classes. So we don't need to repair it too.\n\n    // (Error()).constructor inherit from Function, which gets a tamed\n    // constructor here.\n\n    // todo: in an ES6 class that does not inherit from anything, what does its\n    // constructor inherit from? We worry that it inherits from Function, in\n    // which case instances could give access to unsafeFunction. markm says\n    // we're fine: the constructor inherits from Object.prototype\n\n    // This line replaces the original constructor in the prototype chain\n    // with the tamed one. No copy of the original is peserved.\n    defineProperties(FunctionPrototype, {\n      constructor: { value: TamedFunction }\n    });\n\n    // This line sets the tamed constructor's prototype data property to\n    // the original one.\n    defineProperties(TamedFunction, {\n      prototype: { value: FunctionPrototype }\n    });\n\n    if (TamedFunction !== Function.prototype.constructor) {\n      // Ensures that all functions meet \"instanceof Function\" in a realm.\n      setPrototypeOf(TamedFunction, Function.prototype.constructor);\n    }\n  }\n\n  // Here, the order of operation is important: Function needs to be repaired\n  // first since the other repaired constructors need to inherit from the tamed\n  // Function function constructor.\n\n  // note: this really wants to be part of the standard, because new\n  // constructors may be added in the future, reachable from syntax, and this\n  // list must be updated to match.\n\n  // \"plain arrow functions\" inherit from Function.prototype\n\n  repairFunction('Function', '(function(){})');\n  repairFunction('GeneratorFunction', '(function*(){})');\n  repairFunction('AsyncFunction', '(async function(){})');\n  repairFunction('AsyncGeneratorFunction', '(async function*(){})');\n}\n","// this module must never be importable outside the Realm shim itself\nimport { createCallAndWrapError } from './callAndWrapError';\nimport { getSharedGlobalDescs } from './stdlib';\nimport { repairAccessors } from './repair/accessors';\nimport { repairFunctions } from './repair/functions';\nimport { cleanupSource } from './utilities';\nimport { freeze } from './commons';\n\n// A \"context\" is a fresh unsafe Realm as given to us by existing platforms.\n// We need this to implement the shim. However, when Realms land for real,\n// this feature will be provided by the underlying engine instead.\n\n// note: in a node module, the top-level 'this' is not the global object\n// (it's *something* but we aren't sure what), however an indirect eval of\n// 'this' will be the correct global object.\n\nconst unsafeGlobalSrc = \"'use strict'; this\";\nconst unsafeGlobalEvalSrc = `(0, eval)(\"'use strict'; this\")`;\n\n// This method is only exported for testing purposes.\nexport function createNewUnsafeGlobalForNode() {\n  // Note that webpack and others will shim 'vm' including the method\n  // 'runInNewContext', so the presence of vm is not a useful check\n\n  // TODO: Find a better test that works with bundlers\n  // eslint-disable-next-line no-new-func\n  const isNode = new Function(\n    'try {return this===global}catch(e){return false}'\n  )();\n\n  if (!isNode) {\n    return undefined;\n  }\n\n  // eslint-disable-next-line global-require\n  const vm = require('vm');\n\n  // Use unsafeGlobalEvalSrc to ensure we get the right 'this'.\n  const unsafeGlobal = vm.runInNewContext(unsafeGlobalEvalSrc);\n\n  return unsafeGlobal;\n}\n\n// This method is only exported for testing purposes.\nexport function createNewUnsafeGlobalForBrowser() {\n  if (typeof document === 'undefined') {\n    return undefined;\n  }\n  const iframe = document.createElement('iframe');\n  iframe.style.display = 'none';\n\n  document.body.appendChild(iframe);\n  const unsafeGlobal = iframe.contentWindow.eval(unsafeGlobalSrc);\n\n  // We keep the iframe attached to the DOM because removing it\n  // causes its global object to lose intrinsics, its eval()\n  // function to evaluate code, etc.\n\n  // TODO: can we remove and garbage-collect the iframes?\n\n  return unsafeGlobal;\n}\n\nconst getNewUnsafeGlobal = () => {\n  const newUnsafeGlobalForBrowser = createNewUnsafeGlobalForBrowser();\n  const newUnsafeGlobalForNode = createNewUnsafeGlobalForNode();\n  if (\n    (!newUnsafeGlobalForBrowser && !newUnsafeGlobalForNode) ||\n    (newUnsafeGlobalForBrowser && newUnsafeGlobalForNode)\n  ) {\n    throw new Error('unexpected platform, unable to create Realm');\n  }\n  return newUnsafeGlobalForBrowser || newUnsafeGlobalForNode;\n};\n\n// The unsafeRec is shim-specific. It acts as the mechanism to obtain a fresh\n// set of intrinsics together with their associated eval and Function\n// evaluators. These must be used as a matched set, since the evaluators are\n// tied to a set of intrinsics, aka the \"undeniables\". If it were possible to\n// mix-and-match them from different contexts, that would enable some\n// attacks.\nfunction createUnsafeRec(unsafeGlobal, allShims = []) {\n  const sharedGlobalDescs = getSharedGlobalDescs(unsafeGlobal);\n\n  const unsafeEval = unsafeGlobal.eval;\n  const unsafeFunction = unsafeGlobal.Function;\n\n  const callAndWrapError = createCallAndWrapError(unsafeEval);\n\n  return freeze({\n    unsafeGlobal,\n    sharedGlobalDescs,\n    unsafeEval,\n    unsafeFunction,\n    callAndWrapError,\n    allShims\n  });\n}\n\nconst repairAccessorsShim = cleanupSource(\n  `\"use strict\"; (${repairAccessors})();`\n);\nconst repairFunctionsShim = cleanupSource(\n  `\"use strict\"; (${repairFunctions})();`\n);\n\n// Create a new unsafeRec from a brand new context, with new intrinsics and a\n// new global object\nexport function createNewUnsafeRec(allShims) {\n  const unsafeGlobal = getNewUnsafeGlobal();\n  unsafeGlobal.eval(repairAccessorsShim);\n  unsafeGlobal.eval(repairFunctionsShim);\n  return createUnsafeRec(unsafeGlobal, allShims);\n}\n\n// Create a new unsafeRec from the current context, where the Realm shim is\n// being parsed and executed, aka the \"Primal Realm\"\nexport function createCurrentUnsafeRec() {\n  const unsafeGlobal = (0, eval)(unsafeGlobalSrc);\n  repairAccessors();\n  repairFunctions();\n  return createUnsafeRec(unsafeGlobal);\n}\n","import {\n  arrayFilter,\n  getOwnPropertyDescriptors,\n  getOwnPropertyNames,\n  objectHasOwnProperty,\n  regexpTest\n} from './commons';\n\n// todo: think about how this interacts with endowments, check for conflicts\n// between the names being optimized and the ones added by endowments\n\n/**\n * Simplified validation of indentifier names: may only contain alphanumeric\n * characters (or \"$\" or \"_\"), and may not start with a digit. This is safe\n * and does not reduces the compatibility of the shim. The motivation for\n * this limitation was to decrease the complexity of the implementation,\n * and to maintain a resonable level of performance.\n * Note: \\w is equivalent [a-zA-Z_0-9]\n * See 11.6.1 Identifier Names\n */\nconst identifierPattern = /^[a-zA-Z_$][\\w$]*$/;\n\n/**\n * In JavaScript you cannot use these reserved words as variables.\n * See 11.6.1 Identifier Names\n */\nconst keywords = new Set([\n  // 11.6.2.1 Keywords\n  'await',\n  'break',\n  'case',\n  'catch',\n  'class',\n  'const',\n  'continue',\n  'debugger',\n  'default',\n  'delete',\n  'do',\n  'else',\n  'export',\n  'extends',\n  'finally',\n  'for',\n  'function',\n  'if',\n  'import',\n  'in',\n  'instanceof',\n  'new',\n  'return',\n  'super',\n  'switch',\n  'this',\n  'throw',\n  'try',\n  'typeof',\n  'var',\n  'void',\n  'while',\n  'with',\n  'yield',\n\n  // Also reserved when parsing strict mode code\n  'let',\n  'static',\n\n  // 11.6.2.2 Future Reserved Words\n  'enum',\n\n  // Also reserved when parsing strict mode code\n  'implements',\n  'package',\n  'protected',\n  'interface',\n  'private',\n  'public',\n\n  // Reserved but not mentioned in specs\n  'await',\n\n  'null',\n  'true',\n  'false',\n\n  'this',\n  'arguments'\n]);\n\n/**\n * getOptimizableGlobals()\n * What variable names might it bring into scope? These include all\n * property names which can be variable names, including the names\n * of inherited properties. It excludes symbols and names which are\n * keywords. We drop symbols safely. Currently, this shim refuses\n * service if any of the names are keywords or keyword-like. This is\n * safe and only prevent performance optimization.\n */\nexport function getOptimizableGlobals(safeGlobal) {\n  const descs = getOwnPropertyDescriptors(safeGlobal);\n\n  // getOwnPropertyNames does ignore Symbols so we don't need this extra check:\n  // typeof name === 'string' &&\n  const constants = arrayFilter(getOwnPropertyNames(descs), name => {\n    // Ensure we have a valid identifier. We use regexpTest rather than\n    // /../.test() to guard against the case where RegExp has been poisoned.\n    if (\n      name === 'eval' ||\n      keywords.has(name) ||\n      !regexpTest(identifierPattern, name)\n    ) {\n      return false;\n    }\n\n    const desc = descs[name];\n    return (\n      //\n      // The getters will not have .writable, don't let the falsyness of\n      // 'undefined' trick us: test with === false, not ! . However descriptors\n      // inherit from the (potentially poisoned) global object, so we might see\n      // extra properties which weren't really there. Accessor properties have\n      // 'get/set/enumerable/configurable', while data properties have\n      // 'value/writable/enumerable/configurable'.\n      desc.configurable === false &&\n      desc.writable === false &&\n      //\n      // Checks for data properties because they're the only ones we can\n      // optimize (accessors are most likely non-constant). Descriptors can't\n      // can't have accessors and value properties at the same time, therefore\n      // this check is sufficient. Using explicit own property deal with the\n      // case where Object.prototype has been poisoned.\n      objectHasOwnProperty(desc, 'value')\n    );\n  });\n\n  return constants;\n}\n","import { cleanupSource } from './utilities';\n\n/**\n * ScopeHandler manages a Proxy which serves as the global scope for the\n * safeEvaluator operation (the Proxy is the argument of a 'with' binding).\n * As described in createSafeEvaluator(), it has several functions:\n * - allow the very first (and only the very first) use of 'eval' to map to\n *   the real (unsafe) eval function, so it acts as a 'direct eval' and can\n *    access its lexical scope (which maps to the 'with' binding, which the\n *   ScopeHandler also controls).\n * - ensure that all subsequent uses of 'eval' map to the safeEvaluator,\n *   which lives as the 'eval' property of the safeGlobal.\n * - route all other property lookups at the safeGlobal.\n * - hide the unsafeGlobal which lives on the scope chain above the 'with'.\n * - ensure the Proxy invariants despite some global properties being frozen.\n *\n * @returns {ProxyHandler<any> & Record<string, any>}\n */\nexport function buildScopeHandler(\n  unsafeRec,\n  safeGlobal,\n  endowments = {},\n  sloppyGlobals = false\n) {\n  const { unsafeGlobal, unsafeEval } = unsafeRec;\n\n  const { freeze } = Object;\n  const { get: reflectGet } = Reflect;\n  const { unscopables } = Symbol;\n\n  /**\n   * alwaysThrowHandler is a proxy handler which throws on any trap called.\n   * It's made from a proxy with a get trap that throws. Its target is\n   * an immutable (frozen) object and is safe to share, except accross realms\n   */\n  const alwaysThrowHandler = new Proxy(freeze({}), {\n    get(target, prop) {\n      // todo: replace with throwTantrum\n      throw new TypeError(\n        `unexpected scope handler trap called: ${String(prop)}`\n      );\n    }\n  });\n\n  return {\n    // The scope handler throws if any trap other than get/set/has are run\n    // (e.g. getOwnPropertyDescriptors, apply, getPrototypeOf).\n    // eslint-disable-next-line no-proto\n    __proto__: alwaysThrowHandler,\n\n    // This flag allow us to determine if the eval() call is an done by the\n    // realm's code or if it is user-land invocation, so we can react differently.\n    // We use a property and not an accessor to avoid increasing the stack trace\n    // and reduce the possibility of OOM.\n    useUnsafeEvaluator: false,\n\n    get(shadow, prop) {\n      if (prop === unscopables) {\n        // Safe to return a primal realm Object here because the only code that\n        // can do a get() on a non-string is the internals of with() itself,\n        // and the only thing it does is to look for properties on it. User\n        // code cannot do a lookup on non-strings.\n        return undefined;\n      }\n\n      // Special treatment for eval. The very first lookup of 'eval' gets the\n      // unsafe (real direct) eval, so it will get the lexical scope that uses\n      // the 'with' context.\n      if (prop === 'eval') {\n        // test that it is true rather than merely truthy\n        if (this.useUnsafeEvaluator === true) {\n          // revoke before use\n          this.useUnsafeEvaluator = false;\n          return unsafeEval;\n        }\n        // fall through\n      }\n\n      // Properties of the global.\n      if (prop in endowments) {\n        return reflectGet(endowments, prop, safeGlobal);\n      }\n\n      // Properties of the global.\n      if (prop in safeGlobal) {\n        return safeGlobal[prop];\n      }\n\n      // Prevent the lookup for other properties.\n      return undefined;\n    },\n\n    // eslint-disable-next-line class-methods-use-this\n    set(shadow, prop, value) {\n      // todo: allow modifications when prop in endowments and it\n      // is writable, assuming we've already rejected overlap (see\n      // createSafeEvaluatorFactory.factory). This TypeError gets replaced with\n      // reflectSet(endowments, prop, value, safeGlobal);\n      if (prop in endowments) {\n        // todo: shim integrity: TypeError, String\n        throw new TypeError(`do not modify endowments like ${String(prop)}`);\n      }\n\n      safeGlobal[prop] = value;\n\n      // Return true after successful set.\n      return true;\n    },\n\n    // we need has() to return false for some names to prevent the lookup  from\n    // climbing the scope chain and eventually reaching the unsafeGlobal\n    // object, which is bad.\n\n    // note: unscopables! every string in Object[Symbol.unscopables]\n\n    // todo: we'd like to just have has() return true for everything, and then\n    // use get() to raise a ReferenceError for anything not on the safe global.\n    // But we want to be compatible with ReferenceError in the normal case and\n    // the lack of ReferenceError in the 'typeof' case. Must either reliably\n    // distinguish these two cases (the trap behavior might be different), or\n    // we rely on a mandatory source-to-source transform to change 'typeof abc'\n    // to XXX. We already need a mandatory parse to prevent the 'import',\n    // since it's a special form instead of merely being a global variable/\n\n    // note: if we make has() return true always, then we must implement a\n    // set() trap to avoid subverting the protection of strict mode (it would\n    // accept assignments to undefined globals, when it ought to throw\n    // ReferenceError for such assignments)\n\n    has(shadow, prop) {\n      // proxies stringify 'prop', so no TOCTTOU danger here\n\n      if (sloppyGlobals) {\n        // Everything is potentially available.\n        return true;\n      }\n\n      // unsafeGlobal: hide all properties of unsafeGlobal at the\n      // expense of 'typeof' being wrong for those properties. For\n      // example, in the browser, evaluating 'document = 3', will add\n      // a property to safeGlobal instead of throwing a\n      // ReferenceError.\n      if (\n        prop === 'eval' ||\n        prop in endowments ||\n        prop in safeGlobal ||\n        prop in unsafeGlobal\n      ) {\n        return true;\n      }\n\n      return false;\n    },\n\n    // note: this is likely a bug of safari\n    // https://bugs.webkit.org/show_bug.cgi?id=195534\n\n    getPrototypeOf() {\n      return null;\n    }\n  };\n}\n\nconst buildScopeHandlerString = cleanupSource(\n  `'use strict'; (${buildScopeHandler})`\n);\nexport function createScopeHandler(\n  unsafeRec,\n  safeGlobal,\n  endowments,\n  sloppyGlobals\n) {\n  const { unsafeEval } = unsafeRec;\n  return unsafeEval(buildScopeHandlerString)(\n    unsafeRec,\n    safeGlobal,\n    endowments,\n    sloppyGlobals\n  );\n}\n","import { cleanupSource } from './utilities';\n\nfunction buildSafeEval(unsafeRec, safeEvalOperation) {\n  const { callAndWrapError } = unsafeRec;\n\n  const { defineProperties } = Object;\n\n  // We use the the concise method syntax to create an eval without a\n  // [[Construct]] behavior (such that the invocation \"new eval()\" throws\n  // TypeError: eval is not a constructor\"), but which still accepts a\n  // 'this' binding.\n  const safeEval = {\n    eval() {\n      return callAndWrapError(safeEvalOperation, arguments);\n    }\n  }.eval;\n\n  // safeEval's prototype RootRealm's value and instanceof Function\n  // is true inside the realm. It doesn't point at the primal realm\n  // value, and there is no defense against leaking primal realm\n  // intrinsics.\n\n  defineProperties(safeEval, {\n    toString: {\n      // We break up the following literal string so that an\n      // apparent direct eval syntax does not appear in this\n      // file. Thus, we avoid rejection by the overly eager\n      // rejectDangerousSources.\n      value: () => `function ${'eval'}() { [shim code] }`,\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  return safeEval;\n}\nconst buildSafeEvalString = cleanupSource(`'use strict'; (${buildSafeEval})`);\nexport function createSafeEval(unsafeRec, safeEvalOperation) {\n  const { unsafeEval } = unsafeRec;\n  return unsafeEval(buildSafeEvalString)(unsafeRec, safeEvalOperation);\n}\n","import { cleanupSource } from './utilities';\n\nfunction buildSafeFunction(unsafeRec, safeFunctionOperation) {\n  const { callAndWrapError, unsafeFunction } = unsafeRec;\n\n  const { defineProperties } = Object;\n\n  const safeFunction = function Function() {\n    return callAndWrapError(safeFunctionOperation, arguments);\n  };\n\n  // Ensure that Function from any compartment in a root realm can be used\n  // with instance checks in any compartment of the same root realm.\n\n  defineProperties(safeFunction, {\n    // Ensure that any function created in any compartment in a root realm is an\n    // instance of Function in any compartment of the same root ralm.\n    prototype: { value: unsafeFunction.prototype },\n\n    // Provide a custom output without overwriting the\n    // Function.prototype.toString which is called by some third-party\n    // libraries.\n    toString: {\n      value: () => 'function Function() { [shim code] }',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  return safeFunction;\n}\nconst buildSafeFunctionString = cleanupSource(\n  `'use strict'; (${buildSafeFunction})`\n);\nexport function createSafeFunction(unsafeRec, safeFunctionOperation) {\n  const { unsafeEval } = unsafeRec;\n  return unsafeEval(buildSafeFunctionString)(unsafeRec, safeFunctionOperation);\n}\n","// https://www.ecma-international.org/ecma-262/9.0/index.html#sec-html-like-comments\n// explains that JavaScript parsers may or may not recognize html\n// comment tokens \"<\" immediately followed by \"!--\" and \"--\"\n// immediately followed by \">\" in non-module source text, and treat\n// them as a kind of line comment. Since otherwise both of these can\n// appear in normal JavaScript source code as a sequence of operators,\n// we have the terrifying possibility of the same source code parsing\n// one way on one correct JavaScript implementation, and another way\n// on another.\n//\n// This shim takes the conservative strategy of just rejecting source\n// text that contains these strings anywhere. Note that this very\n// source file is written strangely to avoid mentioning these\n// character strings explicitly.\n\n// We do not write the regexp in a straightforward way, so that an\n// apparennt html comment does not appear in this file. Thus, we avoid\n// rejection by the overly eager rejectDangerousSources.\nconst htmlCommentPattern = new RegExp(`(?:${'<'}!--|--${'>'})`);\n\nfunction rejectHtmlComments(s) {\n  const index = s.search(htmlCommentPattern);\n  if (index !== -1) {\n    const linenum = s.slice(0, index).split('\\n').length; // more or less\n    throw new SyntaxError(\n      `possible html comment syntax rejected around line ${linenum}`\n    );\n  }\n}\n\n// The proposed dynamic import expression is the only syntax currently\n// proposed, that can appear in non-module JavaScript code, that\n// enables direct access to the outside world that cannot be\n// surpressed or intercepted without parsing and rewriting. Instead,\n// this shim conservatively rejects any source text that seems to\n// contain such an expression. To do this safely without parsing, we\n// must also reject some valid programs, i.e., those containing\n// apparent import expressions in literal strings or comments.\n\n// The current conservative rule looks for the identifier \"import\"\n// followed by either an open paren or something that looks like the\n// beginning of a comment. We assume that we do not need to worry\n// about html comment syntax because that was already rejected by\n// rejectHtmlComments.\n\n// this \\s *must* match all kinds of syntax-defined whitespace. If e.g.\n// U+2028 (LINE SEPARATOR) or U+2029 (PARAGRAPH SEPARATOR) is treated as\n// whitespace by the parser, but not matched by /\\s/, then this would admit\n// an attack like: import\\u2028('power.js') . We're trying to distinguish\n// something like that from something like importnotreally('power.js') which\n// is perfectly safe.\n\nconst importPattern = /\\bimport\\s*(?:\\(|\\/[/*])/;\n\nfunction rejectImportExpressions(s) {\n  const index = s.search(importPattern);\n  if (index !== -1) {\n    const linenum = s.slice(0, index).split('\\n').length; // more or less\n    throw new SyntaxError(\n      `possible import expression rejected around line ${linenum}`\n    );\n  }\n}\n\n// The shim cannot correctly emulate a direct eval as explained at\n// https://github.com/Agoric/realms-shim/issues/12\n// Without rejecting apparent direct eval syntax, we would\n// accidentally evaluate these with an emulation of indirect eval. Tp\n// prevent future compatibility problems, in shifting from use of the\n// shim to genuine platform support for the proposal, we should\n// instead statically reject code that seems to contain a direct eval\n// expression.\n//\n// As with the dynamic import expression, to avoid a full parse, we do\n// this approximately with a regexp, that will also reject strings\n// that appear safely in comments or strings. Unlike dynamic import,\n// if we miss some, this only creates future compat problems, not\n// security problems. Thus, we are only trying to catch innocent\n// occurrences, not malicious one. In particular, `(eval)(...)` is\n// direct eval syntax that would not be caught by the following regexp.\n\nconst someDirectEvalPattern = /\\beval\\s*(?:\\(|\\/[/*])/;\n\nfunction rejectSomeDirectEvalExpressions(s) {\n  const index = s.search(someDirectEvalPattern);\n  if (index !== -1) {\n    const linenum = s.slice(0, index).split('\\n').length; // more or less\n    throw new SyntaxError(\n      `possible direct eval expression rejected around line ${linenum}`\n    );\n  }\n}\n\nexport function rejectDangerousSources(s) {\n  rejectHtmlComments(s);\n  rejectImportExpressions(s);\n  rejectSomeDirectEvalExpressions(s);\n}\n\n// Export a rewriter transform.\nexport const rejectDangerousSourcesTransform = {\n  rewrite(rs) {\n    rejectDangerousSources(rs.src);\n    return rs;\n  }\n};\n","// Portions adapted from V8 - Copyright 2016 the V8 project authors.\n// https://github.com/v8/v8/blob/master/src/builtins/builtins-function.cc\n\nimport { assert, throwTantrum } from './utilities';\nimport {\n  apply,\n  arrayConcat,\n  arrayJoin,\n  arrayPop,\n  create,\n  getOwnPropertyDescriptors,\n  getPrototypeOf,\n  regexpTest,\n  stringIncludes\n} from './commons';\nimport { getOptimizableGlobals } from './optimizer';\nimport { createScopeHandler } from './scopeHandlerFacade';\nimport { createSafeEval } from './safeEvalFacade';\nimport { createSafeFunction } from './safeFunctionFacade';\nimport { rejectDangerousSourcesTransform } from './sourceParser';\n\nfunction buildOptimizer(constants) {\n  // No need to build an oprimizer when there are no constants.\n  if (constants.length === 0) return '';\n  // Use 'this' to avoid going through the scope proxy, which is unecessary\n  // since the optimizer only needs references to the safe global.\n  return `const {${arrayJoin(constants, ',')}} = this;`;\n}\n\nfunction createScopedEvaluatorFactory(unsafeRec, constants) {\n  const { unsafeFunction } = unsafeRec;\n\n  const optimizer = buildOptimizer(constants);\n\n  // Create a function in sloppy mode, so that we can use 'with'. It returns\n  // a function in strict mode that evaluates the provided code using direct\n  // eval, and thus in strict mode in the same scope. We must be very careful\n  // to not create new names in this scope\n\n  // 1: we use 'with' (around a Proxy) to catch all free variable names. The\n  // first 'arguments[0]' holds the Proxy which safely wraps the safeGlobal\n  // 2: 'optimizer' catches common variable names for speed\n  // 3: The inner strict function is effectively passed two parameters:\n  //    a) its arguments[0] is the source to be directly evaluated.\n  //    b) its 'this' is the this binding seen by the code being\n  //       directly evaluated.\n\n  // everything in the 'optimizer' string is looked up in the proxy\n  // (including an 'arguments[0]', which points at the Proxy). 'function' is\n  // a keyword, not a variable, so it is not looked up. then 'eval' is looked\n  // up in the proxy, that's the first time it is looked up after\n  // useUnsafeEvaluator is turned on, so the proxy returns the real the\n  // unsafeEval, which satisfies the IsDirectEvalTrap predicate, so it uses\n  // the direct eval and gets the lexical scope. The second 'arguments[0]' is\n  // looked up in the context of the inner function. The *contents* of\n  // arguments[0], because we're using direct eval, are looked up in the\n  // Proxy, by which point the useUnsafeEvaluator switch has been flipped\n  // back to 'false', so any instances of 'eval' in that string will get the\n  // safe evaluator.\n\n  return unsafeFunction(`\n    with (arguments[0]) {\n      ${optimizer}\n      return function() {\n        'use strict';\n        return eval(arguments[0]);\n      };\n    }\n  `);\n}\n\nfunction applyTransforms(rewriterState, transforms) {\n  // Clone before calling transforms.\n  rewriterState = {\n    src: `${rewriterState.src}`,\n    endowments: create(\n      null,\n      getOwnPropertyDescriptors(rewriterState.endowments)\n    )\n  };\n\n  // Rewrite the source, threading through rewriter state as necessary.\n  rewriterState = transforms.reduce(\n    (rs, transform) => (transform.rewrite ? transform.rewrite(rs) : rs),\n    rewriterState\n  );\n\n  // Clone after transforms\n  rewriterState = {\n    src: `${rewriterState.src}`,\n    endowments: create(\n      null,\n      getOwnPropertyDescriptors(rewriterState.endowments)\n    )\n  };\n\n  return rewriterState;\n}\n\nexport function createSafeEvaluatorFactory(\n  unsafeRec,\n  safeGlobal,\n  transforms,\n  sloppyGlobals\n) {\n  const constants = getOptimizableGlobals(safeGlobal);\n  const scopedEvaluatorFactory = createScopedEvaluatorFactory(\n    unsafeRec,\n    constants\n  );\n\n  function factory(endowments = {}, options = {}) {\n    // todo clone all arguments passed to returned function\n    const localTransforms = options.transforms || [];\n    const realmTransforms = transforms || [];\n\n    const mandatoryTransforms = [rejectDangerousSourcesTransform];\n    const allTransforms = arrayConcat(\n      localTransforms,\n      realmTransforms,\n      mandatoryTransforms\n    );\n\n    function safeEvalOperation(src) {\n      let rewriterState = { src, endowments };\n      rewriterState = applyTransforms(rewriterState, allTransforms);\n\n      const scopeHandler = createScopeHandler(\n        unsafeRec,\n        safeGlobal,\n        rewriterState.endowments,\n        sloppyGlobals\n      );\n      const scopeProxyRevocable = Proxy.revocable({}, scopeHandler);\n      const scopeProxy = scopeProxyRevocable.proxy;\n      const scopedEvaluator = apply(scopedEvaluatorFactory, safeGlobal, [\n        scopeProxy\n      ]);\n\n      scopeHandler.useUnsafeEvaluator = true;\n      let err;\n      try {\n        // Ensure that \"this\" resolves to the safe global.\n        return apply(scopedEvaluator, safeGlobal, [rewriterState.src]);\n      } catch (e) {\n        // stash the child-code error in hopes of debugging the internal failure\n        err = e;\n        throw e;\n      } finally {\n        if (scopeHandler.useUnsafeEvaluator) {\n          // the proxy switches this off immediately after ths\n          // first access, but if that's not the case we prevent\n          // further variable resolution on the scope and abort.\n          scopeProxyRevocable.revoke();\n          throwTantrum('handler did not revoke useUnsafeEvaluator', err);\n        }\n      }\n    }\n\n    return safeEvalOperation;\n  }\n\n  return factory;\n}\n\nexport function createSafeEvaluator(unsafeRec, safeEvalOperation) {\n  const { unsafeFunction } = unsafeRec;\n\n  const safeEval = createSafeEval(unsafeRec, safeEvalOperation);\n\n  assert(getPrototypeOf(safeEval).constructor !== Function, 'hide Function');\n  assert(\n    getPrototypeOf(safeEval).constructor !== unsafeFunction,\n    'hide unsafeFunction'\n  );\n\n  return safeEval;\n}\n\nexport function createSafeEvaluatorWhichTakesEndowments(safeEvaluatorFactory) {\n  return (x, endowments, options = {}) =>\n    safeEvaluatorFactory(endowments, options)(x);\n}\n\n/**\n * A safe version of the native Function which relies on\n * the safety of evalEvaluator for confinement.\n */\nexport function createFunctionEvaluator(unsafeRec, safeEvalOperation) {\n  const { unsafeGlobal, unsafeFunction } = unsafeRec;\n\n  function safeFunctionOperation(...params) {\n    const functionBody = `${arrayPop(params) || ''}`;\n    let functionParams = `${arrayJoin(params, ',')}`;\n    if (!regexpTest(/^[\\w\\s,]*$/, functionParams)) {\n      throw new SyntaxError(\n        'shim limitation: Function arg must be simple ASCII identifiers, possibly separated by commas: no default values, pattern matches, or non-ASCII parameter names'\n      );\n      // this protects against Matt Austin's clever attack:\n      // Function(\"arg=`\", \"/*body`){});({x: this/**/\")\n      // which would turn into\n      //     (function(arg=`\n      //     /*``*/){\n      //      /*body`){});({x: this/**/\n      //     })\n      // which parses as a default argument of `\\n/*``*/){\\n/*body` , which\n      // is a pair of template literals back-to-back (so the first one\n      // nominally evaluates to the parser to use on the second one), which\n      // can't actually execute (because the first literal evals to a string,\n      // which can't be a parser function), but that doesn't matter because\n      // the function is bypassed entirely. When that gets evaluated, it\n      // defines (but does not invoke) a function, then evaluates a simple\n      // {x: this} expression, giving access to the safe global.\n    }\n\n    // Is this a real functionBody, or is someone attempting an injection\n    // attack? This will throw a SyntaxError if the string is not actually a\n    // function body. We coerce the body into a real string above to prevent\n    // someone from passing an object with a toString() that returns a safe\n    // string the first time, but an evil string the second time.\n    // eslint-disable-next-line no-new, new-cap\n    new unsafeFunction(functionBody);\n\n    if (stringIncludes(functionParams, ')')) {\n      // If the formal parameters string include ) - an illegal\n      // character - it may make the combined function expression\n      // compile. We avoid this problem by checking for this early on.\n\n      // note: v8 throws just like this does, but chrome accepts\n      // e.g. 'a = new Date()'\n      throw new unsafeGlobal.SyntaxError(\n        'shim limitation: Function arg string contains parenthesis'\n      );\n      // todo: shim integrity threat if they change SyntaxError\n    }\n\n    // todo: check to make sure this .length is safe. markm says safe.\n    if (functionParams.length > 0) {\n      // If the formal parameters include an unbalanced block comment, the\n      // function must be rejected. Since JavaScript does not allow nested\n      // comments we can include a trailing block comment to catch this.\n      functionParams += '\\n/*``*/';\n    }\n\n    const src = `(function(${functionParams}){\\n${functionBody}\\n})`;\n\n    return safeEvalOperation(src);\n  }\n\n  const safeFunction = createSafeFunction(unsafeRec, safeFunctionOperation);\n\n  assert(\n    getPrototypeOf(safeFunction).constructor !== Function,\n    'hide Function'\n  );\n  assert(\n    getPrototypeOf(safeFunction).constructor !== unsafeFunction,\n    'hide unsafeFunction'\n  );\n\n  return safeFunction;\n}\n","import { createRealmFacade, buildChildRealm } from './realmFacade';\nimport { createNewUnsafeRec, createCurrentUnsafeRec } from './unsafeRec';\nimport {\n  createSafeEvaluatorFactory,\n  createSafeEvaluator,\n  createSafeEvaluatorWhichTakesEndowments,\n  createFunctionEvaluator\n} from './evaluators';\nimport { assert } from './utilities';\nimport { create, defineProperties, freeze, arrayConcat } from './commons';\n\n// Mimic private members on the realm instances.\n// We define it in the same module and do not export it.\nconst RealmRecForRealmInstance = new WeakMap();\n\nfunction getRealmRecForRealmInstance(realm) {\n  // Detect non-objects.\n  assert(Object(realm) === realm, 'bad object, not a Realm instance');\n  // Realm instance has no realmRec. Should not proceed.\n  assert(RealmRecForRealmInstance.has(realm), 'Realm instance has no record');\n\n  return RealmRecForRealmInstance.get(realm);\n}\n\nfunction registerRealmRecForRealmInstance(realm, realmRec) {\n  // Detect non-objects.\n  assert(Object(realm) === realm, 'bad object, not a Realm instance');\n  // Attempt to change an existing realmRec on a realm instance. Should not proceed.\n  assert(\n    !RealmRecForRealmInstance.has(realm),\n    'Realm instance already has a record'\n  );\n\n  RealmRecForRealmInstance.set(realm, realmRec);\n}\n\n// Initialize the global variables for the new Realm.\nfunction setDefaultBindings(safeGlobal, safeEval, safeFunction) {\n  defineProperties(safeGlobal, {\n    eval: {\n      value: safeEval,\n      writable: true,\n      configurable: true\n    },\n    Function: {\n      value: safeFunction,\n      writable: true,\n      configurable: true\n    }\n  });\n}\n\nfunction createRealmRec(unsafeRec, transforms, sloppyGlobals) {\n  const { sharedGlobalDescs, unsafeGlobal } = unsafeRec;\n\n  const safeGlobal = create(unsafeGlobal.Object.prototype, sharedGlobalDescs);\n\n  const safeEvaluatorFactory = createSafeEvaluatorFactory(\n    unsafeRec,\n    safeGlobal,\n    transforms,\n    sloppyGlobals\n  );\n  const safeEvalOperation = safeEvaluatorFactory();\n  const safeEval = createSafeEvaluator(unsafeRec, safeEvalOperation);\n  const safeFunction = createFunctionEvaluator(unsafeRec, safeEvalOperation);\n  const safeEvalWhichTakesEndowments = createSafeEvaluatorWhichTakesEndowments(\n    safeEvaluatorFactory\n  );\n\n  setDefaultBindings(safeGlobal, safeEval, safeFunction);\n\n  const realmRec = freeze({\n    safeGlobal,\n    safeEval,\n    safeEvalWhichTakesEndowments,\n    safeFunction\n  });\n\n  return realmRec;\n}\n\n/**\n * A root realm uses a fresh set of new intrinics. Here we first create\n * a new unsafe record, which inherits the shims. Then we proceed with\n * the creation of the realm record, and we apply the shims.\n */\nfunction initRootRealm(parentUnsafeRec, self, options) {\n  // note: 'self' is the instance of the Realm.\n\n  // todo: investigate attacks via Array.species\n  // todo: this accepts newShims='string', but it should reject that\n  const { shims: newShims, transforms, sloppyGlobals } = options;\n  const allShims = arrayConcat(parentUnsafeRec.allShims, newShims);\n\n  // The unsafe record is created already repaired.\n  const unsafeRec = createNewUnsafeRec(allShims);\n\n  // eslint-disable-next-line no-use-before-define\n  const Realm = createRealmFacade(unsafeRec, BaseRealm);\n\n  // Add a Realm descriptor to sharedGlobalDescs, so it can be defined onto the\n  // safeGlobal like the rest of the globals.\n  unsafeRec.sharedGlobalDescs.Realm = {\n    value: Realm,\n    writable: true,\n    configurable: true\n  };\n\n  // Creating the realmRec provides the global object, eval() and Function()\n  // to the realm.\n  const realmRec = createRealmRec(unsafeRec, transforms, sloppyGlobals);\n\n  // Apply all shims in the new RootRealm. We don't do this for compartments.\n  const { safeEvalWhichTakesEndowments } = realmRec;\n  for (const shim of allShims) {\n    safeEvalWhichTakesEndowments(shim);\n  }\n\n  // The realmRec acts as a private field on the realm instance.\n  registerRealmRecForRealmInstance(self, realmRec);\n}\n\n/**\n * A compartment shares the intrinsics of its root realm. Here, only a\n * realmRec is necessary to hold the global object, eval() and Function().\n */\nfunction initCompartment(unsafeRec, self, options = {}) {\n  // note: 'self' is the instance of the Realm.\n\n  const { transforms, sloppyGlobals } = options;\n  const realmRec = createRealmRec(unsafeRec, transforms, sloppyGlobals);\n\n  // The realmRec acts as a private field on the realm instance.\n  registerRealmRecForRealmInstance(self, realmRec);\n}\n\nfunction getRealmGlobal(self) {\n  const { safeGlobal } = getRealmRecForRealmInstance(self);\n  return safeGlobal;\n}\n\nfunction realmEvaluate(self, x, endowments = {}, options = {}) {\n  // todo: don't pass in primal-realm objects like {}, for safety. OTOH its\n  // properties are copied onto the new global 'target'.\n  // todo: figure out a way to membrane away the contents to safety.\n  const { safeEvalWhichTakesEndowments } = getRealmRecForRealmInstance(self);\n  return safeEvalWhichTakesEndowments(x, endowments, options);\n}\n\nconst BaseRealm = {\n  initRootRealm,\n  initCompartment,\n  getRealmGlobal,\n  realmEvaluate\n};\n\n// Create the current unsafeRec from the current \"primal\" environment (the realm\n// where the Realm shim is loaded and executed).\nconst currentUnsafeRec = createCurrentUnsafeRec();\n\n/**\n * The \"primal\" realm class is defined in the current \"primal\" environment,\n * and is part of the shim. There is no need to facade this class via evaluation\n * because both share the same intrinsics.\n */\nconst Realm = buildChildRealm(currentUnsafeRec, BaseRealm);\n\nexport default Realm;\n","// Declare shorthand functions. Sharing these declarations across modules\n// improves both consistency and minification. Unused declarations are\n// dropped by the tree shaking process.\n\n// we capture these, not just for brevity, but for security. If any code\n// modifies Object to change what 'assign' points to, the Realm shim would be\n// corrupted.\n\nexport const {\n  assign,\n  create,\n  freeze,\n  defineProperties, // Object.defineProperty is allowed to fail\n  // silentlty, use Object.defineProperties instead.\n  getOwnPropertyDescriptor,\n  getOwnPropertyDescriptors,\n  getOwnPropertyNames,\n  getPrototypeOf,\n  setPrototypeOf\n} = Object;\n\nexport const {\n  apply,\n  ownKeys // Reflect.ownKeys includes Symbols and unenumerables,\n  // unlike Object.keys()\n} = Reflect;\n\n/**\n * uncurryThis() See\n * http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\n * which only lives at\n * http://web.archive.org/web/20160805225710/http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\n *\n * Performance:\n * 1. The native call is about 10x faster on FF than chrome\n * 2. The version using Function.bind() is about 100x slower on FF,\n *    equal on chrome, 2x slower on Safari\n * 3. The version using a spread and Reflect.apply() is about 10x\n *    slower on FF, equal on chrome, 2x slower on Safari\n *\n * const bind = Function.prototype.bind;\n * const uncurryThis = bind.bind(bind.call);\n */\nconst uncurryThis = fn => (thisArg, ...args) => apply(fn, thisArg, args);\n\n// We also capture these for security: changes to Array.prototype after the\n// Realm shim runs shouldn't affect subsequent Realm operations.\nexport const objectHasOwnProperty = uncurryThis(\n    Object.prototype.hasOwnProperty\n  ),\n  arrayForEach = uncurryThis(Array.prototype.forEach),\n  arrayFilter = uncurryThis(Array.prototype.filter),\n  arrayPush = uncurryThis(Array.prototype.push),\n  arrayPop = uncurryThis(Array.prototype.pop),\n  arrayJoin = uncurryThis(Array.prototype.join),\n  arrayConcat = uncurryThis(Array.prototype.concat),\n  regexpTest = uncurryThis(RegExp.prototype.test),\n  stringMatch = uncurryThis(String.prototype.match),\n  stringIncludes = uncurryThis(String.prototype.includes);\n"],"names":["throwTantrum","s","err","msg","console","error","stack","assert","condition","message","cleanupSource","src","replace","buildChildRealm","unsafeRec","BaseRealm","callAndWrapError","initRootRealm","initCompartment","getRealmGlobal","realmEvaluate","create","defineProperties","Object","Realm","constructor","TypeError","makeRootRealm","options","r","prototype","makeCompartment","global","evaluate","x","endowments","toString","value","writable","enumerable","configurable","createRealmFacade","unsafeEval","buildChildRealmString","createCallAndWrapError","buildCallAndWrapErrorString","getSharedGlobalDescs","unsafeGlobal","describe","names","name","desc","getOwnPropertyDescriptor","descriptors","frozenGlobalPropertyNames","stableGlobalPropertyNames","unstableGlobalPropertyNames","repairAccessors","toObject","obj","asPropertyName","aFunction","accessor","defineProperty","getPrototypeOf","objectPrototype","__lookupGetter__","ignore","__defineGetter__","prop","func","O","get","__defineSetter__","set","__lookupSetter__","repairFunctions","repairFunction","declaration","FunctionInstance","eval","e","SyntaxError","FunctionPrototype","TamedFunction","Function","setPrototypeOf","createNewUnsafeGlobalForNode","isNode","vm","require","runInNewContext","unsafeGlobalEvalSrc","createNewUnsafeGlobalForBrowser","document","iframe","createElement","style","display","body","appendChild","contentWindow","unsafeGlobalSrc","createUnsafeRec","allShims","sharedGlobalDescs","unsafeFunction","freeze","createNewUnsafeRec","getNewUnsafeGlobal","repairAccessorsShim","repairFunctionsShim","getOptimizableGlobals","safeGlobal","descs","getOwnPropertyDescriptors","constants","arrayFilter","getOwnPropertyNames","keywords","has","regexpTest","identifierPattern","objectHasOwnProperty","createScopeHandler","sloppyGlobals","buildScopeHandlerString","createSafeEval","safeEvalOperation","buildSafeEvalString","createSafeFunction","safeFunctionOperation","buildSafeFunctionString","rejectHtmlComments","index","search","htmlCommentPattern","linenum","slice","split","length","rejectImportExpressions","importPattern","rejectSomeDirectEvalExpressions","someDirectEvalPattern","rejectDangerousSources","buildOptimizer","arrayJoin","createScopedEvaluatorFactory","optimizer","applyTransforms","rewriterState","transforms","reduce","rs","transform","rewrite","createSafeEvaluatorFactory","scopedEvaluatorFactory","localTransforms","allTransforms","arrayConcat","rejectDangerousSourcesTransform","scopeHandler","scopeProxyRevocable","Proxy","revocable","scopeProxy","proxy","scopedEvaluator","apply","useUnsafeEvaluator","revoke","createSafeEvaluator","safeEval","createSafeEvaluatorWhichTakesEndowments","safeEvaluatorFactory","createFunctionEvaluator","safeFunction","params","functionBody","arrayPop","functionParams","stringIncludes","getRealmRecForRealmInstance","realm","RealmRecForRealmInstance","registerRealmRecForRealmInstance","realmRec","setDefaultBindings","createRealmRec","safeEvalWhichTakesEndowments","Reflect","uncurryThis","fn","thisArg","args","mapGet","Map","setHas","Set","errorNameToErrorConstructor","EvalError","RangeError","ReferenceError","URIError","errorConstructors","Error","target","eName","eMessage","eStack","ignored","ErrorConstructor","err2","assign","ownKeys","hasOwnProperty","Array","filter","pop","join","concat","RegExp","test","String","includes","newUnsafeGlobalForBrowser","newUnsafeGlobalForNode","reflectGet","unscopables","Symbol","alwaysThrowHandler","__proto__","shadow","arguments","WeakMap","parentUnsafeRec","self","shims","newShims","shim","currentUnsafeRec"],"mappings":"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"}
##############################################
/src/dist/realms-shim.esm.js.map:1:{"version":3,"file":"realms-shim.esm.js","sources":["../src/utilities.js","../src/realmFacade.js","../src/callAndWrapError.js","../src/commons.js","../src/stdlib.js","../src/repair/accessors.js","../src/repair/functions.js","../src/unsafeRec.js","../src/optimizer.js","../src/scopeHandlerFacade.js","../src/safeEvalFacade.js","../src/safeFunctionFacade.js","../src/sourceParser.js","../src/evaluators.js","../src/realm.js"],"sourcesContent":["// we'd like to abandon, but we can't, so just scream and break a lot of\n// stuff. However, since we aren't really aborting the process, be careful to\n// not throw an Error object which could be captured by child-Realm code and\n// used to access the (too-powerful) primal-realm Error object.\n\nexport function throwTantrum(s, err = undefined) {\n  const msg = `please report internal shim error: ${s}`;\n\n  // we want to log these 'should never happen' things.\n  // eslint-disable-next-line no-console\n  console.error(msg);\n  if (err) {\n    // eslint-disable-next-line no-console\n    console.error(`${err}`);\n    // eslint-disable-next-line no-console\n    console.error(`${err.stack}`);\n  }\n\n  // eslint-disable-next-line no-debugger\n  debugger;\n  throw msg;\n}\n\nexport function assert(condition, message) {\n  if (!condition) {\n    throwTantrum(message);\n  }\n}\n\n/**\n * cleanupSource()\n * Remove code modifications introduced by ems and nyx in\n * test mode which intefere with Function.toString().\n *\n * Becuase this change is not required at runtime, the\n * body of this function is hollowed-out during the build\n * process by rollup-plugin-strip-code. As configured in\n * in rollup.config.jj, all code between the custom tags\n * START_TESTS_ONLY and END_TESTS_ONLY, and including those\n * tags, is stripped, turning this function into a noop.\n */\nexport function cleanupSource(src) {\n  // Restore eval which is modified by esm module.\n  // (0, eval) => (0, _<something>.e)\n  src = src.replace(/\\(0,\\s*_[^.]+\\.e\\)/g, '(0, eval)');\n\n  // Restore Reflect which is modified by esm module.\n  // Reflect => _<something>.e.Reflect\n  src = src.replace(/_[^.]+\\.g\\.Reflect/g, 'Reflect');\n\n  // Remove code coverage which is injected by nyc module.\n  src = src.replace(/cov_[^+]+\\+\\+[;,]/g, '');\n\n  return src;\n}\n","import { cleanupSource } from './utilities';\n\n// buildChildRealm is immediately turned into a string, and this function is\n// never referenced again, because it closes over the wrong intrinsics\n\nexport function buildChildRealm(unsafeRec, BaseRealm) {\n  const { callAndWrapError } = unsafeRec;\n  const {\n    initRootRealm,\n    initCompartment,\n    getRealmGlobal,\n    realmEvaluate\n  } = BaseRealm;\n\n  const { create, defineProperties } = Object;\n\n  class Realm {\n    constructor() {\n      // The Realm constructor is not intended to be used with the new operator\n      // or to be subclassed. It may be used as the value of an extends clause\n      // of a class definition but a super call to the Realm constructor will\n      // cause an exception.\n\n      // When Realm is called as a function, an exception is also raised because\n      // a class constructor cannot be invoked without 'new'.\n      throw new TypeError('Realm is not a constructor');\n    }\n\n    static makeRootRealm(options = {}) {\n      // This is the exposed interface.\n\n      // Bypass the constructor.\n      const r = create(Realm.prototype);\n      callAndWrapError(initRootRealm, [unsafeRec, r, options]);\n      return r;\n    }\n\n    static makeCompartment(options = {}) {\n      // Bypass the constructor.\n      const r = create(Realm.prototype);\n      callAndWrapError(initCompartment, [unsafeRec, r, options]);\n      return r;\n    }\n\n    // we omit the constructor because it is empty. All the personalization\n    // takes place in one of the two static methods,\n    // makeRootRealm/makeCompartment\n\n    get global() {\n      // this is safe against being called with strange 'this' because\n      // baseGetGlobal immediately does a trademark check (it fails unless\n      // this 'this' is present in a weakmap that is only populated with\n      // legitimate Realm instances)\n      return callAndWrapError(getRealmGlobal, [this]);\n    }\n\n    evaluate(x, endowments, options = {}) {\n      // safe against strange 'this', as above\n      return callAndWrapError(realmEvaluate, [this, x, endowments, options]);\n    }\n  }\n\n  defineProperties(Realm, {\n    toString: {\n      value: () => 'function Realm() { [shim code] }',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  defineProperties(Realm.prototype, {\n    toString: {\n      value: () => '[object Realm]',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  return Realm;\n}\n\n// The parentheses means we don't bind the 'buildChildRealm' name inside the\n// child's namespace. this would accept an anonymous function declaration.\n// function expression (not a declaration) so it has a completion value.\nconst buildChildRealmString = cleanupSource(\n  `'use strict'; (${buildChildRealm})`\n);\n\nexport function createRealmFacade(unsafeRec, BaseRealm) {\n  const { unsafeEval } = unsafeRec;\n  // The BaseRealm is the Realm class created by\n  // the shim. It's only valid for the context where\n  // it was parsed.\n\n  // The Realm facade is a lightweight class built in the\n  // context a different context, that provide a fully\n  // functional Realm class using the intrisics\n  // of that context.\n\n  // This process is simplified because all methods\n  // and properties on a realm instance already return\n  // values using the intrinsics of the realm's context.\n\n  // Invoke the BaseRealm constructor with Realm as the prototype.\n  return unsafeEval(buildChildRealmString)(unsafeRec, BaseRealm);\n}\n","import { cleanupSource } from './utilities';\n\nfunction buildCallAndWrapError() {\n  // This Object and Reflect are brand new, from a new unsafeRec, so no user\n  // code has been run or had a chance to manipulate them. Don't ever run this\n  // function *after* user code has had a chance to pollute its environment,\n  // or it could be used to gain access to BaseRealm and primal-realm Error\n  // objects.\n  const { getPrototypeOf } = Object;\n  const { apply } = Reflect;\n  const uncurryThis = fn => (thisArg, ...args) => apply(fn, thisArg, args);\n  const mapGet = uncurryThis(Map.prototype.get);\n  const setHas = uncurryThis(Set.prototype.has);\n\n  const errorNameToErrorConstructor = new Map([\n    ['EvalError', EvalError],\n    ['RangeError', RangeError],\n    ['ReferenceError', ReferenceError],\n    ['SyntaxError', SyntaxError],\n    ['TypeError', TypeError],\n    ['URIError', URIError]\n  ]);\n  const errorConstructors = new Set([\n    EvalError.prototype,\n    RangeError.prototype,\n    ReferenceError.prototype,\n    SyntaxError.prototype,\n    TypeError.prototype,\n    URIError.prototype,\n    Error.prototype\n  ]);\n\n  function callAndWrapError(target, args) {\n    try {\n      return apply(target, undefined, args);\n    } catch (err) {\n      // 1. Thrown primitives\n      if (Object(err) !== err) {\n        // err is a primitive value, which is safe to rethrow\n        throw err;\n      }\n\n      // 2. Current realm errors\n      if (setHas(errorConstructors, getPrototypeOf(err))) {\n        // err is a from the current realm, which is safe to rethrow.\n        // Object instances (normally) only contain intrinsics from the\n        // same realm. An error containing intrinsics from different\n        // realms would have to be manually constucted, which imply that\n        // such intrinsics were available, and confinement was already lost.\n        throw err;\n      }\n\n      // 3. Other realm errors\n      let eName, eMessage, eStack;\n      try {\n        // The other environment might seek to use 'err' to reach the\n        // parent's intrinsics and corrupt them. In addition, exceptions\n        // raised in the primal realm need to be converted to the current\n        // realm.\n\n        // `${err.name}` will cause string coercion of 'err.name'.\n        // If err.name is an object (probably a String of another Realm),\n        // the coercion uses err.name.toString(), which is under the control\n        // of the other realm. If err.name were a primitive (e.g. a number),\n        // it would use Number.toString(err.name), using the child's version\n        // of Number (which the child could modify to capture its argument for\n        // later use), however primitives don't have properties like .prototype\n        // so they aren't useful for an attack.\n        eName = `${err.name}`;\n        eMessage = `${err.message}`;\n        eStack = `${err.stack || eMessage}`;\n        // eName/eMessage/eStack are now realm-independent primitive strings, and\n        // safe to expose.\n      } catch (ignored) {\n        // if err.name.toString() throws, keep the (parent realm) Error away.\n        throw new Error('unknown error');\n      }\n      const ErrorConstructor =\n        mapGet(errorNameToErrorConstructor, eName) || Error;\n      try {\n        throw new ErrorConstructor(eMessage);\n      } catch (err2) {\n        err2.stack = eStack; // replace with the captured inner stack\n        throw err2;\n      }\n    }\n  }\n\n  return callAndWrapError;\n}\n\nconst buildCallAndWrapErrorString = cleanupSource(\n  `'use strict'; (${buildCallAndWrapError})`\n);\nexport function createCallAndWrapError(unsafeEval) {\n  return unsafeEval(buildCallAndWrapErrorString)();\n}\n","// Declare shorthand functions. Sharing these declarations across modules\n// improves both consistency and minification. Unused declarations are\n// dropped by the tree shaking process.\n\n// we capture these, not just for brevity, but for security. If any code\n// modifies Object to change what 'assign' points to, the Realm shim would be\n// corrupted.\n\nexport const {\n  assign,\n  create,\n  freeze,\n  defineProperties, // Object.defineProperty is allowed to fail\n  // silentlty, use Object.defineProperties instead.\n  getOwnPropertyDescriptor,\n  getOwnPropertyDescriptors,\n  getOwnPropertyNames,\n  getPrototypeOf,\n  setPrototypeOf\n} = Object;\n\nexport const {\n  apply,\n  ownKeys // Reflect.ownKeys includes Symbols and unenumerables,\n  // unlike Object.keys()\n} = Reflect;\n\n/**\n * uncurryThis() See\n * http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\n * which only lives at\n * http://web.archive.org/web/20160805225710/http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\n *\n * Performance:\n * 1. The native call is about 10x faster on FF than chrome\n * 2. The version using Function.bind() is about 100x slower on FF,\n *    equal on chrome, 2x slower on Safari\n * 3. The version using a spread and Reflect.apply() is about 10x\n *    slower on FF, equal on chrome, 2x slower on Safari\n *\n * const bind = Function.prototype.bind;\n * const uncurryThis = bind.bind(bind.call);\n */\nconst uncurryThis = fn => (thisArg, ...args) => apply(fn, thisArg, args);\n\n// We also capture these for security: changes to Array.prototype after the\n// Realm shim runs shouldn't affect subsequent Realm operations.\nexport const objectHasOwnProperty = uncurryThis(\n    Object.prototype.hasOwnProperty\n  ),\n  arrayForEach = uncurryThis(Array.prototype.forEach),\n  arrayFilter = uncurryThis(Array.prototype.filter),\n  arrayPush = uncurryThis(Array.prototype.push),\n  arrayPop = uncurryThis(Array.prototype.pop),\n  arrayJoin = uncurryThis(Array.prototype.join),\n  arrayConcat = uncurryThis(Array.prototype.concat),\n  regexpTest = uncurryThis(RegExp.prototype.test),\n  stringMatch = uncurryThis(String.prototype.match),\n  stringIncludes = uncurryThis(String.prototype.includes);\n","import { getOwnPropertyDescriptor } from './commons';\nimport { assert } from './utilities';\n\n// These value properties of the global object are non-writable,\n// non-configurable data properties.\nconst frozenGlobalPropertyNames = [\n  // *** 18.1 Value Properties of the Global Object\n\n  'Infinity',\n  'NaN',\n  'undefined'\n];\n\n// All the following stdlib items have the same name on both our intrinsics\n// object and on the global object. Unlike Infinity/NaN/undefined, these\n// should all be writable and configurable. This is divided into two\n// sets. The stable ones are those the shim can freeze early because\n// we don't expect anyone will want to mutate them. The unstable ones\n// are the ones that we correctly initialize to writable and\n// configurable so that they can still be replaced or removed.\nconst stableGlobalPropertyNames = [\n  // *** 18.2 Function Properties of the Global Object\n\n  // 'eval', // comes from safeEval instead\n  'isFinite',\n  'isNaN',\n  'parseFloat',\n  'parseInt',\n\n  'decodeURI',\n  'decodeURIComponent',\n  'encodeURI',\n  'encodeURIComponent',\n\n  // *** 18.3 Constructor Properties of the Global Object\n\n  'Array',\n  'ArrayBuffer',\n  'Boolean',\n  'DataView',\n  // 'Date',  // Unstable\n  // 'Error',  // Unstable\n  'EvalError',\n  'Float32Array',\n  'Float64Array',\n  // 'Function',  // comes from safeFunction instead\n  'Int8Array',\n  'Int16Array',\n  'Int32Array',\n  'Map',\n  'Number',\n  'Object',\n  // 'Promise',  // Unstable\n  // 'Proxy',  // Unstable\n  'RangeError',\n  'ReferenceError',\n  // 'RegExp',  // Unstable\n  'Set',\n  // 'SharedArrayBuffer'  // removed on Jan 5, 2018\n  'String',\n  'Symbol',\n  'SyntaxError',\n  'TypeError',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Uint16Array',\n  'Uint32Array',\n  'URIError',\n  'WeakMap',\n  'WeakSet',\n\n  // *** 18.4 Other Properties of the Global Object\n\n  // 'Atomics', // removed on Jan 5, 2018\n  'JSON',\n  'Math',\n  'Reflect',\n\n  // *** Annex B\n\n  'escape',\n  'unescape'\n\n  // *** ECMA-402\n\n  // 'Intl'  // Unstable\n\n  // *** ESNext\n\n  // 'Realm' // Comes from createRealmGlobalObject()\n];\n\nconst unstableGlobalPropertyNames = [\n  'Date',\n  'Error',\n  'Promise',\n  'Proxy',\n  'RegExp',\n  'Intl'\n];\n\nexport function getSharedGlobalDescs(unsafeGlobal) {\n  const descriptors = {};\n\n  function describe(names, writable, enumerable, configurable) {\n    for (const name of names) {\n      const desc = getOwnPropertyDescriptor(unsafeGlobal, name);\n      if (desc) {\n        // Abort if an accessor is found on the unsafe global object\n        // instead of a data property. We should never get into this\n        // non standard situation.\n        assert(\n          'value' in desc,\n          `unexpected accessor on global property: ${name}`\n        );\n\n        descriptors[name] = {\n          value: desc.value,\n          writable,\n          enumerable,\n          configurable\n        };\n      }\n    }\n  }\n\n  describe(frozenGlobalPropertyNames, false, false, false);\n  // The following is correct but expensive.\n  // describe(stableGlobalPropertyNames, true, false, true);\n  // Instead, for now, we let these get optimized.\n  //\n  // TODO: We should provide an option to turn this optimization off,\n  // by feeding \"true, false, true\" here instead.\n  describe(stableGlobalPropertyNames, false, false, false);\n  // These we keep replaceable and removable, because we expect\n  // others, e.g., SES, may want to do so.\n  describe(unstableGlobalPropertyNames, true, false, true);\n\n  return descriptors;\n}\n","// Adapted from SES/Caja - Copyright (C) 2011 Google Inc.\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js\n\n/**\n * Replace the legacy accessors of Object to comply with strict mode\n * and ES2016 semantics, we do this by redefining them while in 'use strict'.\n *\n * todo: list the issues resolved\n *\n * This function can be used in two ways: (1) invoked directly to fix the primal\n * realm's Object.prototype, and (2) converted to a string to be executed\n * inside each new RootRealm to fix their Object.prototypes. Evaluation requires\n * the function to have no dependencies, so don't import anything from\n * the outside.\n */\n\n// todo: this file should be moved out to a separate repo and npm module.\nexport function repairAccessors() {\n  const {\n    defineProperty,\n    defineProperties,\n    getOwnPropertyDescriptor,\n    getPrototypeOf,\n    prototype: objectPrototype\n  } = Object;\n\n  // On some platforms, the implementation of these functions act as\n  // if they are in sloppy mode: if they're invoked badly, they will\n  // expose the global object, so we need to repair these for\n  // security. Thus it is our responsibility to fix this, and we need\n  // to include repairAccessors. E.g. Chrome in 2016.\n\n  try {\n    // Verify that the method is not callable.\n    // eslint-disable-next-line no-restricted-properties, no-underscore-dangle\n    (0, objectPrototype.__lookupGetter__)('x');\n  } catch (ignore) {\n    // Throws, no need to patch.\n    return;\n  }\n\n  function toObject(obj) {\n    if (obj === undefined || obj === null) {\n      throw new TypeError(`can't convert undefined or null to object`);\n    }\n    return Object(obj);\n  }\n\n  function asPropertyName(obj) {\n    if (typeof obj === 'symbol') {\n      return obj;\n    }\n    return `${obj}`;\n  }\n\n  function aFunction(obj, accessor) {\n    if (typeof obj !== 'function') {\n      throw TypeError(`invalid ${accessor} usage`);\n    }\n    return obj;\n  }\n\n  defineProperties(objectPrototype, {\n    __defineGetter__: {\n      value: function __defineGetter__(prop, func) {\n        const O = toObject(this);\n        defineProperty(O, prop, {\n          get: aFunction(func, 'getter'),\n          enumerable: true,\n          configurable: true\n        });\n      }\n    },\n    __defineSetter__: {\n      value: function __defineSetter__(prop, func) {\n        const O = toObject(this);\n        defineProperty(O, prop, {\n          set: aFunction(func, 'setter'),\n          enumerable: true,\n          configurable: true\n        });\n      }\n    },\n    __lookupGetter__: {\n      value: function __lookupGetter__(prop) {\n        let O = toObject(this);\n        prop = asPropertyName(prop);\n        let desc;\n        while (O && !(desc = getOwnPropertyDescriptor(O, prop))) {\n          O = getPrototypeOf(O);\n        }\n        return desc && desc.get;\n      }\n    },\n    __lookupSetter__: {\n      value: function __lookupSetter__(prop) {\n        let O = toObject(this);\n        prop = asPropertyName(prop);\n        let desc;\n        while (O && !(desc = getOwnPropertyDescriptor(O, prop))) {\n          O = getPrototypeOf(O);\n        }\n        return desc && desc.set;\n      }\n    }\n  });\n}\n","// Adapted from SES/Caja\n// Copyright (C) 2011 Google Inc.\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js\n\n/**\n * This block replaces the original Function constructor, and the original\n * %GeneratorFunction% %AsyncFunction% and %AsyncGeneratorFunction%, with\n * safe replacements that throw if invoked.\n *\n * These are all reachable via syntax, so it isn't sufficient to just\n * replace global properties with safe versions. Our main goal is to prevent\n * access to the Function constructor through these starting points.\n\n * After this block is done, the originals must no longer be reachable, unless\n * a copy has been made, and funtions can only be created by syntax (using eval)\n * or by invoking a previously saved reference to the originals.\n */\n\n// todo: this file should be moved out to a separate repo and npm module.\nexport function repairFunctions() {\n  const { defineProperties, getPrototypeOf, setPrototypeOf } = Object;\n\n  /**\n   * The process to repair constructors:\n   * 1. Create an instance of the function by evaluating syntax\n   * 2. Obtain the prototype from the instance\n   * 3. Create a substitute tamed constructor\n   * 4. Replace the original constructor with the tamed constructor\n   * 5. Replace tamed constructor prototype property with the original one\n   * 6. Replace its [[Prototype]] slot with the tamed constructor of Function\n   */\n  function repairFunction(name, declaration) {\n    let FunctionInstance;\n    try {\n      // eslint-disable-next-line no-new-func\n      FunctionInstance = (0, eval)(declaration);\n    } catch (e) {\n      if (e instanceof SyntaxError) {\n        // Prevent failure on platforms where async and/or generators\n        // are not supported.\n        return;\n      }\n      // Re-throw\n      throw e;\n    }\n    const FunctionPrototype = getPrototypeOf(FunctionInstance);\n\n    // Prevents the evaluation of source when calling constructor on the\n    // prototype of functions.\n    const TamedFunction = function() {\n      throw new TypeError('Not available');\n    };\n    defineProperties(TamedFunction, { name: { value: name } });\n\n    // (new Error()).constructors does not inherit from Function, because Error\n    // was defined before ES6 classes. So we don't need to repair it too.\n\n    // (Error()).constructor inherit from Function, which gets a tamed\n    // constructor here.\n\n    // todo: in an ES6 class that does not inherit from anything, what does its\n    // constructor inherit from? We worry that it inherits from Function, in\n    // which case instances could give access to unsafeFunction. markm says\n    // we're fine: the constructor inherits from Object.prototype\n\n    // This line replaces the original constructor in the prototype chain\n    // with the tamed one. No copy of the original is peserved.\n    defineProperties(FunctionPrototype, {\n      constructor: { value: TamedFunction }\n    });\n\n    // This line sets the tamed constructor's prototype data property to\n    // the original one.\n    defineProperties(TamedFunction, {\n      prototype: { value: FunctionPrototype }\n    });\n\n    if (TamedFunction !== Function.prototype.constructor) {\n      // Ensures that all functions meet \"instanceof Function\" in a realm.\n      setPrototypeOf(TamedFunction, Function.prototype.constructor);\n    }\n  }\n\n  // Here, the order of operation is important: Function needs to be repaired\n  // first since the other repaired constructors need to inherit from the tamed\n  // Function function constructor.\n\n  // note: this really wants to be part of the standard, because new\n  // constructors may be added in the future, reachable from syntax, and this\n  // list must be updated to match.\n\n  // \"plain arrow functions\" inherit from Function.prototype\n\n  repairFunction('Function', '(function(){})');\n  repairFunction('GeneratorFunction', '(function*(){})');\n  repairFunction('AsyncFunction', '(async function(){})');\n  repairFunction('AsyncGeneratorFunction', '(async function*(){})');\n}\n","// this module must never be importable outside the Realm shim itself\nimport { createCallAndWrapError } from './callAndWrapError';\nimport { getSharedGlobalDescs } from './stdlib';\nimport { repairAccessors } from './repair/accessors';\nimport { repairFunctions } from './repair/functions';\nimport { cleanupSource } from './utilities';\nimport { freeze } from './commons';\n\n// A \"context\" is a fresh unsafe Realm as given to us by existing platforms.\n// We need this to implement the shim. However, when Realms land for real,\n// this feature will be provided by the underlying engine instead.\n\n// note: in a node module, the top-level 'this' is not the global object\n// (it's *something* but we aren't sure what), however an indirect eval of\n// 'this' will be the correct global object.\n\nconst unsafeGlobalSrc = \"'use strict'; this\";\nconst unsafeGlobalEvalSrc = `(0, eval)(\"'use strict'; this\")`;\n\n// This method is only exported for testing purposes.\nexport function createNewUnsafeGlobalForNode() {\n  // Note that webpack and others will shim 'vm' including the method\n  // 'runInNewContext', so the presence of vm is not a useful check\n\n  // TODO: Find a better test that works with bundlers\n  // eslint-disable-next-line no-new-func\n  const isNode = new Function(\n    'try {return this===global}catch(e){return false}'\n  )();\n\n  if (!isNode) {\n    return undefined;\n  }\n\n  // eslint-disable-next-line global-require\n  const vm = require('vm');\n\n  // Use unsafeGlobalEvalSrc to ensure we get the right 'this'.\n  const unsafeGlobal = vm.runInNewContext(unsafeGlobalEvalSrc);\n\n  return unsafeGlobal;\n}\n\n// This method is only exported for testing purposes.\nexport function createNewUnsafeGlobalForBrowser() {\n  if (typeof document === 'undefined') {\n    return undefined;\n  }\n  const iframe = document.createElement('iframe');\n  iframe.style.display = 'none';\n\n  document.body.appendChild(iframe);\n  const unsafeGlobal = iframe.contentWindow.eval(unsafeGlobalSrc);\n\n  // We keep the iframe attached to the DOM because removing it\n  // causes its global object to lose intrinsics, its eval()\n  // function to evaluate code, etc.\n\n  // TODO: can we remove and garbage-collect the iframes?\n\n  return unsafeGlobal;\n}\n\nconst getNewUnsafeGlobal = () => {\n  const newUnsafeGlobalForBrowser = createNewUnsafeGlobalForBrowser();\n  const newUnsafeGlobalForNode = createNewUnsafeGlobalForNode();\n  if (\n    (!newUnsafeGlobalForBrowser && !newUnsafeGlobalForNode) ||\n    (newUnsafeGlobalForBrowser && newUnsafeGlobalForNode)\n  ) {\n    throw new Error('unexpected platform, unable to create Realm');\n  }\n  return newUnsafeGlobalForBrowser || newUnsafeGlobalForNode;\n};\n\n// The unsafeRec is shim-specific. It acts as the mechanism to obtain a fresh\n// set of intrinsics together with their associated eval and Function\n// evaluators. These must be used as a matched set, since the evaluators are\n// tied to a set of intrinsics, aka the \"undeniables\". If it were possible to\n// mix-and-match them from different contexts, that would enable some\n// attacks.\nfunction createUnsafeRec(unsafeGlobal, allShims = []) {\n  const sharedGlobalDescs = getSharedGlobalDescs(unsafeGlobal);\n\n  const unsafeEval = unsafeGlobal.eval;\n  const unsafeFunction = unsafeGlobal.Function;\n\n  const callAndWrapError = createCallAndWrapError(unsafeEval);\n\n  return freeze({\n    unsafeGlobal,\n    sharedGlobalDescs,\n    unsafeEval,\n    unsafeFunction,\n    callAndWrapError,\n    allShims\n  });\n}\n\nconst repairAccessorsShim = cleanupSource(\n  `\"use strict\"; (${repairAccessors})();`\n);\nconst repairFunctionsShim = cleanupSource(\n  `\"use strict\"; (${repairFunctions})();`\n);\n\n// Create a new unsafeRec from a brand new context, with new intrinsics and a\n// new global object\nexport function createNewUnsafeRec(allShims) {\n  const unsafeGlobal = getNewUnsafeGlobal();\n  unsafeGlobal.eval(repairAccessorsShim);\n  unsafeGlobal.eval(repairFunctionsShim);\n  return createUnsafeRec(unsafeGlobal, allShims);\n}\n\n// Create a new unsafeRec from the current context, where the Realm shim is\n// being parsed and executed, aka the \"Primal Realm\"\nexport function createCurrentUnsafeRec() {\n  const unsafeGlobal = (0, eval)(unsafeGlobalSrc);\n  repairAccessors();\n  repairFunctions();\n  return createUnsafeRec(unsafeGlobal);\n}\n","import {\n  arrayFilter,\n  getOwnPropertyDescriptors,\n  getOwnPropertyNames,\n  objectHasOwnProperty,\n  regexpTest\n} from './commons';\n\n// todo: think about how this interacts with endowments, check for conflicts\n// between the names being optimized and the ones added by endowments\n\n/**\n * Simplified validation of indentifier names: may only contain alphanumeric\n * characters (or \"$\" or \"_\"), and may not start with a digit. This is safe\n * and does not reduces the compatibility of the shim. The motivation for\n * this limitation was to decrease the complexity of the implementation,\n * and to maintain a resonable level of performance.\n * Note: \\w is equivalent [a-zA-Z_0-9]\n * See 11.6.1 Identifier Names\n */\nconst identifierPattern = /^[a-zA-Z_$][\\w$]*$/;\n\n/**\n * In JavaScript you cannot use these reserved words as variables.\n * See 11.6.1 Identifier Names\n */\nconst keywords = new Set([\n  // 11.6.2.1 Keywords\n  'await',\n  'break',\n  'case',\n  'catch',\n  'class',\n  'const',\n  'continue',\n  'debugger',\n  'default',\n  'delete',\n  'do',\n  'else',\n  'export',\n  'extends',\n  'finally',\n  'for',\n  'function',\n  'if',\n  'import',\n  'in',\n  'instanceof',\n  'new',\n  'return',\n  'super',\n  'switch',\n  'this',\n  'throw',\n  'try',\n  'typeof',\n  'var',\n  'void',\n  'while',\n  'with',\n  'yield',\n\n  // Also reserved when parsing strict mode code\n  'let',\n  'static',\n\n  // 11.6.2.2 Future Reserved Words\n  'enum',\n\n  // Also reserved when parsing strict mode code\n  'implements',\n  'package',\n  'protected',\n  'interface',\n  'private',\n  'public',\n\n  // Reserved but not mentioned in specs\n  'await',\n\n  'null',\n  'true',\n  'false',\n\n  'this',\n  'arguments'\n]);\n\n/**\n * getOptimizableGlobals()\n * What variable names might it bring into scope? These include all\n * property names which can be variable names, including the names\n * of inherited properties. It excludes symbols and names which are\n * keywords. We drop symbols safely. Currently, this shim refuses\n * service if any of the names are keywords or keyword-like. This is\n * safe and only prevent performance optimization.\n */\nexport function getOptimizableGlobals(safeGlobal) {\n  const descs = getOwnPropertyDescriptors(safeGlobal);\n\n  // getOwnPropertyNames does ignore Symbols so we don't need this extra check:\n  // typeof name === 'string' &&\n  const constants = arrayFilter(getOwnPropertyNames(descs), name => {\n    // Ensure we have a valid identifier. We use regexpTest rather than\n    // /../.test() to guard against the case where RegExp has been poisoned.\n    if (\n      name === 'eval' ||\n      keywords.has(name) ||\n      !regexpTest(identifierPattern, name)\n    ) {\n      return false;\n    }\n\n    const desc = descs[name];\n    return (\n      //\n      // The getters will not have .writable, don't let the falsyness of\n      // 'undefined' trick us: test with === false, not ! . However descriptors\n      // inherit from the (potentially poisoned) global object, so we might see\n      // extra properties which weren't really there. Accessor properties have\n      // 'get/set/enumerable/configurable', while data properties have\n      // 'value/writable/enumerable/configurable'.\n      desc.configurable === false &&\n      desc.writable === false &&\n      //\n      // Checks for data properties because they're the only ones we can\n      // optimize (accessors are most likely non-constant). Descriptors can't\n      // can't have accessors and value properties at the same time, therefore\n      // this check is sufficient. Using explicit own property deal with the\n      // case where Object.prototype has been poisoned.\n      objectHasOwnProperty(desc, 'value')\n    );\n  });\n\n  return constants;\n}\n","import { cleanupSource } from './utilities';\n\n/**\n * ScopeHandler manages a Proxy which serves as the global scope for the\n * safeEvaluator operation (the Proxy is the argument of a 'with' binding).\n * As described in createSafeEvaluator(), it has several functions:\n * - allow the very first (and only the very first) use of 'eval' to map to\n *   the real (unsafe) eval function, so it acts as a 'direct eval' and can\n *    access its lexical scope (which maps to the 'with' binding, which the\n *   ScopeHandler also controls).\n * - ensure that all subsequent uses of 'eval' map to the safeEvaluator,\n *   which lives as the 'eval' property of the safeGlobal.\n * - route all other property lookups at the safeGlobal.\n * - hide the unsafeGlobal which lives on the scope chain above the 'with'.\n * - ensure the Proxy invariants despite some global properties being frozen.\n *\n * @returns {ProxyHandler<any> & Record<string, any>}\n */\nexport function buildScopeHandler(\n  unsafeRec,\n  safeGlobal,\n  endowments = {},\n  sloppyGlobals = false\n) {\n  const { unsafeGlobal, unsafeEval } = unsafeRec;\n\n  const { freeze } = Object;\n  const { get: reflectGet } = Reflect;\n  const { unscopables } = Symbol;\n\n  /**\n   * alwaysThrowHandler is a proxy handler which throws on any trap called.\n   * It's made from a proxy with a get trap that throws. Its target is\n   * an immutable (frozen) object and is safe to share, except accross realms\n   */\n  const alwaysThrowHandler = new Proxy(freeze({}), {\n    get(target, prop) {\n      // todo: replace with throwTantrum\n      throw new TypeError(\n        `unexpected scope handler trap called: ${String(prop)}`\n      );\n    }\n  });\n\n  return {\n    // The scope handler throws if any trap other than get/set/has are run\n    // (e.g. getOwnPropertyDescriptors, apply, getPrototypeOf).\n    // eslint-disable-next-line no-proto\n    __proto__: alwaysThrowHandler,\n\n    // This flag allow us to determine if the eval() call is an done by the\n    // realm's code or if it is user-land invocation, so we can react differently.\n    // We use a property and not an accessor to avoid increasing the stack trace\n    // and reduce the possibility of OOM.\n    useUnsafeEvaluator: false,\n\n    get(shadow, prop) {\n      if (prop === unscopables) {\n        // Safe to return a primal realm Object here because the only code that\n        // can do a get() on a non-string is the internals of with() itself,\n        // and the only thing it does is to look for properties on it. User\n        // code cannot do a lookup on non-strings.\n        return undefined;\n      }\n\n      // Special treatment for eval. The very first lookup of 'eval' gets the\n      // unsafe (real direct) eval, so it will get the lexical scope that uses\n      // the 'with' context.\n      if (prop === 'eval') {\n        // test that it is true rather than merely truthy\n        if (this.useUnsafeEvaluator === true) {\n          // revoke before use\n          this.useUnsafeEvaluator = false;\n          return unsafeEval;\n        }\n        // fall through\n      }\n\n      // Properties of the global.\n      if (prop in endowments) {\n        return reflectGet(endowments, prop, safeGlobal);\n      }\n\n      // Properties of the global.\n      if (prop in safeGlobal) {\n        return safeGlobal[prop];\n      }\n\n      // Prevent the lookup for other properties.\n      return undefined;\n    },\n\n    // eslint-disable-next-line class-methods-use-this\n    set(shadow, prop, value) {\n      // todo: allow modifications when prop in endowments and it\n      // is writable, assuming we've already rejected overlap (see\n      // createSafeEvaluatorFactory.factory). This TypeError gets replaced with\n      // reflectSet(endowments, prop, value, safeGlobal);\n      if (prop in endowments) {\n        // todo: shim integrity: TypeError, String\n        throw new TypeError(`do not modify endowments like ${String(prop)}`);\n      }\n\n      safeGlobal[prop] = value;\n\n      // Return true after successful set.\n      return true;\n    },\n\n    // we need has() to return false for some names to prevent the lookup  from\n    // climbing the scope chain and eventually reaching the unsafeGlobal\n    // object, which is bad.\n\n    // note: unscopables! every string in Object[Symbol.unscopables]\n\n    // todo: we'd like to just have has() return true for everything, and then\n    // use get() to raise a ReferenceError for anything not on the safe global.\n    // But we want to be compatible with ReferenceError in the normal case and\n    // the lack of ReferenceError in the 'typeof' case. Must either reliably\n    // distinguish these two cases (the trap behavior might be different), or\n    // we rely on a mandatory source-to-source transform to change 'typeof abc'\n    // to XXX. We already need a mandatory parse to prevent the 'import',\n    // since it's a special form instead of merely being a global variable/\n\n    // note: if we make has() return true always, then we must implement a\n    // set() trap to avoid subverting the protection of strict mode (it would\n    // accept assignments to undefined globals, when it ought to throw\n    // ReferenceError for such assignments)\n\n    has(shadow, prop) {\n      // proxies stringify 'prop', so no TOCTTOU danger here\n\n      if (sloppyGlobals) {\n        // Everything is potentially available.\n        return true;\n      }\n\n      // unsafeGlobal: hide all properties of unsafeGlobal at the\n      // expense of 'typeof' being wrong for those properties. For\n      // example, in the browser, evaluating 'document = 3', will add\n      // a property to safeGlobal instead of throwing a\n      // ReferenceError.\n      if (\n        prop === 'eval' ||\n        prop in endowments ||\n        prop in safeGlobal ||\n        prop in unsafeGlobal\n      ) {\n        return true;\n      }\n\n      return false;\n    },\n\n    // note: this is likely a bug of safari\n    // https://bugs.webkit.org/show_bug.cgi?id=195534\n\n    getPrototypeOf() {\n      return null;\n    }\n  };\n}\n\nconst buildScopeHandlerString = cleanupSource(\n  `'use strict'; (${buildScopeHandler})`\n);\nexport function createScopeHandler(\n  unsafeRec,\n  safeGlobal,\n  endowments,\n  sloppyGlobals\n) {\n  const { unsafeEval } = unsafeRec;\n  return unsafeEval(buildScopeHandlerString)(\n    unsafeRec,\n    safeGlobal,\n    endowments,\n    sloppyGlobals\n  );\n}\n","import { cleanupSource } from './utilities';\n\nfunction buildSafeEval(unsafeRec, safeEvalOperation) {\n  const { callAndWrapError } = unsafeRec;\n\n  const { defineProperties } = Object;\n\n  // We use the the concise method syntax to create an eval without a\n  // [[Construct]] behavior (such that the invocation \"new eval()\" throws\n  // TypeError: eval is not a constructor\"), but which still accepts a\n  // 'this' binding.\n  const safeEval = {\n    eval() {\n      return callAndWrapError(safeEvalOperation, arguments);\n    }\n  }.eval;\n\n  // safeEval's prototype RootRealm's value and instanceof Function\n  // is true inside the realm. It doesn't point at the primal realm\n  // value, and there is no defense against leaking primal realm\n  // intrinsics.\n\n  defineProperties(safeEval, {\n    toString: {\n      // We break up the following literal string so that an\n      // apparent direct eval syntax does not appear in this\n      // file. Thus, we avoid rejection by the overly eager\n      // rejectDangerousSources.\n      value: () => `function ${'eval'}() { [shim code] }`,\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  return safeEval;\n}\nconst buildSafeEvalString = cleanupSource(`'use strict'; (${buildSafeEval})`);\nexport function createSafeEval(unsafeRec, safeEvalOperation) {\n  const { unsafeEval } = unsafeRec;\n  return unsafeEval(buildSafeEvalString)(unsafeRec, safeEvalOperation);\n}\n","import { cleanupSource } from './utilities';\n\nfunction buildSafeFunction(unsafeRec, safeFunctionOperation) {\n  const { callAndWrapError, unsafeFunction } = unsafeRec;\n\n  const { defineProperties } = Object;\n\n  const safeFunction = function Function() {\n    return callAndWrapError(safeFunctionOperation, arguments);\n  };\n\n  // Ensure that Function from any compartment in a root realm can be used\n  // with instance checks in any compartment of the same root realm.\n\n  defineProperties(safeFunction, {\n    // Ensure that any function created in any compartment in a root realm is an\n    // instance of Function in any compartment of the same root ralm.\n    prototype: { value: unsafeFunction.prototype },\n\n    // Provide a custom output without overwriting the\n    // Function.prototype.toString which is called by some third-party\n    // libraries.\n    toString: {\n      value: () => 'function Function() { [shim code] }',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  return safeFunction;\n}\nconst buildSafeFunctionString = cleanupSource(\n  `'use strict'; (${buildSafeFunction})`\n);\nexport function createSafeFunction(unsafeRec, safeFunctionOperation) {\n  const { unsafeEval } = unsafeRec;\n  return unsafeEval(buildSafeFunctionString)(unsafeRec, safeFunctionOperation);\n}\n","// https://www.ecma-international.org/ecma-262/9.0/index.html#sec-html-like-comments\n// explains that JavaScript parsers may or may not recognize html\n// comment tokens \"<\" immediately followed by \"!--\" and \"--\"\n// immediately followed by \">\" in non-module source text, and treat\n// them as a kind of line comment. Since otherwise both of these can\n// appear in normal JavaScript source code as a sequence of operators,\n// we have the terrifying possibility of the same source code parsing\n// one way on one correct JavaScript implementation, and another way\n// on another.\n//\n// This shim takes the conservative strategy of just rejecting source\n// text that contains these strings anywhere. Note that this very\n// source file is written strangely to avoid mentioning these\n// character strings explicitly.\n\n// We do not write the regexp in a straightforward way, so that an\n// apparennt html comment does not appear in this file. Thus, we avoid\n// rejection by the overly eager rejectDangerousSources.\nconst htmlCommentPattern = new RegExp(`(?:${'<'}!--|--${'>'})`);\n\nfunction rejectHtmlComments(s) {\n  const index = s.search(htmlCommentPattern);\n  if (index !== -1) {\n    const linenum = s.slice(0, index).split('\\n').length; // more or less\n    throw new SyntaxError(\n      `possible html comment syntax rejected around line ${linenum}`\n    );\n  }\n}\n\n// The proposed dynamic import expression is the only syntax currently\n// proposed, that can appear in non-module JavaScript code, that\n// enables direct access to the outside world that cannot be\n// surpressed or intercepted without parsing and rewriting. Instead,\n// this shim conservatively rejects any source text that seems to\n// contain such an expression. To do this safely without parsing, we\n// must also reject some valid programs, i.e., those containing\n// apparent import expressions in literal strings or comments.\n\n// The current conservative rule looks for the identifier \"import\"\n// followed by either an open paren or something that looks like the\n// beginning of a comment. We assume that we do not need to worry\n// about html comment syntax because that was already rejected by\n// rejectHtmlComments.\n\n// this \\s *must* match all kinds of syntax-defined whitespace. If e.g.\n// U+2028 (LINE SEPARATOR) or U+2029 (PARAGRAPH SEPARATOR) is treated as\n// whitespace by the parser, but not matched by /\\s/, then this would admit\n// an attack like: import\\u2028('power.js') . We're trying to distinguish\n// something like that from something like importnotreally('power.js') which\n// is perfectly safe.\n\nconst importPattern = /\\bimport\\s*(?:\\(|\\/[/*])/;\n\nfunction rejectImportExpressions(s) {\n  const index = s.search(importPattern);\n  if (index !== -1) {\n    const linenum = s.slice(0, index).split('\\n').length; // more or less\n    throw new SyntaxError(\n      `possible import expression rejected around line ${linenum}`\n    );\n  }\n}\n\n// The shim cannot correctly emulate a direct eval as explained at\n// https://github.com/Agoric/realms-shim/issues/12\n// Without rejecting apparent direct eval syntax, we would\n// accidentally evaluate these with an emulation of indirect eval. Tp\n// prevent future compatibility problems, in shifting from use of the\n// shim to genuine platform support for the proposal, we should\n// instead statically reject code that seems to contain a direct eval\n// expression.\n//\n// As with the dynamic import expression, to avoid a full parse, we do\n// this approximately with a regexp, that will also reject strings\n// that appear safely in comments or strings. Unlike dynamic import,\n// if we miss some, this only creates future compat problems, not\n// security problems. Thus, we are only trying to catch innocent\n// occurrences, not malicious one. In particular, `(eval)(...)` is\n// direct eval syntax that would not be caught by the following regexp.\n\nconst someDirectEvalPattern = /\\beval\\s*(?:\\(|\\/[/*])/;\n\nfunction rejectSomeDirectEvalExpressions(s) {\n  const index = s.search(someDirectEvalPattern);\n  if (index !== -1) {\n    const linenum = s.slice(0, index).split('\\n').length; // more or less\n    throw new SyntaxError(\n      `possible direct eval expression rejected around line ${linenum}`\n    );\n  }\n}\n\nexport function rejectDangerousSources(s) {\n  rejectHtmlComments(s);\n  rejectImportExpressions(s);\n  rejectSomeDirectEvalExpressions(s);\n}\n\n// Export a rewriter transform.\nexport const rejectDangerousSourcesTransform = {\n  rewrite(rs) {\n    rejectDangerousSources(rs.src);\n    return rs;\n  }\n};\n","// Portions adapted from V8 - Copyright 2016 the V8 project authors.\n// https://github.com/v8/v8/blob/master/src/builtins/builtins-function.cc\n\nimport { assert, throwTantrum } from './utilities';\nimport {\n  apply,\n  arrayConcat,\n  arrayJoin,\n  arrayPop,\n  create,\n  getOwnPropertyDescriptors,\n  getPrototypeOf,\n  regexpTest,\n  stringIncludes\n} from './commons';\nimport { getOptimizableGlobals } from './optimizer';\nimport { createScopeHandler } from './scopeHandlerFacade';\nimport { createSafeEval } from './safeEvalFacade';\nimport { createSafeFunction } from './safeFunctionFacade';\nimport { rejectDangerousSourcesTransform } from './sourceParser';\n\nfunction buildOptimizer(constants) {\n  // No need to build an oprimizer when there are no constants.\n  if (constants.length === 0) return '';\n  // Use 'this' to avoid going through the scope proxy, which is unecessary\n  // since the optimizer only needs references to the safe global.\n  return `const {${arrayJoin(constants, ',')}} = this;`;\n}\n\nfunction createScopedEvaluatorFactory(unsafeRec, constants) {\n  const { unsafeFunction } = unsafeRec;\n\n  const optimizer = buildOptimizer(constants);\n\n  // Create a function in sloppy mode, so that we can use 'with'. It returns\n  // a function in strict mode that evaluates the provided code using direct\n  // eval, and thus in strict mode in the same scope. We must be very careful\n  // to not create new names in this scope\n\n  // 1: we use 'with' (around a Proxy) to catch all free variable names. The\n  // first 'arguments[0]' holds the Proxy which safely wraps the safeGlobal\n  // 2: 'optimizer' catches common variable names for speed\n  // 3: The inner strict function is effectively passed two parameters:\n  //    a) its arguments[0] is the source to be directly evaluated.\n  //    b) its 'this' is the this binding seen by the code being\n  //       directly evaluated.\n\n  // everything in the 'optimizer' string is looked up in the proxy\n  // (including an 'arguments[0]', which points at the Proxy). 'function' is\n  // a keyword, not a variable, so it is not looked up. then 'eval' is looked\n  // up in the proxy, that's the first time it is looked up after\n  // useUnsafeEvaluator is turned on, so the proxy returns the real the\n  // unsafeEval, which satisfies the IsDirectEvalTrap predicate, so it uses\n  // the direct eval and gets the lexical scope. The second 'arguments[0]' is\n  // looked up in the context of the inner function. The *contents* of\n  // arguments[0], because we're using direct eval, are looked up in the\n  // Proxy, by which point the useUnsafeEvaluator switch has been flipped\n  // back to 'false', so any instances of 'eval' in that string will get the\n  // safe evaluator.\n\n  return unsafeFunction(`\n    with (arguments[0]) {\n      ${optimizer}\n      return function() {\n        'use strict';\n        return eval(arguments[0]);\n      };\n    }\n  `);\n}\n\nfunction applyTransforms(rewriterState, transforms) {\n  // Clone before calling transforms.\n  rewriterState = {\n    src: `${rewriterState.src}`,\n    endowments: create(\n      null,\n      getOwnPropertyDescriptors(rewriterState.endowments)\n    )\n  };\n\n  // Rewrite the source, threading through rewriter state as necessary.\n  rewriterState = transforms.reduce(\n    (rs, transform) => (transform.rewrite ? transform.rewrite(rs) : rs),\n    rewriterState\n  );\n\n  // Clone after transforms\n  rewriterState = {\n    src: `${rewriterState.src}`,\n    endowments: create(\n      null,\n      getOwnPropertyDescriptors(rewriterState.endowments)\n    )\n  };\n\n  return rewriterState;\n}\n\nexport function createSafeEvaluatorFactory(\n  unsafeRec,\n  safeGlobal,\n  transforms,\n  sloppyGlobals\n) {\n  const constants = getOptimizableGlobals(safeGlobal);\n  const scopedEvaluatorFactory = createScopedEvaluatorFactory(\n    unsafeRec,\n    constants\n  );\n\n  function factory(endowments = {}, options = {}) {\n    // todo clone all arguments passed to returned function\n    const localTransforms = options.transforms || [];\n    const realmTransforms = transforms || [];\n\n    const mandatoryTransforms = [rejectDangerousSourcesTransform];\n    const allTransforms = arrayConcat(\n      localTransforms,\n      realmTransforms,\n      mandatoryTransforms\n    );\n\n    function safeEvalOperation(src) {\n      let rewriterState = { src, endowments };\n      rewriterState = applyTransforms(rewriterState, allTransforms);\n\n      const scopeHandler = createScopeHandler(\n        unsafeRec,\n        safeGlobal,\n        rewriterState.endowments,\n        sloppyGlobals\n      );\n      const scopeProxyRevocable = Proxy.revocable({}, scopeHandler);\n      const scopeProxy = scopeProxyRevocable.proxy;\n      const scopedEvaluator = apply(scopedEvaluatorFactory, safeGlobal, [\n        scopeProxy\n      ]);\n\n      scopeHandler.useUnsafeEvaluator = true;\n      let err;\n      try {\n        // Ensure that \"this\" resolves to the safe global.\n        return apply(scopedEvaluator, safeGlobal, [rewriterState.src]);\n      } catch (e) {\n        // stash the child-code error in hopes of debugging the internal failure\n        err = e;\n        throw e;\n      } finally {\n        if (scopeHandler.useUnsafeEvaluator) {\n          // the proxy switches this off immediately after ths\n          // first access, but if that's not the case we prevent\n          // further variable resolution on the scope and abort.\n          scopeProxyRevocable.revoke();\n          throwTantrum('handler did not revoke useUnsafeEvaluator', err);\n        }\n      }\n    }\n\n    return safeEvalOperation;\n  }\n\n  return factory;\n}\n\nexport function createSafeEvaluator(unsafeRec, safeEvalOperation) {\n  const { unsafeFunction } = unsafeRec;\n\n  const safeEval = createSafeEval(unsafeRec, safeEvalOperation);\n\n  assert(getPrototypeOf(safeEval).constructor !== Function, 'hide Function');\n  assert(\n    getPrototypeOf(safeEval).constructor !== unsafeFunction,\n    'hide unsafeFunction'\n  );\n\n  return safeEval;\n}\n\nexport function createSafeEvaluatorWhichTakesEndowments(safeEvaluatorFactory) {\n  return (x, endowments, options = {}) =>\n    safeEvaluatorFactory(endowments, options)(x);\n}\n\n/**\n * A safe version of the native Function which relies on\n * the safety of evalEvaluator for confinement.\n */\nexport function createFunctionEvaluator(unsafeRec, safeEvalOperation) {\n  const { unsafeGlobal, unsafeFunction } = unsafeRec;\n\n  function safeFunctionOperation(...params) {\n    const functionBody = `${arrayPop(params) || ''}`;\n    let functionParams = `${arrayJoin(params, ',')}`;\n    if (!regexpTest(/^[\\w\\s,]*$/, functionParams)) {\n      throw new SyntaxError(\n        'shim limitation: Function arg must be simple ASCII identifiers, possibly separated by commas: no default values, pattern matches, or non-ASCII parameter names'\n      );\n      // this protects against Matt Austin's clever attack:\n      // Function(\"arg=`\", \"/*body`){});({x: this/**/\")\n      // which would turn into\n      //     (function(arg=`\n      //     /*``*/){\n      //      /*body`){});({x: this/**/\n      //     })\n      // which parses as a default argument of `\\n/*``*/){\\n/*body` , which\n      // is a pair of template literals back-to-back (so the first one\n      // nominally evaluates to the parser to use on the second one), which\n      // can't actually execute (because the first literal evals to a string,\n      // which can't be a parser function), but that doesn't matter because\n      // the function is bypassed entirely. When that gets evaluated, it\n      // defines (but does not invoke) a function, then evaluates a simple\n      // {x: this} expression, giving access to the safe global.\n    }\n\n    // Is this a real functionBody, or is someone attempting an injection\n    // attack? This will throw a SyntaxError if the string is not actually a\n    // function body. We coerce the body into a real string above to prevent\n    // someone from passing an object with a toString() that returns a safe\n    // string the first time, but an evil string the second time.\n    // eslint-disable-next-line no-new, new-cap\n    new unsafeFunction(functionBody);\n\n    if (stringIncludes(functionParams, ')')) {\n      // If the formal parameters string include ) - an illegal\n      // character - it may make the combined function expression\n      // compile. We avoid this problem by checking for this early on.\n\n      // note: v8 throws just like this does, but chrome accepts\n      // e.g. 'a = new Date()'\n      throw new unsafeGlobal.SyntaxError(\n        'shim limitation: Function arg string contains parenthesis'\n      );\n      // todo: shim integrity threat if they change SyntaxError\n    }\n\n    // todo: check to make sure this .length is safe. markm says safe.\n    if (functionParams.length > 0) {\n      // If the formal parameters include an unbalanced block comment, the\n      // function must be rejected. Since JavaScript does not allow nested\n      // comments we can include a trailing block comment to catch this.\n      functionParams += '\\n/*``*/';\n    }\n\n    const src = `(function(${functionParams}){\\n${functionBody}\\n})`;\n\n    return safeEvalOperation(src);\n  }\n\n  const safeFunction = createSafeFunction(unsafeRec, safeFunctionOperation);\n\n  assert(\n    getPrototypeOf(safeFunction).constructor !== Function,\n    'hide Function'\n  );\n  assert(\n    getPrototypeOf(safeFunction).constructor !== unsafeFunction,\n    'hide unsafeFunction'\n  );\n\n  return safeFunction;\n}\n","import { createRealmFacade, buildChildRealm } from './realmFacade';\nimport { createNewUnsafeRec, createCurrentUnsafeRec } from './unsafeRec';\nimport {\n  createSafeEvaluatorFactory,\n  createSafeEvaluator,\n  createSafeEvaluatorWhichTakesEndowments,\n  createFunctionEvaluator\n} from './evaluators';\nimport { assert } from './utilities';\nimport { create, defineProperties, freeze, arrayConcat } from './commons';\n\n// Mimic private members on the realm instances.\n// We define it in the same module and do not export it.\nconst RealmRecForRealmInstance = new WeakMap();\n\nfunction getRealmRecForRealmInstance(realm) {\n  // Detect non-objects.\n  assert(Object(realm) === realm, 'bad object, not a Realm instance');\n  // Realm instance has no realmRec. Should not proceed.\n  assert(RealmRecForRealmInstance.has(realm), 'Realm instance has no record');\n\n  return RealmRecForRealmInstance.get(realm);\n}\n\nfunction registerRealmRecForRealmInstance(realm, realmRec) {\n  // Detect non-objects.\n  assert(Object(realm) === realm, 'bad object, not a Realm instance');\n  // Attempt to change an existing realmRec on a realm instance. Should not proceed.\n  assert(\n    !RealmRecForRealmInstance.has(realm),\n    'Realm instance already has a record'\n  );\n\n  RealmRecForRealmInstance.set(realm, realmRec);\n}\n\n// Initialize the global variables for the new Realm.\nfunction setDefaultBindings(safeGlobal, safeEval, safeFunction) {\n  defineProperties(safeGlobal, {\n    eval: {\n      value: safeEval,\n      writable: true,\n      configurable: true\n    },\n    Function: {\n      value: safeFunction,\n      writable: true,\n      configurable: true\n    }\n  });\n}\n\nfunction createRealmRec(unsafeRec, transforms, sloppyGlobals) {\n  const { sharedGlobalDescs, unsafeGlobal } = unsafeRec;\n\n  const safeGlobal = create(unsafeGlobal.Object.prototype, sharedGlobalDescs);\n\n  const safeEvaluatorFactory = createSafeEvaluatorFactory(\n    unsafeRec,\n    safeGlobal,\n    transforms,\n    sloppyGlobals\n  );\n  const safeEvalOperation = safeEvaluatorFactory();\n  const safeEval = createSafeEvaluator(unsafeRec, safeEvalOperation);\n  const safeFunction = createFunctionEvaluator(unsafeRec, safeEvalOperation);\n  const safeEvalWhichTakesEndowments = createSafeEvaluatorWhichTakesEndowments(\n    safeEvaluatorFactory\n  );\n\n  setDefaultBindings(safeGlobal, safeEval, safeFunction);\n\n  const realmRec = freeze({\n    safeGlobal,\n    safeEval,\n    safeEvalWhichTakesEndowments,\n    safeFunction\n  });\n\n  return realmRec;\n}\n\n/**\n * A root realm uses a fresh set of new intrinics. Here we first create\n * a new unsafe record, which inherits the shims. Then we proceed with\n * the creation of the realm record, and we apply the shims.\n */\nfunction initRootRealm(parentUnsafeRec, self, options) {\n  // note: 'self' is the instance of the Realm.\n\n  // todo: investigate attacks via Array.species\n  // todo: this accepts newShims='string', but it should reject that\n  const { shims: newShims, transforms, sloppyGlobals } = options;\n  const allShims = arrayConcat(parentUnsafeRec.allShims, newShims);\n\n  // The unsafe record is created already repaired.\n  const unsafeRec = createNewUnsafeRec(allShims);\n\n  // eslint-disable-next-line no-use-before-define\n  const Realm = createRealmFacade(unsafeRec, BaseRealm);\n\n  // Add a Realm descriptor to sharedGlobalDescs, so it can be defined onto the\n  // safeGlobal like the rest of the globals.\n  unsafeRec.sharedGlobalDescs.Realm = {\n    value: Realm,\n    writable: true,\n    configurable: true\n  };\n\n  // Creating the realmRec provides the global object, eval() and Function()\n  // to the realm.\n  const realmRec = createRealmRec(unsafeRec, transforms, sloppyGlobals);\n\n  // Apply all shims in the new RootRealm. We don't do this for compartments.\n  const { safeEvalWhichTakesEndowments } = realmRec;\n  for (const shim of allShims) {\n    safeEvalWhichTakesEndowments(shim);\n  }\n\n  // The realmRec acts as a private field on the realm instance.\n  registerRealmRecForRealmInstance(self, realmRec);\n}\n\n/**\n * A compartment shares the intrinsics of its root realm. Here, only a\n * realmRec is necessary to hold the global object, eval() and Function().\n */\nfunction initCompartment(unsafeRec, self, options = {}) {\n  // note: 'self' is the instance of the Realm.\n\n  const { transforms, sloppyGlobals } = options;\n  const realmRec = createRealmRec(unsafeRec, transforms, sloppyGlobals);\n\n  // The realmRec acts as a private field on the realm instance.\n  registerRealmRecForRealmInstance(self, realmRec);\n}\n\nfunction getRealmGlobal(self) {\n  const { safeGlobal } = getRealmRecForRealmInstance(self);\n  return safeGlobal;\n}\n\nfunction realmEvaluate(self, x, endowments = {}, options = {}) {\n  // todo: don't pass in primal-realm objects like {}, for safety. OTOH its\n  // properties are copied onto the new global 'target'.\n  // todo: figure out a way to membrane away the contents to safety.\n  const { safeEvalWhichTakesEndowments } = getRealmRecForRealmInstance(self);\n  return safeEvalWhichTakesEndowments(x, endowments, options);\n}\n\nconst BaseRealm = {\n  initRootRealm,\n  initCompartment,\n  getRealmGlobal,\n  realmEvaluate\n};\n\n// Create the current unsafeRec from the current \"primal\" environment (the realm\n// where the Realm shim is loaded and executed).\nconst currentUnsafeRec = createCurrentUnsafeRec();\n\n/**\n * The \"primal\" realm class is defined in the current \"primal\" environment,\n * and is part of the shim. There is no need to facade this class via evaluation\n * because both share the same intrinsics.\n */\nconst Realm = buildChildRealm(currentUnsafeRec, BaseRealm);\n\nexport default Realm;\n"],"names":[],"mappings":"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"}
##############################################
/src/dist/realms-shim.esm.js-709-  document.body.appendChild(iframe);
/src/dist/realms-shim.esm.js:710:  const unsafeGlobal = iframe.contentWindow.eval(unsafeGlobalSrc);
/src/dist/realms-shim.esm.js-711-
/src/dist/realms-shim.esm.js-712-  // We keep the iframe attached to the DOM because removing it
/src/dist/realms-shim.esm.js:713:  // causes its global object to lose intrinsics, its eval()
/src/dist/realms-shim.esm.js-714-  // function to evaluate code, etc.
##############################################
/src/dist/realms-shim.esm.js-767-  const unsafeGlobal = getNewUnsafeGlobal();
/src/dist/realms-shim.esm.js:768:  unsafeGlobal.eval(repairAccessorsShim);
/src/dist/realms-shim.esm.js:769:  unsafeGlobal.eval(repairFunctionsShim);
/src/dist/realms-shim.esm.js-770-  return createUnsafeRec(unsafeGlobal, allShims);
##############################################
/src/dist/realms-shim.esm.js-959-
/src/dist/realms-shim.esm.js:960:    // This flag allow us to determine if the eval() call is an done by the
/src/dist/realms-shim.esm.js-961-    // realm's code or if it is user-land invocation, so we can react differently.
##############################################
/src/dist/realms-shim.esm.js-1096-  // We use the the concise method syntax to create an eval without a
/src/dist/realms-shim.esm.js:1097:  // [[Construct]] behavior (such that the invocation "new eval()" throws
/src/dist/realms-shim.esm.js-1098-  // TypeError: eval is not a constructor"), but which still accepts a
##############################################
/src/dist/realms-shim.esm.js-1100-  const safeEval = {
/src/dist/realms-shim.esm.js:1101:    eval() {
/src/dist/realms-shim.esm.js-1102-      return callAndWrapError(safeEvalOperation, arguments);
##############################################
/src/dist/realms-shim.esm.js-1322-        'use strict';
/src/dist/realms-shim.esm.js:1323:        return eval(arguments[0]);
/src/dist/realms-shim.esm.js-1324-      };
##############################################
/src/dist/realms-shim.esm.js-1618-
/src/dist/realms-shim.esm.js:1619:  // Creating the realmRec provides the global object, eval() and Function()
/src/dist/realms-shim.esm.js-1620-  // to the realm.
##############################################
/src/dist/realms-shim.esm.js-1634- * A compartment shares the intrinsics of its root realm. Here, only a
/src/dist/realms-shim.esm.js:1635: * realmRec is necessary to hold the global object, eval() and Function().
/src/dist/realms-shim.esm.js-1636- */
##############################################
/src/dist/realms-shim.umd.js-715-    document.body.appendChild(iframe);
/src/dist/realms-shim.umd.js:716:    const unsafeGlobal = iframe.contentWindow.eval(unsafeGlobalSrc);
/src/dist/realms-shim.umd.js-717-
/src/dist/realms-shim.umd.js-718-    // We keep the iframe attached to the DOM because removing it
/src/dist/realms-shim.umd.js:719:    // causes its global object to lose intrinsics, its eval()
/src/dist/realms-shim.umd.js-720-    // function to evaluate code, etc.
##############################################
/src/dist/realms-shim.umd.js-773-    const unsafeGlobal = getNewUnsafeGlobal();
/src/dist/realms-shim.umd.js:774:    unsafeGlobal.eval(repairAccessorsShim);
/src/dist/realms-shim.umd.js:775:    unsafeGlobal.eval(repairFunctionsShim);
/src/dist/realms-shim.umd.js-776-    return createUnsafeRec(unsafeGlobal, allShims);
##############################################
/src/dist/realms-shim.umd.js-965-
/src/dist/realms-shim.umd.js:966:      // This flag allow us to determine if the eval() call is an done by the
/src/dist/realms-shim.umd.js-967-      // realm's code or if it is user-land invocation, so we can react differently.
##############################################
/src/dist/realms-shim.umd.js-1102-    // We use the the concise method syntax to create an eval without a
/src/dist/realms-shim.umd.js:1103:    // [[Construct]] behavior (such that the invocation "new eval()" throws
/src/dist/realms-shim.umd.js-1104-    // TypeError: eval is not a constructor"), but which still accepts a
##############################################
/src/dist/realms-shim.umd.js-1106-    const safeEval = {
/src/dist/realms-shim.umd.js:1107:      eval() {
/src/dist/realms-shim.umd.js-1108-        return callAndWrapError(safeEvalOperation, arguments);
##############################################
/src/dist/realms-shim.umd.js-1328-        'use strict';
/src/dist/realms-shim.umd.js:1329:        return eval(arguments[0]);
/src/dist/realms-shim.umd.js-1330-      };
##############################################
/src/dist/realms-shim.umd.js-1624-
/src/dist/realms-shim.umd.js:1625:    // Creating the realmRec provides the global object, eval() and Function()
/src/dist/realms-shim.umd.js-1626-    // to the realm.
##############################################
/src/dist/realms-shim.umd.js-1640-   * A compartment shares the intrinsics of its root realm. Here, only a
/src/dist/realms-shim.umd.js:1641:   * realmRec is necessary to hold the global object, eval() and Function().
/src/dist/realms-shim.umd.js-1642-   */
##############################################
/src/dist/realms-shim.umd.js.map:1:{"version":3,"file":"realms-shim.umd.js","sources":["../src/utilities.js","../src/realmFacade.js","../src/callAndWrapError.js","../src/commons.js","../src/stdlib.js","../src/repair/accessors.js","../src/repair/functions.js","../src/unsafeRec.js","../src/optimizer.js","../src/scopeHandlerFacade.js","../src/safeEvalFacade.js","../src/safeFunctionFacade.js","../src/sourceParser.js","../src/evaluators.js","../src/realm.js"],"sourcesContent":["// we'd like to abandon, but we can't, so just scream and break a lot of\n// stuff. However, since we aren't really aborting the process, be careful to\n// not throw an Error object which could be captured by child-Realm code and\n// used to access the (too-powerful) primal-realm Error object.\n\nexport function throwTantrum(s, err = undefined) {\n  const msg = `please report internal shim error: ${s}`;\n\n  // we want to log these 'should never happen' things.\n  // eslint-disable-next-line no-console\n  console.error(msg);\n  if (err) {\n    // eslint-disable-next-line no-console\n    console.error(`${err}`);\n    // eslint-disable-next-line no-console\n    console.error(`${err.stack}`);\n  }\n\n  // eslint-disable-next-line no-debugger\n  debugger;\n  throw msg;\n}\n\nexport function assert(condition, message) {\n  if (!condition) {\n    throwTantrum(message);\n  }\n}\n\n/**\n * cleanupSource()\n * Remove code modifications introduced by ems and nyx in\n * test mode which intefere with Function.toString().\n *\n * Becuase this change is not required at runtime, the\n * body of this function is hollowed-out during the build\n * process by rollup-plugin-strip-code. As configured in\n * in rollup.config.jj, all code between the custom tags\n * START_TESTS_ONLY and END_TESTS_ONLY, and including those\n * tags, is stripped, turning this function into a noop.\n */\nexport function cleanupSource(src) {\n  // Restore eval which is modified by esm module.\n  // (0, eval) => (0, _<something>.e)\n  src = src.replace(/\\(0,\\s*_[^.]+\\.e\\)/g, '(0, eval)');\n\n  // Restore Reflect which is modified by esm module.\n  // Reflect => _<something>.e.Reflect\n  src = src.replace(/_[^.]+\\.g\\.Reflect/g, 'Reflect');\n\n  // Remove code coverage which is injected by nyc module.\n  src = src.replace(/cov_[^+]+\\+\\+[;,]/g, '');\n\n  return src;\n}\n","import { cleanupSource } from './utilities';\n\n// buildChildRealm is immediately turned into a string, and this function is\n// never referenced again, because it closes over the wrong intrinsics\n\nexport function buildChildRealm(unsafeRec, BaseRealm) {\n  const { callAndWrapError } = unsafeRec;\n  const {\n    initRootRealm,\n    initCompartment,\n    getRealmGlobal,\n    realmEvaluate\n  } = BaseRealm;\n\n  const { create, defineProperties } = Object;\n\n  class Realm {\n    constructor() {\n      // The Realm constructor is not intended to be used with the new operator\n      // or to be subclassed. It may be used as the value of an extends clause\n      // of a class definition but a super call to the Realm constructor will\n      // cause an exception.\n\n      // When Realm is called as a function, an exception is also raised because\n      // a class constructor cannot be invoked without 'new'.\n      throw new TypeError('Realm is not a constructor');\n    }\n\n    static makeRootRealm(options = {}) {\n      // This is the exposed interface.\n\n      // Bypass the constructor.\n      const r = create(Realm.prototype);\n      callAndWrapError(initRootRealm, [unsafeRec, r, options]);\n      return r;\n    }\n\n    static makeCompartment(options = {}) {\n      // Bypass the constructor.\n      const r = create(Realm.prototype);\n      callAndWrapError(initCompartment, [unsafeRec, r, options]);\n      return r;\n    }\n\n    // we omit the constructor because it is empty. All the personalization\n    // takes place in one of the two static methods,\n    // makeRootRealm/makeCompartment\n\n    get global() {\n      // this is safe against being called with strange 'this' because\n      // baseGetGlobal immediately does a trademark check (it fails unless\n      // this 'this' is present in a weakmap that is only populated with\n      // legitimate Realm instances)\n      return callAndWrapError(getRealmGlobal, [this]);\n    }\n\n    evaluate(x, endowments, options = {}) {\n      // safe against strange 'this', as above\n      return callAndWrapError(realmEvaluate, [this, x, endowments, options]);\n    }\n  }\n\n  defineProperties(Realm, {\n    toString: {\n      value: () => 'function Realm() { [shim code] }',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  defineProperties(Realm.prototype, {\n    toString: {\n      value: () => '[object Realm]',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  return Realm;\n}\n\n// The parentheses means we don't bind the 'buildChildRealm' name inside the\n// child's namespace. this would accept an anonymous function declaration.\n// function expression (not a declaration) so it has a completion value.\nconst buildChildRealmString = cleanupSource(\n  `'use strict'; (${buildChildRealm})`\n);\n\nexport function createRealmFacade(unsafeRec, BaseRealm) {\n  const { unsafeEval } = unsafeRec;\n  // The BaseRealm is the Realm class created by\n  // the shim. It's only valid for the context where\n  // it was parsed.\n\n  // The Realm facade is a lightweight class built in the\n  // context a different context, that provide a fully\n  // functional Realm class using the intrisics\n  // of that context.\n\n  // This process is simplified because all methods\n  // and properties on a realm instance already return\n  // values using the intrinsics of the realm's context.\n\n  // Invoke the BaseRealm constructor with Realm as the prototype.\n  return unsafeEval(buildChildRealmString)(unsafeRec, BaseRealm);\n}\n","import { cleanupSource } from './utilities';\n\nfunction buildCallAndWrapError() {\n  // This Object and Reflect are brand new, from a new unsafeRec, so no user\n  // code has been run or had a chance to manipulate them. Don't ever run this\n  // function *after* user code has had a chance to pollute its environment,\n  // or it could be used to gain access to BaseRealm and primal-realm Error\n  // objects.\n  const { getPrototypeOf } = Object;\n  const { apply } = Reflect;\n  const uncurryThis = fn => (thisArg, ...args) => apply(fn, thisArg, args);\n  const mapGet = uncurryThis(Map.prototype.get);\n  const setHas = uncurryThis(Set.prototype.has);\n\n  const errorNameToErrorConstructor = new Map([\n    ['EvalError', EvalError],\n    ['RangeError', RangeError],\n    ['ReferenceError', ReferenceError],\n    ['SyntaxError', SyntaxError],\n    ['TypeError', TypeError],\n    ['URIError', URIError]\n  ]);\n  const errorConstructors = new Set([\n    EvalError.prototype,\n    RangeError.prototype,\n    ReferenceError.prototype,\n    SyntaxError.prototype,\n    TypeError.prototype,\n    URIError.prototype,\n    Error.prototype\n  ]);\n\n  function callAndWrapError(target, args) {\n    try {\n      return apply(target, undefined, args);\n    } catch (err) {\n      // 1. Thrown primitives\n      if (Object(err) !== err) {\n        // err is a primitive value, which is safe to rethrow\n        throw err;\n      }\n\n      // 2. Current realm errors\n      if (setHas(errorConstructors, getPrototypeOf(err))) {\n        // err is a from the current realm, which is safe to rethrow.\n        // Object instances (normally) only contain intrinsics from the\n        // same realm. An error containing intrinsics from different\n        // realms would have to be manually constucted, which imply that\n        // such intrinsics were available, and confinement was already lost.\n        throw err;\n      }\n\n      // 3. Other realm errors\n      let eName, eMessage, eStack;\n      try {\n        // The other environment might seek to use 'err' to reach the\n        // parent's intrinsics and corrupt them. In addition, exceptions\n        // raised in the primal realm need to be converted to the current\n        // realm.\n\n        // `${err.name}` will cause string coercion of 'err.name'.\n        // If err.name is an object (probably a String of another Realm),\n        // the coercion uses err.name.toString(), which is under the control\n        // of the other realm. If err.name were a primitive (e.g. a number),\n        // it would use Number.toString(err.name), using the child's version\n        // of Number (which the child could modify to capture its argument for\n        // later use), however primitives don't have properties like .prototype\n        // so they aren't useful for an attack.\n        eName = `${err.name}`;\n        eMessage = `${err.message}`;\n        eStack = `${err.stack || eMessage}`;\n        // eName/eMessage/eStack are now realm-independent primitive strings, and\n        // safe to expose.\n      } catch (ignored) {\n        // if err.name.toString() throws, keep the (parent realm) Error away.\n        throw new Error('unknown error');\n      }\n      const ErrorConstructor =\n        mapGet(errorNameToErrorConstructor, eName) || Error;\n      try {\n        throw new ErrorConstructor(eMessage);\n      } catch (err2) {\n        err2.stack = eStack; // replace with the captured inner stack\n        throw err2;\n      }\n    }\n  }\n\n  return callAndWrapError;\n}\n\nconst buildCallAndWrapErrorString = cleanupSource(\n  `'use strict'; (${buildCallAndWrapError})`\n);\nexport function createCallAndWrapError(unsafeEval) {\n  return unsafeEval(buildCallAndWrapErrorString)();\n}\n","// Declare shorthand functions. Sharing these declarations across modules\n// improves both consistency and minification. Unused declarations are\n// dropped by the tree shaking process.\n\n// we capture these, not just for brevity, but for security. If any code\n// modifies Object to change what 'assign' points to, the Realm shim would be\n// corrupted.\n\nexport const {\n  assign,\n  create,\n  freeze,\n  defineProperties, // Object.defineProperty is allowed to fail\n  // silentlty, use Object.defineProperties instead.\n  getOwnPropertyDescriptor,\n  getOwnPropertyDescriptors,\n  getOwnPropertyNames,\n  getPrototypeOf,\n  setPrototypeOf\n} = Object;\n\nexport const {\n  apply,\n  ownKeys // Reflect.ownKeys includes Symbols and unenumerables,\n  // unlike Object.keys()\n} = Reflect;\n\n/**\n * uncurryThis() See\n * http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\n * which only lives at\n * http://web.archive.org/web/20160805225710/http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\n *\n * Performance:\n * 1. The native call is about 10x faster on FF than chrome\n * 2. The version using Function.bind() is about 100x slower on FF,\n *    equal on chrome, 2x slower on Safari\n * 3. The version using a spread and Reflect.apply() is about 10x\n *    slower on FF, equal on chrome, 2x slower on Safari\n *\n * const bind = Function.prototype.bind;\n * const uncurryThis = bind.bind(bind.call);\n */\nconst uncurryThis = fn => (thisArg, ...args) => apply(fn, thisArg, args);\n\n// We also capture these for security: changes to Array.prototype after the\n// Realm shim runs shouldn't affect subsequent Realm operations.\nexport const objectHasOwnProperty = uncurryThis(\n    Object.prototype.hasOwnProperty\n  ),\n  arrayForEach = uncurryThis(Array.prototype.forEach),\n  arrayFilter = uncurryThis(Array.prototype.filter),\n  arrayPush = uncurryThis(Array.prototype.push),\n  arrayPop = uncurryThis(Array.prototype.pop),\n  arrayJoin = uncurryThis(Array.prototype.join),\n  arrayConcat = uncurryThis(Array.prototype.concat),\n  regexpTest = uncurryThis(RegExp.prototype.test),\n  stringMatch = uncurryThis(String.prototype.match),\n  stringIncludes = uncurryThis(String.prototype.includes);\n","import { getOwnPropertyDescriptor } from './commons';\nimport { assert } from './utilities';\n\n// These value properties of the global object are non-writable,\n// non-configurable data properties.\nconst frozenGlobalPropertyNames = [\n  // *** 18.1 Value Properties of the Global Object\n\n  'Infinity',\n  'NaN',\n  'undefined'\n];\n\n// All the following stdlib items have the same name on both our intrinsics\n// object and on the global object. Unlike Infinity/NaN/undefined, these\n// should all be writable and configurable. This is divided into two\n// sets. The stable ones are those the shim can freeze early because\n// we don't expect anyone will want to mutate them. The unstable ones\n// are the ones that we correctly initialize to writable and\n// configurable so that they can still be replaced or removed.\nconst stableGlobalPropertyNames = [\n  // *** 18.2 Function Properties of the Global Object\n\n  // 'eval', // comes from safeEval instead\n  'isFinite',\n  'isNaN',\n  'parseFloat',\n  'parseInt',\n\n  'decodeURI',\n  'decodeURIComponent',\n  'encodeURI',\n  'encodeURIComponent',\n\n  // *** 18.3 Constructor Properties of the Global Object\n\n  'Array',\n  'ArrayBuffer',\n  'Boolean',\n  'DataView',\n  // 'Date',  // Unstable\n  // 'Error',  // Unstable\n  'EvalError',\n  'Float32Array',\n  'Float64Array',\n  // 'Function',  // comes from safeFunction instead\n  'Int8Array',\n  'Int16Array',\n  'Int32Array',\n  'Map',\n  'Number',\n  'Object',\n  // 'Promise',  // Unstable\n  // 'Proxy',  // Unstable\n  'RangeError',\n  'ReferenceError',\n  // 'RegExp',  // Unstable\n  'Set',\n  // 'SharedArrayBuffer'  // removed on Jan 5, 2018\n  'String',\n  'Symbol',\n  'SyntaxError',\n  'TypeError',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Uint16Array',\n  'Uint32Array',\n  'URIError',\n  'WeakMap',\n  'WeakSet',\n\n  // *** 18.4 Other Properties of the Global Object\n\n  // 'Atomics', // removed on Jan 5, 2018\n  'JSON',\n  'Math',\n  'Reflect',\n\n  // *** Annex B\n\n  'escape',\n  'unescape'\n\n  // *** ECMA-402\n\n  // 'Intl'  // Unstable\n\n  // *** ESNext\n\n  // 'Realm' // Comes from createRealmGlobalObject()\n];\n\nconst unstableGlobalPropertyNames = [\n  'Date',\n  'Error',\n  'Promise',\n  'Proxy',\n  'RegExp',\n  'Intl'\n];\n\nexport function getSharedGlobalDescs(unsafeGlobal) {\n  const descriptors = {};\n\n  function describe(names, writable, enumerable, configurable) {\n    for (const name of names) {\n      const desc = getOwnPropertyDescriptor(unsafeGlobal, name);\n      if (desc) {\n        // Abort if an accessor is found on the unsafe global object\n        // instead of a data property. We should never get into this\n        // non standard situation.\n        assert(\n          'value' in desc,\n          `unexpected accessor on global property: ${name}`\n        );\n\n        descriptors[name] = {\n          value: desc.value,\n          writable,\n          enumerable,\n          configurable\n        };\n      }\n    }\n  }\n\n  describe(frozenGlobalPropertyNames, false, false, false);\n  // The following is correct but expensive.\n  // describe(stableGlobalPropertyNames, true, false, true);\n  // Instead, for now, we let these get optimized.\n  //\n  // TODO: We should provide an option to turn this optimization off,\n  // by feeding \"true, false, true\" here instead.\n  describe(stableGlobalPropertyNames, false, false, false);\n  // These we keep replaceable and removable, because we expect\n  // others, e.g., SES, may want to do so.\n  describe(unstableGlobalPropertyNames, true, false, true);\n\n  return descriptors;\n}\n","// Adapted from SES/Caja - Copyright (C) 2011 Google Inc.\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js\n\n/**\n * Replace the legacy accessors of Object to comply with strict mode\n * and ES2016 semantics, we do this by redefining them while in 'use strict'.\n *\n * todo: list the issues resolved\n *\n * This function can be used in two ways: (1) invoked directly to fix the primal\n * realm's Object.prototype, and (2) converted to a string to be executed\n * inside each new RootRealm to fix their Object.prototypes. Evaluation requires\n * the function to have no dependencies, so don't import anything from\n * the outside.\n */\n\n// todo: this file should be moved out to a separate repo and npm module.\nexport function repairAccessors() {\n  const {\n    defineProperty,\n    defineProperties,\n    getOwnPropertyDescriptor,\n    getPrototypeOf,\n    prototype: objectPrototype\n  } = Object;\n\n  // On some platforms, the implementation of these functions act as\n  // if they are in sloppy mode: if they're invoked badly, they will\n  // expose the global object, so we need to repair these for\n  // security. Thus it is our responsibility to fix this, and we need\n  // to include repairAccessors. E.g. Chrome in 2016.\n\n  try {\n    // Verify that the method is not callable.\n    // eslint-disable-next-line no-restricted-properties, no-underscore-dangle\n    (0, objectPrototype.__lookupGetter__)('x');\n  } catch (ignore) {\n    // Throws, no need to patch.\n    return;\n  }\n\n  function toObject(obj) {\n    if (obj === undefined || obj === null) {\n      throw new TypeError(`can't convert undefined or null to object`);\n    }\n    return Object(obj);\n  }\n\n  function asPropertyName(obj) {\n    if (typeof obj === 'symbol') {\n      return obj;\n    }\n    return `${obj}`;\n  }\n\n  function aFunction(obj, accessor) {\n    if (typeof obj !== 'function') {\n      throw TypeError(`invalid ${accessor} usage`);\n    }\n    return obj;\n  }\n\n  defineProperties(objectPrototype, {\n    __defineGetter__: {\n      value: function __defineGetter__(prop, func) {\n        const O = toObject(this);\n        defineProperty(O, prop, {\n          get: aFunction(func, 'getter'),\n          enumerable: true,\n          configurable: true\n        });\n      }\n    },\n    __defineSetter__: {\n      value: function __defineSetter__(prop, func) {\n        const O = toObject(this);\n        defineProperty(O, prop, {\n          set: aFunction(func, 'setter'),\n          enumerable: true,\n          configurable: true\n        });\n      }\n    },\n    __lookupGetter__: {\n      value: function __lookupGetter__(prop) {\n        let O = toObject(this);\n        prop = asPropertyName(prop);\n        let desc;\n        while (O && !(desc = getOwnPropertyDescriptor(O, prop))) {\n          O = getPrototypeOf(O);\n        }\n        return desc && desc.get;\n      }\n    },\n    __lookupSetter__: {\n      value: function __lookupSetter__(prop) {\n        let O = toObject(this);\n        prop = asPropertyName(prop);\n        let desc;\n        while (O && !(desc = getOwnPropertyDescriptor(O, prop))) {\n          O = getPrototypeOf(O);\n        }\n        return desc && desc.set;\n      }\n    }\n  });\n}\n","// Adapted from SES/Caja\n// Copyright (C) 2011 Google Inc.\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js\n\n/**\n * This block replaces the original Function constructor, and the original\n * %GeneratorFunction% %AsyncFunction% and %AsyncGeneratorFunction%, with\n * safe replacements that throw if invoked.\n *\n * These are all reachable via syntax, so it isn't sufficient to just\n * replace global properties with safe versions. Our main goal is to prevent\n * access to the Function constructor through these starting points.\n\n * After this block is done, the originals must no longer be reachable, unless\n * a copy has been made, and funtions can only be created by syntax (using eval)\n * or by invoking a previously saved reference to the originals.\n */\n\n// todo: this file should be moved out to a separate repo and npm module.\nexport function repairFunctions() {\n  const { defineProperties, getPrototypeOf, setPrototypeOf } = Object;\n\n  /**\n   * The process to repair constructors:\n   * 1. Create an instance of the function by evaluating syntax\n   * 2. Obtain the prototype from the instance\n   * 3. Create a substitute tamed constructor\n   * 4. Replace the original constructor with the tamed constructor\n   * 5. Replace tamed constructor prototype property with the original one\n   * 6. Replace its [[Prototype]] slot with the tamed constructor of Function\n   */\n  function repairFunction(name, declaration) {\n    let FunctionInstance;\n    try {\n      // eslint-disable-next-line no-new-func\n      FunctionInstance = (0, eval)(declaration);\n    } catch (e) {\n      if (e instanceof SyntaxError) {\n        // Prevent failure on platforms where async and/or generators\n        // are not supported.\n        return;\n      }\n      // Re-throw\n      throw e;\n    }\n    const FunctionPrototype = getPrototypeOf(FunctionInstance);\n\n    // Prevents the evaluation of source when calling constructor on the\n    // prototype of functions.\n    const TamedFunction = function() {\n      throw new TypeError('Not available');\n    };\n    defineProperties(TamedFunction, { name: { value: name } });\n\n    // (new Error()).constructors does not inherit from Function, because Error\n    // was defined before ES6 classes. So we don't need to repair it too.\n\n    // (Error()).constructor inherit from Function, which gets a tamed\n    // constructor here.\n\n    // todo: in an ES6 class that does not inherit from anything, what does its\n    // constructor inherit from? We worry that it inherits from Function, in\n    // which case instances could give access to unsafeFunction. markm says\n    // we're fine: the constructor inherits from Object.prototype\n\n    // This line replaces the original constructor in the prototype chain\n    // with the tamed one. No copy of the original is peserved.\n    defineProperties(FunctionPrototype, {\n      constructor: { value: TamedFunction }\n    });\n\n    // This line sets the tamed constructor's prototype data property to\n    // the original one.\n    defineProperties(TamedFunction, {\n      prototype: { value: FunctionPrototype }\n    });\n\n    if (TamedFunction !== Function.prototype.constructor) {\n      // Ensures that all functions meet \"instanceof Function\" in a realm.\n      setPrototypeOf(TamedFunction, Function.prototype.constructor);\n    }\n  }\n\n  // Here, the order of operation is important: Function needs to be repaired\n  // first since the other repaired constructors need to inherit from the tamed\n  // Function function constructor.\n\n  // note: this really wants to be part of the standard, because new\n  // constructors may be added in the future, reachable from syntax, and this\n  // list must be updated to match.\n\n  // \"plain arrow functions\" inherit from Function.prototype\n\n  repairFunction('Function', '(function(){})');\n  repairFunction('GeneratorFunction', '(function*(){})');\n  repairFunction('AsyncFunction', '(async function(){})');\n  repairFunction('AsyncGeneratorFunction', '(async function*(){})');\n}\n","// this module must never be importable outside the Realm shim itself\nimport { createCallAndWrapError } from './callAndWrapError';\nimport { getSharedGlobalDescs } from './stdlib';\nimport { repairAccessors } from './repair/accessors';\nimport { repairFunctions } from './repair/functions';\nimport { cleanupSource } from './utilities';\nimport { freeze } from './commons';\n\n// A \"context\" is a fresh unsafe Realm as given to us by existing platforms.\n// We need this to implement the shim. However, when Realms land for real,\n// this feature will be provided by the underlying engine instead.\n\n// note: in a node module, the top-level 'this' is not the global object\n// (it's *something* but we aren't sure what), however an indirect eval of\n// 'this' will be the correct global object.\n\nconst unsafeGlobalSrc = \"'use strict'; this\";\nconst unsafeGlobalEvalSrc = `(0, eval)(\"'use strict'; this\")`;\n\n// This method is only exported for testing purposes.\nexport function createNewUnsafeGlobalForNode() {\n  // Note that webpack and others will shim 'vm' including the method\n  // 'runInNewContext', so the presence of vm is not a useful check\n\n  // TODO: Find a better test that works with bundlers\n  // eslint-disable-next-line no-new-func\n  const isNode = new Function(\n    'try {return this===global}catch(e){return false}'\n  )();\n\n  if (!isNode) {\n    return undefined;\n  }\n\n  // eslint-disable-next-line global-require\n  const vm = require('vm');\n\n  // Use unsafeGlobalEvalSrc to ensure we get the right 'this'.\n  const unsafeGlobal = vm.runInNewContext(unsafeGlobalEvalSrc);\n\n  return unsafeGlobal;\n}\n\n// This method is only exported for testing purposes.\nexport function createNewUnsafeGlobalForBrowser() {\n  if (typeof document === 'undefined') {\n    return undefined;\n  }\n  const iframe = document.createElement('iframe');\n  iframe.style.display = 'none';\n\n  document.body.appendChild(iframe);\n  const unsafeGlobal = iframe.contentWindow.eval(unsafeGlobalSrc);\n\n  // We keep the iframe attached to the DOM because removing it\n  // causes its global object to lose intrinsics, its eval()\n  // function to evaluate code, etc.\n\n  // TODO: can we remove and garbage-collect the iframes?\n\n  return unsafeGlobal;\n}\n\nconst getNewUnsafeGlobal = () => {\n  const newUnsafeGlobalForBrowser = createNewUnsafeGlobalForBrowser();\n  const newUnsafeGlobalForNode = createNewUnsafeGlobalForNode();\n  if (\n    (!newUnsafeGlobalForBrowser && !newUnsafeGlobalForNode) ||\n    (newUnsafeGlobalForBrowser && newUnsafeGlobalForNode)\n  ) {\n    throw new Error('unexpected platform, unable to create Realm');\n  }\n  return newUnsafeGlobalForBrowser || newUnsafeGlobalForNode;\n};\n\n// The unsafeRec is shim-specific. It acts as the mechanism to obtain a fresh\n// set of intrinsics together with their associated eval and Function\n// evaluators. These must be used as a matched set, since the evaluators are\n// tied to a set of intrinsics, aka the \"undeniables\". If it were possible to\n// mix-and-match them from different contexts, that would enable some\n// attacks.\nfunction createUnsafeRec(unsafeGlobal, allShims = []) {\n  const sharedGlobalDescs = getSharedGlobalDescs(unsafeGlobal);\n\n  const unsafeEval = unsafeGlobal.eval;\n  const unsafeFunction = unsafeGlobal.Function;\n\n  const callAndWrapError = createCallAndWrapError(unsafeEval);\n\n  return freeze({\n    unsafeGlobal,\n    sharedGlobalDescs,\n    unsafeEval,\n    unsafeFunction,\n    callAndWrapError,\n    allShims\n  });\n}\n\nconst repairAccessorsShim = cleanupSource(\n  `\"use strict\"; (${repairAccessors})();`\n);\nconst repairFunctionsShim = cleanupSource(\n  `\"use strict\"; (${repairFunctions})();`\n);\n\n// Create a new unsafeRec from a brand new context, with new intrinsics and a\n// new global object\nexport function createNewUnsafeRec(allShims) {\n  const unsafeGlobal = getNewUnsafeGlobal();\n  unsafeGlobal.eval(repairAccessorsShim);\n  unsafeGlobal.eval(repairFunctionsShim);\n  return createUnsafeRec(unsafeGlobal, allShims);\n}\n\n// Create a new unsafeRec from the current context, where the Realm shim is\n// being parsed and executed, aka the \"Primal Realm\"\nexport function createCurrentUnsafeRec() {\n  const unsafeGlobal = (0, eval)(unsafeGlobalSrc);\n  repairAccessors();\n  repairFunctions();\n  return createUnsafeRec(unsafeGlobal);\n}\n","import {\n  arrayFilter,\n  getOwnPropertyDescriptors,\n  getOwnPropertyNames,\n  objectHasOwnProperty,\n  regexpTest\n} from './commons';\n\n// todo: think about how this interacts with endowments, check for conflicts\n// between the names being optimized and the ones added by endowments\n\n/**\n * Simplified validation of indentifier names: may only contain alphanumeric\n * characters (or \"$\" or \"_\"), and may not start with a digit. This is safe\n * and does not reduces the compatibility of the shim. The motivation for\n * this limitation was to decrease the complexity of the implementation,\n * and to maintain a resonable level of performance.\n * Note: \\w is equivalent [a-zA-Z_0-9]\n * See 11.6.1 Identifier Names\n */\nconst identifierPattern = /^[a-zA-Z_$][\\w$]*$/;\n\n/**\n * In JavaScript you cannot use these reserved words as variables.\n * See 11.6.1 Identifier Names\n */\nconst keywords = new Set([\n  // 11.6.2.1 Keywords\n  'await',\n  'break',\n  'case',\n  'catch',\n  'class',\n  'const',\n  'continue',\n  'debugger',\n  'default',\n  'delete',\n  'do',\n  'else',\n  'export',\n  'extends',\n  'finally',\n  'for',\n  'function',\n  'if',\n  'import',\n  'in',\n  'instanceof',\n  'new',\n  'return',\n  'super',\n  'switch',\n  'this',\n  'throw',\n  'try',\n  'typeof',\n  'var',\n  'void',\n  'while',\n  'with',\n  'yield',\n\n  // Also reserved when parsing strict mode code\n  'let',\n  'static',\n\n  // 11.6.2.2 Future Reserved Words\n  'enum',\n\n  // Also reserved when parsing strict mode code\n  'implements',\n  'package',\n  'protected',\n  'interface',\n  'private',\n  'public',\n\n  // Reserved but not mentioned in specs\n  'await',\n\n  'null',\n  'true',\n  'false',\n\n  'this',\n  'arguments'\n]);\n\n/**\n * getOptimizableGlobals()\n * What variable names might it bring into scope? These include all\n * property names which can be variable names, including the names\n * of inherited properties. It excludes symbols and names which are\n * keywords. We drop symbols safely. Currently, this shim refuses\n * service if any of the names are keywords or keyword-like. This is\n * safe and only prevent performance optimization.\n */\nexport function getOptimizableGlobals(safeGlobal) {\n  const descs = getOwnPropertyDescriptors(safeGlobal);\n\n  // getOwnPropertyNames does ignore Symbols so we don't need this extra check:\n  // typeof name === 'string' &&\n  const constants = arrayFilter(getOwnPropertyNames(descs), name => {\n    // Ensure we have a valid identifier. We use regexpTest rather than\n    // /../.test() to guard against the case where RegExp has been poisoned.\n    if (\n      name === 'eval' ||\n      keywords.has(name) ||\n      !regexpTest(identifierPattern, name)\n    ) {\n      return false;\n    }\n\n    const desc = descs[name];\n    return (\n      //\n      // The getters will not have .writable, don't let the falsyness of\n      // 'undefined' trick us: test with === false, not ! . However descriptors\n      // inherit from the (potentially poisoned) global object, so we might see\n      // extra properties which weren't really there. Accessor properties have\n      // 'get/set/enumerable/configurable', while data properties have\n      // 'value/writable/enumerable/configurable'.\n      desc.configurable === false &&\n      desc.writable === false &&\n      //\n      // Checks for data properties because they're the only ones we can\n      // optimize (accessors are most likely non-constant). Descriptors can't\n      // can't have accessors and value properties at the same time, therefore\n      // this check is sufficient. Using explicit own property deal with the\n      // case where Object.prototype has been poisoned.\n      objectHasOwnProperty(desc, 'value')\n    );\n  });\n\n  return constants;\n}\n","import { cleanupSource } from './utilities';\n\n/**\n * ScopeHandler manages a Proxy which serves as the global scope for the\n * safeEvaluator operation (the Proxy is the argument of a 'with' binding).\n * As described in createSafeEvaluator(), it has several functions:\n * - allow the very first (and only the very first) use of 'eval' to map to\n *   the real (unsafe) eval function, so it acts as a 'direct eval' and can\n *    access its lexical scope (which maps to the 'with' binding, which the\n *   ScopeHandler also controls).\n * - ensure that all subsequent uses of 'eval' map to the safeEvaluator,\n *   which lives as the 'eval' property of the safeGlobal.\n * - route all other property lookups at the safeGlobal.\n * - hide the unsafeGlobal which lives on the scope chain above the 'with'.\n * - ensure the Proxy invariants despite some global properties being frozen.\n *\n * @returns {ProxyHandler<any> & Record<string, any>}\n */\nexport function buildScopeHandler(\n  unsafeRec,\n  safeGlobal,\n  endowments = {},\n  sloppyGlobals = false\n) {\n  const { unsafeGlobal, unsafeEval } = unsafeRec;\n\n  const { freeze } = Object;\n  const { get: reflectGet } = Reflect;\n  const { unscopables } = Symbol;\n\n  /**\n   * alwaysThrowHandler is a proxy handler which throws on any trap called.\n   * It's made from a proxy with a get trap that throws. Its target is\n   * an immutable (frozen) object and is safe to share, except accross realms\n   */\n  const alwaysThrowHandler = new Proxy(freeze({}), {\n    get(target, prop) {\n      // todo: replace with throwTantrum\n      throw new TypeError(\n        `unexpected scope handler trap called: ${String(prop)}`\n      );\n    }\n  });\n\n  return {\n    // The scope handler throws if any trap other than get/set/has are run\n    // (e.g. getOwnPropertyDescriptors, apply, getPrototypeOf).\n    // eslint-disable-next-line no-proto\n    __proto__: alwaysThrowHandler,\n\n    // This flag allow us to determine if the eval() call is an done by the\n    // realm's code or if it is user-land invocation, so we can react differently.\n    // We use a property and not an accessor to avoid increasing the stack trace\n    // and reduce the possibility of OOM.\n    useUnsafeEvaluator: false,\n\n    get(shadow, prop) {\n      if (prop === unscopables) {\n        // Safe to return a primal realm Object here because the only code that\n        // can do a get() on a non-string is the internals of with() itself,\n        // and the only thing it does is to look for properties on it. User\n        // code cannot do a lookup on non-strings.\n        return undefined;\n      }\n\n      // Special treatment for eval. The very first lookup of 'eval' gets the\n      // unsafe (real direct) eval, so it will get the lexical scope that uses\n      // the 'with' context.\n      if (prop === 'eval') {\n        // test that it is true rather than merely truthy\n        if (this.useUnsafeEvaluator === true) {\n          // revoke before use\n          this.useUnsafeEvaluator = false;\n          return unsafeEval;\n        }\n        // fall through\n      }\n\n      // Properties of the global.\n      if (prop in endowments) {\n        return reflectGet(endowments, prop, safeGlobal);\n      }\n\n      // Properties of the global.\n      if (prop in safeGlobal) {\n        return safeGlobal[prop];\n      }\n\n      // Prevent the lookup for other properties.\n      return undefined;\n    },\n\n    // eslint-disable-next-line class-methods-use-this\n    set(shadow, prop, value) {\n      // todo: allow modifications when prop in endowments and it\n      // is writable, assuming we've already rejected overlap (see\n      // createSafeEvaluatorFactory.factory). This TypeError gets replaced with\n      // reflectSet(endowments, prop, value, safeGlobal);\n      if (prop in endowments) {\n        // todo: shim integrity: TypeError, String\n        throw new TypeError(`do not modify endowments like ${String(prop)}`);\n      }\n\n      safeGlobal[prop] = value;\n\n      // Return true after successful set.\n      return true;\n    },\n\n    // we need has() to return false for some names to prevent the lookup  from\n    // climbing the scope chain and eventually reaching the unsafeGlobal\n    // object, which is bad.\n\n    // note: unscopables! every string in Object[Symbol.unscopables]\n\n    // todo: we'd like to just have has() return true for everything, and then\n    // use get() to raise a ReferenceError for anything not on the safe global.\n    // But we want to be compatible with ReferenceError in the normal case and\n    // the lack of ReferenceError in the 'typeof' case. Must either reliably\n    // distinguish these two cases (the trap behavior might be different), or\n    // we rely on a mandatory source-to-source transform to change 'typeof abc'\n    // to XXX. We already need a mandatory parse to prevent the 'import',\n    // since it's a special form instead of merely being a global variable/\n\n    // note: if we make has() return true always, then we must implement a\n    // set() trap to avoid subverting the protection of strict mode (it would\n    // accept assignments to undefined globals, when it ought to throw\n    // ReferenceError for such assignments)\n\n    has(shadow, prop) {\n      // proxies stringify 'prop', so no TOCTTOU danger here\n\n      if (sloppyGlobals) {\n        // Everything is potentially available.\n        return true;\n      }\n\n      // unsafeGlobal: hide all properties of unsafeGlobal at the\n      // expense of 'typeof' being wrong for those properties. For\n      // example, in the browser, evaluating 'document = 3', will add\n      // a property to safeGlobal instead of throwing a\n      // ReferenceError.\n      if (\n        prop === 'eval' ||\n        prop in endowments ||\n        prop in safeGlobal ||\n        prop in unsafeGlobal\n      ) {\n        return true;\n      }\n\n      return false;\n    },\n\n    // note: this is likely a bug of safari\n    // https://bugs.webkit.org/show_bug.cgi?id=195534\n\n    getPrototypeOf() {\n      return null;\n    }\n  };\n}\n\nconst buildScopeHandlerString = cleanupSource(\n  `'use strict'; (${buildScopeHandler})`\n);\nexport function createScopeHandler(\n  unsafeRec,\n  safeGlobal,\n  endowments,\n  sloppyGlobals\n) {\n  const { unsafeEval } = unsafeRec;\n  return unsafeEval(buildScopeHandlerString)(\n    unsafeRec,\n    safeGlobal,\n    endowments,\n    sloppyGlobals\n  );\n}\n","import { cleanupSource } from './utilities';\n\nfunction buildSafeEval(unsafeRec, safeEvalOperation) {\n  const { callAndWrapError } = unsafeRec;\n\n  const { defineProperties } = Object;\n\n  // We use the the concise method syntax to create an eval without a\n  // [[Construct]] behavior (such that the invocation \"new eval()\" throws\n  // TypeError: eval is not a constructor\"), but which still accepts a\n  // 'this' binding.\n  const safeEval = {\n    eval() {\n      return callAndWrapError(safeEvalOperation, arguments);\n    }\n  }.eval;\n\n  // safeEval's prototype RootRealm's value and instanceof Function\n  // is true inside the realm. It doesn't point at the primal realm\n  // value, and there is no defense against leaking primal realm\n  // intrinsics.\n\n  defineProperties(safeEval, {\n    toString: {\n      // We break up the following literal string so that an\n      // apparent direct eval syntax does not appear in this\n      // file. Thus, we avoid rejection by the overly eager\n      // rejectDangerousSources.\n      value: () => `function ${'eval'}() { [shim code] }`,\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  return safeEval;\n}\nconst buildSafeEvalString = cleanupSource(`'use strict'; (${buildSafeEval})`);\nexport function createSafeEval(unsafeRec, safeEvalOperation) {\n  const { unsafeEval } = unsafeRec;\n  return unsafeEval(buildSafeEvalString)(unsafeRec, safeEvalOperation);\n}\n","import { cleanupSource } from './utilities';\n\nfunction buildSafeFunction(unsafeRec, safeFunctionOperation) {\n  const { callAndWrapError, unsafeFunction } = unsafeRec;\n\n  const { defineProperties } = Object;\n\n  const safeFunction = function Function() {\n    return callAndWrapError(safeFunctionOperation, arguments);\n  };\n\n  // Ensure that Function from any compartment in a root realm can be used\n  // with instance checks in any compartment of the same root realm.\n\n  defineProperties(safeFunction, {\n    // Ensure that any function created in any compartment in a root realm is an\n    // instance of Function in any compartment of the same root ralm.\n    prototype: { value: unsafeFunction.prototype },\n\n    // Provide a custom output without overwriting the\n    // Function.prototype.toString which is called by some third-party\n    // libraries.\n    toString: {\n      value: () => 'function Function() { [shim code] }',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  return safeFunction;\n}\nconst buildSafeFunctionString = cleanupSource(\n  `'use strict'; (${buildSafeFunction})`\n);\nexport function createSafeFunction(unsafeRec, safeFunctionOperation) {\n  const { unsafeEval } = unsafeRec;\n  return unsafeEval(buildSafeFunctionString)(unsafeRec, safeFunctionOperation);\n}\n","// https://www.ecma-international.org/ecma-262/9.0/index.html#sec-html-like-comments\n// explains that JavaScript parsers may or may not recognize html\n// comment tokens \"<\" immediately followed by \"!--\" and \"--\"\n// immediately followed by \">\" in non-module source text, and treat\n// them as a kind of line comment. Since otherwise both of these can\n// appear in normal JavaScript source code as a sequence of operators,\n// we have the terrifying possibility of the same source code parsing\n// one way on one correct JavaScript implementation, and another way\n// on another.\n//\n// This shim takes the conservative strategy of just rejecting source\n// text that contains these strings anywhere. Note that this very\n// source file is written strangely to avoid mentioning these\n// character strings explicitly.\n\n// We do not write the regexp in a straightforward way, so that an\n// apparennt html comment does not appear in this file. Thus, we avoid\n// rejection by the overly eager rejectDangerousSources.\nconst htmlCommentPattern = new RegExp(`(?:${'<'}!--|--${'>'})`);\n\nfunction rejectHtmlComments(s) {\n  const index = s.search(htmlCommentPattern);\n  if (index !== -1) {\n    const linenum = s.slice(0, index).split('\\n').length; // more or less\n    throw new SyntaxError(\n      `possible html comment syntax rejected around line ${linenum}`\n    );\n  }\n}\n\n// The proposed dynamic import expression is the only syntax currently\n// proposed, that can appear in non-module JavaScript code, that\n// enables direct access to the outside world that cannot be\n// surpressed or intercepted without parsing and rewriting. Instead,\n// this shim conservatively rejects any source text that seems to\n// contain such an expression. To do this safely without parsing, we\n// must also reject some valid programs, i.e., those containing\n// apparent import expressions in literal strings or comments.\n\n// The current conservative rule looks for the identifier \"import\"\n// followed by either an open paren or something that looks like the\n// beginning of a comment. We assume that we do not need to worry\n// about html comment syntax because that was already rejected by\n// rejectHtmlComments.\n\n// this \\s *must* match all kinds of syntax-defined whitespace. If e.g.\n// U+2028 (LINE SEPARATOR) or U+2029 (PARAGRAPH SEPARATOR) is treated as\n// whitespace by the parser, but not matched by /\\s/, then this would admit\n// an attack like: import\\u2028('power.js') . We're trying to distinguish\n// something like that from something like importnotreally('power.js') which\n// is perfectly safe.\n\nconst importPattern = /\\bimport\\s*(?:\\(|\\/[/*])/;\n\nfunction rejectImportExpressions(s) {\n  const index = s.search(importPattern);\n  if (index !== -1) {\n    const linenum = s.slice(0, index).split('\\n').length; // more or less\n    throw new SyntaxError(\n      `possible import expression rejected around line ${linenum}`\n    );\n  }\n}\n\n// The shim cannot correctly emulate a direct eval as explained at\n// https://github.com/Agoric/realms-shim/issues/12\n// Without rejecting apparent direct eval syntax, we would\n// accidentally evaluate these with an emulation of indirect eval. Tp\n// prevent future compatibility problems, in shifting from use of the\n// shim to genuine platform support for the proposal, we should\n// instead statically reject code that seems to contain a direct eval\n// expression.\n//\n// As with the dynamic import expression, to avoid a full parse, we do\n// this approximately with a regexp, that will also reject strings\n// that appear safely in comments or strings. Unlike dynamic import,\n// if we miss some, this only creates future compat problems, not\n// security problems. Thus, we are only trying to catch innocent\n// occurrences, not malicious one. In particular, `(eval)(...)` is\n// direct eval syntax that would not be caught by the following regexp.\n\nconst someDirectEvalPattern = /\\beval\\s*(?:\\(|\\/[/*])/;\n\nfunction rejectSomeDirectEvalExpressions(s) {\n  const index = s.search(someDirectEvalPattern);\n  if (index !== -1) {\n    const linenum = s.slice(0, index).split('\\n').length; // more or less\n    throw new SyntaxError(\n      `possible direct eval expression rejected around line ${linenum}`\n    );\n  }\n}\n\nexport function rejectDangerousSources(s) {\n  rejectHtmlComments(s);\n  rejectImportExpressions(s);\n  rejectSomeDirectEvalExpressions(s);\n}\n\n// Export a rewriter transform.\nexport const rejectDangerousSourcesTransform = {\n  rewrite(rs) {\n    rejectDangerousSources(rs.src);\n    return rs;\n  }\n};\n","// Portions adapted from V8 - Copyright 2016 the V8 project authors.\n// https://github.com/v8/v8/blob/master/src/builtins/builtins-function.cc\n\nimport { assert, throwTantrum } from './utilities';\nimport {\n  apply,\n  arrayConcat,\n  arrayJoin,\n  arrayPop,\n  create,\n  getOwnPropertyDescriptors,\n  getPrototypeOf,\n  regexpTest,\n  stringIncludes\n} from './commons';\nimport { getOptimizableGlobals } from './optimizer';\nimport { createScopeHandler } from './scopeHandlerFacade';\nimport { createSafeEval } from './safeEvalFacade';\nimport { createSafeFunction } from './safeFunctionFacade';\nimport { rejectDangerousSourcesTransform } from './sourceParser';\n\nfunction buildOptimizer(constants) {\n  // No need to build an oprimizer when there are no constants.\n  if (constants.length === 0) return '';\n  // Use 'this' to avoid going through the scope proxy, which is unecessary\n  // since the optimizer only needs references to the safe global.\n  return `const {${arrayJoin(constants, ',')}} = this;`;\n}\n\nfunction createScopedEvaluatorFactory(unsafeRec, constants) {\n  const { unsafeFunction } = unsafeRec;\n\n  const optimizer = buildOptimizer(constants);\n\n  // Create a function in sloppy mode, so that we can use 'with'. It returns\n  // a function in strict mode that evaluates the provided code using direct\n  // eval, and thus in strict mode in the same scope. We must be very careful\n  // to not create new names in this scope\n\n  // 1: we use 'with' (around a Proxy) to catch all free variable names. The\n  // first 'arguments[0]' holds the Proxy which safely wraps the safeGlobal\n  // 2: 'optimizer' catches common variable names for speed\n  // 3: The inner strict function is effectively passed two parameters:\n  //    a) its arguments[0] is the source to be directly evaluated.\n  //    b) its 'this' is the this binding seen by the code being\n  //       directly evaluated.\n\n  // everything in the 'optimizer' string is looked up in the proxy\n  // (including an 'arguments[0]', which points at the Proxy). 'function' is\n  // a keyword, not a variable, so it is not looked up. then 'eval' is looked\n  // up in the proxy, that's the first time it is looked up after\n  // useUnsafeEvaluator is turned on, so the proxy returns the real the\n  // unsafeEval, which satisfies the IsDirectEvalTrap predicate, so it uses\n  // the direct eval and gets the lexical scope. The second 'arguments[0]' is\n  // looked up in the context of the inner function. The *contents* of\n  // arguments[0], because we're using direct eval, are looked up in the\n  // Proxy, by which point the useUnsafeEvaluator switch has been flipped\n  // back to 'false', so any instances of 'eval' in that string will get the\n  // safe evaluator.\n\n  return unsafeFunction(`\n    with (arguments[0]) {\n      ${optimizer}\n      return function() {\n        'use strict';\n        return eval(arguments[0]);\n      };\n    }\n  `);\n}\n\nfunction applyTransforms(rewriterState, transforms) {\n  // Clone before calling transforms.\n  rewriterState = {\n    src: `${rewriterState.src}`,\n    endowments: create(\n      null,\n      getOwnPropertyDescriptors(rewriterState.endowments)\n    )\n  };\n\n  // Rewrite the source, threading through rewriter state as necessary.\n  rewriterState = transforms.reduce(\n    (rs, transform) => (transform.rewrite ? transform.rewrite(rs) : rs),\n    rewriterState\n  );\n\n  // Clone after transforms\n  rewriterState = {\n    src: `${rewriterState.src}`,\n    endowments: create(\n      null,\n      getOwnPropertyDescriptors(rewriterState.endowments)\n    )\n  };\n\n  return rewriterState;\n}\n\nexport function createSafeEvaluatorFactory(\n  unsafeRec,\n  safeGlobal,\n  transforms,\n  sloppyGlobals\n) {\n  const constants = getOptimizableGlobals(safeGlobal);\n  const scopedEvaluatorFactory = createScopedEvaluatorFactory(\n    unsafeRec,\n    constants\n  );\n\n  function factory(endowments = {}, options = {}) {\n    // todo clone all arguments passed to returned function\n    const localTransforms = options.transforms || [];\n    const realmTransforms = transforms || [];\n\n    const mandatoryTransforms = [rejectDangerousSourcesTransform];\n    const allTransforms = arrayConcat(\n      localTransforms,\n      realmTransforms,\n      mandatoryTransforms\n    );\n\n    function safeEvalOperation(src) {\n      let rewriterState = { src, endowments };\n      rewriterState = applyTransforms(rewriterState, allTransforms);\n\n      const scopeHandler = createScopeHandler(\n        unsafeRec,\n        safeGlobal,\n        rewriterState.endowments,\n        sloppyGlobals\n      );\n      const scopeProxyRevocable = Proxy.revocable({}, scopeHandler);\n      const scopeProxy = scopeProxyRevocable.proxy;\n      const scopedEvaluator = apply(scopedEvaluatorFactory, safeGlobal, [\n        scopeProxy\n      ]);\n\n      scopeHandler.useUnsafeEvaluator = true;\n      let err;\n      try {\n        // Ensure that \"this\" resolves to the safe global.\n        return apply(scopedEvaluator, safeGlobal, [rewriterState.src]);\n      } catch (e) {\n        // stash the child-code error in hopes of debugging the internal failure\n        err = e;\n        throw e;\n      } finally {\n        if (scopeHandler.useUnsafeEvaluator) {\n          // the proxy switches this off immediately after ths\n          // first access, but if that's not the case we prevent\n          // further variable resolution on the scope and abort.\n          scopeProxyRevocable.revoke();\n          throwTantrum('handler did not revoke useUnsafeEvaluator', err);\n        }\n      }\n    }\n\n    return safeEvalOperation;\n  }\n\n  return factory;\n}\n\nexport function createSafeEvaluator(unsafeRec, safeEvalOperation) {\n  const { unsafeFunction } = unsafeRec;\n\n  const safeEval = createSafeEval(unsafeRec, safeEvalOperation);\n\n  assert(getPrototypeOf(safeEval).constructor !== Function, 'hide Function');\n  assert(\n    getPrototypeOf(safeEval).constructor !== unsafeFunction,\n    'hide unsafeFunction'\n  );\n\n  return safeEval;\n}\n\nexport function createSafeEvaluatorWhichTakesEndowments(safeEvaluatorFactory) {\n  return (x, endowments, options = {}) =>\n    safeEvaluatorFactory(endowments, options)(x);\n}\n\n/**\n * A safe version of the native Function which relies on\n * the safety of evalEvaluator for confinement.\n */\nexport function createFunctionEvaluator(unsafeRec, safeEvalOperation) {\n  const { unsafeGlobal, unsafeFunction } = unsafeRec;\n\n  function safeFunctionOperation(...params) {\n    const functionBody = `${arrayPop(params) || ''}`;\n    let functionParams = `${arrayJoin(params, ',')}`;\n    if (!regexpTest(/^[\\w\\s,]*$/, functionParams)) {\n      throw new SyntaxError(\n        'shim limitation: Function arg must be simple ASCII identifiers, possibly separated by commas: no default values, pattern matches, or non-ASCII parameter names'\n      );\n      // this protects against Matt Austin's clever attack:\n      // Function(\"arg=`\", \"/*body`){});({x: this/**/\")\n      // which would turn into\n      //     (function(arg=`\n      //     /*``*/){\n      //      /*body`){});({x: this/**/\n      //     })\n      // which parses as a default argument of `\\n/*``*/){\\n/*body` , which\n      // is a pair of template literals back-to-back (so the first one\n      // nominally evaluates to the parser to use on the second one), which\n      // can't actually execute (because the first literal evals to a string,\n      // which can't be a parser function), but that doesn't matter because\n      // the function is bypassed entirely. When that gets evaluated, it\n      // defines (but does not invoke) a function, then evaluates a simple\n      // {x: this} expression, giving access to the safe global.\n    }\n\n    // Is this a real functionBody, or is someone attempting an injection\n    // attack? This will throw a SyntaxError if the string is not actually a\n    // function body. We coerce the body into a real string above to prevent\n    // someone from passing an object with a toString() that returns a safe\n    // string the first time, but an evil string the second time.\n    // eslint-disable-next-line no-new, new-cap\n    new unsafeFunction(functionBody);\n\n    if (stringIncludes(functionParams, ')')) {\n      // If the formal parameters string include ) - an illegal\n      // character - it may make the combined function expression\n      // compile. We avoid this problem by checking for this early on.\n\n      // note: v8 throws just like this does, but chrome accepts\n      // e.g. 'a = new Date()'\n      throw new unsafeGlobal.SyntaxError(\n        'shim limitation: Function arg string contains parenthesis'\n      );\n      // todo: shim integrity threat if they change SyntaxError\n    }\n\n    // todo: check to make sure this .length is safe. markm says safe.\n    if (functionParams.length > 0) {\n      // If the formal parameters include an unbalanced block comment, the\n      // function must be rejected. Since JavaScript does not allow nested\n      // comments we can include a trailing block comment to catch this.\n      functionParams += '\\n/*``*/';\n    }\n\n    const src = `(function(${functionParams}){\\n${functionBody}\\n})`;\n\n    return safeEvalOperation(src);\n  }\n\n  const safeFunction = createSafeFunction(unsafeRec, safeFunctionOperation);\n\n  assert(\n    getPrototypeOf(safeFunction).constructor !== Function,\n    'hide Function'\n  );\n  assert(\n    getPrototypeOf(safeFunction).constructor !== unsafeFunction,\n    'hide unsafeFunction'\n  );\n\n  return safeFunction;\n}\n","import { createRealmFacade, buildChildRealm } from './realmFacade';\nimport { createNewUnsafeRec, createCurrentUnsafeRec } from './unsafeRec';\nimport {\n  createSafeEvaluatorFactory,\n  createSafeEvaluator,\n  createSafeEvaluatorWhichTakesEndowments,\n  createFunctionEvaluator\n} from './evaluators';\nimport { assert } from './utilities';\nimport { create, defineProperties, freeze, arrayConcat } from './commons';\n\n// Mimic private members on the realm instances.\n// We define it in the same module and do not export it.\nconst RealmRecForRealmInstance = new WeakMap();\n\nfunction getRealmRecForRealmInstance(realm) {\n  // Detect non-objects.\n  assert(Object(realm) === realm, 'bad object, not a Realm instance');\n  // Realm instance has no realmRec. Should not proceed.\n  assert(RealmRecForRealmInstance.has(realm), 'Realm instance has no record');\n\n  return RealmRecForRealmInstance.get(realm);\n}\n\nfunction registerRealmRecForRealmInstance(realm, realmRec) {\n  // Detect non-objects.\n  assert(Object(realm) === realm, 'bad object, not a Realm instance');\n  // Attempt to change an existing realmRec on a realm instance. Should not proceed.\n  assert(\n    !RealmRecForRealmInstance.has(realm),\n    'Realm instance already has a record'\n  );\n\n  RealmRecForRealmInstance.set(realm, realmRec);\n}\n\n// Initialize the global variables for the new Realm.\nfunction setDefaultBindings(safeGlobal, safeEval, safeFunction) {\n  defineProperties(safeGlobal, {\n    eval: {\n      value: safeEval,\n      writable: true,\n      configurable: true\n    },\n    Function: {\n      value: safeFunction,\n      writable: true,\n      configurable: true\n    }\n  });\n}\n\nfunction createRealmRec(unsafeRec, transforms, sloppyGlobals) {\n  const { sharedGlobalDescs, unsafeGlobal } = unsafeRec;\n\n  const safeGlobal = create(unsafeGlobal.Object.prototype, sharedGlobalDescs);\n\n  const safeEvaluatorFactory = createSafeEvaluatorFactory(\n    unsafeRec,\n    safeGlobal,\n    transforms,\n    sloppyGlobals\n  );\n  const safeEvalOperation = safeEvaluatorFactory();\n  const safeEval = createSafeEvaluator(unsafeRec, safeEvalOperation);\n  const safeFunction = createFunctionEvaluator(unsafeRec, safeEvalOperation);\n  const safeEvalWhichTakesEndowments = createSafeEvaluatorWhichTakesEndowments(\n    safeEvaluatorFactory\n  );\n\n  setDefaultBindings(safeGlobal, safeEval, safeFunction);\n\n  const realmRec = freeze({\n    safeGlobal,\n    safeEval,\n    safeEvalWhichTakesEndowments,\n    safeFunction\n  });\n\n  return realmRec;\n}\n\n/**\n * A root realm uses a fresh set of new intrinics. Here we first create\n * a new unsafe record, which inherits the shims. Then we proceed with\n * the creation of the realm record, and we apply the shims.\n */\nfunction initRootRealm(parentUnsafeRec, self, options) {\n  // note: 'self' is the instance of the Realm.\n\n  // todo: investigate attacks via Array.species\n  // todo: this accepts newShims='string', but it should reject that\n  const { shims: newShims, transforms, sloppyGlobals } = options;\n  const allShims = arrayConcat(parentUnsafeRec.allShims, newShims);\n\n  // The unsafe record is created already repaired.\n  const unsafeRec = createNewUnsafeRec(allShims);\n\n  // eslint-disable-next-line no-use-before-define\n  const Realm = createRealmFacade(unsafeRec, BaseRealm);\n\n  // Add a Realm descriptor to sharedGlobalDescs, so it can be defined onto the\n  // safeGlobal like the rest of the globals.\n  unsafeRec.sharedGlobalDescs.Realm = {\n    value: Realm,\n    writable: true,\n    configurable: true\n  };\n\n  // Creating the realmRec provides the global object, eval() and Function()\n  // to the realm.\n  const realmRec = createRealmRec(unsafeRec, transforms, sloppyGlobals);\n\n  // Apply all shims in the new RootRealm. We don't do this for compartments.\n  const { safeEvalWhichTakesEndowments } = realmRec;\n  for (const shim of allShims) {\n    safeEvalWhichTakesEndowments(shim);\n  }\n\n  // The realmRec acts as a private field on the realm instance.\n  registerRealmRecForRealmInstance(self, realmRec);\n}\n\n/**\n * A compartment shares the intrinsics of its root realm. Here, only a\n * realmRec is necessary to hold the global object, eval() and Function().\n */\nfunction initCompartment(unsafeRec, self, options = {}) {\n  // note: 'self' is the instance of the Realm.\n\n  const { transforms, sloppyGlobals } = options;\n  const realmRec = createRealmRec(unsafeRec, transforms, sloppyGlobals);\n\n  // The realmRec acts as a private field on the realm instance.\n  registerRealmRecForRealmInstance(self, realmRec);\n}\n\nfunction getRealmGlobal(self) {\n  const { safeGlobal } = getRealmRecForRealmInstance(self);\n  return safeGlobal;\n}\n\nfunction realmEvaluate(self, x, endowments = {}, options = {}) {\n  // todo: don't pass in primal-realm objects like {}, for safety. OTOH its\n  // properties are copied onto the new global 'target'.\n  // todo: figure out a way to membrane away the contents to safety.\n  const { safeEvalWhichTakesEndowments } = getRealmRecForRealmInstance(self);\n  return safeEvalWhichTakesEndowments(x, endowments, options);\n}\n\nconst BaseRealm = {\n  initRootRealm,\n  initCompartment,\n  getRealmGlobal,\n  realmEvaluate\n};\n\n// Create the current unsafeRec from the current \"primal\" environment (the realm\n// where the Realm shim is loaded and executed).\nconst currentUnsafeRec = createCurrentUnsafeRec();\n\n/**\n * The \"primal\" realm class is defined in the current \"primal\" environment,\n * and is part of the shim. There is no need to facade this class via evaluation\n * because both share the same intrinsics.\n */\nconst Realm = buildChildRealm(currentUnsafeRec, BaseRealm);\n\nexport default Realm;\n"],"names":[],"mappings":";;;;;;EAAA;EACA;EACA;EACA;;AAEA,EAAO,SAAS,YAAY,CAAC,CAAC,EAAE,GAAG,GAAG,SAAS,EAAE;EACjD,EAAE,MAAM,GAAG,GAAG,CAAC,mCAAmC,EAAE,CAAC,CAAC,CAAC,CAAC;;EAExD;EACA;EACA,EAAE,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;EACrB,EAAE,IAAI,GAAG,EAAE;EACX;EACA,IAAI,OAAO,CAAC,KAAK,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;EAC5B;EACA,IAAI,OAAO,CAAC,KAAK,CAAC,CAAC,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;EAClC,GAAG;;EAEH;EACA,EAAE,SAAS;EACX,EAAE,MAAM,GAAG,CAAC;EACZ,CAAC;;AAED,EAAO,SAAS,MAAM,CAAC,SAAS,EAAE,OAAO,EAAE;EAC3C,EAAE,IAAI,CAAC,SAAS,EAAE;EAClB,IAAI,YAAY,CAAC,OAAO,CAAC,CAAC;EAC1B,GAAG;EACH,CAAC;;EAED;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACA,EAAO,SAAS,aAAa,CAAC,GAAG,EAAE;EACnC;EACA;EACA,EAAE,GAAG,GAAG,GAAG,CAAC,OAAO,CAAC,qBAAqB,EAAE,WAAW,CAAC,CAAC;;EAExD;EACA;EACA,EAAE,GAAG,GAAG,GAAG,CAAC,OAAO,CAAC,qBAAqB,EAAE,SAAS,CAAC,CAAC;;EAEtD;EACA,EAAE,GAAG,GAAG,GAAG,CAAC,OAAO,CAAC,oBAAoB,EAAE,EAAE,CAAC,CAAC;;EAE9C,EAAE,OAAO,GAAG,CAAC;EACb,CAAC;;ECpDD;EACA;;AAEA,EAAO,SAAS,eAAe,CAAC,SAAS,EAAE,SAAS,EAAE;EACtD,EAAE,MAAM,EAAE,gBAAgB,EAAE,GAAG,SAAS,CAAC;EACzC,EAAE,MAAM;EACR,IAAI,aAAa;EACjB,IAAI,eAAe;EACnB,IAAI,cAAc;EAClB,IAAI,aAAa;EACjB,GAAG,GAAG,SAAS,CAAC;;EAEhB,EAAE,MAAM,EAAE,MAAM,EAAE,gBAAgB,EAAE,GAAG,MAAM,CAAC;;EAE9C,EAAE,MAAM,KAAK,CAAC;EACd,IAAI,WAAW,GAAG;EAClB;EACA;EACA;EACA;;EAEA;EACA;EACA,MAAM,MAAM,IAAI,SAAS,CAAC,4BAA4B,CAAC,CAAC;EACxD,KAAK;;EAEL,IAAI,OAAO,aAAa,CAAC,OAAO,GAAG,EAAE,EAAE;EACvC;;EAEA;EACA,MAAM,MAAM,CAAC,GAAG,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;EACxC,MAAM,gBAAgB,CAAC,aAAa,EAAE,CAAC,SAAS,EAAE,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC;EAC/D,MAAM,OAAO,CAAC,CAAC;EACf,KAAK;;EAEL,IAAI,OAAO,eAAe,CAAC,OAAO,GAAG,EAAE,EAAE;EACzC;EACA,MAAM,MAAM,CAAC,GAAG,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;EACxC,MAAM,gBAAgB,CAAC,eAAe,EAAE,CAAC,SAAS,EAAE,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC;EACjE,MAAM,OAAO,CAAC,CAAC;EACf,KAAK;;EAEL;EACA;EACA;;EAEA,IAAI,IAAI,MAAM,GAAG;EACjB;EACA;EACA;EACA;EACA,MAAM,OAAO,gBAAgB,CAAC,cAAc,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC;EACtD,KAAK;;EAEL,IAAI,QAAQ,CAAC,CAAC,EAAE,UAAU,EAAE,OAAO,GAAG,EAAE,EAAE;EAC1C;EACA,MAAM,OAAO,gBAAgB,CAAC,aAAa,EAAE,CAAC,IAAI,EAAE,CAAC,EAAE,UAAU,EAAE,OAAO,CAAC,CAAC,CAAC;EAC7E,KAAK;EACL,GAAG;;EAEH,EAAE,gBAAgB,CAAC,KAAK,EAAE;EAC1B,IAAI,QAAQ,EAAE;EACd,MAAM,KAAK,EAAE,MAAM,kCAAkC;EACrD,MAAM,QAAQ,EAAE,KAAK;EACrB,MAAM,UAAU,EAAE,KAAK;EACvB,MAAM,YAAY,EAAE,IAAI;EACxB,KAAK;EACL,GAAG,CAAC,CAAC;;EAEL,EAAE,gBAAgB,CAAC,KAAK,CAAC,SAAS,EAAE;EACpC,IAAI,QAAQ,EAAE;EACd,MAAM,KAAK,EAAE,MAAM,gBAAgB;EACnC,MAAM,QAAQ,EAAE,KAAK;EACrB,MAAM,UAAU,EAAE,KAAK;EACvB,MAAM,YAAY,EAAE,IAAI;EACxB,KAAK;EACL,GAAG,CAAC,CAAC;;EAEL,EAAE,OAAO,KAAK,CAAC;EACf,CAAC;;EAED;EACA;EACA;EACA,MAAM,qBAAqB,GAAG,aAAa;EAC3C,EAAE,CAAC,eAAe,EAAE,eAAe,CAAC,CAAC,CAAC;EACtC,CAAC,CAAC;;AAEF,EAAO,SAAS,iBAAiB,CAAC,SAAS,EAAE,SAAS,EAAE;EACxD,EAAE,MAAM,EAAE,UAAU,EAAE,GAAG,SAAS,CAAC;EACnC;EACA;EACA;;EAEA;EACA;EACA;EACA;;EAEA;EACA;EACA;;EAEA;EACA,EAAE,OAAO,UAAU,CAAC,qBAAqB,CAAC,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC;EACjE,CAAC;;ECzGD,SAAS,qBAAqB,GAAG;EACjC;EACA;EACA;EACA;EACA;EACA,EAAE,MAAM,EAAE,cAAc,EAAE,GAAG,MAAM,CAAC;EACpC,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG,OAAO,CAAC;EAC5B,EAAE,MAAM,WAAW,GAAG,EAAE,IAAI,CAAC,OAAO,EAAE,GAAG,IAAI,KAAK,KAAK,CAAC,EAAE,EAAE,OAAO,EAAE,IAAI,CAAC,CAAC;EAC3E,EAAE,MAAM,MAAM,GAAG,WAAW,CAAC,GAAG,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;EAChD,EAAE,MAAM,MAAM,GAAG,WAAW,CAAC,GAAG,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;;EAEhD,EAAE,MAAM,2BAA2B,GAAG,IAAI,GAAG,CAAC;EAC9C,IAAI,CAAC,WAAW,EAAE,SAAS,CAAC;EAC5B,IAAI,CAAC,YAAY,EAAE,UAAU,CAAC;EAC9B,IAAI,CAAC,gBAAgB,EAAE,cAAc,CAAC;EACtC,IAAI,CAAC,aAAa,EAAE,WAAW,CAAC;EAChC,IAAI,CAAC,WAAW,EAAE,SAAS,CAAC;EAC5B,IAAI,CAAC,UAAU,EAAE,QAAQ,CAAC;EAC1B,GAAG,CAAC,CAAC;EACL,EAAE,MAAM,iBAAiB,GAAG,IAAI,GAAG,CAAC;EACpC,IAAI,SAAS,CAAC,SAAS;EACvB,IAAI,UAAU,CAAC,SAAS;EACxB,IAAI,cAAc,CAAC,SAAS;EAC5B,IAAI,WAAW,CAAC,SAAS;EACzB,IAAI,SAAS,CAAC,SAAS;EACvB,IAAI,QAAQ,CAAC,SAAS;EACtB,IAAI,KAAK,CAAC,SAAS;EACnB,GAAG,CAAC,CAAC;;EAEL,EAAE,SAAS,gBAAgB,CAAC,MAAM,EAAE,IAAI,EAAE;EAC1C,IAAI,IAAI;EACR,MAAM,OAAO,KAAK,CAAC,MAAM,EAAE,SAAS,EAAE,IAAI,CAAC,CAAC;EAC5C,KAAK,CAAC,OAAO,GAAG,EAAE;EAClB;EACA,MAAM,IAAI,MAAM,CAAC,GAAG,CAAC,KAAK,GAAG,EAAE;EAC/B;EACA,QAAQ,MAAM,GAAG,CAAC;EAClB,OAAO;;EAEP;EACA,MAAM,IAAI,MAAM,CAAC,iBAAiB,EAAE,cAAc,CAAC,GAAG,CAAC,CAAC,EAAE;EAC1D;EACA;EACA;EACA;EACA;EACA,QAAQ,MAAM,GAAG,CAAC;EAClB,OAAO;;EAEP;EACA,MAAM,IAAI,KAAK,EAAE,QAAQ,EAAE,MAAM,CAAC;EAClC,MAAM,IAAI;EACV;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,QAAQ,KAAK,GAAG,CAAC,EAAE,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC;EAC9B,QAAQ,QAAQ,GAAG,CAAC,EAAE,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC;EACpC,QAAQ,MAAM,GAAG,CAAC,EAAE,GAAG,CAAC,KAAK,IAAI,QAAQ,CAAC,CAAC,CAAC;EAC5C;EACA;EACA,OAAO,CAAC,OAAO,OAAO,EAAE;EACxB;EACA,QAAQ,MAAM,IAAI,KAAK,CAAC,eAAe,CAAC,CAAC;EACzC,OAAO;EACP,MAAM,MAAM,gBAAgB;EAC5B,QAAQ,MAAM,CAAC,2BAA2B,EAAE,KAAK,CAAC,IAAI,KAAK,CAAC;EAC5D,MAAM,IAAI;EACV,QAAQ,MAAM,IAAI,gBAAgB,CAAC,QAAQ,CAAC,CAAC;EAC7C,OAAO,CAAC,OAAO,IAAI,EAAE;EACrB,QAAQ,IAAI,CAAC,KAAK,GAAG,MAAM,CAAC;EAC5B,QAAQ,MAAM,IAAI,CAAC;EACnB,OAAO;EACP,KAAK;EACL,GAAG;;EAEH,EAAE,OAAO,gBAAgB,CAAC;EAC1B,CAAC;;EAED,MAAM,2BAA2B,GAAG,aAAa;EACjD,EAAE,CAAC,eAAe,EAAE,qBAAqB,CAAC,CAAC,CAAC;EAC5C,CAAC,CAAC;AACF,EAAO,SAAS,sBAAsB,CAAC,UAAU,EAAE;EACnD,EAAE,OAAO,UAAU,CAAC,2BAA2B,CAAC,EAAE,CAAC;EACnD,CAAC;;EChGD;EACA;EACA;;EAEA;EACA;EACA;;AAEA,EAAO,MAAM;EACb,EAAE,MAAM;EACR,EAAE,MAAM;EACR,EAAE,MAAM;EACR,EAAE,gBAAgB;EAClB;EACA,EAAE,wBAAwB;EAC1B,EAAE,yBAAyB;EAC3B,EAAE,mBAAmB;EACrB,EAAE,cAAc;EAChB,EAAE,cAAc;EAChB,CAAC,GAAG,MAAM,CAAC;;AAEX,EAAO,MAAM;EACb,EAAE,KAAK;EACP,EAAE,OAAO;EACT;EACA,CAAC,GAAG,OAAO,CAAC;;EAEZ;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,MAAM,WAAW,GAAG,EAAE,IAAI,CAAC,OAAO,EAAE,GAAG,IAAI,KAAK,KAAK,CAAC,EAAE,EAAE,OAAO,EAAE,IAAI,CAAC,CAAC;;EAEzE;EACA;AACA,AAAY,QAAC,oBAAoB,GAAG,WAAW;EAC/C,IAAI,MAAM,CAAC,SAAS,CAAC,cAAc;EACnC,GAAG,CAAC;EACJ,EAAE,AACA,WAAW,GAAG,WAAW,CAAC,KAAK,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;EACpD,EAAE,AACA,QAAQ,GAAG,WAAW,CAAC,KAAK,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;EAC9C,EAAE,SAAS,GAAG,WAAW,CAAC,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;EAChD,EAAE,WAAW,GAAG,WAAW,CAAC,KAAK,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;EACpD,EAAE,UAAU,GAAG,WAAW,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;EAClD,EAAE,AACA,cAAc,GAAG,WAAW,CAAC,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC;;ECvDzD;EACA;EACA,MAAM,yBAAyB,GAAG;EAClC;;EAEA,EAAE,UAAU;EACZ,EAAE,KAAK;EACP,EAAE,WAAW;EACb,CAAC,CAAC;;EAEF;EACA;EACA;EACA;EACA;EACA;EACA;EACA,MAAM,yBAAyB,GAAG;EAClC;;EAEA;EACA,EAAE,UAAU;EACZ,EAAE,OAAO;EACT,EAAE,YAAY;EACd,EAAE,UAAU;;EAEZ,EAAE,WAAW;EACb,EAAE,oBAAoB;EACtB,EAAE,WAAW;EACb,EAAE,oBAAoB;;EAEtB;;EAEA,EAAE,OAAO;EACT,EAAE,aAAa;EACf,EAAE,SAAS;EACX,EAAE,UAAU;EACZ;EACA;EACA,EAAE,WAAW;EACb,EAAE,cAAc;EAChB,EAAE,cAAc;EAChB;EACA,EAAE,WAAW;EACb,EAAE,YAAY;EACd,EAAE,YAAY;EACd,EAAE,KAAK;EACP,EAAE,QAAQ;EACV,EAAE,QAAQ;EACV;EACA;EACA,EAAE,YAAY;EACd,EAAE,gBAAgB;EAClB;EACA,EAAE,KAAK;EACP;EACA,EAAE,QAAQ;EACV,EAAE,QAAQ;EACV,EAAE,aAAa;EACf,EAAE,WAAW;EACb,EAAE,YAAY;EACd,EAAE,mBAAmB;EACrB,EAAE,aAAa;EACf,EAAE,aAAa;EACf,EAAE,UAAU;EACZ,EAAE,SAAS;EACX,EAAE,SAAS;;EAEX;;EAEA;EACA,EAAE,MAAM;EACR,EAAE,MAAM;EACR,EAAE,SAAS;;EAEX;;EAEA,EAAE,QAAQ;EACV,EAAE,UAAU;;EAEZ;;EAEA;;EAEA;;EAEA;EACA,CAAC,CAAC;;EAEF,MAAM,2BAA2B,GAAG;EACpC,EAAE,MAAM;EACR,EAAE,OAAO;EACT,EAAE,SAAS;EACX,EAAE,OAAO;EACT,EAAE,QAAQ;EACV,EAAE,MAAM;EACR,CAAC,CAAC;;AAEF,EAAO,SAAS,oBAAoB,CAAC,YAAY,EAAE;EACnD,EAAE,MAAM,WAAW,GAAG,EAAE,CAAC;;EAEzB,EAAE,SAAS,QAAQ,CAAC,KAAK,EAAE,QAAQ,EAAE,UAAU,EAAE,YAAY,EAAE;EAC/D,IAAI,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;EAC9B,MAAM,MAAM,IAAI,GAAG,wBAAwB,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;EAChE,MAAM,IAAI,IAAI,EAAE;EAChB;EACA;EACA;EACA,QAAQ,MAAM;EACd,UAAU,OAAO,IAAI,IAAI;EACzB,UAAU,CAAC,wCAAwC,EAAE,IAAI,CAAC,CAAC;EAC3D,SAAS,CAAC;;EAEV,QAAQ,WAAW,CAAC,IAAI,CAAC,GAAG;EAC5B,UAAU,KAAK,EAAE,IAAI,CAAC,KAAK;EAC3B,UAAU,QAAQ;EAClB,UAAU,UAAU;EACpB,UAAU,YAAY;EACtB,SAAS,CAAC;EACV,OAAO;EACP,KAAK;EACL,GAAG;;EAEH,EAAE,QAAQ,CAAC,yBAAyB,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;EAC3D;EACA;EACA;EACA;EACA;EACA;EACA,EAAE,QAAQ,CAAC,yBAAyB,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;EAC3D;EACA;EACA,EAAE,QAAQ,CAAC,2BAA2B,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;;EAE3D,EAAE,OAAO,WAAW,CAAC;EACrB,CAAC;;EC3ID;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;AACA,EAAO,SAAS,eAAe,GAAG;EAClC,EAAE,MAAM;EACR,IAAI,cAAc;EAClB,IAAI,gBAAgB;EACpB,IAAI,wBAAwB;EAC5B,IAAI,cAAc;EAClB,IAAI,SAAS,EAAE,eAAe;EAC9B,GAAG,GAAG,MAAM,CAAC;;EAEb;EACA;EACA;EACA;EACA;;EAEA,EAAE,IAAI;EACN;EACA;EACA,IAAI,CAAC,CAAC,EAAE,eAAe,CAAC,gBAAgB,EAAE,GAAG,CAAC,CAAC;EAC/C,GAAG,CAAC,OAAO,MAAM,EAAE;EACnB;EACA,IAAI,OAAO;EACX,GAAG;;EAEH,EAAE,SAAS,QAAQ,CAAC,GAAG,EAAE;EACzB,IAAI,IAAI,GAAG,KAAK,SAAS,IAAI,GAAG,KAAK,IAAI,EAAE;EAC3C,MAAM,MAAM,IAAI,SAAS,CAAC,CAAC,yCAAyC,CAAC,CAAC,CAAC;EACvE,KAAK;EACL,IAAI,OAAO,MAAM,CAAC,GAAG,CAAC,CAAC;EACvB,GAAG;;EAEH,EAAE,SAAS,cAAc,CAAC,GAAG,EAAE;EAC/B,IAAI,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;EACjC,MAAM,OAAO,GAAG,CAAC;EACjB,KAAK;EACL,IAAI,OAAO,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;EACpB,GAAG;;EAEH,EAAE,SAAS,SAAS,CAAC,GAAG,EAAE,QAAQ,EAAE;EACpC,IAAI,IAAI,OAAO,GAAG,KAAK,UAAU,EAAE;EACnC,MAAM,MAAM,SAAS,CAAC,CAAC,QAAQ,EAAE,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC;EACnD,KAAK;EACL,IAAI,OAAO,GAAG,CAAC;EACf,GAAG;;EAEH,EAAE,gBAAgB,CAAC,eAAe,EAAE;EACpC,IAAI,gBAAgB,EAAE;EACtB,MAAM,KAAK,EAAE,SAAS,gBAAgB,CAAC,IAAI,EAAE,IAAI,EAAE;EACnD,QAAQ,MAAM,CAAC,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC;EACjC,QAAQ,cAAc,CAAC,CAAC,EAAE,IAAI,EAAE;EAChC,UAAU,GAAG,EAAE,SAAS,CAAC,IAAI,EAAE,QAAQ,CAAC;EACxC,UAAU,UAAU,EAAE,IAAI;EAC1B,UAAU,YAAY,EAAE,IAAI;EAC5B,SAAS,CAAC,CAAC;EACX,OAAO;EACP,KAAK;EACL,IAAI,gBAAgB,EAAE;EACtB,MAAM,KAAK,EAAE,SAAS,gBAAgB,CAAC,IAAI,EAAE,IAAI,EAAE;EACnD,QAAQ,MAAM,CAAC,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC;EACjC,QAAQ,cAAc,CAAC,CAAC,EAAE,IAAI,EAAE;EAChC,UAAU,GAAG,EAAE,SAAS,CAAC,IAAI,EAAE,QAAQ,CAAC;EACxC,UAAU,UAAU,EAAE,IAAI;EAC1B,UAAU,YAAY,EAAE,IAAI;EAC5B,SAAS,CAAC,CAAC;EACX,OAAO;EACP,KAAK;EACL,IAAI,gBAAgB,EAAE;EACtB,MAAM,KAAK,EAAE,SAAS,gBAAgB,CAAC,IAAI,EAAE;EAC7C,QAAQ,IAAI,CAAC,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC;EAC/B,QAAQ,IAAI,GAAG,cAAc,CAAC,IAAI,CAAC,CAAC;EACpC,QAAQ,IAAI,IAAI,CAAC;EACjB,QAAQ,OAAO,CAAC,IAAI,EAAE,IAAI,GAAG,wBAAwB,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,EAAE;EACjE,UAAU,CAAC,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC;EAChC,SAAS;EACT,QAAQ,OAAO,IAAI,IAAI,IAAI,CAAC,GAAG,CAAC;EAChC,OAAO;EACP,KAAK;EACL,IAAI,gBAAgB,EAAE;EACtB,MAAM,KAAK,EAAE,SAAS,gBAAgB,CAAC,IAAI,EAAE;EAC7C,QAAQ,IAAI,CAAC,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC;EAC/B,QAAQ,IAAI,GAAG,cAAc,CAAC,IAAI,CAAC,CAAC;EACpC,QAAQ,IAAI,IAAI,CAAC;EACjB,QAAQ,OAAO,CAAC,IAAI,EAAE,IAAI,GAAG,wBAAwB,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,EAAE;EACjE,UAAU,CAAC,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC;EAChC,SAAS;EACT,QAAQ,OAAO,IAAI,IAAI,IAAI,CAAC,GAAG,CAAC;EAChC,OAAO;EACP,KAAK;EACL,GAAG,CAAC,CAAC;EACL,CAAC;;EC3GD;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;;EAEA;AACA,EAAO,SAAS,eAAe,GAAG;EAClC,EAAE,MAAM,EAAE,gBAAgB,EAAE,cAAc,EAAE,cAAc,EAAE,GAAG,MAAM,CAAC;;EAEtE;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,EAAE,SAAS,cAAc,CAAC,IAAI,EAAE,WAAW,EAAE;EAC7C,IAAI,IAAI,gBAAgB,CAAC;EACzB,IAAI,IAAI;EACR;EACA,MAAM,gBAAgB,GAAG,CAAC,CAAC,EAAE,IAAI,EAAE,WAAW,CAAC,CAAC;EAChD,KAAK,CAAC,OAAO,CAAC,EAAE;EAChB,MAAM,IAAI,CAAC,YAAY,WAAW,EAAE;EACpC;EACA;EACA,QAAQ,OAAO;EACf,OAAO;EACP;EACA,MAAM,MAAM,CAAC,CAAC;EACd,KAAK;EACL,IAAI,MAAM,iBAAiB,GAAG,cAAc,CAAC,gBAAgB,CAAC,CAAC;;EAE/D;EACA;EACA,IAAI,MAAM,aAAa,GAAG,WAAW;EACrC,MAAM,MAAM,IAAI,SAAS,CAAC,eAAe,CAAC,CAAC;EAC3C,KAAK,CAAC;EACN,IAAI,gBAAgB,CAAC,aAAa,EAAE,EAAE,IAAI,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE,EAAE,CAAC,CAAC;;EAE/D;EACA;;EAEA;EACA;;EAEA;EACA;EACA;EACA;;EAEA;EACA;EACA,IAAI,gBAAgB,CAAC,iBAAiB,EAAE;EACxC,MAAM,WAAW,EAAE,EAAE,KAAK,EAAE,aAAa,EAAE;EAC3C,KAAK,CAAC,CAAC;;EAEP;EACA;EACA,IAAI,gBAAgB,CAAC,aAAa,EAAE;EACpC,MAAM,SAAS,EAAE,EAAE,KAAK,EAAE,iBAAiB,EAAE;EAC7C,KAAK,CAAC,CAAC;;EAEP,IAAI,IAAI,aAAa,KAAK,QAAQ,CAAC,SAAS,CAAC,WAAW,EAAE;EAC1D;EACA,MAAM,cAAc,CAAC,aAAa,EAAE,QAAQ,CAAC,SAAS,CAAC,WAAW,CAAC,CAAC;EACpE,KAAK;EACL,GAAG;;EAEH;EACA;EACA;;EAEA;EACA;EACA;;EAEA;;EAEA,EAAE,cAAc,CAAC,UAAU,EAAE,gBAAgB,CAAC,CAAC;EAC/C,EAAE,cAAc,CAAC,mBAAmB,EAAE,iBAAiB,CAAC,CAAC;EACzD,EAAE,cAAc,CAAC,eAAe,EAAE,sBAAsB,CAAC,CAAC;EAC1D,EAAE,cAAc,CAAC,wBAAwB,EAAE,uBAAuB,CAAC,CAAC;EACpE,CAAC;;EClGD;AACA,AAMA;EACA;EACA;EACA;;EAEA;EACA;EACA;;EAEA,MAAM,eAAe,GAAG,oBAAoB,CAAC;EAC7C,MAAM,mBAAmB,GAAG,CAAC,+BAA+B,CAAC,CAAC;;EAE9D;AACA,EAAO,SAAS,4BAA4B,GAAG;EAC/C;EACA;;EAEA;EACA;EACA,EAAE,MAAM,MAAM,GAAG,IAAI,QAAQ;EAC7B,IAAI,kDAAkD;EACtD,GAAG,EAAE,CAAC;;EAEN,EAAE,IAAI,CAAC,MAAM,EAAE;EACf,IAAI,OAAO,SAAS,CAAC;EACrB,GAAG;;EAEH;EACA,EAAE,MAAM,EAAE,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC;;EAE3B;EACA,EAAE,MAAM,YAAY,GAAG,EAAE,CAAC,eAAe,CAAC,mBAAmB,CAAC,CAAC;;EAE/D,EAAE,OAAO,YAAY,CAAC;EACtB,CAAC;;EAED;AACA,EAAO,SAAS,+BAA+B,GAAG;EAClD,EAAE,IAAI,OAAO,QAAQ,KAAK,WAAW,EAAE;EACvC,IAAI,OAAO,SAAS,CAAC;EACrB,GAAG;EACH,EAAE,MAAM,MAAM,GAAG,QAAQ,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;EAClD,EAAE,MAAM,CAAC,KAAK,CAAC,OAAO,GAAG,MAAM,CAAC;;EAEhC,EAAE,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;EACpC,EAAE,MAAM,YAAY,GAAG,MAAM,CAAC,aAAa,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;;EAElE;EACA;EACA;;EAEA;;EAEA,EAAE,OAAO,YAAY,CAAC;EACtB,CAAC;;EAED,MAAM,kBAAkB,GAAG,MAAM;EACjC,EAAE,MAAM,yBAAyB,GAAG,+BAA+B,EAAE,CAAC;EACtE,EAAE,MAAM,sBAAsB,GAAG,4BAA4B,EAAE,CAAC;EAChE,EAAE;EACF,IAAI,CAAC,CAAC,yBAAyB,IAAI,CAAC,sBAAsB;EAC1D,KAAK,yBAAyB,IAAI,sBAAsB,CAAC;EACzD,IAAI;EACJ,IAAI,MAAM,IAAI,KAAK,CAAC,6CAA6C,CAAC,CAAC;EACnE,GAAG;EACH,EAAE,OAAO,yBAAyB,IAAI,sBAAsB,CAAC;EAC7D,CAAC,CAAC;;EAEF;EACA;EACA;EACA;EACA;EACA;EACA,SAAS,eAAe,CAAC,YAAY,EAAE,QAAQ,GAAG,EAAE,EAAE;EACtD,EAAE,MAAM,iBAAiB,GAAG,oBAAoB,CAAC,YAAY,CAAC,CAAC;;EAE/D,EAAE,MAAM,UAAU,GAAG,YAAY,CAAC,IAAI,CAAC;EACvC,EAAE,MAAM,cAAc,GAAG,YAAY,CAAC,QAAQ,CAAC;;EAE/C,EAAE,MAAM,gBAAgB,GAAG,sBAAsB,CAAC,UAAU,CAAC,CAAC;;EAE9D,EAAE,OAAO,MAAM,CAAC;EAChB,IAAI,YAAY;EAChB,IAAI,iBAAiB;EACrB,IAAI,UAAU;EACd,IAAI,cAAc;EAClB,IAAI,gBAAgB;EACpB,IAAI,QAAQ;EACZ,GAAG,CAAC,CAAC;EACL,CAAC;;EAED,MAAM,mBAAmB,GAAG,aAAa;EACzC,EAAE,CAAC,eAAe,EAAE,eAAe,CAAC,IAAI,CAAC;EACzC,CAAC,CAAC;EACF,MAAM,mBAAmB,GAAG,aAAa;EACzC,EAAE,CAAC,eAAe,EAAE,eAAe,CAAC,IAAI,CAAC;EACzC,CAAC,CAAC;;EAEF;EACA;AACA,EAAO,SAAS,kBAAkB,CAAC,QAAQ,EAAE;EAC7C,EAAE,MAAM,YAAY,GAAG,kBAAkB,EAAE,CAAC;EAC5C,EAAE,YAAY,CAAC,IAAI,CAAC,mBAAmB,CAAC,CAAC;EACzC,EAAE,YAAY,CAAC,IAAI,CAAC,mBAAmB,CAAC,CAAC;EACzC,EAAE,OAAO,eAAe,CAAC,YAAY,EAAE,QAAQ,CAAC,CAAC;EACjD,CAAC;;EAED;EACA;AACA,EAAO,SAAS,sBAAsB,GAAG;EACzC,EAAE,MAAM,YAAY,GAAG,CAAC,GAAG,IAAI,EAAE,eAAe,CAAC,CAAC;EAClD,EAAE,eAAe,EAAE,CAAC;EACpB,EAAE,eAAe,EAAE,CAAC;EACpB,EAAE,OAAO,eAAe,CAAC,YAAY,CAAC,CAAC;EACvC,CAAC;;EClHD;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,MAAM,iBAAiB,GAAG,oBAAoB,CAAC;;EAE/C;EACA;EACA;EACA;EACA,MAAM,QAAQ,GAAG,IAAI,GAAG,CAAC;EACzB;EACA,EAAE,OAAO;EACT,EAAE,OAAO;EACT,EAAE,MAAM;EACR,EAAE,OAAO;EACT,EAAE,OAAO;EACT,EAAE,OAAO;EACT,EAAE,UAAU;EACZ,EAAE,UAAU;EACZ,EAAE,SAAS;EACX,EAAE,QAAQ;EACV,EAAE,IAAI;EACN,EAAE,MAAM;EACR,EAAE,QAAQ;EACV,EAAE,SAAS;EACX,EAAE,SAAS;EACX,EAAE,KAAK;EACP,EAAE,UAAU;EACZ,EAAE,IAAI;EACN,EAAE,QAAQ;EACV,EAAE,IAAI;EACN,EAAE,YAAY;EACd,EAAE,KAAK;EACP,EAAE,QAAQ;EACV,EAAE,OAAO;EACT,EAAE,QAAQ;EACV,EAAE,MAAM;EACR,EAAE,OAAO;EACT,EAAE,KAAK;EACP,EAAE,QAAQ;EACV,EAAE,KAAK;EACP,EAAE,MAAM;EACR,EAAE,OAAO;EACT,EAAE,MAAM;EACR,EAAE,OAAO;;EAET;EACA,EAAE,KAAK;EACP,EAAE,QAAQ;;EAEV;EACA,EAAE,MAAM;;EAER;EACA,EAAE,YAAY;EACd,EAAE,SAAS;EACX,EAAE,WAAW;EACb,EAAE,WAAW;EACb,EAAE,SAAS;EACX,EAAE,QAAQ;;EAEV;EACA,EAAE,OAAO;;EAET,EAAE,MAAM;EACR,EAAE,MAAM;EACR,EAAE,OAAO;;EAET,EAAE,MAAM;EACR,EAAE,WAAW;EACb,CAAC,CAAC,CAAC;;EAEH;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACA,EAAO,SAAS,qBAAqB,CAAC,UAAU,EAAE;EAClD,EAAE,MAAM,KAAK,GAAG,yBAAyB,CAAC,UAAU,CAAC,CAAC;;EAEtD;EACA;EACA,EAAE,MAAM,SAAS,GAAG,WAAW,CAAC,mBAAmB,CAAC,KAAK,CAAC,EAAE,IAAI,IAAI;EACpE;EACA;EACA,IAAI;EACJ,MAAM,IAAI,KAAK,MAAM;EACrB,MAAM,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC;EACxB,MAAM,CAAC,UAAU,CAAC,iBAAiB,EAAE,IAAI,CAAC;EAC1C,MAAM;EACN,MAAM,OAAO,KAAK,CAAC;EACnB,KAAK;;EAEL,IAAI,MAAM,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC;EAC7B,IAAI;EACJ;EACA;EACA;EACA;EACA;EACA;EACA;EACA,MAAM,IAAI,CAAC,YAAY,KAAK,KAAK;EACjC,MAAM,IAAI,CAAC,QAAQ,KAAK,KAAK;EAC7B;EACA;EACA;EACA;EACA;EACA;EACA,MAAM,oBAAoB,CAAC,IAAI,EAAE,OAAO,CAAC;EACzC,MAAM;EACN,GAAG,CAAC,CAAC;;EAEL,EAAE,OAAO,SAAS,CAAC;EACnB,CAAC;;ECtID;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACA,EAAO,SAAS,iBAAiB;EACjC,EAAE,SAAS;EACX,EAAE,UAAU;EACZ,EAAE,UAAU,GAAG,EAAE;EACjB,EAAE,aAAa,GAAG,KAAK;EACvB,EAAE;EACF,EAAE,MAAM,EAAE,YAAY,EAAE,UAAU,EAAE,GAAG,SAAS,CAAC;;EAEjD,EAAE,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,CAAC;EAC5B,EAAE,MAAM,EAAE,GAAG,EAAE,UAAU,EAAE,GAAG,OAAO,CAAC;EACtC,EAAE,MAAM,EAAE,WAAW,EAAE,GAAG,MAAM,CAAC;;EAEjC;EACA;EACA;EACA;EACA;EACA,EAAE,MAAM,kBAAkB,GAAG,IAAI,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC,EAAE;EACnD,IAAI,GAAG,CAAC,MAAM,EAAE,IAAI,EAAE;EACtB;EACA,MAAM,MAAM,IAAI,SAAS;EACzB,QAAQ,CAAC,sCAAsC,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;EAC/D,OAAO,CAAC;EACR,KAAK;EACL,GAAG,CAAC,CAAC;;EAEL,EAAE,OAAO;EACT;EACA;EACA;EACA,IAAI,SAAS,EAAE,kBAAkB;;EAEjC;EACA;EACA;EACA;EACA,IAAI,kBAAkB,EAAE,KAAK;;EAE7B,IAAI,GAAG,CAAC,MAAM,EAAE,IAAI,EAAE;EACtB,MAAM,IAAI,IAAI,KAAK,WAAW,EAAE;EAChC;EACA;EACA;EACA;EACA,QAAQ,OAAO,SAAS,CAAC;EACzB,OAAO;;EAEP;EACA;EACA;EACA,MAAM,IAAI,IAAI,KAAK,MAAM,EAAE;EAC3B;EACA,QAAQ,IAAI,IAAI,CAAC,kBAAkB,KAAK,IAAI,EAAE;EAC9C;EACA,UAAU,IAAI,CAAC,kBAAkB,GAAG,KAAK,CAAC;EAC1C,UAAU,OAAO,UAAU,CAAC;EAC5B,SAAS;EACT;EACA,OAAO;;EAEP;EACA,MAAM,IAAI,IAAI,IAAI,UAAU,EAAE;EAC9B,QAAQ,OAAO,UAAU,CAAC,UAAU,EAAE,IAAI,EAAE,UAAU,CAAC,CAAC;EACxD,OAAO;;EAEP;EACA,MAAM,IAAI,IAAI,IAAI,UAAU,EAAE;EAC9B,QAAQ,OAAO,UAAU,CAAC,IAAI,CAAC,CAAC;EAChC,OAAO;;EAEP;EACA,MAAM,OAAO,SAAS,CAAC;EACvB,KAAK;;EAEL;EACA,IAAI,GAAG,CAAC,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE;EAC7B;EACA;EACA;EACA;EACA,MAAM,IAAI,IAAI,IAAI,UAAU,EAAE;EAC9B;EACA,QAAQ,MAAM,IAAI,SAAS,CAAC,CAAC,8BAA8B,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;EAC7E,OAAO;;EAEP,MAAM,UAAU,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC;;EAE/B;EACA,MAAM,OAAO,IAAI,CAAC;EAClB,KAAK;;EAEL;EACA;EACA;;EAEA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;;EAEA,IAAI,GAAG,CAAC,MAAM,EAAE,IAAI,EAAE;EACtB;;EAEA,MAAM,IAAI,aAAa,EAAE;EACzB;EACA,QAAQ,OAAO,IAAI,CAAC;EACpB,OAAO;;EAEP;EACA;EACA;EACA;EACA;EACA,MAAM;EACN,QAAQ,IAAI,KAAK,MAAM;EACvB,QAAQ,IAAI,IAAI,UAAU;EAC1B,QAAQ,IAAI,IAAI,UAAU;EAC1B,QAAQ,IAAI,IAAI,YAAY;EAC5B,QAAQ;EACR,QAAQ,OAAO,IAAI,CAAC;EACpB,OAAO;;EAEP,MAAM,OAAO,KAAK,CAAC;EACnB,KAAK;;EAEL;EACA;;EAEA,IAAI,cAAc,GAAG;EACrB,MAAM,OAAO,IAAI,CAAC;EAClB,KAAK;EACL,GAAG,CAAC;EACJ,CAAC;;EAED,MAAM,uBAAuB,GAAG,aAAa;EAC7C,EAAE,CAAC,eAAe,EAAE,iBAAiB,CAAC,CAAC,CAAC;EACxC,CAAC,CAAC;AACF,EAAO,SAAS,kBAAkB;EAClC,EAAE,SAAS;EACX,EAAE,UAAU;EACZ,EAAE,UAAU;EACZ,EAAE,aAAa;EACf,EAAE;EACF,EAAE,MAAM,EAAE,UAAU,EAAE,GAAG,SAAS,CAAC;EACnC,EAAE,OAAO,UAAU,CAAC,uBAAuB,CAAC;EAC5C,IAAI,SAAS;EACb,IAAI,UAAU;EACd,IAAI,UAAU;EACd,IAAI,aAAa;EACjB,GAAG,CAAC;EACJ,CAAC;;ECjLD,SAAS,aAAa,CAAC,SAAS,EAAE,iBAAiB,EAAE;EACrD,EAAE,MAAM,EAAE,gBAAgB,EAAE,GAAG,SAAS,CAAC;;EAEzC,EAAE,MAAM,EAAE,gBAAgB,EAAE,GAAG,MAAM,CAAC;;EAEtC;EACA;EACA;EACA;EACA,EAAE,MAAM,QAAQ,GAAG;EACnB,IAAI,IAAI,GAAG;EACX,MAAM,OAAO,gBAAgB,CAAC,iBAAiB,EAAE,SAAS,CAAC,CAAC;EAC5D,KAAK;EACL,GAAG,CAAC,IAAI,CAAC;;EAET;EACA;EACA;EACA;;EAEA,EAAE,gBAAgB,CAAC,QAAQ,EAAE;EAC7B,IAAI,QAAQ,EAAE;EACd;EACA;EACA;EACA;EACA,MAAM,KAAK,EAAE,MAAM,CAAC,SAAS,EAAE,MAAM,CAAC,kBAAkB,CAAC;EACzD,MAAM,QAAQ,EAAE,KAAK;EACrB,MAAM,UAAU,EAAE,KAAK;EACvB,MAAM,YAAY,EAAE,IAAI;EACxB,KAAK;EACL,GAAG,CAAC,CAAC;;EAEL,EAAE,OAAO,QAAQ,CAAC;EAClB,CAAC;EACD,MAAM,mBAAmB,GAAG,aAAa,CAAC,CAAC,eAAe,EAAE,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9E,EAAO,SAAS,cAAc,CAAC,SAAS,EAAE,iBAAiB,EAAE;EAC7D,EAAE,MAAM,EAAE,UAAU,EAAE,GAAG,SAAS,CAAC;EACnC,EAAE,OAAO,UAAU,CAAC,mBAAmB,CAAC,CAAC,SAAS,EAAE,iBAAiB,CAAC,CAAC;EACvE,CAAC;;ECvCD,SAAS,iBAAiB,CAAC,SAAS,EAAE,qBAAqB,EAAE;EAC7D,EAAE,MAAM,EAAE,gBAAgB,EAAE,cAAc,EAAE,GAAG,SAAS,CAAC;;EAEzD,EAAE,MAAM,EAAE,gBAAgB,EAAE,GAAG,MAAM,CAAC;;EAEtC,EAAE,MAAM,YAAY,GAAG,SAAS,QAAQ,GAAG;EAC3C,IAAI,OAAO,gBAAgB,CAAC,qBAAqB,EAAE,SAAS,CAAC,CAAC;EAC9D,GAAG,CAAC;;EAEJ;EACA;;EAEA,EAAE,gBAAgB,CAAC,YAAY,EAAE;EACjC;EACA;EACA,IAAI,SAAS,EAAE,EAAE,KAAK,EAAE,cAAc,CAAC,SAAS,EAAE;;EAElD;EACA;EACA;EACA,IAAI,QAAQ,EAAE;EACd,MAAM,KAAK,EAAE,MAAM,qCAAqC;EACxD,MAAM,QAAQ,EAAE,KAAK;EACrB,MAAM,UAAU,EAAE,KAAK;EACvB,MAAM,YAAY,EAAE,IAAI;EACxB,KAAK;EACL,GAAG,CAAC,CAAC;;EAEL,EAAE,OAAO,YAAY,CAAC;EACtB,CAAC;EACD,MAAM,uBAAuB,GAAG,aAAa;EAC7C,EAAE,CAAC,eAAe,EAAE,iBAAiB,CAAC,CAAC,CAAC;EACxC,CAAC,CAAC;AACF,EAAO,SAAS,kBAAkB,CAAC,SAAS,EAAE,qBAAqB,EAAE;EACrE,EAAE,MAAM,EAAE,UAAU,EAAE,GAAG,SAAS,CAAC;EACnC,EAAE,OAAO,UAAU,CAAC,uBAAuB,CAAC,CAAC,SAAS,EAAE,qBAAqB,CAAC,CAAC;EAC/E,CAAC;;ECtCD;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA,MAAM,kBAAkB,GAAG,IAAI,MAAM,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;;EAEhE,SAAS,kBAAkB,CAAC,CAAC,EAAE;EAC/B,EAAE,MAAM,KAAK,GAAG,CAAC,CAAC,MAAM,CAAC,kBAAkB,CAAC,CAAC;EAC7C,EAAE,IAAI,KAAK,KAAK,CAAC,CAAC,EAAE;EACpB,IAAI,MAAM,OAAO,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC;EACzD,IAAI,MAAM,IAAI,WAAW;EACzB,MAAM,CAAC,kDAAkD,EAAE,OAAO,CAAC,CAAC;EACpE,KAAK,CAAC;EACN,GAAG;EACH,CAAC;;EAED;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;;EAEA,MAAM,aAAa,GAAG,0BAA0B,CAAC;;EAEjD,SAAS,uBAAuB,CAAC,CAAC,EAAE;EACpC,EAAE,MAAM,KAAK,GAAG,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC;EACxC,EAAE,IAAI,KAAK,KAAK,CAAC,CAAC,EAAE;EACpB,IAAI,MAAM,OAAO,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC;EACzD,IAAI,MAAM,IAAI,WAAW;EACzB,MAAM,CAAC,gDAAgD,EAAE,OAAO,CAAC,CAAC;EAClE,KAAK,CAAC;EACN,GAAG;EACH,CAAC;;EAED;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA,MAAM,qBAAqB,GAAG,wBAAwB,CAAC;;EAEvD,SAAS,+BAA+B,CAAC,CAAC,EAAE;EAC5C,EAAE,MAAM,KAAK,GAAG,CAAC,CAAC,MAAM,CAAC,qBAAqB,CAAC,CAAC;EAChD,EAAE,IAAI,KAAK,KAAK,CAAC,CAAC,EAAE;EACpB,IAAI,MAAM,OAAO,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC;EACzD,IAAI,MAAM,IAAI,WAAW;EACzB,MAAM,CAAC,qDAAqD,EAAE,OAAO,CAAC,CAAC;EACvE,KAAK,CAAC;EACN,GAAG;EACH,CAAC;;AAED,EAAO,SAAS,sBAAsB,CAAC,CAAC,EAAE;EAC1C,EAAE,kBAAkB,CAAC,CAAC,CAAC,CAAC;EACxB,EAAE,uBAAuB,CAAC,CAAC,CAAC,CAAC;EAC7B,EAAE,+BAA+B,CAAC,CAAC,CAAC,CAAC;EACrC,CAAC;;EAED;AACA,EAAO,MAAM,+BAA+B,GAAG;EAC/C,EAAE,OAAO,CAAC,EAAE,EAAE;EACd,IAAI,sBAAsB,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC;EACnC,IAAI,OAAO,EAAE,CAAC;EACd,GAAG;EACH,CAAC,CAAC;;ECzGF;AACA,AAmBA;EACA,SAAS,cAAc,CAAC,SAAS,EAAE;EACnC;EACA,EAAE,IAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE,OAAO,EAAE,CAAC;EACxC;EACA;EACA,EAAE,OAAO,CAAC,OAAO,EAAE,SAAS,CAAC,SAAS,EAAE,GAAG,CAAC,CAAC,SAAS,CAAC,CAAC;EACxD,CAAC;;EAED,SAAS,4BAA4B,CAAC,SAAS,EAAE,SAAS,EAAE;EAC5D,EAAE,MAAM,EAAE,cAAc,EAAE,GAAG,SAAS,CAAC;;EAEvC,EAAE,MAAM,SAAS,GAAG,cAAc,CAAC,SAAS,CAAC,CAAC;;EAE9C;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA,EAAE,OAAO,cAAc,CAAC,CAAC;;MAEnB,EAAE,SAAS,CAAC;;;;;;EAMhB,CAAC,CAAC,CAAC;EACL,CAAC;;EAED,SAAS,eAAe,CAAC,aAAa,EAAE,UAAU,EAAE;EACpD;EACA,EAAE,aAAa,GAAG;EAClB,IAAI,GAAG,EAAE,CAAC,EAAE,aAAa,CAAC,GAAG,CAAC,CAAC;EAC/B,IAAI,UAAU,EAAE,MAAM;EACtB,MAAM,IAAI;EACV,MAAM,yBAAyB,CAAC,aAAa,CAAC,UAAU,CAAC;EACzD,KAAK;EACL,GAAG,CAAC;;EAEJ;EACA,EAAE,aAAa,GAAG,UAAU,CAAC,MAAM;EACnC,IAAI,CAAC,EAAE,EAAE,SAAS,MAAM,SAAS,CAAC,OAAO,GAAG,SAAS,CAAC,OAAO,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC;EACvE,IAAI,aAAa;EACjB,GAAG,CAAC;;EAEJ;EACA,EAAE,aAAa,GAAG;EAClB,IAAI,GAAG,EAAE,CAAC,EAAE,aAAa,CAAC,GAAG,CAAC,CAAC;EAC/B,IAAI,UAAU,EAAE,MAAM;EACtB,MAAM,IAAI;EACV,MAAM,yBAAyB,CAAC,aAAa,CAAC,UAAU,CAAC;EACzD,KAAK;EACL,GAAG,CAAC;;EAEJ,EAAE,OAAO,aAAa,CAAC;EACvB,CAAC;;AAED,EAAO,SAAS,0BAA0B;EAC1C,EAAE,SAAS;EACX,EAAE,UAAU;EACZ,EAAE,UAAU;EACZ,EAAE,aAAa;EACf,EAAE;EACF,EAAE,MAAM,SAAS,GAAG,qBAAqB,CAAC,UAAU,CAAC,CAAC;EACtD,EAAE,MAAM,sBAAsB,GAAG,4BAA4B;EAC7D,IAAI,SAAS;EACb,IAAI,SAAS;EACb,GAAG,CAAC;;EAEJ,EAAE,SAAS,OAAO,CAAC,UAAU,GAAG,EAAE,EAAE,OAAO,GAAG,EAAE,EAAE;EAClD;EACA,IAAI,MAAM,eAAe,GAAG,OAAO,CAAC,UAAU,IAAI,EAAE,CAAC;EACrD,IAAI,MAAM,eAAe,GAAG,UAAU,IAAI,EAAE,CAAC;;EAE7C,IAAI,MAAM,mBAAmB,GAAG,CAAC,+BAA+B,CAAC,CAAC;EAClE,IAAI,MAAM,aAAa,GAAG,WAAW;EACrC,MAAM,eAAe;EACrB,MAAM,eAAe;EACrB,MAAM,mBAAmB;EACzB,KAAK,CAAC;;EAEN,IAAI,SAAS,iBAAiB,CAAC,GAAG,EAAE;EACpC,MAAM,IAAI,aAAa,GAAG,EAAE,GAAG,EAAE,UAAU,EAAE,CAAC;EAC9C,MAAM,aAAa,GAAG,eAAe,CAAC,aAAa,EAAE,aAAa,CAAC,CAAC;;EAEpE,MAAM,MAAM,YAAY,GAAG,kBAAkB;EAC7C,QAAQ,SAAS;EACjB,QAAQ,UAAU;EAClB,QAAQ,aAAa,CAAC,UAAU;EAChC,QAAQ,aAAa;EACrB,OAAO,CAAC;EACR,MAAM,MAAM,mBAAmB,GAAG,KAAK,CAAC,SAAS,CAAC,EAAE,EAAE,YAAY,CAAC,CAAC;EACpE,MAAM,MAAM,UAAU,GAAG,mBAAmB,CAAC,KAAK,CAAC;EACnD,MAAM,MAAM,eAAe,GAAG,KAAK,CAAC,sBAAsB,EAAE,UAAU,EAAE;EACxE,QAAQ,UAAU;EAClB,OAAO,CAAC,CAAC;;EAET,MAAM,YAAY,CAAC,kBAAkB,GAAG,IAAI,CAAC;EAC7C,MAAM,IAAI,GAAG,CAAC;EACd,MAAM,IAAI;EACV;EACA,QAAQ,OAAO,KAAK,CAAC,eAAe,EAAE,UAAU,EAAE,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,CAAC;EACvE,OAAO,CAAC,OAAO,CAAC,EAAE;EAClB;EACA,QAAQ,GAAG,GAAG,CAAC,CAAC;EAChB,QAAQ,MAAM,CAAC,CAAC;EAChB,OAAO,SAAS;EAChB,QAAQ,IAAI,YAAY,CAAC,kBAAkB,EAAE;EAC7C;EACA;EACA;EACA,UAAU,mBAAmB,CAAC,MAAM,EAAE,CAAC;EACvC,UAAU,YAAY,CAAC,2CAA2C,EAAE,GAAG,CAAC,CAAC;EACzE,SAAS;EACT,OAAO;EACP,KAAK;;EAEL,IAAI,OAAO,iBAAiB,CAAC;EAC7B,GAAG;;EAEH,EAAE,OAAO,OAAO,CAAC;EACjB,CAAC;;AAED,EAAO,SAAS,mBAAmB,CAAC,SAAS,EAAE,iBAAiB,EAAE;EAClE,EAAE,MAAM,EAAE,cAAc,EAAE,GAAG,SAAS,CAAC;;EAEvC,EAAE,MAAM,QAAQ,GAAG,cAAc,CAAC,SAAS,EAAE,iBAAiB,CAAC,CAAC;;EAEhE,EAAE,MAAM,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC,WAAW,KAAK,QAAQ,EAAE,eAAe,CAAC,CAAC;EAC7E,EAAE,MAAM;EACR,IAAI,cAAc,CAAC,QAAQ,CAAC,CAAC,WAAW,KAAK,cAAc;EAC3D,IAAI,qBAAqB;EACzB,GAAG,CAAC;;EAEJ,EAAE,OAAO,QAAQ,CAAC;EAClB,CAAC;;AAED,EAAO,SAAS,uCAAuC,CAAC,oBAAoB,EAAE;EAC9E,EAAE,OAAO,CAAC,CAAC,EAAE,UAAU,EAAE,OAAO,GAAG,EAAE;EACrC,IAAI,oBAAoB,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;EACjD,CAAC;;EAED;EACA;EACA;EACA;AACA,EAAO,SAAS,uBAAuB,CAAC,SAAS,EAAE,iBAAiB,EAAE;EACtE,EAAE,MAAM,EAAE,YAAY,EAAE,cAAc,EAAE,GAAG,SAAS,CAAC;;EAErD,EAAE,SAAS,qBAAqB,CAAC,GAAG,MAAM,EAAE;EAC5C,IAAI,MAAM,YAAY,GAAG,CAAC,EAAE,QAAQ,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;EACrD,IAAI,IAAI,cAAc,GAAG,CAAC,EAAE,SAAS,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;EACrD,IAAI,IAAI,CAAC,UAAU,CAAC,YAAY,EAAE,cAAc,CAAC,EAAE;EACnD,MAAM,MAAM,IAAI,WAAW;EAC3B,QAAQ,gKAAgK;EACxK,OAAO,CAAC;EACR;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,KAAK;;EAEL;EACA;EACA;EACA;EACA;EACA;EACA,IAAI,IAAI,cAAc,CAAC,YAAY,CAAC,CAAC;;EAErC,IAAI,IAAI,cAAc,CAAC,cAAc,EAAE,GAAG,CAAC,EAAE;EAC7C;EACA;EACA;;EAEA;EACA;EACA,MAAM,MAAM,IAAI,YAAY,CAAC,WAAW;EACxC,QAAQ,2DAA2D;EACnE,OAAO,CAAC;EACR;EACA,KAAK;;EAEL;EACA,IAAI,IAAI,cAAc,CAAC,MAAM,GAAG,CAAC,EAAE;EACnC;EACA;EACA;EACA,MAAM,cAAc,IAAI,UAAU,CAAC;EACnC,KAAK;;EAEL,IAAI,MAAM,GAAG,GAAG,CAAC,UAAU,EAAE,cAAc,CAAC,IAAI,EAAE,YAAY,CAAC,IAAI,CAAC,CAAC;;EAErE,IAAI,OAAO,iBAAiB,CAAC,GAAG,CAAC,CAAC;EAClC,GAAG;;EAEH,EAAE,MAAM,YAAY,GAAG,kBAAkB,CAAC,SAAS,EAAE,qBAAqB,CAAC,CAAC;;EAE5E,EAAE,MAAM;EACR,IAAI,cAAc,CAAC,YAAY,CAAC,CAAC,WAAW,KAAK,QAAQ;EACzD,IAAI,eAAe;EACnB,GAAG,CAAC;EACJ,EAAE,MAAM;EACR,IAAI,cAAc,CAAC,YAAY,CAAC,CAAC,WAAW,KAAK,cAAc;EAC/D,IAAI,qBAAqB;EACzB,GAAG,CAAC;;EAEJ,EAAE,OAAO,YAAY,CAAC;EACtB,CAAC;;EC1PD;EACA;EACA,MAAM,wBAAwB,GAAG,IAAI,OAAO,EAAE,CAAC;;EAE/C,SAAS,2BAA2B,CAAC,KAAK,EAAE;EAC5C;EACA,EAAE,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,KAAK,EAAE,kCAAkC,CAAC,CAAC;EACtE;EACA,EAAE,MAAM,CAAC,wBAAwB,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,8BAA8B,CAAC,CAAC;;EAE9E,EAAE,OAAO,wBAAwB,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;EAC7C,CAAC;;EAED,SAAS,gCAAgC,CAAC,KAAK,EAAE,QAAQ,EAAE;EAC3D;EACA,EAAE,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,KAAK,EAAE,kCAAkC,CAAC,CAAC;EACtE;EACA,EAAE,MAAM;EACR,IAAI,CAAC,wBAAwB,CAAC,GAAG,CAAC,KAAK,CAAC;EACxC,IAAI,qCAAqC;EACzC,GAAG,CAAC;;EAEJ,EAAE,wBAAwB,CAAC,GAAG,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;EAChD,CAAC;;EAED;EACA,SAAS,kBAAkB,CAAC,UAAU,EAAE,QAAQ,EAAE,YAAY,EAAE;EAChE,EAAE,gBAAgB,CAAC,UAAU,EAAE;EAC/B,IAAI,IAAI,EAAE;EACV,MAAM,KAAK,EAAE,QAAQ;EACrB,MAAM,QAAQ,EAAE,IAAI;EACpB,MAAM,YAAY,EAAE,IAAI;EACxB,KAAK;EACL,IAAI,QAAQ,EAAE;EACd,MAAM,KAAK,EAAE,YAAY;EACzB,MAAM,QAAQ,EAAE,IAAI;EACpB,MAAM,YAAY,EAAE,IAAI;EACxB,KAAK;EACL,GAAG,CAAC,CAAC;EACL,CAAC;;EAED,SAAS,cAAc,CAAC,SAAS,EAAE,UAAU,EAAE,aAAa,EAAE;EAC9D,EAAE,MAAM,EAAE,iBAAiB,EAAE,YAAY,EAAE,GAAG,SAAS,CAAC;;EAExD,EAAE,MAAM,UAAU,GAAG,MAAM,CAAC,YAAY,CAAC,MAAM,CAAC,SAAS,EAAE,iBAAiB,CAAC,CAAC;;EAE9E,EAAE,MAAM,oBAAoB,GAAG,0BAA0B;EACzD,IAAI,SAAS;EACb,IAAI,UAAU;EACd,IAAI,UAAU;EACd,IAAI,aAAa;EACjB,GAAG,CAAC;EACJ,EAAE,MAAM,iBAAiB,GAAG,oBAAoB,EAAE,CAAC;EACnD,EAAE,MAAM,QAAQ,GAAG,mBAAmB,CAAC,SAAS,EAAE,iBAAiB,CAAC,CAAC;EACrE,EAAE,MAAM,YAAY,GAAG,uBAAuB,CAAC,SAAS,EAAE,iBAAiB,CAAC,CAAC;EAC7E,EAAE,MAAM,4BAA4B,GAAG,uCAAuC;EAC9E,IAAI,oBAAoB;EACxB,GAAG,CAAC;;EAEJ,EAAE,kBAAkB,CAAC,UAAU,EAAE,QAAQ,EAAE,YAAY,CAAC,CAAC;;EAEzD,EAAE,MAAM,QAAQ,GAAG,MAAM,CAAC;EAC1B,IAAI,UAAU;EACd,IAAI,QAAQ;EACZ,IAAI,4BAA4B;EAChC,IAAI,YAAY;EAChB,GAAG,CAAC,CAAC;;EAEL,EAAE,OAAO,QAAQ,CAAC;EAClB,CAAC;;EAED;EACA;EACA;EACA;EACA;EACA,SAAS,aAAa,CAAC,eAAe,EAAE,IAAI,EAAE,OAAO,EAAE;EACvD;;EAEA;EACA;EACA,EAAE,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,UAAU,EAAE,aAAa,EAAE,GAAG,OAAO,CAAC;EACjE,EAAE,MAAM,QAAQ,GAAG,WAAW,CAAC,eAAe,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;;EAEnE;EACA,EAAE,MAAM,SAAS,GAAG,kBAAkB,CAAC,QAAQ,CAAC,CAAC;;EAEjD;EACA,EAAE,MAAM,KAAK,GAAG,iBAAiB,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC;;EAExD;EACA;EACA,EAAE,SAAS,CAAC,iBAAiB,CAAC,KAAK,GAAG;EACtC,IAAI,KAAK,EAAE,KAAK;EAChB,IAAI,QAAQ,EAAE,IAAI;EAClB,IAAI,YAAY,EAAE,IAAI;EACtB,GAAG,CAAC;;EAEJ;EACA;EACA,EAAE,MAAM,QAAQ,GAAG,cAAc,CAAC,SAAS,EAAE,UAAU,EAAE,aAAa,CAAC,CAAC;;EAExE;EACA,EAAE,MAAM,EAAE,4BAA4B,EAAE,GAAG,QAAQ,CAAC;EACpD,EAAE,KAAK,MAAM,IAAI,IAAI,QAAQ,EAAE;EAC/B,IAAI,4BAA4B,CAAC,IAAI,CAAC,CAAC;EACvC,GAAG;;EAEH;EACA,EAAE,gCAAgC,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;EACnD,CAAC;;EAED;EACA;EACA;EACA;EACA,SAAS,eAAe,CAAC,SAAS,EAAE,IAAI,EAAE,OAAO,GAAG,EAAE,EAAE;EACxD;;EAEA,EAAE,MAAM,EAAE,UAAU,EAAE,aAAa,EAAE,GAAG,OAAO,CAAC;EAChD,EAAE,MAAM,QAAQ,GAAG,cAAc,CAAC,SAAS,EAAE,UAAU,EAAE,aAAa,CAAC,CAAC;;EAExE;EACA,EAAE,gCAAgC,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;EACnD,CAAC;;EAED,SAAS,cAAc,CAAC,IAAI,EAAE;EAC9B,EAAE,MAAM,EAAE,UAAU,EAAE,GAAG,2BAA2B,CAAC,IAAI,CAAC,CAAC;EAC3D,EAAE,OAAO,UAAU,CAAC;EACpB,CAAC;;EAED,SAAS,aAAa,CAAC,IAAI,EAAE,CAAC,EAAE,UAAU,GAAG,EAAE,EAAE,OAAO,GAAG,EAAE,EAAE;EAC/D;EACA;EACA;EACA,EAAE,MAAM,EAAE,4BAA4B,EAAE,GAAG,2BAA2B,CAAC,IAAI,CAAC,CAAC;EAC7E,EAAE,OAAO,4BAA4B,CAAC,CAAC,EAAE,UAAU,EAAE,OAAO,CAAC,CAAC;EAC9D,CAAC;;EAED,MAAM,SAAS,GAAG;EAClB,EAAE,aAAa;EACf,EAAE,eAAe;EACjB,EAAE,cAAc;EAChB,EAAE,aAAa;EACf,CAAC,CAAC;;EAEF;EACA;EACA,MAAM,gBAAgB,GAAG,sBAAsB,EAAE,CAAC;;EAElD;EACA;EACA;EACA;EACA;EACA,MAAM,KAAK,GAAG,eAAe,CAAC,gBAAgB,EAAE,SAAS,CAAC,CAAC;;;;;;;;"}
##############################################
/src/dist/realms-shim.esm.min.js.map:1:{"version":3,"file":"realms-shim.esm.min.js","sources":["../src/utilities.js","../src/realmFacade.js","../src/callAndWrapError.js","../src/commons.js","../src/stdlib.js","../src/repair/accessors.js","../src/repair/functions.js","../src/unsafeRec.js","../src/optimizer.js","../src/scopeHandlerFacade.js","../src/safeEvalFacade.js","../src/safeFunctionFacade.js","../src/sourceParser.js","../src/evaluators.js","../src/realm.js"],"sourcesContent":["// we'd like to abandon, but we can't, so just scream and break a lot of\n// stuff. However, since we aren't really aborting the process, be careful to\n// not throw an Error object which could be captured by child-Realm code and\n// used to access the (too-powerful) primal-realm Error object.\n\nexport function throwTantrum(s, err = undefined) {\n  const msg = `please report internal shim error: ${s}`;\n\n  // we want to log these 'should never happen' things.\n  // eslint-disable-next-line no-console\n  console.error(msg);\n  if (err) {\n    // eslint-disable-next-line no-console\n    console.error(`${err}`);\n    // eslint-disable-next-line no-console\n    console.error(`${err.stack}`);\n  }\n\n  // eslint-disable-next-line no-debugger\n  debugger;\n  throw msg;\n}\n\nexport function assert(condition, message) {\n  if (!condition) {\n    throwTantrum(message);\n  }\n}\n\n/**\n * cleanupSource()\n * Remove code modifications introduced by ems and nyx in\n * test mode which intefere with Function.toString().\n *\n * Becuase this change is not required at runtime, the\n * body of this function is hollowed-out during the build\n * process by rollup-plugin-strip-code. As configured in\n * in rollup.config.jj, all code between the custom tags\n * START_TESTS_ONLY and END_TESTS_ONLY, and including those\n * tags, is stripped, turning this function into a noop.\n */\nexport function cleanupSource(src) {\n  // Restore eval which is modified by esm module.\n  // (0, eval) => (0, _<something>.e)\n  src = src.replace(/\\(0,\\s*_[^.]+\\.e\\)/g, '(0, eval)');\n\n  // Restore Reflect which is modified by esm module.\n  // Reflect => _<something>.e.Reflect\n  src = src.replace(/_[^.]+\\.g\\.Reflect/g, 'Reflect');\n\n  // Remove code coverage which is injected by nyc module.\n  src = src.replace(/cov_[^+]+\\+\\+[;,]/g, '');\n\n  return src;\n}\n","import { cleanupSource } from './utilities';\n\n// buildChildRealm is immediately turned into a string, and this function is\n// never referenced again, because it closes over the wrong intrinsics\n\nexport function buildChildRealm(unsafeRec, BaseRealm) {\n  const { callAndWrapError } = unsafeRec;\n  const {\n    initRootRealm,\n    initCompartment,\n    getRealmGlobal,\n    realmEvaluate\n  } = BaseRealm;\n\n  const { create, defineProperties } = Object;\n\n  class Realm {\n    constructor() {\n      // The Realm constructor is not intended to be used with the new operator\n      // or to be subclassed. It may be used as the value of an extends clause\n      // of a class definition but a super call to the Realm constructor will\n      // cause an exception.\n\n      // When Realm is called as a function, an exception is also raised because\n      // a class constructor cannot be invoked without 'new'.\n      throw new TypeError('Realm is not a constructor');\n    }\n\n    static makeRootRealm(options = {}) {\n      // This is the exposed interface.\n\n      // Bypass the constructor.\n      const r = create(Realm.prototype);\n      callAndWrapError(initRootRealm, [unsafeRec, r, options]);\n      return r;\n    }\n\n    static makeCompartment(options = {}) {\n      // Bypass the constructor.\n      const r = create(Realm.prototype);\n      callAndWrapError(initCompartment, [unsafeRec, r, options]);\n      return r;\n    }\n\n    // we omit the constructor because it is empty. All the personalization\n    // takes place in one of the two static methods,\n    // makeRootRealm/makeCompartment\n\n    get global() {\n      // this is safe against being called with strange 'this' because\n      // baseGetGlobal immediately does a trademark check (it fails unless\n      // this 'this' is present in a weakmap that is only populated with\n      // legitimate Realm instances)\n      return callAndWrapError(getRealmGlobal, [this]);\n    }\n\n    evaluate(x, endowments, options = {}) {\n      // safe against strange 'this', as above\n      return callAndWrapError(realmEvaluate, [this, x, endowments, options]);\n    }\n  }\n\n  defineProperties(Realm, {\n    toString: {\n      value: () => 'function Realm() { [shim code] }',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  defineProperties(Realm.prototype, {\n    toString: {\n      value: () => '[object Realm]',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  return Realm;\n}\n\n// The parentheses means we don't bind the 'buildChildRealm' name inside the\n// child's namespace. this would accept an anonymous function declaration.\n// function expression (not a declaration) so it has a completion value.\nconst buildChildRealmString = cleanupSource(\n  `'use strict'; (${buildChildRealm})`\n);\n\nexport function createRealmFacade(unsafeRec, BaseRealm) {\n  const { unsafeEval } = unsafeRec;\n  // The BaseRealm is the Realm class created by\n  // the shim. It's only valid for the context where\n  // it was parsed.\n\n  // The Realm facade is a lightweight class built in the\n  // context a different context, that provide a fully\n  // functional Realm class using the intrisics\n  // of that context.\n\n  // This process is simplified because all methods\n  // and properties on a realm instance already return\n  // values using the intrinsics of the realm's context.\n\n  // Invoke the BaseRealm constructor with Realm as the prototype.\n  return unsafeEval(buildChildRealmString)(unsafeRec, BaseRealm);\n}\n","import { cleanupSource } from './utilities';\n\nfunction buildCallAndWrapError() {\n  // This Object and Reflect are brand new, from a new unsafeRec, so no user\n  // code has been run or had a chance to manipulate them. Don't ever run this\n  // function *after* user code has had a chance to pollute its environment,\n  // or it could be used to gain access to BaseRealm and primal-realm Error\n  // objects.\n  const { getPrototypeOf } = Object;\n  const { apply } = Reflect;\n  const uncurryThis = fn => (thisArg, ...args) => apply(fn, thisArg, args);\n  const mapGet = uncurryThis(Map.prototype.get);\n  const setHas = uncurryThis(Set.prototype.has);\n\n  const errorNameToErrorConstructor = new Map([\n    ['EvalError', EvalError],\n    ['RangeError', RangeError],\n    ['ReferenceError', ReferenceError],\n    ['SyntaxError', SyntaxError],\n    ['TypeError', TypeError],\n    ['URIError', URIError]\n  ]);\n  const errorConstructors = new Set([\n    EvalError.prototype,\n    RangeError.prototype,\n    ReferenceError.prototype,\n    SyntaxError.prototype,\n    TypeError.prototype,\n    URIError.prototype,\n    Error.prototype\n  ]);\n\n  function callAndWrapError(target, args) {\n    try {\n      return apply(target, undefined, args);\n    } catch (err) {\n      // 1. Thrown primitives\n      if (Object(err) !== err) {\n        // err is a primitive value, which is safe to rethrow\n        throw err;\n      }\n\n      // 2. Current realm errors\n      if (setHas(errorConstructors, getPrototypeOf(err))) {\n        // err is a from the current realm, which is safe to rethrow.\n        // Object instances (normally) only contain intrinsics from the\n        // same realm. An error containing intrinsics from different\n        // realms would have to be manually constucted, which imply that\n        // such intrinsics were available, and confinement was already lost.\n        throw err;\n      }\n\n      // 3. Other realm errors\n      let eName, eMessage, eStack;\n      try {\n        // The other environment might seek to use 'err' to reach the\n        // parent's intrinsics and corrupt them. In addition, exceptions\n        // raised in the primal realm need to be converted to the current\n        // realm.\n\n        // `${err.name}` will cause string coercion of 'err.name'.\n        // If err.name is an object (probably a String of another Realm),\n        // the coercion uses err.name.toString(), which is under the control\n        // of the other realm. If err.name were a primitive (e.g. a number),\n        // it would use Number.toString(err.name), using the child's version\n        // of Number (which the child could modify to capture its argument for\n        // later use), however primitives don't have properties like .prototype\n        // so they aren't useful for an attack.\n        eName = `${err.name}`;\n        eMessage = `${err.message}`;\n        eStack = `${err.stack || eMessage}`;\n        // eName/eMessage/eStack are now realm-independent primitive strings, and\n        // safe to expose.\n      } catch (ignored) {\n        // if err.name.toString() throws, keep the (parent realm) Error away.\n        throw new Error('unknown error');\n      }\n      const ErrorConstructor =\n        mapGet(errorNameToErrorConstructor, eName) || Error;\n      try {\n        throw new ErrorConstructor(eMessage);\n      } catch (err2) {\n        err2.stack = eStack; // replace with the captured inner stack\n        throw err2;\n      }\n    }\n  }\n\n  return callAndWrapError;\n}\n\nconst buildCallAndWrapErrorString = cleanupSource(\n  `'use strict'; (${buildCallAndWrapError})`\n);\nexport function createCallAndWrapError(unsafeEval) {\n  return unsafeEval(buildCallAndWrapErrorString)();\n}\n","// Declare shorthand functions. Sharing these declarations across modules\n// improves both consistency and minification. Unused declarations are\n// dropped by the tree shaking process.\n\n// we capture these, not just for brevity, but for security. If any code\n// modifies Object to change what 'assign' points to, the Realm shim would be\n// corrupted.\n\nexport const {\n  assign,\n  create,\n  freeze,\n  defineProperties, // Object.defineProperty is allowed to fail\n  // silentlty, use Object.defineProperties instead.\n  getOwnPropertyDescriptor,\n  getOwnPropertyDescriptors,\n  getOwnPropertyNames,\n  getPrototypeOf,\n  setPrototypeOf\n} = Object;\n\nexport const {\n  apply,\n  ownKeys // Reflect.ownKeys includes Symbols and unenumerables,\n  // unlike Object.keys()\n} = Reflect;\n\n/**\n * uncurryThis() See\n * http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\n * which only lives at\n * http://web.archive.org/web/20160805225710/http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\n *\n * Performance:\n * 1. The native call is about 10x faster on FF than chrome\n * 2. The version using Function.bind() is about 100x slower on FF,\n *    equal on chrome, 2x slower on Safari\n * 3. The version using a spread and Reflect.apply() is about 10x\n *    slower on FF, equal on chrome, 2x slower on Safari\n *\n * const bind = Function.prototype.bind;\n * const uncurryThis = bind.bind(bind.call);\n */\nconst uncurryThis = fn => (thisArg, ...args) => apply(fn, thisArg, args);\n\n// We also capture these for security: changes to Array.prototype after the\n// Realm shim runs shouldn't affect subsequent Realm operations.\nexport const objectHasOwnProperty = uncurryThis(\n    Object.prototype.hasOwnProperty\n  ),\n  arrayForEach = uncurryThis(Array.prototype.forEach),\n  arrayFilter = uncurryThis(Array.prototype.filter),\n  arrayPush = uncurryThis(Array.prototype.push),\n  arrayPop = uncurryThis(Array.prototype.pop),\n  arrayJoin = uncurryThis(Array.prototype.join),\n  arrayConcat = uncurryThis(Array.prototype.concat),\n  regexpTest = uncurryThis(RegExp.prototype.test),\n  stringMatch = uncurryThis(String.prototype.match),\n  stringIncludes = uncurryThis(String.prototype.includes);\n","import { getOwnPropertyDescriptor } from './commons';\nimport { assert } from './utilities';\n\n// These value properties of the global object are non-writable,\n// non-configurable data properties.\nconst frozenGlobalPropertyNames = [\n  // *** 18.1 Value Properties of the Global Object\n\n  'Infinity',\n  'NaN',\n  'undefined'\n];\n\n// All the following stdlib items have the same name on both our intrinsics\n// object and on the global object. Unlike Infinity/NaN/undefined, these\n// should all be writable and configurable. This is divided into two\n// sets. The stable ones are those the shim can freeze early because\n// we don't expect anyone will want to mutate them. The unstable ones\n// are the ones that we correctly initialize to writable and\n// configurable so that they can still be replaced or removed.\nconst stableGlobalPropertyNames = [\n  // *** 18.2 Function Properties of the Global Object\n\n  // 'eval', // comes from safeEval instead\n  'isFinite',\n  'isNaN',\n  'parseFloat',\n  'parseInt',\n\n  'decodeURI',\n  'decodeURIComponent',\n  'encodeURI',\n  'encodeURIComponent',\n\n  // *** 18.3 Constructor Properties of the Global Object\n\n  'Array',\n  'ArrayBuffer',\n  'Boolean',\n  'DataView',\n  // 'Date',  // Unstable\n  // 'Error',  // Unstable\n  'EvalError',\n  'Float32Array',\n  'Float64Array',\n  // 'Function',  // comes from safeFunction instead\n  'Int8Array',\n  'Int16Array',\n  'Int32Array',\n  'Map',\n  'Number',\n  'Object',\n  // 'Promise',  // Unstable\n  // 'Proxy',  // Unstable\n  'RangeError',\n  'ReferenceError',\n  // 'RegExp',  // Unstable\n  'Set',\n  // 'SharedArrayBuffer'  // removed on Jan 5, 2018\n  'String',\n  'Symbol',\n  'SyntaxError',\n  'TypeError',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Uint16Array',\n  'Uint32Array',\n  'URIError',\n  'WeakMap',\n  'WeakSet',\n\n  // *** 18.4 Other Properties of the Global Object\n\n  // 'Atomics', // removed on Jan 5, 2018\n  'JSON',\n  'Math',\n  'Reflect',\n\n  // *** Annex B\n\n  'escape',\n  'unescape'\n\n  // *** ECMA-402\n\n  // 'Intl'  // Unstable\n\n  // *** ESNext\n\n  // 'Realm' // Comes from createRealmGlobalObject()\n];\n\nconst unstableGlobalPropertyNames = [\n  'Date',\n  'Error',\n  'Promise',\n  'Proxy',\n  'RegExp',\n  'Intl'\n];\n\nexport function getSharedGlobalDescs(unsafeGlobal) {\n  const descriptors = {};\n\n  function describe(names, writable, enumerable, configurable) {\n    for (const name of names) {\n      const desc = getOwnPropertyDescriptor(unsafeGlobal, name);\n      if (desc) {\n        // Abort if an accessor is found on the unsafe global object\n        // instead of a data property. We should never get into this\n        // non standard situation.\n        assert(\n          'value' in desc,\n          `unexpected accessor on global property: ${name}`\n        );\n\n        descriptors[name] = {\n          value: desc.value,\n          writable,\n          enumerable,\n          configurable\n        };\n      }\n    }\n  }\n\n  describe(frozenGlobalPropertyNames, false, false, false);\n  // The following is correct but expensive.\n  // describe(stableGlobalPropertyNames, true, false, true);\n  // Instead, for now, we let these get optimized.\n  //\n  // TODO: We should provide an option to turn this optimization off,\n  // by feeding \"true, false, true\" here instead.\n  describe(stableGlobalPropertyNames, false, false, false);\n  // These we keep replaceable and removable, because we expect\n  // others, e.g., SES, may want to do so.\n  describe(unstableGlobalPropertyNames, true, false, true);\n\n  return descriptors;\n}\n","// Adapted from SES/Caja - Copyright (C) 2011 Google Inc.\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js\n\n/**\n * Replace the legacy accessors of Object to comply with strict mode\n * and ES2016 semantics, we do this by redefining them while in 'use strict'.\n *\n * todo: list the issues resolved\n *\n * This function can be used in two ways: (1) invoked directly to fix the primal\n * realm's Object.prototype, and (2) converted to a string to be executed\n * inside each new RootRealm to fix their Object.prototypes. Evaluation requires\n * the function to have no dependencies, so don't import anything from\n * the outside.\n */\n\n// todo: this file should be moved out to a separate repo and npm module.\nexport function repairAccessors() {\n  const {\n    defineProperty,\n    defineProperties,\n    getOwnPropertyDescriptor,\n    getPrototypeOf,\n    prototype: objectPrototype\n  } = Object;\n\n  // On some platforms, the implementation of these functions act as\n  // if they are in sloppy mode: if they're invoked badly, they will\n  // expose the global object, so we need to repair these for\n  // security. Thus it is our responsibility to fix this, and we need\n  // to include repairAccessors. E.g. Chrome in 2016.\n\n  try {\n    // Verify that the method is not callable.\n    // eslint-disable-next-line no-restricted-properties, no-underscore-dangle\n    (0, objectPrototype.__lookupGetter__)('x');\n  } catch (ignore) {\n    // Throws, no need to patch.\n    return;\n  }\n\n  function toObject(obj) {\n    if (obj === undefined || obj === null) {\n      throw new TypeError(`can't convert undefined or null to object`);\n    }\n    return Object(obj);\n  }\n\n  function asPropertyName(obj) {\n    if (typeof obj === 'symbol') {\n      return obj;\n    }\n    return `${obj}`;\n  }\n\n  function aFunction(obj, accessor) {\n    if (typeof obj !== 'function') {\n      throw TypeError(`invalid ${accessor} usage`);\n    }\n    return obj;\n  }\n\n  defineProperties(objectPrototype, {\n    __defineGetter__: {\n      value: function __defineGetter__(prop, func) {\n        const O = toObject(this);\n        defineProperty(O, prop, {\n          get: aFunction(func, 'getter'),\n          enumerable: true,\n          configurable: true\n        });\n      }\n    },\n    __defineSetter__: {\n      value: function __defineSetter__(prop, func) {\n        const O = toObject(this);\n        defineProperty(O, prop, {\n          set: aFunction(func, 'setter'),\n          enumerable: true,\n          configurable: true\n        });\n      }\n    },\n    __lookupGetter__: {\n      value: function __lookupGetter__(prop) {\n        let O = toObject(this);\n        prop = asPropertyName(prop);\n        let desc;\n        while (O && !(desc = getOwnPropertyDescriptor(O, prop))) {\n          O = getPrototypeOf(O);\n        }\n        return desc && desc.get;\n      }\n    },\n    __lookupSetter__: {\n      value: function __lookupSetter__(prop) {\n        let O = toObject(this);\n        prop = asPropertyName(prop);\n        let desc;\n        while (O && !(desc = getOwnPropertyDescriptor(O, prop))) {\n          O = getPrototypeOf(O);\n        }\n        return desc && desc.set;\n      }\n    }\n  });\n}\n","// Adapted from SES/Caja\n// Copyright (C) 2011 Google Inc.\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js\n\n/**\n * This block replaces the original Function constructor, and the original\n * %GeneratorFunction% %AsyncFunction% and %AsyncGeneratorFunction%, with\n * safe replacements that throw if invoked.\n *\n * These are all reachable via syntax, so it isn't sufficient to just\n * replace global properties with safe versions. Our main goal is to prevent\n * access to the Function constructor through these starting points.\n\n * After this block is done, the originals must no longer be reachable, unless\n * a copy has been made, and funtions can only be created by syntax (using eval)\n * or by invoking a previously saved reference to the originals.\n */\n\n// todo: this file should be moved out to a separate repo and npm module.\nexport function repairFunctions() {\n  const { defineProperties, getPrototypeOf, setPrototypeOf } = Object;\n\n  /**\n   * The process to repair constructors:\n   * 1. Create an instance of the function by evaluating syntax\n   * 2. Obtain the prototype from the instance\n   * 3. Create a substitute tamed constructor\n   * 4. Replace the original constructor with the tamed constructor\n   * 5. Replace tamed constructor prototype property with the original one\n   * 6. Replace its [[Prototype]] slot with the tamed constructor of Function\n   */\n  function repairFunction(name, declaration) {\n    let FunctionInstance;\n    try {\n      // eslint-disable-next-line no-new-func\n      FunctionInstance = (0, eval)(declaration);\n    } catch (e) {\n      if (e instanceof SyntaxError) {\n        // Prevent failure on platforms where async and/or generators\n        // are not supported.\n        return;\n      }\n      // Re-throw\n      throw e;\n    }\n    const FunctionPrototype = getPrototypeOf(FunctionInstance);\n\n    // Prevents the evaluation of source when calling constructor on the\n    // prototype of functions.\n    const TamedFunction = function() {\n      throw new TypeError('Not available');\n    };\n    defineProperties(TamedFunction, { name: { value: name } });\n\n    // (new Error()).constructors does not inherit from Function, because Error\n    // was defined before ES6 classes. So we don't need to repair it too.\n\n    // (Error()).constructor inherit from Function, which gets a tamed\n    // constructor here.\n\n    // todo: in an ES6 class that does not inherit from anything, what does its\n    // constructor inherit from? We worry that it inherits from Function, in\n    // which case instances could give access to unsafeFunction. markm says\n    // we're fine: the constructor inherits from Object.prototype\n\n    // This line replaces the original constructor in the prototype chain\n    // with the tamed one. No copy of the original is peserved.\n    defineProperties(FunctionPrototype, {\n      constructor: { value: TamedFunction }\n    });\n\n    // This line sets the tamed constructor's prototype data property to\n    // the original one.\n    defineProperties(TamedFunction, {\n      prototype: { value: FunctionPrototype }\n    });\n\n    if (TamedFunction !== Function.prototype.constructor) {\n      // Ensures that all functions meet \"instanceof Function\" in a realm.\n      setPrototypeOf(TamedFunction, Function.prototype.constructor);\n    }\n  }\n\n  // Here, the order of operation is important: Function needs to be repaired\n  // first since the other repaired constructors need to inherit from the tamed\n  // Function function constructor.\n\n  // note: this really wants to be part of the standard, because new\n  // constructors may be added in the future, reachable from syntax, and this\n  // list must be updated to match.\n\n  // \"plain arrow functions\" inherit from Function.prototype\n\n  repairFunction('Function', '(function(){})');\n  repairFunction('GeneratorFunction', '(function*(){})');\n  repairFunction('AsyncFunction', '(async function(){})');\n  repairFunction('AsyncGeneratorFunction', '(async function*(){})');\n}\n","// this module must never be importable outside the Realm shim itself\nimport { createCallAndWrapError } from './callAndWrapError';\nimport { getSharedGlobalDescs } from './stdlib';\nimport { repairAccessors } from './repair/accessors';\nimport { repairFunctions } from './repair/functions';\nimport { cleanupSource } from './utilities';\nimport { freeze } from './commons';\n\n// A \"context\" is a fresh unsafe Realm as given to us by existing platforms.\n// We need this to implement the shim. However, when Realms land for real,\n// this feature will be provided by the underlying engine instead.\n\n// note: in a node module, the top-level 'this' is not the global object\n// (it's *something* but we aren't sure what), however an indirect eval of\n// 'this' will be the correct global object.\n\nconst unsafeGlobalSrc = \"'use strict'; this\";\nconst unsafeGlobalEvalSrc = `(0, eval)(\"'use strict'; this\")`;\n\n// This method is only exported for testing purposes.\nexport function createNewUnsafeGlobalForNode() {\n  // Note that webpack and others will shim 'vm' including the method\n  // 'runInNewContext', so the presence of vm is not a useful check\n\n  // TODO: Find a better test that works with bundlers\n  // eslint-disable-next-line no-new-func\n  const isNode = new Function(\n    'try {return this===global}catch(e){return false}'\n  )();\n\n  if (!isNode) {\n    return undefined;\n  }\n\n  // eslint-disable-next-line global-require\n  const vm = require('vm');\n\n  // Use unsafeGlobalEvalSrc to ensure we get the right 'this'.\n  const unsafeGlobal = vm.runInNewContext(unsafeGlobalEvalSrc);\n\n  return unsafeGlobal;\n}\n\n// This method is only exported for testing purposes.\nexport function createNewUnsafeGlobalForBrowser() {\n  if (typeof document === 'undefined') {\n    return undefined;\n  }\n  const iframe = document.createElement('iframe');\n  iframe.style.display = 'none';\n\n  document.body.appendChild(iframe);\n  const unsafeGlobal = iframe.contentWindow.eval(unsafeGlobalSrc);\n\n  // We keep the iframe attached to the DOM because removing it\n  // causes its global object to lose intrinsics, its eval()\n  // function to evaluate code, etc.\n\n  // TODO: can we remove and garbage-collect the iframes?\n\n  return unsafeGlobal;\n}\n\nconst getNewUnsafeGlobal = () => {\n  const newUnsafeGlobalForBrowser = createNewUnsafeGlobalForBrowser();\n  const newUnsafeGlobalForNode = createNewUnsafeGlobalForNode();\n  if (\n    (!newUnsafeGlobalForBrowser && !newUnsafeGlobalForNode) ||\n    (newUnsafeGlobalForBrowser && newUnsafeGlobalForNode)\n  ) {\n    throw new Error('unexpected platform, unable to create Realm');\n  }\n  return newUnsafeGlobalForBrowser || newUnsafeGlobalForNode;\n};\n\n// The unsafeRec is shim-specific. It acts as the mechanism to obtain a fresh\n// set of intrinsics together with their associated eval and Function\n// evaluators. These must be used as a matched set, since the evaluators are\n// tied to a set of intrinsics, aka the \"undeniables\". If it were possible to\n// mix-and-match them from different contexts, that would enable some\n// attacks.\nfunction createUnsafeRec(unsafeGlobal, allShims = []) {\n  const sharedGlobalDescs = getSharedGlobalDescs(unsafeGlobal);\n\n  const unsafeEval = unsafeGlobal.eval;\n  const unsafeFunction = unsafeGlobal.Function;\n\n  const callAndWrapError = createCallAndWrapError(unsafeEval);\n\n  return freeze({\n    unsafeGlobal,\n    sharedGlobalDescs,\n    unsafeEval,\n    unsafeFunction,\n    callAndWrapError,\n    allShims\n  });\n}\n\nconst repairAccessorsShim = cleanupSource(\n  `\"use strict\"; (${repairAccessors})();`\n);\nconst repairFunctionsShim = cleanupSource(\n  `\"use strict\"; (${repairFunctions})();`\n);\n\n// Create a new unsafeRec from a brand new context, with new intrinsics and a\n// new global object\nexport function createNewUnsafeRec(allShims) {\n  const unsafeGlobal = getNewUnsafeGlobal();\n  unsafeGlobal.eval(repairAccessorsShim);\n  unsafeGlobal.eval(repairFunctionsShim);\n  return createUnsafeRec(unsafeGlobal, allShims);\n}\n\n// Create a new unsafeRec from the current context, where the Realm shim is\n// being parsed and executed, aka the \"Primal Realm\"\nexport function createCurrentUnsafeRec() {\n  const unsafeGlobal = (0, eval)(unsafeGlobalSrc);\n  repairAccessors();\n  repairFunctions();\n  return createUnsafeRec(unsafeGlobal);\n}\n","import {\n  arrayFilter,\n  getOwnPropertyDescriptors,\n  getOwnPropertyNames,\n  objectHasOwnProperty,\n  regexpTest\n} from './commons';\n\n// todo: think about how this interacts with endowments, check for conflicts\n// between the names being optimized and the ones added by endowments\n\n/**\n * Simplified validation of indentifier names: may only contain alphanumeric\n * characters (or \"$\" or \"_\"), and may not start with a digit. This is safe\n * and does not reduces the compatibility of the shim. The motivation for\n * this limitation was to decrease the complexity of the implementation,\n * and to maintain a resonable level of performance.\n * Note: \\w is equivalent [a-zA-Z_0-9]\n * See 11.6.1 Identifier Names\n */\nconst identifierPattern = /^[a-zA-Z_$][\\w$]*$/;\n\n/**\n * In JavaScript you cannot use these reserved words as variables.\n * See 11.6.1 Identifier Names\n */\nconst keywords = new Set([\n  // 11.6.2.1 Keywords\n  'await',\n  'break',\n  'case',\n  'catch',\n  'class',\n  'const',\n  'continue',\n  'debugger',\n  'default',\n  'delete',\n  'do',\n  'else',\n  'export',\n  'extends',\n  'finally',\n  'for',\n  'function',\n  'if',\n  'import',\n  'in',\n  'instanceof',\n  'new',\n  'return',\n  'super',\n  'switch',\n  'this',\n  'throw',\n  'try',\n  'typeof',\n  'var',\n  'void',\n  'while',\n  'with',\n  'yield',\n\n  // Also reserved when parsing strict mode code\n  'let',\n  'static',\n\n  // 11.6.2.2 Future Reserved Words\n  'enum',\n\n  // Also reserved when parsing strict mode code\n  'implements',\n  'package',\n  'protected',\n  'interface',\n  'private',\n  'public',\n\n  // Reserved but not mentioned in specs\n  'await',\n\n  'null',\n  'true',\n  'false',\n\n  'this',\n  'arguments'\n]);\n\n/**\n * getOptimizableGlobals()\n * What variable names might it bring into scope? These include all\n * property names which can be variable names, including the names\n * of inherited properties. It excludes symbols and names which are\n * keywords. We drop symbols safely. Currently, this shim refuses\n * service if any of the names are keywords or keyword-like. This is\n * safe and only prevent performance optimization.\n */\nexport function getOptimizableGlobals(safeGlobal) {\n  const descs = getOwnPropertyDescriptors(safeGlobal);\n\n  // getOwnPropertyNames does ignore Symbols so we don't need this extra check:\n  // typeof name === 'string' &&\n  const constants = arrayFilter(getOwnPropertyNames(descs), name => {\n    // Ensure we have a valid identifier. We use regexpTest rather than\n    // /../.test() to guard against the case where RegExp has been poisoned.\n    if (\n      name === 'eval' ||\n      keywords.has(name) ||\n      !regexpTest(identifierPattern, name)\n    ) {\n      return false;\n    }\n\n    const desc = descs[name];\n    return (\n      //\n      // The getters will not have .writable, don't let the falsyness of\n      // 'undefined' trick us: test with === false, not ! . However descriptors\n      // inherit from the (potentially poisoned) global object, so we might see\n      // extra properties which weren't really there. Accessor properties have\n      // 'get/set/enumerable/configurable', while data properties have\n      // 'value/writable/enumerable/configurable'.\n      desc.configurable === false &&\n      desc.writable === false &&\n      //\n      // Checks for data properties because they're the only ones we can\n      // optimize (accessors are most likely non-constant). Descriptors can't\n      // can't have accessors and value properties at the same time, therefore\n      // this check is sufficient. Using explicit own property deal with the\n      // case where Object.prototype has been poisoned.\n      objectHasOwnProperty(desc, 'value')\n    );\n  });\n\n  return constants;\n}\n","import { cleanupSource } from './utilities';\n\n/**\n * ScopeHandler manages a Proxy which serves as the global scope for the\n * safeEvaluator operation (the Proxy is the argument of a 'with' binding).\n * As described in createSafeEvaluator(), it has several functions:\n * - allow the very first (and only the very first) use of 'eval' to map to\n *   the real (unsafe) eval function, so it acts as a 'direct eval' and can\n *    access its lexical scope (which maps to the 'with' binding, which the\n *   ScopeHandler also controls).\n * - ensure that all subsequent uses of 'eval' map to the safeEvaluator,\n *   which lives as the 'eval' property of the safeGlobal.\n * - route all other property lookups at the safeGlobal.\n * - hide the unsafeGlobal which lives on the scope chain above the 'with'.\n * - ensure the Proxy invariants despite some global properties being frozen.\n *\n * @returns {ProxyHandler<any> & Record<string, any>}\n */\nexport function buildScopeHandler(\n  unsafeRec,\n  safeGlobal,\n  endowments = {},\n  sloppyGlobals = false\n) {\n  const { unsafeGlobal, unsafeEval } = unsafeRec;\n\n  const { freeze } = Object;\n  const { get: reflectGet } = Reflect;\n  const { unscopables } = Symbol;\n\n  /**\n   * alwaysThrowHandler is a proxy handler which throws on any trap called.\n   * It's made from a proxy with a get trap that throws. Its target is\n   * an immutable (frozen) object and is safe to share, except accross realms\n   */\n  const alwaysThrowHandler = new Proxy(freeze({}), {\n    get(target, prop) {\n      // todo: replace with throwTantrum\n      throw new TypeError(\n        `unexpected scope handler trap called: ${String(prop)}`\n      );\n    }\n  });\n\n  return {\n    // The scope handler throws if any trap other than get/set/has are run\n    // (e.g. getOwnPropertyDescriptors, apply, getPrototypeOf).\n    // eslint-disable-next-line no-proto\n    __proto__: alwaysThrowHandler,\n\n    // This flag allow us to determine if the eval() call is an done by the\n    // realm's code or if it is user-land invocation, so we can react differently.\n    // We use a property and not an accessor to avoid increasing the stack trace\n    // and reduce the possibility of OOM.\n    useUnsafeEvaluator: false,\n\n    get(shadow, prop) {\n      if (prop === unscopables) {\n        // Safe to return a primal realm Object here because the only code that\n        // can do a get() on a non-string is the internals of with() itself,\n        // and the only thing it does is to look for properties on it. User\n        // code cannot do a lookup on non-strings.\n        return undefined;\n      }\n\n      // Special treatment for eval. The very first lookup of 'eval' gets the\n      // unsafe (real direct) eval, so it will get the lexical scope that uses\n      // the 'with' context.\n      if (prop === 'eval') {\n        // test that it is true rather than merely truthy\n        if (this.useUnsafeEvaluator === true) {\n          // revoke before use\n          this.useUnsafeEvaluator = false;\n          return unsafeEval;\n        }\n        // fall through\n      }\n\n      // Properties of the global.\n      if (prop in endowments) {\n        return reflectGet(endowments, prop, safeGlobal);\n      }\n\n      // Properties of the global.\n      if (prop in safeGlobal) {\n        return safeGlobal[prop];\n      }\n\n      // Prevent the lookup for other properties.\n      return undefined;\n    },\n\n    // eslint-disable-next-line class-methods-use-this\n    set(shadow, prop, value) {\n      // todo: allow modifications when prop in endowments and it\n      // is writable, assuming we've already rejected overlap (see\n      // createSafeEvaluatorFactory.factory). This TypeError gets replaced with\n      // reflectSet(endowments, prop, value, safeGlobal);\n      if (prop in endowments) {\n        // todo: shim integrity: TypeError, String\n        throw new TypeError(`do not modify endowments like ${String(prop)}`);\n      }\n\n      safeGlobal[prop] = value;\n\n      // Return true after successful set.\n      return true;\n    },\n\n    // we need has() to return false for some names to prevent the lookup  from\n    // climbing the scope chain and eventually reaching the unsafeGlobal\n    // object, which is bad.\n\n    // note: unscopables! every string in Object[Symbol.unscopables]\n\n    // todo: we'd like to just have has() return true for everything, and then\n    // use get() to raise a ReferenceError for anything not on the safe global.\n    // But we want to be compatible with ReferenceError in the normal case and\n    // the lack of ReferenceError in the 'typeof' case. Must either reliably\n    // distinguish these two cases (the trap behavior might be different), or\n    // we rely on a mandatory source-to-source transform to change 'typeof abc'\n    // to XXX. We already need a mandatory parse to prevent the 'import',\n    // since it's a special form instead of merely being a global variable/\n\n    // note: if we make has() return true always, then we must implement a\n    // set() trap to avoid subverting the protection of strict mode (it would\n    // accept assignments to undefined globals, when it ought to throw\n    // ReferenceError for such assignments)\n\n    has(shadow, prop) {\n      // proxies stringify 'prop', so no TOCTTOU danger here\n\n      if (sloppyGlobals) {\n        // Everything is potentially available.\n        return true;\n      }\n\n      // unsafeGlobal: hide all properties of unsafeGlobal at the\n      // expense of 'typeof' being wrong for those properties. For\n      // example, in the browser, evaluating 'document = 3', will add\n      // a property to safeGlobal instead of throwing a\n      // ReferenceError.\n      if (\n        prop === 'eval' ||\n        prop in endowments ||\n        prop in safeGlobal ||\n        prop in unsafeGlobal\n      ) {\n        return true;\n      }\n\n      return false;\n    },\n\n    // note: this is likely a bug of safari\n    // https://bugs.webkit.org/show_bug.cgi?id=195534\n\n    getPrototypeOf() {\n      return null;\n    }\n  };\n}\n\nconst buildScopeHandlerString = cleanupSource(\n  `'use strict'; (${buildScopeHandler})`\n);\nexport function createScopeHandler(\n  unsafeRec,\n  safeGlobal,\n  endowments,\n  sloppyGlobals\n) {\n  const { unsafeEval } = unsafeRec;\n  return unsafeEval(buildScopeHandlerString)(\n    unsafeRec,\n    safeGlobal,\n    endowments,\n    sloppyGlobals\n  );\n}\n","import { cleanupSource } from './utilities';\n\nfunction buildSafeEval(unsafeRec, safeEvalOperation) {\n  const { callAndWrapError } = unsafeRec;\n\n  const { defineProperties } = Object;\n\n  // We use the the concise method syntax to create an eval without a\n  // [[Construct]] behavior (such that the invocation \"new eval()\" throws\n  // TypeError: eval is not a constructor\"), but which still accepts a\n  // 'this' binding.\n  const safeEval = {\n    eval() {\n      return callAndWrapError(safeEvalOperation, arguments);\n    }\n  }.eval;\n\n  // safeEval's prototype RootRealm's value and instanceof Function\n  // is true inside the realm. It doesn't point at the primal realm\n  // value, and there is no defense against leaking primal realm\n  // intrinsics.\n\n  defineProperties(safeEval, {\n    toString: {\n      // We break up the following literal string so that an\n      // apparent direct eval syntax does not appear in this\n      // file. Thus, we avoid rejection by the overly eager\n      // rejectDangerousSources.\n      value: () => `function ${'eval'}() { [shim code] }`,\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  return safeEval;\n}\nconst buildSafeEvalString = cleanupSource(`'use strict'; (${buildSafeEval})`);\nexport function createSafeEval(unsafeRec, safeEvalOperation) {\n  const { unsafeEval } = unsafeRec;\n  return unsafeEval(buildSafeEvalString)(unsafeRec, safeEvalOperation);\n}\n","import { cleanupSource } from './utilities';\n\nfunction buildSafeFunction(unsafeRec, safeFunctionOperation) {\n  const { callAndWrapError, unsafeFunction } = unsafeRec;\n\n  const { defineProperties } = Object;\n\n  const safeFunction = function Function() {\n    return callAndWrapError(safeFunctionOperation, arguments);\n  };\n\n  // Ensure that Function from any compartment in a root realm can be used\n  // with instance checks in any compartment of the same root realm.\n\n  defineProperties(safeFunction, {\n    // Ensure that any function created in any compartment in a root realm is an\n    // instance of Function in any compartment of the same root ralm.\n    prototype: { value: unsafeFunction.prototype },\n\n    // Provide a custom output without overwriting the\n    // Function.prototype.toString which is called by some third-party\n    // libraries.\n    toString: {\n      value: () => 'function Function() { [shim code] }',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  return safeFunction;\n}\nconst buildSafeFunctionString = cleanupSource(\n  `'use strict'; (${buildSafeFunction})`\n);\nexport function createSafeFunction(unsafeRec, safeFunctionOperation) {\n  const { unsafeEval } = unsafeRec;\n  return unsafeEval(buildSafeFunctionString)(unsafeRec, safeFunctionOperation);\n}\n","// https://www.ecma-international.org/ecma-262/9.0/index.html#sec-html-like-comments\n// explains that JavaScript parsers may or may not recognize html\n// comment tokens \"<\" immediately followed by \"!--\" and \"--\"\n// immediately followed by \">\" in non-module source text, and treat\n// them as a kind of line comment. Since otherwise both of these can\n// appear in normal JavaScript source code as a sequence of operators,\n// we have the terrifying possibility of the same source code parsing\n// one way on one correct JavaScript implementation, and another way\n// on another.\n//\n// This shim takes the conservative strategy of just rejecting source\n// text that contains these strings anywhere. Note that this very\n// source file is written strangely to avoid mentioning these\n// character strings explicitly.\n\n// We do not write the regexp in a straightforward way, so that an\n// apparennt html comment does not appear in this file. Thus, we avoid\n// rejection by the overly eager rejectDangerousSources.\nconst htmlCommentPattern = new RegExp(`(?:${'<'}!--|--${'>'})`);\n\nfunction rejectHtmlComments(s) {\n  const index = s.search(htmlCommentPattern);\n  if (index !== -1) {\n    const linenum = s.slice(0, index).split('\\n').length; // more or less\n    throw new SyntaxError(\n      `possible html comment syntax rejected around line ${linenum}`\n    );\n  }\n}\n\n// The proposed dynamic import expression is the only syntax currently\n// proposed, that can appear in non-module JavaScript code, that\n// enables direct access to the outside world that cannot be\n// surpressed or intercepted without parsing and rewriting. Instead,\n// this shim conservatively rejects any source text that seems to\n// contain such an expression. To do this safely without parsing, we\n// must also reject some valid programs, i.e., those containing\n// apparent import expressions in literal strings or comments.\n\n// The current conservative rule looks for the identifier \"import\"\n// followed by either an open paren or something that looks like the\n// beginning of a comment. We assume that we do not need to worry\n// about html comment syntax because that was already rejected by\n// rejectHtmlComments.\n\n// this \\s *must* match all kinds of syntax-defined whitespace. If e.g.\n// U+2028 (LINE SEPARATOR) or U+2029 (PARAGRAPH SEPARATOR) is treated as\n// whitespace by the parser, but not matched by /\\s/, then this would admit\n// an attack like: import\\u2028('power.js') . We're trying to distinguish\n// something like that from something like importnotreally('power.js') which\n// is perfectly safe.\n\nconst importPattern = /\\bimport\\s*(?:\\(|\\/[/*])/;\n\nfunction rejectImportExpressions(s) {\n  const index = s.search(importPattern);\n  if (index !== -1) {\n    const linenum = s.slice(0, index).split('\\n').length; // more or less\n    throw new SyntaxError(\n      `possible import expression rejected around line ${linenum}`\n    );\n  }\n}\n\n// The shim cannot correctly emulate a direct eval as explained at\n// https://github.com/Agoric/realms-shim/issues/12\n// Without rejecting apparent direct eval syntax, we would\n// accidentally evaluate these with an emulation of indirect eval. Tp\n// prevent future compatibility problems, in shifting from use of the\n// shim to genuine platform support for the proposal, we should\n// instead statically reject code that seems to contain a direct eval\n// expression.\n//\n// As with the dynamic import expression, to avoid a full parse, we do\n// this approximately with a regexp, that will also reject strings\n// that appear safely in comments or strings. Unlike dynamic import,\n// if we miss some, this only creates future compat problems, not\n// security problems. Thus, we are only trying to catch innocent\n// occurrences, not malicious one. In particular, `(eval)(...)` is\n// direct eval syntax that would not be caught by the following regexp.\n\nconst someDirectEvalPattern = /\\beval\\s*(?:\\(|\\/[/*])/;\n\nfunction rejectSomeDirectEvalExpressions(s) {\n  const index = s.search(someDirectEvalPattern);\n  if (index !== -1) {\n    const linenum = s.slice(0, index).split('\\n').length; // more or less\n    throw new SyntaxError(\n      `possible direct eval expression rejected around line ${linenum}`\n    );\n  }\n}\n\nexport function rejectDangerousSources(s) {\n  rejectHtmlComments(s);\n  rejectImportExpressions(s);\n  rejectSomeDirectEvalExpressions(s);\n}\n\n// Export a rewriter transform.\nexport const rejectDangerousSourcesTransform = {\n  rewrite(rs) {\n    rejectDangerousSources(rs.src);\n    return rs;\n  }\n};\n","// Portions adapted from V8 - Copyright 2016 the V8 project authors.\n// https://github.com/v8/v8/blob/master/src/builtins/builtins-function.cc\n\nimport { assert, throwTantrum } from './utilities';\nimport {\n  apply,\n  arrayConcat,\n  arrayJoin,\n  arrayPop,\n  create,\n  getOwnPropertyDescriptors,\n  getPrototypeOf,\n  regexpTest,\n  stringIncludes\n} from './commons';\nimport { getOptimizableGlobals } from './optimizer';\nimport { createScopeHandler } from './scopeHandlerFacade';\nimport { createSafeEval } from './safeEvalFacade';\nimport { createSafeFunction } from './safeFunctionFacade';\nimport { rejectDangerousSourcesTransform } from './sourceParser';\n\nfunction buildOptimizer(constants) {\n  // No need to build an oprimizer when there are no constants.\n  if (constants.length === 0) return '';\n  // Use 'this' to avoid going through the scope proxy, which is unecessary\n  // since the optimizer only needs references to the safe global.\n  return `const {${arrayJoin(constants, ',')}} = this;`;\n}\n\nfunction createScopedEvaluatorFactory(unsafeRec, constants) {\n  const { unsafeFunction } = unsafeRec;\n\n  const optimizer = buildOptimizer(constants);\n\n  // Create a function in sloppy mode, so that we can use 'with'. It returns\n  // a function in strict mode that evaluates the provided code using direct\n  // eval, and thus in strict mode in the same scope. We must be very careful\n  // to not create new names in this scope\n\n  // 1: we use 'with' (around a Proxy) to catch all free variable names. The\n  // first 'arguments[0]' holds the Proxy which safely wraps the safeGlobal\n  // 2: 'optimizer' catches common variable names for speed\n  // 3: The inner strict function is effectively passed two parameters:\n  //    a) its arguments[0] is the source to be directly evaluated.\n  //    b) its 'this' is the this binding seen by the code being\n  //       directly evaluated.\n\n  // everything in the 'optimizer' string is looked up in the proxy\n  // (including an 'arguments[0]', which points at the Proxy). 'function' is\n  // a keyword, not a variable, so it is not looked up. then 'eval' is looked\n  // up in the proxy, that's the first time it is looked up after\n  // useUnsafeEvaluator is turned on, so the proxy returns the real the\n  // unsafeEval, which satisfies the IsDirectEvalTrap predicate, so it uses\n  // the direct eval and gets the lexical scope. The second 'arguments[0]' is\n  // looked up in the context of the inner function. The *contents* of\n  // arguments[0], because we're using direct eval, are looked up in the\n  // Proxy, by which point the useUnsafeEvaluator switch has been flipped\n  // back to 'false', so any instances of 'eval' in that string will get the\n  // safe evaluator.\n\n  return unsafeFunction(`\n    with (arguments[0]) {\n      ${optimizer}\n      return function() {\n        'use strict';\n        return eval(arguments[0]);\n      };\n    }\n  `);\n}\n\nfunction applyTransforms(rewriterState, transforms) {\n  // Clone before calling transforms.\n  rewriterState = {\n    src: `${rewriterState.src}`,\n    endowments: create(\n      null,\n      getOwnPropertyDescriptors(rewriterState.endowments)\n    )\n  };\n\n  // Rewrite the source, threading through rewriter state as necessary.\n  rewriterState = transforms.reduce(\n    (rs, transform) => (transform.rewrite ? transform.rewrite(rs) : rs),\n    rewriterState\n  );\n\n  // Clone after transforms\n  rewriterState = {\n    src: `${rewriterState.src}`,\n    endowments: create(\n      null,\n      getOwnPropertyDescriptors(rewriterState.endowments)\n    )\n  };\n\n  return rewriterState;\n}\n\nexport function createSafeEvaluatorFactory(\n  unsafeRec,\n  safeGlobal,\n  transforms,\n  sloppyGlobals\n) {\n  const constants = getOptimizableGlobals(safeGlobal);\n  const scopedEvaluatorFactory = createScopedEvaluatorFactory(\n    unsafeRec,\n    constants\n  );\n\n  function factory(endowments = {}, options = {}) {\n    // todo clone all arguments passed to returned function\n    const localTransforms = options.transforms || [];\n    const realmTransforms = transforms || [];\n\n    const mandatoryTransforms = [rejectDangerousSourcesTransform];\n    const allTransforms = arrayConcat(\n      localTransforms,\n      realmTransforms,\n      mandatoryTransforms\n    );\n\n    function safeEvalOperation(src) {\n      let rewriterState = { src, endowments };\n      rewriterState = applyTransforms(rewriterState, allTransforms);\n\n      const scopeHandler = createScopeHandler(\n        unsafeRec,\n        safeGlobal,\n        rewriterState.endowments,\n        sloppyGlobals\n      );\n      const scopeProxyRevocable = Proxy.revocable({}, scopeHandler);\n      const scopeProxy = scopeProxyRevocable.proxy;\n      const scopedEvaluator = apply(scopedEvaluatorFactory, safeGlobal, [\n        scopeProxy\n      ]);\n\n      scopeHandler.useUnsafeEvaluator = true;\n      let err;\n      try {\n        // Ensure that \"this\" resolves to the safe global.\n        return apply(scopedEvaluator, safeGlobal, [rewriterState.src]);\n      } catch (e) {\n        // stash the child-code error in hopes of debugging the internal failure\n        err = e;\n        throw e;\n      } finally {\n        if (scopeHandler.useUnsafeEvaluator) {\n          // the proxy switches this off immediately after ths\n          // first access, but if that's not the case we prevent\n          // further variable resolution on the scope and abort.\n          scopeProxyRevocable.revoke();\n          throwTantrum('handler did not revoke useUnsafeEvaluator', err);\n        }\n      }\n    }\n\n    return safeEvalOperation;\n  }\n\n  return factory;\n}\n\nexport function createSafeEvaluator(unsafeRec, safeEvalOperation) {\n  const { unsafeFunction } = unsafeRec;\n\n  const safeEval = createSafeEval(unsafeRec, safeEvalOperation);\n\n  assert(getPrototypeOf(safeEval).constructor !== Function, 'hide Function');\n  assert(\n    getPrototypeOf(safeEval).constructor !== unsafeFunction,\n    'hide unsafeFunction'\n  );\n\n  return safeEval;\n}\n\nexport function createSafeEvaluatorWhichTakesEndowments(safeEvaluatorFactory) {\n  return (x, endowments, options = {}) =>\n    safeEvaluatorFactory(endowments, options)(x);\n}\n\n/**\n * A safe version of the native Function which relies on\n * the safety of evalEvaluator for confinement.\n */\nexport function createFunctionEvaluator(unsafeRec, safeEvalOperation) {\n  const { unsafeGlobal, unsafeFunction } = unsafeRec;\n\n  function safeFunctionOperation(...params) {\n    const functionBody = `${arrayPop(params) || ''}`;\n    let functionParams = `${arrayJoin(params, ',')}`;\n    if (!regexpTest(/^[\\w\\s,]*$/, functionParams)) {\n      throw new SyntaxError(\n        'shim limitation: Function arg must be simple ASCII identifiers, possibly separated by commas: no default values, pattern matches, or non-ASCII parameter names'\n      );\n      // this protects against Matt Austin's clever attack:\n      // Function(\"arg=`\", \"/*body`){});({x: this/**/\")\n      // which would turn into\n      //     (function(arg=`\n      //     /*``*/){\n      //      /*body`){});({x: this/**/\n      //     })\n      // which parses as a default argument of `\\n/*``*/){\\n/*body` , which\n      // is a pair of template literals back-to-back (so the first one\n      // nominally evaluates to the parser to use on the second one), which\n      // can't actually execute (because the first literal evals to a string,\n      // which can't be a parser function), but that doesn't matter because\n      // the function is bypassed entirely. When that gets evaluated, it\n      // defines (but does not invoke) a function, then evaluates a simple\n      // {x: this} expression, giving access to the safe global.\n    }\n\n    // Is this a real functionBody, or is someone attempting an injection\n    // attack? This will throw a SyntaxError if the string is not actually a\n    // function body. We coerce the body into a real string above to prevent\n    // someone from passing an object with a toString() that returns a safe\n    // string the first time, but an evil string the second time.\n    // eslint-disable-next-line no-new, new-cap\n    new unsafeFunction(functionBody);\n\n    if (stringIncludes(functionParams, ')')) {\n      // If the formal parameters string include ) - an illegal\n      // character - it may make the combined function expression\n      // compile. We avoid this problem by checking for this early on.\n\n      // note: v8 throws just like this does, but chrome accepts\n      // e.g. 'a = new Date()'\n      throw new unsafeGlobal.SyntaxError(\n        'shim limitation: Function arg string contains parenthesis'\n      );\n      // todo: shim integrity threat if they change SyntaxError\n    }\n\n    // todo: check to make sure this .length is safe. markm says safe.\n    if (functionParams.length > 0) {\n      // If the formal parameters include an unbalanced block comment, the\n      // function must be rejected. Since JavaScript does not allow nested\n      // comments we can include a trailing block comment to catch this.\n      functionParams += '\\n/*``*/';\n    }\n\n    const src = `(function(${functionParams}){\\n${functionBody}\\n})`;\n\n    return safeEvalOperation(src);\n  }\n\n  const safeFunction = createSafeFunction(unsafeRec, safeFunctionOperation);\n\n  assert(\n    getPrototypeOf(safeFunction).constructor !== Function,\n    'hide Function'\n  );\n  assert(\n    getPrototypeOf(safeFunction).constructor !== unsafeFunction,\n    'hide unsafeFunction'\n  );\n\n  return safeFunction;\n}\n","import { createRealmFacade, buildChildRealm } from './realmFacade';\nimport { createNewUnsafeRec, createCurrentUnsafeRec } from './unsafeRec';\nimport {\n  createSafeEvaluatorFactory,\n  createSafeEvaluator,\n  createSafeEvaluatorWhichTakesEndowments,\n  createFunctionEvaluator\n} from './evaluators';\nimport { assert } from './utilities';\nimport { create, defineProperties, freeze, arrayConcat } from './commons';\n\n// Mimic private members on the realm instances.\n// We define it in the same module and do not export it.\nconst RealmRecForRealmInstance = new WeakMap();\n\nfunction getRealmRecForRealmInstance(realm) {\n  // Detect non-objects.\n  assert(Object(realm) === realm, 'bad object, not a Realm instance');\n  // Realm instance has no realmRec. Should not proceed.\n  assert(RealmRecForRealmInstance.has(realm), 'Realm instance has no record');\n\n  return RealmRecForRealmInstance.get(realm);\n}\n\nfunction registerRealmRecForRealmInstance(realm, realmRec) {\n  // Detect non-objects.\n  assert(Object(realm) === realm, 'bad object, not a Realm instance');\n  // Attempt to change an existing realmRec on a realm instance. Should not proceed.\n  assert(\n    !RealmRecForRealmInstance.has(realm),\n    'Realm instance already has a record'\n  );\n\n  RealmRecForRealmInstance.set(realm, realmRec);\n}\n\n// Initialize the global variables for the new Realm.\nfunction setDefaultBindings(safeGlobal, safeEval, safeFunction) {\n  defineProperties(safeGlobal, {\n    eval: {\n      value: safeEval,\n      writable: true,\n      configurable: true\n    },\n    Function: {\n      value: safeFunction,\n      writable: true,\n      configurable: true\n    }\n  });\n}\n\nfunction createRealmRec(unsafeRec, transforms, sloppyGlobals) {\n  const { sharedGlobalDescs, unsafeGlobal } = unsafeRec;\n\n  const safeGlobal = create(unsafeGlobal.Object.prototype, sharedGlobalDescs);\n\n  const safeEvaluatorFactory = createSafeEvaluatorFactory(\n    unsafeRec,\n    safeGlobal,\n    transforms,\n    sloppyGlobals\n  );\n  const safeEvalOperation = safeEvaluatorFactory();\n  const safeEval = createSafeEvaluator(unsafeRec, safeEvalOperation);\n  const safeFunction = createFunctionEvaluator(unsafeRec, safeEvalOperation);\n  const safeEvalWhichTakesEndowments = createSafeEvaluatorWhichTakesEndowments(\n    safeEvaluatorFactory\n  );\n\n  setDefaultBindings(safeGlobal, safeEval, safeFunction);\n\n  const realmRec = freeze({\n    safeGlobal,\n    safeEval,\n    safeEvalWhichTakesEndowments,\n    safeFunction\n  });\n\n  return realmRec;\n}\n\n/**\n * A root realm uses a fresh set of new intrinics. Here we first create\n * a new unsafe record, which inherits the shims. Then we proceed with\n * the creation of the realm record, and we apply the shims.\n */\nfunction initRootRealm(parentUnsafeRec, self, options) {\n  // note: 'self' is the instance of the Realm.\n\n  // todo: investigate attacks via Array.species\n  // todo: this accepts newShims='string', but it should reject that\n  const { shims: newShims, transforms, sloppyGlobals } = options;\n  const allShims = arrayConcat(parentUnsafeRec.allShims, newShims);\n\n  // The unsafe record is created already repaired.\n  const unsafeRec = createNewUnsafeRec(allShims);\n\n  // eslint-disable-next-line no-use-before-define\n  const Realm = createRealmFacade(unsafeRec, BaseRealm);\n\n  // Add a Realm descriptor to sharedGlobalDescs, so it can be defined onto the\n  // safeGlobal like the rest of the globals.\n  unsafeRec.sharedGlobalDescs.Realm = {\n    value: Realm,\n    writable: true,\n    configurable: true\n  };\n\n  // Creating the realmRec provides the global object, eval() and Function()\n  // to the realm.\n  const realmRec = createRealmRec(unsafeRec, transforms, sloppyGlobals);\n\n  // Apply all shims in the new RootRealm. We don't do this for compartments.\n  const { safeEvalWhichTakesEndowments } = realmRec;\n  for (const shim of allShims) {\n    safeEvalWhichTakesEndowments(shim);\n  }\n\n  // The realmRec acts as a private field on the realm instance.\n  registerRealmRecForRealmInstance(self, realmRec);\n}\n\n/**\n * A compartment shares the intrinsics of its root realm. Here, only a\n * realmRec is necessary to hold the global object, eval() and Function().\n */\nfunction initCompartment(unsafeRec, self, options = {}) {\n  // note: 'self' is the instance of the Realm.\n\n  const { transforms, sloppyGlobals } = options;\n  const realmRec = createRealmRec(unsafeRec, transforms, sloppyGlobals);\n\n  // The realmRec acts as a private field on the realm instance.\n  registerRealmRecForRealmInstance(self, realmRec);\n}\n\nfunction getRealmGlobal(self) {\n  const { safeGlobal } = getRealmRecForRealmInstance(self);\n  return safeGlobal;\n}\n\nfunction realmEvaluate(self, x, endowments = {}, options = {}) {\n  // todo: don't pass in primal-realm objects like {}, for safety. OTOH its\n  // properties are copied onto the new global 'target'.\n  // todo: figure out a way to membrane away the contents to safety.\n  const { safeEvalWhichTakesEndowments } = getRealmRecForRealmInstance(self);\n  return safeEvalWhichTakesEndowments(x, endowments, options);\n}\n\nconst BaseRealm = {\n  initRootRealm,\n  initCompartment,\n  getRealmGlobal,\n  realmEvaluate\n};\n\n// Create the current unsafeRec from the current \"primal\" environment (the realm\n// where the Realm shim is loaded and executed).\nconst currentUnsafeRec = createCurrentUnsafeRec();\n\n/**\n * The \"primal\" realm class is defined in the current \"primal\" environment,\n * and is part of the shim. There is no need to facade this class via evaluation\n * because both share the same intrinsics.\n */\nconst Realm = buildChildRealm(currentUnsafeRec, BaseRealm);\n\nexport default Realm;\n"],"names":["throwTantrum","s","err","msg","console","error","stack","assert","condition","message","cleanupSource","src","replace","buildChildRealm","unsafeRec","BaseRealm","callAndWrapError","initRootRealm","initCompartment","getRealmGlobal","realmEvaluate","create","defineProperties","Object","Realm","constructor","TypeError","makeRootRealm","options","r","prototype","makeCompartment","global","evaluate","x","endowments","toString","value","writable","enumerable","configurable","buildChildRealmString","createRealmFacade","unsafeEval","buildCallAndWrapError","getPrototypeOf","apply","Reflect","uncurryThis","fn","thisArg","args","mapGet","Map","get","setHas","Set","has","errorNameToErrorConstructor","EvalError","RangeError","ReferenceError","SyntaxError","URIError","errorConstructors","Error","target","eName","eMessage","eStack","name","ignored","ErrorConstructor","err2","buildCallAndWrapErrorString","createCallAndWrapError","assign","freeze","getOwnPropertyDescriptor","getOwnPropertyDescriptors","getOwnPropertyNames","setPrototypeOf","ownKeys","objectHasOwnProperty","hasOwnProperty","arrayFilter","Array","filter","arrayPop","pop","arrayJoin","join","arrayConcat","concat","regexpTest","RegExp","test","stringIncludes","String","includes","frozenGlobalPropertyNames","stableGlobalPropertyNames","unstableGlobalPropertyNames","getSharedGlobalDescs","unsafeGlobal","describe","names","desc","descriptors","repairAccessors","toObject","obj","asPropertyName","aFunction","accessor","defineProperty","objectPrototype","__lookupGetter__","ignore","__defineGetter__","prop","func","O","__defineSetter__","set","__lookupSetter__","repairFunctions","repairFunction","declaration","FunctionInstance","eval","e","FunctionPrototype","TamedFunction","Function","unsafeGlobalSrc","unsafeGlobalEvalSrc","createNewUnsafeGlobalForNode","isNode","vm","require","runInNewContext","createNewUnsafeGlobalForBrowser","document","iframe","createElement","style","display","body","appendChild","contentWindow","getNewUnsafeGlobal","newUnsafeGlobalForBrowser","newUnsafeGlobalForNode","createUnsafeRec","allShims","sharedGlobalDescs","unsafeFunction","repairAccessorsShim","repairFunctionsShim","createNewUnsafeRec","createCurrentUnsafeRec","identifierPattern","keywords","getOptimizableGlobals","safeGlobal","descs","constants","buildScopeHandler","sloppyGlobals","reflectGet","unscopables","Symbol","alwaysThrowHandler","Proxy","__proto__","useUnsafeEvaluator","shadow","buildScopeHandlerString","createScopeHandler","buildSafeEval","safeEvalOperation","safeEval","arguments","buildSafeEvalString","createSafeEval","buildSafeFunction","safeFunctionOperation","safeFunction","buildSafeFunctionString","createSafeFunction","htmlCommentPattern","rejectHtmlComments","index","search","linenum","slice","split","length","importPattern","rejectImportExpressions","someDirectEvalPattern","rejectSomeDirectEvalExpressions","rejectDangerousSources","rejectDangerousSourcesTransform","rewrite","rs","buildOptimizer","createScopedEvaluatorFactory","optimizer","applyTransforms","rewriterState","transforms","reduce","transform","createSafeEvaluatorFactory","scopedEvaluatorFactory","localTransforms","allTransforms","scopeHandler","scopeProxyRevocable","revocable","scopeProxy","proxy","scopedEvaluator","revoke","createSafeEvaluator","createSafeEvaluatorWhichTakesEndowments","safeEvaluatorFactory","createFunctionEvaluator","params","functionBody","functionParams","RealmRecForRealmInstance","WeakMap","getRealmRecForRealmInstance","realm","registerRealmRecForRealmInstance","realmRec","setDefaultBindings","createRealmRec","safeEvalWhichTakesEndowments","parentUnsafeRec","self","shims","newShims","shim","currentUnsafeRec"],"mappings":"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"}
##############################################
/src/dist/realms-shim.esm.min.js:1:function throwTantrum(a,b=void 0){const c=`please report internal shim error: ${a}`;console.error(c),b&&(console.error(`${b}`),console.error(`${b.stack}`));debugger;throw c}function assert(a,b){a||throwTantrum(b)}function cleanupSource(a){return a=a.replace(/\(0,\s*_[^.]+\.e\)/g,"(0, eval)"),a=a.replace(/_[^.]+\.g\.Reflect/g,"Reflect"),a=a.replace(/cov_[^+]+\+\+[;,]/g,""),a}function buildChildRealm(a,b){const{callAndWrapError:c}=a,{initRootRealm:d,initCompartment:e,getRealmGlobal:f,realmEvaluate:g}=b,{create:h,defineProperties:i}=Object;class j{constructor(){throw new TypeError("Realm is not a constructor")}static makeRootRealm(b={}){const e=h(j.prototype);return c(d,[a,e,b]),e}static makeCompartment(b={}){const d=h(j.prototype);return c(e,[a,d,b]),d}get global(){return c(f,[this])}evaluate(a,b,d={}){return c(g,[this,a,b,d])}}return i(j,{toString:{value:()=>"function Realm() { [shim code] }",writable:!1,enumerable:!1,configurable:!0}}),i(j.prototype,{toString:{value:()=>"[object Realm]",writable:!1,enumerable:!1,configurable:!0}}),j}const buildChildRealmString=cleanupSource(`'use strict'; (${buildChildRealm})`);function createRealmFacade(a,b){const{unsafeEval:c}=a;return c(buildChildRealmString)(a,b)}function buildCallAndWrapError(){const{getPrototypeOf:a}=Object,{apply:b}=Reflect,c=a=>(c,...d)=>b(a,c,d),d=c(Map.prototype.get),e=c(Set.prototype.has),f=new Map([["EvalError",EvalError],["RangeError",RangeError],["ReferenceError",ReferenceError],["SyntaxError",SyntaxError],["TypeError",TypeError],["URIError",URIError]]),g=new Set([EvalError.prototype,RangeError.prototype,ReferenceError.prototype,SyntaxError.prototype,TypeError.prototype,URIError.prototype,Error.prototype]);return function(c,h){try{return b(c,void 0,h)}catch(b){if(Object(b)!==b)throw b;if(e(g,a(b)))throw b;let c,h,i;try{c=`${b.name}`,h=`${b.message}`,i=`${b.stack||h}`}catch(a){throw new Error("unknown error")}const j=d(f,c)||Error;try{throw new j(h)}catch(a){throw a.stack=i,a}}}}const buildCallAndWrapErrorString=cleanupSource(`'use strict'; (${buildCallAndWrapError})`);function createCallAndWrapError(a){return a(buildCallAndWrapErrorString)()}const{assign,create,freeze,defineProperties,getOwnPropertyDescriptor,getOwnPropertyDescriptors,getOwnPropertyNames,getPrototypeOf,setPrototypeOf}=Object,{apply,ownKeys}=Reflect,uncurryThis=a=>(b,...c)=>apply(a,b,c),objectHasOwnProperty=uncurryThis(Object.prototype.hasOwnProperty),arrayFilter=uncurryThis(Array.prototype.filter),arrayPop=uncurryThis(Array.prototype.pop),arrayJoin=uncurryThis(Array.prototype.join),arrayConcat=uncurryThis(Array.prototype.concat),regexpTest=uncurryThis(RegExp.prototype.test),stringIncludes=uncurryThis(String.prototype.includes),frozenGlobalPropertyNames=["Infinity","NaN","undefined"],stableGlobalPropertyNames=["isFinite","isNaN","parseFloat","parseInt","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","Array","ArrayBuffer","Boolean","DataView","EvalError","Float32Array","Float64Array","Int8Array","Int16Array","Int32Array","Map","Number","Object","RangeError","ReferenceError","Set","String","Symbol","SyntaxError","TypeError","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","URIError","WeakMap","WeakSet","JSON","Math","Reflect","escape","unescape"],unstableGlobalPropertyNames=["Date","Error","Promise","Proxy","RegExp","Intl"];function getSharedGlobalDescs(a){function b(b,d,e,f){for(const g of b){const b=getOwnPropertyDescriptor(a,g);b&&(assert("value"in b,`unexpected accessor on global property: ${g}`),c[g]={value:b.value,writable:d,enumerable:e,configurable:f})}}const c={};return b(frozenGlobalPropertyNames,!1,!1,!1),b(stableGlobalPropertyNames,!1,!1,!1),b(unstableGlobalPropertyNames,!0,!1,!0),c}function repairAccessors(){function a(a){if(a===void 0||null===a)throw new TypeError(`can't convert undefined or null to object`);return Object(a)}function b(a){return"symbol"==typeof a?a:`${a}`}function c(a,b){if("function"!=typeof a)throw TypeError(`invalid ${b} usage`);return a}const{defineProperty:d,defineProperties:e,getOwnPropertyDescriptor:f,getPrototypeOf:g,prototype:h}=Object;try{(0,h.__lookupGetter__)("x")}catch(a){return}e(h,{__defineGetter__:{value:function(b,e){const f=a(this);d(f,b,{get:c(e,"getter"),enumerable:!0,configurable:!0})}},__defineSetter__:{value:function(b,e){const f=a(this);d(f,b,{set:c(e,"setter"),enumerable:!0,configurable:!0})}},__lookupGetter__:{value:function(c){let d=a(this);c=b(c);let e;for(;d&&!(e=f(d,c));)d=g(d);return e&&e.get}},__lookupSetter__:{value:function(c){let d=a(this);c=b(c);let e;for(;d&&!(e=f(d,c));)d=g(d);return e&&e.set}}})}function repairFunctions(){function a(a,e){let f;try{f=(0,eval)(e)}catch(a){if(a instanceof SyntaxError)return;throw a}const g=c(f),h=function(){throw new TypeError("Not available")};b(h,{name:{value:a}}),b(g,{constructor:{value:h}}),b(h,{prototype:{value:g}}),h!==Function.prototype.constructor&&d(h,Function.prototype.constructor)}const{defineProperties:b,getPrototypeOf:c,setPrototypeOf:d}=Object;a("Function","(function(){})"),a("GeneratorFunction","(function*(){})"),a("AsyncFunction","(async function(){})"),a("AsyncGeneratorFunction","(async function*(){})")}const unsafeGlobalSrc="'use strict'; this",unsafeGlobalEvalSrc=`(0, eval)("'use strict'; this")`;function createNewUnsafeGlobalForNode(){const a=new Function("try {return this===global}catch(e){return false}")();if(!a)return;const b=require("vm"),c=b.runInNewContext(unsafeGlobalEvalSrc);return c}function createNewUnsafeGlobalForBrowser(){if("undefined"!=typeof document){const a=document.createElement("iframe");a.style.display="none",document.body.appendChild(a);const b=a.contentWindow.eval(unsafeGlobalSrc);return b}}const getNewUnsafeGlobal=()=>{const a=createNewUnsafeGlobalForBrowser(),b=createNewUnsafeGlobalForNode();if(!a&&!b||a&&b)throw new Error("unexpected platform, unable to create Realm");return a||b};function createUnsafeRec(a,b=[]){const c=getSharedGlobalDescs(a),d=a.eval,e=a.Function,f=createCallAndWrapError(d);return freeze({unsafeGlobal:a,sharedGlobalDescs:c,unsafeEval:d,unsafeFunction:e,callAndWrapError:f,allShims:b})}const repairAccessorsShim=cleanupSource(`"use strict"; (${repairAccessors})();`),repairFunctionsShim=cleanupSource(`"use strict"; (${repairFunctions})();`);function createNewUnsafeRec(a){const b=getNewUnsafeGlobal();return b.eval(repairAccessorsShim),b.eval(repairFunctionsShim),createUnsafeRec(b,a)}function createCurrentUnsafeRec(){const a=(0,eval)(unsafeGlobalSrc);return repairAccessors(),repairFunctions(),createUnsafeRec(a)}const identifierPattern=/^[a-zA-Z_$][\w$]*$/,keywords=new Set(["await","break","case","catch","class","const","continue","debugger","default","delete","do","else","export","extends","finally","for","function","if","import","in","instanceof","new","return","super","switch","this","throw","try","typeof","var","void","while","with","yield","let","static","enum","implements","package","protected","interface","private","public","await","null","true","false","this","arguments"]);function getOptimizableGlobals(a){const b=getOwnPropertyDescriptors(a),c=arrayFilter(getOwnPropertyNames(b),a=>{if("eval"===a||keywords.has(a)||!regexpTest(identifierPattern,a))return!1;const c=b[a];return!1===c.configurable&&!1===c.writable&&objectHasOwnProperty(c,"value")});return c}function buildScopeHandler(a,b,c={},d=!1){const{unsafeGlobal:e,unsafeEval:f}=a,{freeze:g}=Object,{get:h}=Reflect,{unscopables:i}=Symbol,j=new Proxy(g({}),{get(a,b){throw new TypeError(`unexpected scope handler trap called: ${b+""}`)}});return{__proto__:j,useUnsafeEvaluator:!1,get(a,d){return d===i?void 0:"eval"===d&&!0===this.useUnsafeEvaluator?(this.useUnsafeEvaluator=!1,f):d in c?h(c,d,b):d in b?b[d]:void 0},set(a,d,e){if(d in c)throw new TypeError(`do not modify endowments like ${d+""}`);return b[d]=e,!0},has(a,f){return!!d||!!("eval"===f||f in c||f in b||f in e)},getPrototypeOf(){return null}}}const buildScopeHandlerString=cleanupSource(`'use strict'; (${buildScopeHandler})`);function createScopeHandler(a,b,c,d){const{unsafeEval:e}=a;return e(buildScopeHandlerString)(a,b,c,d)}function buildSafeEval(a,b){const{callAndWrapError:c}=a,{defineProperties:d}=Object,e={eval(){return c(b,arguments)}}.eval;return d(e,{toString:{value:()=>`function ${"eval"}() { [shim code] }`,writable:!1,enumerable:!1,configurable:!0}}),e}const buildSafeEvalString=cleanupSource(`'use strict'; (${buildSafeEval})`);function createSafeEval(a,b){const{unsafeEval:c}=a;return c(buildSafeEvalString)(a,b)}function buildSafeFunction(a,b){const{callAndWrapError:c,unsafeFunction:d}=a,{defineProperties:e}=Object,f=function(){return c(b,arguments)};return e(f,{prototype:{value:d.prototype},toString:{value:()=>"function Function() { [shim code] }",writable:!1,enumerable:!1,configurable:!0}}),f}const buildSafeFunctionString=cleanupSource(`'use strict'; (${buildSafeFunction})`);function createSafeFunction(a,b){const{unsafeEval:c}=a;return c(buildSafeFunctionString)(a,b)}const htmlCommentPattern=/(?:<!--|-->)/;function rejectHtmlComments(a){const b=a.search(htmlCommentPattern);if(-1!==b){const c=a.slice(0,b).split("\n").length;throw new SyntaxError(`possible html comment syntax rejected around line ${c}`)}}const importPattern=/\bimport\s*(?:\(|\/[/*])/;function rejectImportExpressions(a){const b=a.search(importPattern);if(-1!==b){const c=a.slice(0,b).split("\n").length;throw new SyntaxError(`possible import expression rejected around line ${c}`)}}const someDirectEvalPattern=/\beval\s*(?:\(|\/[/*])/;function rejectSomeDirectEvalExpressions(a){const b=a.search(someDirectEvalPattern);if(-1!==b){const c=a.slice(0,b).split("\n").length;throw new SyntaxError(`possible direct eval expression rejected around line ${c}`)}}function rejectDangerousSources(a){rejectHtmlComments(a),rejectImportExpressions(a),rejectSomeDirectEvalExpressions(a)}const rejectDangerousSourcesTransform={rewrite(a){return rejectDangerousSources(a.src),a}};function buildOptimizer(a){return 0===a.length?"":`const {${arrayJoin(a,",")}} = this;`}function createScopedEvaluatorFactory(a,b){const{unsafeFunction:c}=a,d=buildOptimizer(b);return c(`
/src/dist/realms-shim.esm.min.js-2-    with (arguments[0]) {
##############################################
/src/dist/realms-shim.esm.min.js-5-        'use strict';
/src/dist/realms-shim.esm.min.js:6:        return eval(arguments[0]);
/src/dist/realms-shim.esm.min.js-7-      };
##############################################
/src/dist/realms-shim.cjs.js.map:1:{"version":3,"file":"realms-shim.cjs.js","sources":["../src/utilities.js","../src/realmFacade.js","../src/callAndWrapError.js","../src/commons.js","../src/stdlib.js","../src/repair/accessors.js","../src/repair/functions.js","../src/unsafeRec.js","../src/optimizer.js","../src/scopeHandlerFacade.js","../src/safeEvalFacade.js","../src/safeFunctionFacade.js","../src/sourceParser.js","../src/evaluators.js","../src/realm.js"],"sourcesContent":["// we'd like to abandon, but we can't, so just scream and break a lot of\n// stuff. However, since we aren't really aborting the process, be careful to\n// not throw an Error object which could be captured by child-Realm code and\n// used to access the (too-powerful) primal-realm Error object.\n\nexport function throwTantrum(s, err = undefined) {\n  const msg = `please report internal shim error: ${s}`;\n\n  // we want to log these 'should never happen' things.\n  // eslint-disable-next-line no-console\n  console.error(msg);\n  if (err) {\n    // eslint-disable-next-line no-console\n    console.error(`${err}`);\n    // eslint-disable-next-line no-console\n    console.error(`${err.stack}`);\n  }\n\n  // eslint-disable-next-line no-debugger\n  debugger;\n  throw msg;\n}\n\nexport function assert(condition, message) {\n  if (!condition) {\n    throwTantrum(message);\n  }\n}\n\n/**\n * cleanupSource()\n * Remove code modifications introduced by ems and nyx in\n * test mode which intefere with Function.toString().\n *\n * Becuase this change is not required at runtime, the\n * body of this function is hollowed-out during the build\n * process by rollup-plugin-strip-code. As configured in\n * in rollup.config.jj, all code between the custom tags\n * START_TESTS_ONLY and END_TESTS_ONLY, and including those\n * tags, is stripped, turning this function into a noop.\n */\nexport function cleanupSource(src) {\n  // Restore eval which is modified by esm module.\n  // (0, eval) => (0, _<something>.e)\n  src = src.replace(/\\(0,\\s*_[^.]+\\.e\\)/g, '(0, eval)');\n\n  // Restore Reflect which is modified by esm module.\n  // Reflect => _<something>.e.Reflect\n  src = src.replace(/_[^.]+\\.g\\.Reflect/g, 'Reflect');\n\n  // Remove code coverage which is injected by nyc module.\n  src = src.replace(/cov_[^+]+\\+\\+[;,]/g, '');\n\n  return src;\n}\n","import { cleanupSource } from './utilities';\n\n// buildChildRealm is immediately turned into a string, and this function is\n// never referenced again, because it closes over the wrong intrinsics\n\nexport function buildChildRealm(unsafeRec, BaseRealm) {\n  const { callAndWrapError } = unsafeRec;\n  const {\n    initRootRealm,\n    initCompartment,\n    getRealmGlobal,\n    realmEvaluate\n  } = BaseRealm;\n\n  const { create, defineProperties } = Object;\n\n  class Realm {\n    constructor() {\n      // The Realm constructor is not intended to be used with the new operator\n      // or to be subclassed. It may be used as the value of an extends clause\n      // of a class definition but a super call to the Realm constructor will\n      // cause an exception.\n\n      // When Realm is called as a function, an exception is also raised because\n      // a class constructor cannot be invoked without 'new'.\n      throw new TypeError('Realm is not a constructor');\n    }\n\n    static makeRootRealm(options = {}) {\n      // This is the exposed interface.\n\n      // Bypass the constructor.\n      const r = create(Realm.prototype);\n      callAndWrapError(initRootRealm, [unsafeRec, r, options]);\n      return r;\n    }\n\n    static makeCompartment(options = {}) {\n      // Bypass the constructor.\n      const r = create(Realm.prototype);\n      callAndWrapError(initCompartment, [unsafeRec, r, options]);\n      return r;\n    }\n\n    // we omit the constructor because it is empty. All the personalization\n    // takes place in one of the two static methods,\n    // makeRootRealm/makeCompartment\n\n    get global() {\n      // this is safe against being called with strange 'this' because\n      // baseGetGlobal immediately does a trademark check (it fails unless\n      // this 'this' is present in a weakmap that is only populated with\n      // legitimate Realm instances)\n      return callAndWrapError(getRealmGlobal, [this]);\n    }\n\n    evaluate(x, endowments, options = {}) {\n      // safe against strange 'this', as above\n      return callAndWrapError(realmEvaluate, [this, x, endowments, options]);\n    }\n  }\n\n  defineProperties(Realm, {\n    toString: {\n      value: () => 'function Realm() { [shim code] }',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  defineProperties(Realm.prototype, {\n    toString: {\n      value: () => '[object Realm]',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  return Realm;\n}\n\n// The parentheses means we don't bind the 'buildChildRealm' name inside the\n// child's namespace. this would accept an anonymous function declaration.\n// function expression (not a declaration) so it has a completion value.\nconst buildChildRealmString = cleanupSource(\n  `'use strict'; (${buildChildRealm})`\n);\n\nexport function createRealmFacade(unsafeRec, BaseRealm) {\n  const { unsafeEval } = unsafeRec;\n  // The BaseRealm is the Realm class created by\n  // the shim. It's only valid for the context where\n  // it was parsed.\n\n  // The Realm facade is a lightweight class built in the\n  // context a different context, that provide a fully\n  // functional Realm class using the intrisics\n  // of that context.\n\n  // This process is simplified because all methods\n  // and properties on a realm instance already return\n  // values using the intrinsics of the realm's context.\n\n  // Invoke the BaseRealm constructor with Realm as the prototype.\n  return unsafeEval(buildChildRealmString)(unsafeRec, BaseRealm);\n}\n","import { cleanupSource } from './utilities';\n\nfunction buildCallAndWrapError() {\n  // This Object and Reflect are brand new, from a new unsafeRec, so no user\n  // code has been run or had a chance to manipulate them. Don't ever run this\n  // function *after* user code has had a chance to pollute its environment,\n  // or it could be used to gain access to BaseRealm and primal-realm Error\n  // objects.\n  const { getPrototypeOf } = Object;\n  const { apply } = Reflect;\n  const uncurryThis = fn => (thisArg, ...args) => apply(fn, thisArg, args);\n  const mapGet = uncurryThis(Map.prototype.get);\n  const setHas = uncurryThis(Set.prototype.has);\n\n  const errorNameToErrorConstructor = new Map([\n    ['EvalError', EvalError],\n    ['RangeError', RangeError],\n    ['ReferenceError', ReferenceError],\n    ['SyntaxError', SyntaxError],\n    ['TypeError', TypeError],\n    ['URIError', URIError]\n  ]);\n  const errorConstructors = new Set([\n    EvalError.prototype,\n    RangeError.prototype,\n    ReferenceError.prototype,\n    SyntaxError.prototype,\n    TypeError.prototype,\n    URIError.prototype,\n    Error.prototype\n  ]);\n\n  function callAndWrapError(target, args) {\n    try {\n      return apply(target, undefined, args);\n    } catch (err) {\n      // 1. Thrown primitives\n      if (Object(err) !== err) {\n        // err is a primitive value, which is safe to rethrow\n        throw err;\n      }\n\n      // 2. Current realm errors\n      if (setHas(errorConstructors, getPrototypeOf(err))) {\n        // err is a from the current realm, which is safe to rethrow.\n        // Object instances (normally) only contain intrinsics from the\n        // same realm. An error containing intrinsics from different\n        // realms would have to be manually constucted, which imply that\n        // such intrinsics were available, and confinement was already lost.\n        throw err;\n      }\n\n      // 3. Other realm errors\n      let eName, eMessage, eStack;\n      try {\n        // The other environment might seek to use 'err' to reach the\n        // parent's intrinsics and corrupt them. In addition, exceptions\n        // raised in the primal realm need to be converted to the current\n        // realm.\n\n        // `${err.name}` will cause string coercion of 'err.name'.\n        // If err.name is an object (probably a String of another Realm),\n        // the coercion uses err.name.toString(), which is under the control\n        // of the other realm. If err.name were a primitive (e.g. a number),\n        // it would use Number.toString(err.name), using the child's version\n        // of Number (which the child could modify to capture its argument for\n        // later use), however primitives don't have properties like .prototype\n        // so they aren't useful for an attack.\n        eName = `${err.name}`;\n        eMessage = `${err.message}`;\n        eStack = `${err.stack || eMessage}`;\n        // eName/eMessage/eStack are now realm-independent primitive strings, and\n        // safe to expose.\n      } catch (ignored) {\n        // if err.name.toString() throws, keep the (parent realm) Error away.\n        throw new Error('unknown error');\n      }\n      const ErrorConstructor =\n        mapGet(errorNameToErrorConstructor, eName) || Error;\n      try {\n        throw new ErrorConstructor(eMessage);\n      } catch (err2) {\n        err2.stack = eStack; // replace with the captured inner stack\n        throw err2;\n      }\n    }\n  }\n\n  return callAndWrapError;\n}\n\nconst buildCallAndWrapErrorString = cleanupSource(\n  `'use strict'; (${buildCallAndWrapError})`\n);\nexport function createCallAndWrapError(unsafeEval) {\n  return unsafeEval(buildCallAndWrapErrorString)();\n}\n","// Declare shorthand functions. Sharing these declarations across modules\n// improves both consistency and minification. Unused declarations are\n// dropped by the tree shaking process.\n\n// we capture these, not just for brevity, but for security. If any code\n// modifies Object to change what 'assign' points to, the Realm shim would be\n// corrupted.\n\nexport const {\n  assign,\n  create,\n  freeze,\n  defineProperties, // Object.defineProperty is allowed to fail\n  // silentlty, use Object.defineProperties instead.\n  getOwnPropertyDescriptor,\n  getOwnPropertyDescriptors,\n  getOwnPropertyNames,\n  getPrototypeOf,\n  setPrototypeOf\n} = Object;\n\nexport const {\n  apply,\n  ownKeys // Reflect.ownKeys includes Symbols and unenumerables,\n  // unlike Object.keys()\n} = Reflect;\n\n/**\n * uncurryThis() See\n * http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\n * which only lives at\n * http://web.archive.org/web/20160805225710/http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\n *\n * Performance:\n * 1. The native call is about 10x faster on FF than chrome\n * 2. The version using Function.bind() is about 100x slower on FF,\n *    equal on chrome, 2x slower on Safari\n * 3. The version using a spread and Reflect.apply() is about 10x\n *    slower on FF, equal on chrome, 2x slower on Safari\n *\n * const bind = Function.prototype.bind;\n * const uncurryThis = bind.bind(bind.call);\n */\nconst uncurryThis = fn => (thisArg, ...args) => apply(fn, thisArg, args);\n\n// We also capture these for security: changes to Array.prototype after the\n// Realm shim runs shouldn't affect subsequent Realm operations.\nexport const objectHasOwnProperty = uncurryThis(\n    Object.prototype.hasOwnProperty\n  ),\n  arrayForEach = uncurryThis(Array.prototype.forEach),\n  arrayFilter = uncurryThis(Array.prototype.filter),\n  arrayPush = uncurryThis(Array.prototype.push),\n  arrayPop = uncurryThis(Array.prototype.pop),\n  arrayJoin = uncurryThis(Array.prototype.join),\n  arrayConcat = uncurryThis(Array.prototype.concat),\n  regexpTest = uncurryThis(RegExp.prototype.test),\n  stringMatch = uncurryThis(String.prototype.match),\n  stringIncludes = uncurryThis(String.prototype.includes);\n","import { getOwnPropertyDescriptor } from './commons';\nimport { assert } from './utilities';\n\n// These value properties of the global object are non-writable,\n// non-configurable data properties.\nconst frozenGlobalPropertyNames = [\n  // *** 18.1 Value Properties of the Global Object\n\n  'Infinity',\n  'NaN',\n  'undefined'\n];\n\n// All the following stdlib items have the same name on both our intrinsics\n// object and on the global object. Unlike Infinity/NaN/undefined, these\n// should all be writable and configurable. This is divided into two\n// sets. The stable ones are those the shim can freeze early because\n// we don't expect anyone will want to mutate them. The unstable ones\n// are the ones that we correctly initialize to writable and\n// configurable so that they can still be replaced or removed.\nconst stableGlobalPropertyNames = [\n  // *** 18.2 Function Properties of the Global Object\n\n  // 'eval', // comes from safeEval instead\n  'isFinite',\n  'isNaN',\n  'parseFloat',\n  'parseInt',\n\n  'decodeURI',\n  'decodeURIComponent',\n  'encodeURI',\n  'encodeURIComponent',\n\n  // *** 18.3 Constructor Properties of the Global Object\n\n  'Array',\n  'ArrayBuffer',\n  'Boolean',\n  'DataView',\n  // 'Date',  // Unstable\n  // 'Error',  // Unstable\n  'EvalError',\n  'Float32Array',\n  'Float64Array',\n  // 'Function',  // comes from safeFunction instead\n  'Int8Array',\n  'Int16Array',\n  'Int32Array',\n  'Map',\n  'Number',\n  'Object',\n  // 'Promise',  // Unstable\n  // 'Proxy',  // Unstable\n  'RangeError',\n  'ReferenceError',\n  // 'RegExp',  // Unstable\n  'Set',\n  // 'SharedArrayBuffer'  // removed on Jan 5, 2018\n  'String',\n  'Symbol',\n  'SyntaxError',\n  'TypeError',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Uint16Array',\n  'Uint32Array',\n  'URIError',\n  'WeakMap',\n  'WeakSet',\n\n  // *** 18.4 Other Properties of the Global Object\n\n  // 'Atomics', // removed on Jan 5, 2018\n  'JSON',\n  'Math',\n  'Reflect',\n\n  // *** Annex B\n\n  'escape',\n  'unescape'\n\n  // *** ECMA-402\n\n  // 'Intl'  // Unstable\n\n  // *** ESNext\n\n  // 'Realm' // Comes from createRealmGlobalObject()\n];\n\nconst unstableGlobalPropertyNames = [\n  'Date',\n  'Error',\n  'Promise',\n  'Proxy',\n  'RegExp',\n  'Intl'\n];\n\nexport function getSharedGlobalDescs(unsafeGlobal) {\n  const descriptors = {};\n\n  function describe(names, writable, enumerable, configurable) {\n    for (const name of names) {\n      const desc = getOwnPropertyDescriptor(unsafeGlobal, name);\n      if (desc) {\n        // Abort if an accessor is found on the unsafe global object\n        // instead of a data property. We should never get into this\n        // non standard situation.\n        assert(\n          'value' in desc,\n          `unexpected accessor on global property: ${name}`\n        );\n\n        descriptors[name] = {\n          value: desc.value,\n          writable,\n          enumerable,\n          configurable\n        };\n      }\n    }\n  }\n\n  describe(frozenGlobalPropertyNames, false, false, false);\n  // The following is correct but expensive.\n  // describe(stableGlobalPropertyNames, true, false, true);\n  // Instead, for now, we let these get optimized.\n  //\n  // TODO: We should provide an option to turn this optimization off,\n  // by feeding \"true, false, true\" here instead.\n  describe(stableGlobalPropertyNames, false, false, false);\n  // These we keep replaceable and removable, because we expect\n  // others, e.g., SES, may want to do so.\n  describe(unstableGlobalPropertyNames, true, false, true);\n\n  return descriptors;\n}\n","// Adapted from SES/Caja - Copyright (C) 2011 Google Inc.\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js\n\n/**\n * Replace the legacy accessors of Object to comply with strict mode\n * and ES2016 semantics, we do this by redefining them while in 'use strict'.\n *\n * todo: list the issues resolved\n *\n * This function can be used in two ways: (1) invoked directly to fix the primal\n * realm's Object.prototype, and (2) converted to a string to be executed\n * inside each new RootRealm to fix their Object.prototypes. Evaluation requires\n * the function to have no dependencies, so don't import anything from\n * the outside.\n */\n\n// todo: this file should be moved out to a separate repo and npm module.\nexport function repairAccessors() {\n  const {\n    defineProperty,\n    defineProperties,\n    getOwnPropertyDescriptor,\n    getPrototypeOf,\n    prototype: objectPrototype\n  } = Object;\n\n  // On some platforms, the implementation of these functions act as\n  // if they are in sloppy mode: if they're invoked badly, they will\n  // expose the global object, so we need to repair these for\n  // security. Thus it is our responsibility to fix this, and we need\n  // to include repairAccessors. E.g. Chrome in 2016.\n\n  try {\n    // Verify that the method is not callable.\n    // eslint-disable-next-line no-restricted-properties, no-underscore-dangle\n    (0, objectPrototype.__lookupGetter__)('x');\n  } catch (ignore) {\n    // Throws, no need to patch.\n    return;\n  }\n\n  function toObject(obj) {\n    if (obj === undefined || obj === null) {\n      throw new TypeError(`can't convert undefined or null to object`);\n    }\n    return Object(obj);\n  }\n\n  function asPropertyName(obj) {\n    if (typeof obj === 'symbol') {\n      return obj;\n    }\n    return `${obj}`;\n  }\n\n  function aFunction(obj, accessor) {\n    if (typeof obj !== 'function') {\n      throw TypeError(`invalid ${accessor} usage`);\n    }\n    return obj;\n  }\n\n  defineProperties(objectPrototype, {\n    __defineGetter__: {\n      value: function __defineGetter__(prop, func) {\n        const O = toObject(this);\n        defineProperty(O, prop, {\n          get: aFunction(func, 'getter'),\n          enumerable: true,\n          configurable: true\n        });\n      }\n    },\n    __defineSetter__: {\n      value: function __defineSetter__(prop, func) {\n        const O = toObject(this);\n        defineProperty(O, prop, {\n          set: aFunction(func, 'setter'),\n          enumerable: true,\n          configurable: true\n        });\n      }\n    },\n    __lookupGetter__: {\n      value: function __lookupGetter__(prop) {\n        let O = toObject(this);\n        prop = asPropertyName(prop);\n        let desc;\n        while (O && !(desc = getOwnPropertyDescriptor(O, prop))) {\n          O = getPrototypeOf(O);\n        }\n        return desc && desc.get;\n      }\n    },\n    __lookupSetter__: {\n      value: function __lookupSetter__(prop) {\n        let O = toObject(this);\n        prop = asPropertyName(prop);\n        let desc;\n        while (O && !(desc = getOwnPropertyDescriptor(O, prop))) {\n          O = getPrototypeOf(O);\n        }\n        return desc && desc.set;\n      }\n    }\n  });\n}\n","// Adapted from SES/Caja\n// Copyright (C) 2011 Google Inc.\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js\n\n/**\n * This block replaces the original Function constructor, and the original\n * %GeneratorFunction% %AsyncFunction% and %AsyncGeneratorFunction%, with\n * safe replacements that throw if invoked.\n *\n * These are all reachable via syntax, so it isn't sufficient to just\n * replace global properties with safe versions. Our main goal is to prevent\n * access to the Function constructor through these starting points.\n\n * After this block is done, the originals must no longer be reachable, unless\n * a copy has been made, and funtions can only be created by syntax (using eval)\n * or by invoking a previously saved reference to the originals.\n */\n\n// todo: this file should be moved out to a separate repo and npm module.\nexport function repairFunctions() {\n  const { defineProperties, getPrototypeOf, setPrototypeOf } = Object;\n\n  /**\n   * The process to repair constructors:\n   * 1. Create an instance of the function by evaluating syntax\n   * 2. Obtain the prototype from the instance\n   * 3. Create a substitute tamed constructor\n   * 4. Replace the original constructor with the tamed constructor\n   * 5. Replace tamed constructor prototype property with the original one\n   * 6. Replace its [[Prototype]] slot with the tamed constructor of Function\n   */\n  function repairFunction(name, declaration) {\n    let FunctionInstance;\n    try {\n      // eslint-disable-next-line no-new-func\n      FunctionInstance = (0, eval)(declaration);\n    } catch (e) {\n      if (e instanceof SyntaxError) {\n        // Prevent failure on platforms where async and/or generators\n        // are not supported.\n        return;\n      }\n      // Re-throw\n      throw e;\n    }\n    const FunctionPrototype = getPrototypeOf(FunctionInstance);\n\n    // Prevents the evaluation of source when calling constructor on the\n    // prototype of functions.\n    const TamedFunction = function() {\n      throw new TypeError('Not available');\n    };\n    defineProperties(TamedFunction, { name: { value: name } });\n\n    // (new Error()).constructors does not inherit from Function, because Error\n    // was defined before ES6 classes. So we don't need to repair it too.\n\n    // (Error()).constructor inherit from Function, which gets a tamed\n    // constructor here.\n\n    // todo: in an ES6 class that does not inherit from anything, what does its\n    // constructor inherit from? We worry that it inherits from Function, in\n    // which case instances could give access to unsafeFunction. markm says\n    // we're fine: the constructor inherits from Object.prototype\n\n    // This line replaces the original constructor in the prototype chain\n    // with the tamed one. No copy of the original is peserved.\n    defineProperties(FunctionPrototype, {\n      constructor: { value: TamedFunction }\n    });\n\n    // This line sets the tamed constructor's prototype data property to\n    // the original one.\n    defineProperties(TamedFunction, {\n      prototype: { value: FunctionPrototype }\n    });\n\n    if (TamedFunction !== Function.prototype.constructor) {\n      // Ensures that all functions meet \"instanceof Function\" in a realm.\n      setPrototypeOf(TamedFunction, Function.prototype.constructor);\n    }\n  }\n\n  // Here, the order of operation is important: Function needs to be repaired\n  // first since the other repaired constructors need to inherit from the tamed\n  // Function function constructor.\n\n  // note: this really wants to be part of the standard, because new\n  // constructors may be added in the future, reachable from syntax, and this\n  // list must be updated to match.\n\n  // \"plain arrow functions\" inherit from Function.prototype\n\n  repairFunction('Function', '(function(){})');\n  repairFunction('GeneratorFunction', '(function*(){})');\n  repairFunction('AsyncFunction', '(async function(){})');\n  repairFunction('AsyncGeneratorFunction', '(async function*(){})');\n}\n","// this module must never be importable outside the Realm shim itself\nimport { createCallAndWrapError } from './callAndWrapError';\nimport { getSharedGlobalDescs } from './stdlib';\nimport { repairAccessors } from './repair/accessors';\nimport { repairFunctions } from './repair/functions';\nimport { cleanupSource } from './utilities';\nimport { freeze } from './commons';\n\n// A \"context\" is a fresh unsafe Realm as given to us by existing platforms.\n// We need this to implement the shim. However, when Realms land for real,\n// this feature will be provided by the underlying engine instead.\n\n// note: in a node module, the top-level 'this' is not the global object\n// (it's *something* but we aren't sure what), however an indirect eval of\n// 'this' will be the correct global object.\n\nconst unsafeGlobalSrc = \"'use strict'; this\";\nconst unsafeGlobalEvalSrc = `(0, eval)(\"'use strict'; this\")`;\n\n// This method is only exported for testing purposes.\nexport function createNewUnsafeGlobalForNode() {\n  // Note that webpack and others will shim 'vm' including the method\n  // 'runInNewContext', so the presence of vm is not a useful check\n\n  // TODO: Find a better test that works with bundlers\n  // eslint-disable-next-line no-new-func\n  const isNode = new Function(\n    'try {return this===global}catch(e){return false}'\n  )();\n\n  if (!isNode) {\n    return undefined;\n  }\n\n  // eslint-disable-next-line global-require\n  const vm = require('vm');\n\n  // Use unsafeGlobalEvalSrc to ensure we get the right 'this'.\n  const unsafeGlobal = vm.runInNewContext(unsafeGlobalEvalSrc);\n\n  return unsafeGlobal;\n}\n\n// This method is only exported for testing purposes.\nexport function createNewUnsafeGlobalForBrowser() {\n  if (typeof document === 'undefined') {\n    return undefined;\n  }\n  const iframe = document.createElement('iframe');\n  iframe.style.display = 'none';\n\n  document.body.appendChild(iframe);\n  const unsafeGlobal = iframe.contentWindow.eval(unsafeGlobalSrc);\n\n  // We keep the iframe attached to the DOM because removing it\n  // causes its global object to lose intrinsics, its eval()\n  // function to evaluate code, etc.\n\n  // TODO: can we remove and garbage-collect the iframes?\n\n  return unsafeGlobal;\n}\n\nconst getNewUnsafeGlobal = () => {\n  const newUnsafeGlobalForBrowser = createNewUnsafeGlobalForBrowser();\n  const newUnsafeGlobalForNode = createNewUnsafeGlobalForNode();\n  if (\n    (!newUnsafeGlobalForBrowser && !newUnsafeGlobalForNode) ||\n    (newUnsafeGlobalForBrowser && newUnsafeGlobalForNode)\n  ) {\n    throw new Error('unexpected platform, unable to create Realm');\n  }\n  return newUnsafeGlobalForBrowser || newUnsafeGlobalForNode;\n};\n\n// The unsafeRec is shim-specific. It acts as the mechanism to obtain a fresh\n// set of intrinsics together with their associated eval and Function\n// evaluators. These must be used as a matched set, since the evaluators are\n// tied to a set of intrinsics, aka the \"undeniables\". If it were possible to\n// mix-and-match them from different contexts, that would enable some\n// attacks.\nfunction createUnsafeRec(unsafeGlobal, allShims = []) {\n  const sharedGlobalDescs = getSharedGlobalDescs(unsafeGlobal);\n\n  const unsafeEval = unsafeGlobal.eval;\n  const unsafeFunction = unsafeGlobal.Function;\n\n  const callAndWrapError = createCallAndWrapError(unsafeEval);\n\n  return freeze({\n    unsafeGlobal,\n    sharedGlobalDescs,\n    unsafeEval,\n    unsafeFunction,\n    callAndWrapError,\n    allShims\n  });\n}\n\nconst repairAccessorsShim = cleanupSource(\n  `\"use strict\"; (${repairAccessors})();`\n);\nconst repairFunctionsShim = cleanupSource(\n  `\"use strict\"; (${repairFunctions})();`\n);\n\n// Create a new unsafeRec from a brand new context, with new intrinsics and a\n// new global object\nexport function createNewUnsafeRec(allShims) {\n  const unsafeGlobal = getNewUnsafeGlobal();\n  unsafeGlobal.eval(repairAccessorsShim);\n  unsafeGlobal.eval(repairFunctionsShim);\n  return createUnsafeRec(unsafeGlobal, allShims);\n}\n\n// Create a new unsafeRec from the current context, where the Realm shim is\n// being parsed and executed, aka the \"Primal Realm\"\nexport function createCurrentUnsafeRec() {\n  const unsafeGlobal = (0, eval)(unsafeGlobalSrc);\n  repairAccessors();\n  repairFunctions();\n  return createUnsafeRec(unsafeGlobal);\n}\n","import {\n  arrayFilter,\n  getOwnPropertyDescriptors,\n  getOwnPropertyNames,\n  objectHasOwnProperty,\n  regexpTest\n} from './commons';\n\n// todo: think about how this interacts with endowments, check for conflicts\n// between the names being optimized and the ones added by endowments\n\n/**\n * Simplified validation of indentifier names: may only contain alphanumeric\n * characters (or \"$\" or \"_\"), and may not start with a digit. This is safe\n * and does not reduces the compatibility of the shim. The motivation for\n * this limitation was to decrease the complexity of the implementation,\n * and to maintain a resonable level of performance.\n * Note: \\w is equivalent [a-zA-Z_0-9]\n * See 11.6.1 Identifier Names\n */\nconst identifierPattern = /^[a-zA-Z_$][\\w$]*$/;\n\n/**\n * In JavaScript you cannot use these reserved words as variables.\n * See 11.6.1 Identifier Names\n */\nconst keywords = new Set([\n  // 11.6.2.1 Keywords\n  'await',\n  'break',\n  'case',\n  'catch',\n  'class',\n  'const',\n  'continue',\n  'debugger',\n  'default',\n  'delete',\n  'do',\n  'else',\n  'export',\n  'extends',\n  'finally',\n  'for',\n  'function',\n  'if',\n  'import',\n  'in',\n  'instanceof',\n  'new',\n  'return',\n  'super',\n  'switch',\n  'this',\n  'throw',\n  'try',\n  'typeof',\n  'var',\n  'void',\n  'while',\n  'with',\n  'yield',\n\n  // Also reserved when parsing strict mode code\n  'let',\n  'static',\n\n  // 11.6.2.2 Future Reserved Words\n  'enum',\n\n  // Also reserved when parsing strict mode code\n  'implements',\n  'package',\n  'protected',\n  'interface',\n  'private',\n  'public',\n\n  // Reserved but not mentioned in specs\n  'await',\n\n  'null',\n  'true',\n  'false',\n\n  'this',\n  'arguments'\n]);\n\n/**\n * getOptimizableGlobals()\n * What variable names might it bring into scope? These include all\n * property names which can be variable names, including the names\n * of inherited properties. It excludes symbols and names which are\n * keywords. We drop symbols safely. Currently, this shim refuses\n * service if any of the names are keywords or keyword-like. This is\n * safe and only prevent performance optimization.\n */\nexport function getOptimizableGlobals(safeGlobal) {\n  const descs = getOwnPropertyDescriptors(safeGlobal);\n\n  // getOwnPropertyNames does ignore Symbols so we don't need this extra check:\n  // typeof name === 'string' &&\n  const constants = arrayFilter(getOwnPropertyNames(descs), name => {\n    // Ensure we have a valid identifier. We use regexpTest rather than\n    // /../.test() to guard against the case where RegExp has been poisoned.\n    if (\n      name === 'eval' ||\n      keywords.has(name) ||\n      !regexpTest(identifierPattern, name)\n    ) {\n      return false;\n    }\n\n    const desc = descs[name];\n    return (\n      //\n      // The getters will not have .writable, don't let the falsyness of\n      // 'undefined' trick us: test with === false, not ! . However descriptors\n      // inherit from the (potentially poisoned) global object, so we might see\n      // extra properties which weren't really there. Accessor properties have\n      // 'get/set/enumerable/configurable', while data properties have\n      // 'value/writable/enumerable/configurable'.\n      desc.configurable === false &&\n      desc.writable === false &&\n      //\n      // Checks for data properties because they're the only ones we can\n      // optimize (accessors are most likely non-constant). Descriptors can't\n      // can't have accessors and value properties at the same time, therefore\n      // this check is sufficient. Using explicit own property deal with the\n      // case where Object.prototype has been poisoned.\n      objectHasOwnProperty(desc, 'value')\n    );\n  });\n\n  return constants;\n}\n","import { cleanupSource } from './utilities';\n\n/**\n * ScopeHandler manages a Proxy which serves as the global scope for the\n * safeEvaluator operation (the Proxy is the argument of a 'with' binding).\n * As described in createSafeEvaluator(), it has several functions:\n * - allow the very first (and only the very first) use of 'eval' to map to\n *   the real (unsafe) eval function, so it acts as a 'direct eval' and can\n *    access its lexical scope (which maps to the 'with' binding, which the\n *   ScopeHandler also controls).\n * - ensure that all subsequent uses of 'eval' map to the safeEvaluator,\n *   which lives as the 'eval' property of the safeGlobal.\n * - route all other property lookups at the safeGlobal.\n * - hide the unsafeGlobal which lives on the scope chain above the 'with'.\n * - ensure the Proxy invariants despite some global properties being frozen.\n *\n * @returns {ProxyHandler<any> & Record<string, any>}\n */\nexport function buildScopeHandler(\n  unsafeRec,\n  safeGlobal,\n  endowments = {},\n  sloppyGlobals = false\n) {\n  const { unsafeGlobal, unsafeEval } = unsafeRec;\n\n  const { freeze } = Object;\n  const { get: reflectGet } = Reflect;\n  const { unscopables } = Symbol;\n\n  /**\n   * alwaysThrowHandler is a proxy handler which throws on any trap called.\n   * It's made from a proxy with a get trap that throws. Its target is\n   * an immutable (frozen) object and is safe to share, except accross realms\n   */\n  const alwaysThrowHandler = new Proxy(freeze({}), {\n    get(target, prop) {\n      // todo: replace with throwTantrum\n      throw new TypeError(\n        `unexpected scope handler trap called: ${String(prop)}`\n      );\n    }\n  });\n\n  return {\n    // The scope handler throws if any trap other than get/set/has are run\n    // (e.g. getOwnPropertyDescriptors, apply, getPrototypeOf).\n    // eslint-disable-next-line no-proto\n    __proto__: alwaysThrowHandler,\n\n    // This flag allow us to determine if the eval() call is an done by the\n    // realm's code or if it is user-land invocation, so we can react differently.\n    // We use a property and not an accessor to avoid increasing the stack trace\n    // and reduce the possibility of OOM.\n    useUnsafeEvaluator: false,\n\n    get(shadow, prop) {\n      if (prop === unscopables) {\n        // Safe to return a primal realm Object here because the only code that\n        // can do a get() on a non-string is the internals of with() itself,\n        // and the only thing it does is to look for properties on it. User\n        // code cannot do a lookup on non-strings.\n        return undefined;\n      }\n\n      // Special treatment for eval. The very first lookup of 'eval' gets the\n      // unsafe (real direct) eval, so it will get the lexical scope that uses\n      // the 'with' context.\n      if (prop === 'eval') {\n        // test that it is true rather than merely truthy\n        if (this.useUnsafeEvaluator === true) {\n          // revoke before use\n          this.useUnsafeEvaluator = false;\n          return unsafeEval;\n        }\n        // fall through\n      }\n\n      // Properties of the global.\n      if (prop in endowments) {\n        return reflectGet(endowments, prop, safeGlobal);\n      }\n\n      // Properties of the global.\n      if (prop in safeGlobal) {\n        return safeGlobal[prop];\n      }\n\n      // Prevent the lookup for other properties.\n      return undefined;\n    },\n\n    // eslint-disable-next-line class-methods-use-this\n    set(shadow, prop, value) {\n      // todo: allow modifications when prop in endowments and it\n      // is writable, assuming we've already rejected overlap (see\n      // createSafeEvaluatorFactory.factory). This TypeError gets replaced with\n      // reflectSet(endowments, prop, value, safeGlobal);\n      if (prop in endowments) {\n        // todo: shim integrity: TypeError, String\n        throw new TypeError(`do not modify endowments like ${String(prop)}`);\n      }\n\n      safeGlobal[prop] = value;\n\n      // Return true after successful set.\n      return true;\n    },\n\n    // we need has() to return false for some names to prevent the lookup  from\n    // climbing the scope chain and eventually reaching the unsafeGlobal\n    // object, which is bad.\n\n    // note: unscopables! every string in Object[Symbol.unscopables]\n\n    // todo: we'd like to just have has() return true for everything, and then\n    // use get() to raise a ReferenceError for anything not on the safe global.\n    // But we want to be compatible with ReferenceError in the normal case and\n    // the lack of ReferenceError in the 'typeof' case. Must either reliably\n    // distinguish these two cases (the trap behavior might be different), or\n    // we rely on a mandatory source-to-source transform to change 'typeof abc'\n    // to XXX. We already need a mandatory parse to prevent the 'import',\n    // since it's a special form instead of merely being a global variable/\n\n    // note: if we make has() return true always, then we must implement a\n    // set() trap to avoid subverting the protection of strict mode (it would\n    // accept assignments to undefined globals, when it ought to throw\n    // ReferenceError for such assignments)\n\n    has(shadow, prop) {\n      // proxies stringify 'prop', so no TOCTTOU danger here\n\n      if (sloppyGlobals) {\n        // Everything is potentially available.\n        return true;\n      }\n\n      // unsafeGlobal: hide all properties of unsafeGlobal at the\n      // expense of 'typeof' being wrong for those properties. For\n      // example, in the browser, evaluating 'document = 3', will add\n      // a property to safeGlobal instead of throwing a\n      // ReferenceError.\n      if (\n        prop === 'eval' ||\n        prop in endowments ||\n        prop in safeGlobal ||\n        prop in unsafeGlobal\n      ) {\n        return true;\n      }\n\n      return false;\n    },\n\n    // note: this is likely a bug of safari\n    // https://bugs.webkit.org/show_bug.cgi?id=195534\n\n    getPrototypeOf() {\n      return null;\n    }\n  };\n}\n\nconst buildScopeHandlerString = cleanupSource(\n  `'use strict'; (${buildScopeHandler})`\n);\nexport function createScopeHandler(\n  unsafeRec,\n  safeGlobal,\n  endowments,\n  sloppyGlobals\n) {\n  const { unsafeEval } = unsafeRec;\n  return unsafeEval(buildScopeHandlerString)(\n    unsafeRec,\n    safeGlobal,\n    endowments,\n    sloppyGlobals\n  );\n}\n","import { cleanupSource } from './utilities';\n\nfunction buildSafeEval(unsafeRec, safeEvalOperation) {\n  const { callAndWrapError } = unsafeRec;\n\n  const { defineProperties } = Object;\n\n  // We use the the concise method syntax to create an eval without a\n  // [[Construct]] behavior (such that the invocation \"new eval()\" throws\n  // TypeError: eval is not a constructor\"), but which still accepts a\n  // 'this' binding.\n  const safeEval = {\n    eval() {\n      return callAndWrapError(safeEvalOperation, arguments);\n    }\n  }.eval;\n\n  // safeEval's prototype RootRealm's value and instanceof Function\n  // is true inside the realm. It doesn't point at the primal realm\n  // value, and there is no defense against leaking primal realm\n  // intrinsics.\n\n  defineProperties(safeEval, {\n    toString: {\n      // We break up the following literal string so that an\n      // apparent direct eval syntax does not appear in this\n      // file. Thus, we avoid rejection by the overly eager\n      // rejectDangerousSources.\n      value: () => `function ${'eval'}() { [shim code] }`,\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  return safeEval;\n}\nconst buildSafeEvalString = cleanupSource(`'use strict'; (${buildSafeEval})`);\nexport function createSafeEval(unsafeRec, safeEvalOperation) {\n  const { unsafeEval } = unsafeRec;\n  return unsafeEval(buildSafeEvalString)(unsafeRec, safeEvalOperation);\n}\n","import { cleanupSource } from './utilities';\n\nfunction buildSafeFunction(unsafeRec, safeFunctionOperation) {\n  const { callAndWrapError, unsafeFunction } = unsafeRec;\n\n  const { defineProperties } = Object;\n\n  const safeFunction = function Function() {\n    return callAndWrapError(safeFunctionOperation, arguments);\n  };\n\n  // Ensure that Function from any compartment in a root realm can be used\n  // with instance checks in any compartment of the same root realm.\n\n  defineProperties(safeFunction, {\n    // Ensure that any function created in any compartment in a root realm is an\n    // instance of Function in any compartment of the same root ralm.\n    prototype: { value: unsafeFunction.prototype },\n\n    // Provide a custom output without overwriting the\n    // Function.prototype.toString which is called by some third-party\n    // libraries.\n    toString: {\n      value: () => 'function Function() { [shim code] }',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  return safeFunction;\n}\nconst buildSafeFunctionString = cleanupSource(\n  `'use strict'; (${buildSafeFunction})`\n);\nexport function createSafeFunction(unsafeRec, safeFunctionOperation) {\n  const { unsafeEval } = unsafeRec;\n  return unsafeEval(buildSafeFunctionString)(unsafeRec, safeFunctionOperation);\n}\n","// https://www.ecma-international.org/ecma-262/9.0/index.html#sec-html-like-comments\n// explains that JavaScript parsers may or may not recognize html\n// comment tokens \"<\" immediately followed by \"!--\" and \"--\"\n// immediately followed by \">\" in non-module source text, and treat\n// them as a kind of line comment. Since otherwise both of these can\n// appear in normal JavaScript source code as a sequence of operators,\n// we have the terrifying possibility of the same source code parsing\n// one way on one correct JavaScript implementation, and another way\n// on another.\n//\n// This shim takes the conservative strategy of just rejecting source\n// text that contains these strings anywhere. Note that this very\n// source file is written strangely to avoid mentioning these\n// character strings explicitly.\n\n// We do not write the regexp in a straightforward way, so that an\n// apparennt html comment does not appear in this file. Thus, we avoid\n// rejection by the overly eager rejectDangerousSources.\nconst htmlCommentPattern = new RegExp(`(?:${'<'}!--|--${'>'})`);\n\nfunction rejectHtmlComments(s) {\n  const index = s.search(htmlCommentPattern);\n  if (index !== -1) {\n    const linenum = s.slice(0, index).split('\\n').length; // more or less\n    throw new SyntaxError(\n      `possible html comment syntax rejected around line ${linenum}`\n    );\n  }\n}\n\n// The proposed dynamic import expression is the only syntax currently\n// proposed, that can appear in non-module JavaScript code, that\n// enables direct access to the outside world that cannot be\n// surpressed or intercepted without parsing and rewriting. Instead,\n// this shim conservatively rejects any source text that seems to\n// contain such an expression. To do this safely without parsing, we\n// must also reject some valid programs, i.e., those containing\n// apparent import expressions in literal strings or comments.\n\n// The current conservative rule looks for the identifier \"import\"\n// followed by either an open paren or something that looks like the\n// beginning of a comment. We assume that we do not need to worry\n// about html comment syntax because that was already rejected by\n// rejectHtmlComments.\n\n// this \\s *must* match all kinds of syntax-defined whitespace. If e.g.\n// U+2028 (LINE SEPARATOR) or U+2029 (PARAGRAPH SEPARATOR) is treated as\n// whitespace by the parser, but not matched by /\\s/, then this would admit\n// an attack like: import\\u2028('power.js') . We're trying to distinguish\n// something like that from something like importnotreally('power.js') which\n// is perfectly safe.\n\nconst importPattern = /\\bimport\\s*(?:\\(|\\/[/*])/;\n\nfunction rejectImportExpressions(s) {\n  const index = s.search(importPattern);\n  if (index !== -1) {\n    const linenum = s.slice(0, index).split('\\n').length; // more or less\n    throw new SyntaxError(\n      `possible import expression rejected around line ${linenum}`\n    );\n  }\n}\n\n// The shim cannot correctly emulate a direct eval as explained at\n// https://github.com/Agoric/realms-shim/issues/12\n// Without rejecting apparent direct eval syntax, we would\n// accidentally evaluate these with an emulation of indirect eval. Tp\n// prevent future compatibility problems, in shifting from use of the\n// shim to genuine platform support for the proposal, we should\n// instead statically reject code that seems to contain a direct eval\n// expression.\n//\n// As with the dynamic import expression, to avoid a full parse, we do\n// this approximately with a regexp, that will also reject strings\n// that appear safely in comments or strings. Unlike dynamic import,\n// if we miss some, this only creates future compat problems, not\n// security problems. Thus, we are only trying to catch innocent\n// occurrences, not malicious one. In particular, `(eval)(...)` is\n// direct eval syntax that would not be caught by the following regexp.\n\nconst someDirectEvalPattern = /\\beval\\s*(?:\\(|\\/[/*])/;\n\nfunction rejectSomeDirectEvalExpressions(s) {\n  const index = s.search(someDirectEvalPattern);\n  if (index !== -1) {\n    const linenum = s.slice(0, index).split('\\n').length; // more or less\n    throw new SyntaxError(\n      `possible direct eval expression rejected around line ${linenum}`\n    );\n  }\n}\n\nexport function rejectDangerousSources(s) {\n  rejectHtmlComments(s);\n  rejectImportExpressions(s);\n  rejectSomeDirectEvalExpressions(s);\n}\n\n// Export a rewriter transform.\nexport const rejectDangerousSourcesTransform = {\n  rewrite(rs) {\n    rejectDangerousSources(rs.src);\n    return rs;\n  }\n};\n","// Portions adapted from V8 - Copyright 2016 the V8 project authors.\n// https://github.com/v8/v8/blob/master/src/builtins/builtins-function.cc\n\nimport { assert, throwTantrum } from './utilities';\nimport {\n  apply,\n  arrayConcat,\n  arrayJoin,\n  arrayPop,\n  create,\n  getOwnPropertyDescriptors,\n  getPrototypeOf,\n  regexpTest,\n  stringIncludes\n} from './commons';\nimport { getOptimizableGlobals } from './optimizer';\nimport { createScopeHandler } from './scopeHandlerFacade';\nimport { createSafeEval } from './safeEvalFacade';\nimport { createSafeFunction } from './safeFunctionFacade';\nimport { rejectDangerousSourcesTransform } from './sourceParser';\n\nfunction buildOptimizer(constants) {\n  // No need to build an oprimizer when there are no constants.\n  if (constants.length === 0) return '';\n  // Use 'this' to avoid going through the scope proxy, which is unecessary\n  // since the optimizer only needs references to the safe global.\n  return `const {${arrayJoin(constants, ',')}} = this;`;\n}\n\nfunction createScopedEvaluatorFactory(unsafeRec, constants) {\n  const { unsafeFunction } = unsafeRec;\n\n  const optimizer = buildOptimizer(constants);\n\n  // Create a function in sloppy mode, so that we can use 'with'. It returns\n  // a function in strict mode that evaluates the provided code using direct\n  // eval, and thus in strict mode in the same scope. We must be very careful\n  // to not create new names in this scope\n\n  // 1: we use 'with' (around a Proxy) to catch all free variable names. The\n  // first 'arguments[0]' holds the Proxy which safely wraps the safeGlobal\n  // 2: 'optimizer' catches common variable names for speed\n  // 3: The inner strict function is effectively passed two parameters:\n  //    a) its arguments[0] is the source to be directly evaluated.\n  //    b) its 'this' is the this binding seen by the code being\n  //       directly evaluated.\n\n  // everything in the 'optimizer' string is looked up in the proxy\n  // (including an 'arguments[0]', which points at the Proxy). 'function' is\n  // a keyword, not a variable, so it is not looked up. then 'eval' is looked\n  // up in the proxy, that's the first time it is looked up after\n  // useUnsafeEvaluator is turned on, so the proxy returns the real the\n  // unsafeEval, which satisfies the IsDirectEvalTrap predicate, so it uses\n  // the direct eval and gets the lexical scope. The second 'arguments[0]' is\n  // looked up in the context of the inner function. The *contents* of\n  // arguments[0], because we're using direct eval, are looked up in the\n  // Proxy, by which point the useUnsafeEvaluator switch has been flipped\n  // back to 'false', so any instances of 'eval' in that string will get the\n  // safe evaluator.\n\n  return unsafeFunction(`\n    with (arguments[0]) {\n      ${optimizer}\n      return function() {\n        'use strict';\n        return eval(arguments[0]);\n      };\n    }\n  `);\n}\n\nfunction applyTransforms(rewriterState, transforms) {\n  // Clone before calling transforms.\n  rewriterState = {\n    src: `${rewriterState.src}`,\n    endowments: create(\n      null,\n      getOwnPropertyDescriptors(rewriterState.endowments)\n    )\n  };\n\n  // Rewrite the source, threading through rewriter state as necessary.\n  rewriterState = transforms.reduce(\n    (rs, transform) => (transform.rewrite ? transform.rewrite(rs) : rs),\n    rewriterState\n  );\n\n  // Clone after transforms\n  rewriterState = {\n    src: `${rewriterState.src}`,\n    endowments: create(\n      null,\n      getOwnPropertyDescriptors(rewriterState.endowments)\n    )\n  };\n\n  return rewriterState;\n}\n\nexport function createSafeEvaluatorFactory(\n  unsafeRec,\n  safeGlobal,\n  transforms,\n  sloppyGlobals\n) {\n  const constants = getOptimizableGlobals(safeGlobal);\n  const scopedEvaluatorFactory = createScopedEvaluatorFactory(\n    unsafeRec,\n    constants\n  );\n\n  function factory(endowments = {}, options = {}) {\n    // todo clone all arguments passed to returned function\n    const localTransforms = options.transforms || [];\n    const realmTransforms = transforms || [];\n\n    const mandatoryTransforms = [rejectDangerousSourcesTransform];\n    const allTransforms = arrayConcat(\n      localTransforms,\n      realmTransforms,\n      mandatoryTransforms\n    );\n\n    function safeEvalOperation(src) {\n      let rewriterState = { src, endowments };\n      rewriterState = applyTransforms(rewriterState, allTransforms);\n\n      const scopeHandler = createScopeHandler(\n        unsafeRec,\n        safeGlobal,\n        rewriterState.endowments,\n        sloppyGlobals\n      );\n      const scopeProxyRevocable = Proxy.revocable({}, scopeHandler);\n      const scopeProxy = scopeProxyRevocable.proxy;\n      const scopedEvaluator = apply(scopedEvaluatorFactory, safeGlobal, [\n        scopeProxy\n      ]);\n\n      scopeHandler.useUnsafeEvaluator = true;\n      let err;\n      try {\n        // Ensure that \"this\" resolves to the safe global.\n        return apply(scopedEvaluator, safeGlobal, [rewriterState.src]);\n      } catch (e) {\n        // stash the child-code error in hopes of debugging the internal failure\n        err = e;\n        throw e;\n      } finally {\n        if (scopeHandler.useUnsafeEvaluator) {\n          // the proxy switches this off immediately after ths\n          // first access, but if that's not the case we prevent\n          // further variable resolution on the scope and abort.\n          scopeProxyRevocable.revoke();\n          throwTantrum('handler did not revoke useUnsafeEvaluator', err);\n        }\n      }\n    }\n\n    return safeEvalOperation;\n  }\n\n  return factory;\n}\n\nexport function createSafeEvaluator(unsafeRec, safeEvalOperation) {\n  const { unsafeFunction } = unsafeRec;\n\n  const safeEval = createSafeEval(unsafeRec, safeEvalOperation);\n\n  assert(getPrototypeOf(safeEval).constructor !== Function, 'hide Function');\n  assert(\n    getPrototypeOf(safeEval).constructor !== unsafeFunction,\n    'hide unsafeFunction'\n  );\n\n  return safeEval;\n}\n\nexport function createSafeEvaluatorWhichTakesEndowments(safeEvaluatorFactory) {\n  return (x, endowments, options = {}) =>\n    safeEvaluatorFactory(endowments, options)(x);\n}\n\n/**\n * A safe version of the native Function which relies on\n * the safety of evalEvaluator for confinement.\n */\nexport function createFunctionEvaluator(unsafeRec, safeEvalOperation) {\n  const { unsafeGlobal, unsafeFunction } = unsafeRec;\n\n  function safeFunctionOperation(...params) {\n    const functionBody = `${arrayPop(params) || ''}`;\n    let functionParams = `${arrayJoin(params, ',')}`;\n    if (!regexpTest(/^[\\w\\s,]*$/, functionParams)) {\n      throw new SyntaxError(\n        'shim limitation: Function arg must be simple ASCII identifiers, possibly separated by commas: no default values, pattern matches, or non-ASCII parameter names'\n      );\n      // this protects against Matt Austin's clever attack:\n      // Function(\"arg=`\", \"/*body`){});({x: this/**/\")\n      // which would turn into\n      //     (function(arg=`\n      //     /*``*/){\n      //      /*body`){});({x: this/**/\n      //     })\n      // which parses as a default argument of `\\n/*``*/){\\n/*body` , which\n      // is a pair of template literals back-to-back (so the first one\n      // nominally evaluates to the parser to use on the second one), which\n      // can't actually execute (because the first literal evals to a string,\n      // which can't be a parser function), but that doesn't matter because\n      // the function is bypassed entirely. When that gets evaluated, it\n      // defines (but does not invoke) a function, then evaluates a simple\n      // {x: this} expression, giving access to the safe global.\n    }\n\n    // Is this a real functionBody, or is someone attempting an injection\n    // attack? This will throw a SyntaxError if the string is not actually a\n    // function body. We coerce the body into a real string above to prevent\n    // someone from passing an object with a toString() that returns a safe\n    // string the first time, but an evil string the second time.\n    // eslint-disable-next-line no-new, new-cap\n    new unsafeFunction(functionBody);\n\n    if (stringIncludes(functionParams, ')')) {\n      // If the formal parameters string include ) - an illegal\n      // character - it may make the combined function expression\n      // compile. We avoid this problem by checking for this early on.\n\n      // note: v8 throws just like this does, but chrome accepts\n      // e.g. 'a = new Date()'\n      throw new unsafeGlobal.SyntaxError(\n        'shim limitation: Function arg string contains parenthesis'\n      );\n      // todo: shim integrity threat if they change SyntaxError\n    }\n\n    // todo: check to make sure this .length is safe. markm says safe.\n    if (functionParams.length > 0) {\n      // If the formal parameters include an unbalanced block comment, the\n      // function must be rejected. Since JavaScript does not allow nested\n      // comments we can include a trailing block comment to catch this.\n      functionParams += '\\n/*``*/';\n    }\n\n    const src = `(function(${functionParams}){\\n${functionBody}\\n})`;\n\n    return safeEvalOperation(src);\n  }\n\n  const safeFunction = createSafeFunction(unsafeRec, safeFunctionOperation);\n\n  assert(\n    getPrototypeOf(safeFunction).constructor !== Function,\n    'hide Function'\n  );\n  assert(\n    getPrototypeOf(safeFunction).constructor !== unsafeFunction,\n    'hide unsafeFunction'\n  );\n\n  return safeFunction;\n}\n","import { createRealmFacade, buildChildRealm } from './realmFacade';\nimport { createNewUnsafeRec, createCurrentUnsafeRec } from './unsafeRec';\nimport {\n  createSafeEvaluatorFactory,\n  createSafeEvaluator,\n  createSafeEvaluatorWhichTakesEndowments,\n  createFunctionEvaluator\n} from './evaluators';\nimport { assert } from './utilities';\nimport { create, defineProperties, freeze, arrayConcat } from './commons';\n\n// Mimic private members on the realm instances.\n// We define it in the same module and do not export it.\nconst RealmRecForRealmInstance = new WeakMap();\n\nfunction getRealmRecForRealmInstance(realm) {\n  // Detect non-objects.\n  assert(Object(realm) === realm, 'bad object, not a Realm instance');\n  // Realm instance has no realmRec. Should not proceed.\n  assert(RealmRecForRealmInstance.has(realm), 'Realm instance has no record');\n\n  return RealmRecForRealmInstance.get(realm);\n}\n\nfunction registerRealmRecForRealmInstance(realm, realmRec) {\n  // Detect non-objects.\n  assert(Object(realm) === realm, 'bad object, not a Realm instance');\n  // Attempt to change an existing realmRec on a realm instance. Should not proceed.\n  assert(\n    !RealmRecForRealmInstance.has(realm),\n    'Realm instance already has a record'\n  );\n\n  RealmRecForRealmInstance.set(realm, realmRec);\n}\n\n// Initialize the global variables for the new Realm.\nfunction setDefaultBindings(safeGlobal, safeEval, safeFunction) {\n  defineProperties(safeGlobal, {\n    eval: {\n      value: safeEval,\n      writable: true,\n      configurable: true\n    },\n    Function: {\n      value: safeFunction,\n      writable: true,\n      configurable: true\n    }\n  });\n}\n\nfunction createRealmRec(unsafeRec, transforms, sloppyGlobals) {\n  const { sharedGlobalDescs, unsafeGlobal } = unsafeRec;\n\n  const safeGlobal = create(unsafeGlobal.Object.prototype, sharedGlobalDescs);\n\n  const safeEvaluatorFactory = createSafeEvaluatorFactory(\n    unsafeRec,\n    safeGlobal,\n    transforms,\n    sloppyGlobals\n  );\n  const safeEvalOperation = safeEvaluatorFactory();\n  const safeEval = createSafeEvaluator(unsafeRec, safeEvalOperation);\n  const safeFunction = createFunctionEvaluator(unsafeRec, safeEvalOperation);\n  const safeEvalWhichTakesEndowments = createSafeEvaluatorWhichTakesEndowments(\n    safeEvaluatorFactory\n  );\n\n  setDefaultBindings(safeGlobal, safeEval, safeFunction);\n\n  const realmRec = freeze({\n    safeGlobal,\n    safeEval,\n    safeEvalWhichTakesEndowments,\n    safeFunction\n  });\n\n  return realmRec;\n}\n\n/**\n * A root realm uses a fresh set of new intrinics. Here we first create\n * a new unsafe record, which inherits the shims. Then we proceed with\n * the creation of the realm record, and we apply the shims.\n */\nfunction initRootRealm(parentUnsafeRec, self, options) {\n  // note: 'self' is the instance of the Realm.\n\n  // todo: investigate attacks via Array.species\n  // todo: this accepts newShims='string', but it should reject that\n  const { shims: newShims, transforms, sloppyGlobals } = options;\n  const allShims = arrayConcat(parentUnsafeRec.allShims, newShims);\n\n  // The unsafe record is created already repaired.\n  const unsafeRec = createNewUnsafeRec(allShims);\n\n  // eslint-disable-next-line no-use-before-define\n  const Realm = createRealmFacade(unsafeRec, BaseRealm);\n\n  // Add a Realm descriptor to sharedGlobalDescs, so it can be defined onto the\n  // safeGlobal like the rest of the globals.\n  unsafeRec.sharedGlobalDescs.Realm = {\n    value: Realm,\n    writable: true,\n    configurable: true\n  };\n\n  // Creating the realmRec provides the global object, eval() and Function()\n  // to the realm.\n  const realmRec = createRealmRec(unsafeRec, transforms, sloppyGlobals);\n\n  // Apply all shims in the new RootRealm. We don't do this for compartments.\n  const { safeEvalWhichTakesEndowments } = realmRec;\n  for (const shim of allShims) {\n    safeEvalWhichTakesEndowments(shim);\n  }\n\n  // The realmRec acts as a private field on the realm instance.\n  registerRealmRecForRealmInstance(self, realmRec);\n}\n\n/**\n * A compartment shares the intrinsics of its root realm. Here, only a\n * realmRec is necessary to hold the global object, eval() and Function().\n */\nfunction initCompartment(unsafeRec, self, options = {}) {\n  // note: 'self' is the instance of the Realm.\n\n  const { transforms, sloppyGlobals } = options;\n  const realmRec = createRealmRec(unsafeRec, transforms, sloppyGlobals);\n\n  // The realmRec acts as a private field on the realm instance.\n  registerRealmRecForRealmInstance(self, realmRec);\n}\n\nfunction getRealmGlobal(self) {\n  const { safeGlobal } = getRealmRecForRealmInstance(self);\n  return safeGlobal;\n}\n\nfunction realmEvaluate(self, x, endowments = {}, options = {}) {\n  // todo: don't pass in primal-realm objects like {}, for safety. OTOH its\n  // properties are copied onto the new global 'target'.\n  // todo: figure out a way to membrane away the contents to safety.\n  const { safeEvalWhichTakesEndowments } = getRealmRecForRealmInstance(self);\n  return safeEvalWhichTakesEndowments(x, endowments, options);\n}\n\nconst BaseRealm = {\n  initRootRealm,\n  initCompartment,\n  getRealmGlobal,\n  realmEvaluate\n};\n\n// Create the current unsafeRec from the current \"primal\" environment (the realm\n// where the Realm shim is loaded and executed).\nconst currentUnsafeRec = createCurrentUnsafeRec();\n\n/**\n * The \"primal\" realm class is defined in the current \"primal\" environment,\n * and is part of the shim. There is no need to facade this class via evaluation\n * because both share the same intrinsics.\n */\nconst Realm = buildChildRealm(currentUnsafeRec, BaseRealm);\n\nexport default Realm;\n"],"names":[],"mappings":"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"}
##############################################
/src/dist/realms-shim.cjs.js-711-  document.body.appendChild(iframe);
/src/dist/realms-shim.cjs.js:712:  const unsafeGlobal = iframe.contentWindow.eval(unsafeGlobalSrc);
/src/dist/realms-shim.cjs.js-713-
/src/dist/realms-shim.cjs.js-714-  // We keep the iframe attached to the DOM because removing it
/src/dist/realms-shim.cjs.js:715:  // causes its global object to lose intrinsics, its eval()
/src/dist/realms-shim.cjs.js-716-  // function to evaluate code, etc.
##############################################
/src/dist/realms-shim.cjs.js-769-  const unsafeGlobal = getNewUnsafeGlobal();
/src/dist/realms-shim.cjs.js:770:  unsafeGlobal.eval(repairAccessorsShim);
/src/dist/realms-shim.cjs.js:771:  unsafeGlobal.eval(repairFunctionsShim);
/src/dist/realms-shim.cjs.js-772-  return createUnsafeRec(unsafeGlobal, allShims);
##############################################
/src/dist/realms-shim.cjs.js-961-
/src/dist/realms-shim.cjs.js:962:    // This flag allow us to determine if the eval() call is an done by the
/src/dist/realms-shim.cjs.js-963-    // realm's code or if it is user-land invocation, so we can react differently.
##############################################
/src/dist/realms-shim.cjs.js-1098-  // We use the the concise method syntax to create an eval without a
/src/dist/realms-shim.cjs.js:1099:  // [[Construct]] behavior (such that the invocation "new eval()" throws
/src/dist/realms-shim.cjs.js-1100-  // TypeError: eval is not a constructor"), but which still accepts a
##############################################
/src/dist/realms-shim.cjs.js-1102-  const safeEval = {
/src/dist/realms-shim.cjs.js:1103:    eval() {
/src/dist/realms-shim.cjs.js-1104-      return callAndWrapError(safeEvalOperation, arguments);
##############################################
/src/dist/realms-shim.cjs.js-1324-        'use strict';
/src/dist/realms-shim.cjs.js:1325:        return eval(arguments[0]);
/src/dist/realms-shim.cjs.js-1326-      };
##############################################
/src/dist/realms-shim.cjs.js-1620-
/src/dist/realms-shim.cjs.js:1621:  // Creating the realmRec provides the global object, eval() and Function()
/src/dist/realms-shim.cjs.js-1622-  // to the realm.
##############################################
/src/dist/realms-shim.cjs.js-1636- * A compartment shares the intrinsics of its root realm. Here, only a
/src/dist/realms-shim.cjs.js:1637: * realmRec is necessary to hold the global object, eval() and Function().
/src/dist/realms-shim.cjs.js-1638- */
##############################################
/src/dist/realms-shim.umd.min.js:1:(function(a,b){"object"==typeof exports&&"undefined"!=typeof module?module.exports=b():"function"==typeof define&&define.amd?define(b):(a=a||self,a.Realm=b())})(this,function(){'use strict';function a(a,b=void 0){const c=`please report internal shim error: ${a}`;console.error(c),b&&(console.error(`${b}`),console.error(`${b.stack}`));debugger;throw c}function b(b,c){b||a(c)}function c(a){return a=a.replace(/\(0,\s*_[^.]+\.e\)/g,"(0, eval)"),a=a.replace(/_[^.]+\.g\.Reflect/g,"Reflect"),a=a.replace(/cov_[^+]+\+\+[;,]/g,""),a}function d(a,b){const{callAndWrapError:c}=a,{initRootRealm:d,initCompartment:e,getRealmGlobal:f,realmEvaluate:g}=b,{create:h,defineProperties:i}=Object;class j{constructor(){throw new TypeError("Realm is not a constructor")}static makeRootRealm(b={}){const e=h(j.prototype);return c(d,[a,e,b]),e}static makeCompartment(b={}){const d=h(j.prototype);return c(e,[a,d,b]),d}get global(){return c(f,[this])}evaluate(a,b,d={}){return c(g,[this,a,b,d])}}return i(j,{toString:{value:()=>"function Realm() { [shim code] }",writable:!1,enumerable:!1,configurable:!0}}),i(j.prototype,{toString:{value:()=>"[object Realm]",writable:!1,enumerable:!1,configurable:!0}}),j}function e(a,b){const{unsafeEval:c}=a;return c(H)(a,b)}function f(a){return a(I)()}function g(a){function c(c,e,f,g){for(const h of c){const c=N(a,h);c&&(b("value"in c,`unexpected accessor on global property: ${h}`),d[h]={value:c.value,writable:e,enumerable:f,configurable:g})}}const d={};return c(aa,!1,!1,!1),c(ba,!1,!1,!1),c(ca,!0,!1,!0),d}function h(){function a(a){if(a===void 0||null===a)throw new TypeError(`can't convert undefined or null to object`);return Object(a)}function b(a){return"symbol"==typeof a?a:`${a}`}function c(a,b){if("function"!=typeof a)throw TypeError(`invalid ${b} usage`);return a}const{defineProperty:d,defineProperties:e,getOwnPropertyDescriptor:f,getPrototypeOf:g,prototype:h}=Object;try{(0,h.__lookupGetter__)("x")}catch(a){return}e(h,{__defineGetter__:{value:function(b,e){const f=a(this);d(f,b,{get:c(e,"getter"),enumerable:!0,configurable:!0})}},__defineSetter__:{value:function(b,e){const f=a(this);d(f,b,{set:c(e,"setter"),enumerable:!0,configurable:!0})}},__lookupGetter__:{value:function(c){let d=a(this);c=b(c);let e;for(;d&&!(e=f(d,c));)d=g(d);return e&&e.get}},__lookupSetter__:{value:function(c){let d=a(this);c=b(c);let e;for(;d&&!(e=f(d,c));)d=g(d);return e&&e.set}}})}function i(){function a(a,e){let f;try{f=(0,eval)(e)}catch(a){if(a instanceof SyntaxError)return;throw a}const g=c(f),h=function(){throw new TypeError("Not available")};b(h,{name:{value:a}}),b(g,{constructor:{value:h}}),b(h,{prototype:{value:g}}),h!==Function.prototype.constructor&&d(h,Function.prototype.constructor)}const{defineProperties:b,getPrototypeOf:c,setPrototypeOf:d}=Object;a("Function","(function(){})"),a("GeneratorFunction","(function*(){})"),a("AsyncFunction","(async function(){})"),a("AsyncGeneratorFunction","(async function*(){})")}function j(){const a=new Function("try {return this===global}catch(e){return false}")();if(!a)return;const b=require("vm"),c=b.runInNewContext(ea);return c}function k(){if("undefined"!=typeof document){const a=document.createElement("iframe");a.style.display="none",document.body.appendChild(a);const b=a.contentWindow.eval(da);return b}}function l(a,b=[]){const c=g(a),d=a.eval,e=a.Function,h=f(d);return L({unsafeGlobal:a,sharedGlobalDescs:c,unsafeEval:d,unsafeFunction:e,callAndWrapError:h,allShims:b})}function m(a){const b=fa();return b.eval(ga),b.eval(ha),l(b,a)}function n(a){const b=O(a),c=W(P(b),a=>{if("eval"===a||ja.has(a)||!$(ia,a))return!1;const c=b[a];return!1===c.configurable&&!1===c.writable&&V(c,"value")});return c}function o(a,b,c,d){const{unsafeEval:e}=a;return e(ka)(a,b,c,d)}function p(a,b){const{unsafeEval:c}=a;return c(la)(a,b)}function q(a,b){const{unsafeEval:c}=a;return c(ma)(a,b)}function r(a){const b=a.search(na);if(-1!==b){const c=a.slice(0,b).split("\n").length;throw new SyntaxError(`possible html comment syntax rejected around line ${c}`)}}function t(a){const b=a.search(oa);if(-1!==b){const c=a.slice(0,b).split("\n").length;throw new SyntaxError(`possible import expression rejected around line ${c}`)}}function u(a){const b=a.search(pa);if(-1!==b){const c=a.slice(0,b).split("\n").length;throw new SyntaxError(`possible direct eval expression rejected around line ${c}`)}}function v(a){r(a),t(a),u(a)}function w(a){return 0===a.length?"":`const {${Y(a,",")}} = this;`}function x(a,b){const{unsafeFunction:c}=a,d=w(b);return c(`
/src/dist/realms-shim.umd.min.js-2-    with (arguments[0]) {
##############################################
/src/dist/realms-shim.umd.min.js-5-        'use strict';
/src/dist/realms-shim.umd.min.js:6:        return eval(arguments[0]);
/src/dist/realms-shim.umd.min.js-7-      };
/src/dist/realms-shim.umd.min.js-8-    }
/src/dist/realms-shim.umd.min.js:9:  `)}function y(a,b){return a={src:`${a.src}`,endowments:K(null,O(a.endowments))},a=b.reduce((a,b)=>b.rewrite?b.rewrite(a):a,a),a={src:`${a.src}`,endowments:K(null,O(a.endowments))},a}function z(b,c,d,e){const f=n(c),g=x(b,f);return function(f={},h={}){const i=h.transforms||[],j=Z(i,d||[],[qa]);return function(d){let h={src:d,endowments:f};h=y(h,j);const i=o(b,c,h.endowments,e),k=Proxy.revocable({},i),l=k.proxy,m=S(g,c,[l]);i.useUnsafeEvaluator=!0;let n;try{return S(m,c,[h.src])}catch(a){throw n=a,a}finally{i.useUnsafeEvaluator&&(k.revoke(),a("handler did not revoke useUnsafeEvaluator",n))}}}}function A(a,c){const{unsafeFunction:d}=a,e=p(a,c);return b(Q(e).constructor!==Function,"hide Function"),b(Q(e).constructor!==d,"hide unsafeFunction"),e}function B(a){return(b,c,d={})=>a(c,d)(b)}function C(a,c){const{unsafeGlobal:d,unsafeFunction:e}=a,f=q(a,function(...a){const b=`${X(a)||""}`;let f=`${Y(a,",")}`;if(!$(/^[\w\s,]*$/,f))throw new SyntaxError("shim limitation: Function arg must be simple ASCII identifiers, possibly separated by commas: no default values, pattern matches, or non-ASCII parameter names");if(new e(b),_(f,")"))throw new d.SyntaxError("shim limitation: Function arg string contains parenthesis");0<f.length&&(f+="\n/*``*/");const g=`(function(${f}){\n${b}\n})`;return c(g)});return b(Q(f).constructor!==Function,"hide Function"),b(Q(f).constructor!==e,"hide unsafeFunction"),f}function D(a){return b(Object(a)===a,"bad object, not a Realm instance"),b(ra.has(a),"Realm instance has no record"),ra.get(a)}function E(a,c){b(Object(a)===a,"bad object, not a Realm instance"),b(!ra.has(a),"Realm instance already has a record"),ra.set(a,c)}function F(a,b,c){M(a,{eval:{value:b,writable:!0,configurable:!0},Function:{value:c,writable:!0,configurable:!0}})}function G(a,b,c){const{sharedGlobalDescs:d,unsafeGlobal:e}=a,f=K(e.Object.prototype,d),g=z(a,f,b,c),h=g(),i=A(a,h),j=C(a,h),k=B(g);F(f,i,j);const l=L({safeGlobal:f,safeEval:i,safeEvalWhichTakesEndowments:k,safeFunction:j});return l}const H=c(`'use strict'; (${d})`),I=c(`'use strict'; (${function(){const{getPrototypeOf:a}=Object,{apply:b}=Reflect,c=a=>(c,...d)=>b(a,c,d),d=c(Map.prototype.get),e=c(Set.prototype.has),f=new Map([["EvalError",EvalError],["RangeError",RangeError],["ReferenceError",ReferenceError],["SyntaxError",SyntaxError],["TypeError",TypeError],["URIError",URIError]]),g=new Set([EvalError.prototype,RangeError.prototype,ReferenceError.prototype,SyntaxError.prototype,TypeError.prototype,URIError.prototype,Error.prototype]);return function(c,h){try{return b(c,void 0,h)}catch(b){if(Object(b)!==b)throw b;if(e(g,a(b)))throw b;let c,h,i;try{c=`${b.name}`,h=`${b.message}`,i=`${b.stack||h}`}catch(a){throw new Error("unknown error")}const j=d(f,c)||Error;try{throw new j(h)}catch(a){throw a.stack=i,a}}}}})`),{assign:J,create:K,freeze:L,defineProperties:M,getOwnPropertyDescriptor:N,getOwnPropertyDescriptors:O,getOwnPropertyNames:P,getPrototypeOf:Q,setPrototypeOf:R}=Object,{apply:S,ownKeys:T}=Reflect,U=a=>(b,...c)=>S(a,b,c),V=U(Object.prototype.hasOwnProperty),W=U(Array.prototype.filter),X=U(Array.prototype.pop),Y=U(Array.prototype.join),Z=U(Array.prototype.concat),$=U(RegExp.prototype.test),_=U(String.prototype.includes),aa=["Infinity","NaN","undefined"],ba=["isFinite","isNaN","parseFloat","parseInt","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","Array","ArrayBuffer","Boolean","DataView","EvalError","Float32Array","Float64Array","Int8Array","Int16Array","Int32Array","Map","Number","Object","RangeError","ReferenceError","Set","String","Symbol","SyntaxError","TypeError","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","URIError","WeakMap","WeakSet","JSON","Math","Reflect","escape","unescape"],ca=["Date","Error","Promise","Proxy","RegExp","Intl"],da="'use strict'; this",ea=`(0, eval)("'use strict'; this")`,fa=()=>{const a=k(),b=j();if(!a&&!b||a&&b)throw new Error("unexpected platform, unable to create Realm");return a||b},ga=c(`"use strict"; (${h})();`),ha=c(`"use strict"; (${i})();`),ia=/^[a-zA-Z_$][\w$]*$/,ja=new Set(["await","break","case","catch","class","const","continue","debugger","default","delete","do","else","export","extends","finally","for","function","if","import","in","instanceof","new","return","super","switch","this","throw","try","typeof","var","void","while","with","yield","let","static","enum","implements","package","protected","interface","private","public","await","null","true","false","this","arguments"]),ka=c(`'use strict'; (${function(a,b,c={},d=!1){const{unsafeGlobal:e,unsafeEval:f}=a,{freeze:g}=Object,{get:h}=Reflect,{unscopables:i}=Symbol,j=new Proxy(g({}),{get(a,b){throw new TypeError(`unexpected scope handler trap called: ${b+""}`)}});return{__proto__:j,useUnsafeEvaluator:!1,get(a,d){return d===i?void 0:"eval"===d&&!0===this.useUnsafeEvaluator?(this.useUnsafeEvaluator=!1,f):d in c?h(c,d,b):d in b?b[d]:void 0},set(a,d,e){if(d in c)throw new TypeError(`do not modify endowments like ${d+""}`);return b[d]=e,!0},has(a,f){return!!d||!!("eval"===f||f in c||f in b||f in e)},getPrototypeOf(){return null}}}})`),la=c(`'use strict'; (${function(a,b){const{callAndWrapError:c}=a,{defineProperties:d}=Object,e={eval(){return c(b,arguments)}}.eval;return d(e,{toString:{value:()=>`function ${"eval"}() { [shim code] }`,writable:!1,enumerable:!1,configurable:!0}}),e}})`),ma=c(`'use strict'; (${function(a,b){const{callAndWrapError:c,unsafeFunction:d}=a,{defineProperties:e}=Object,f=function(){return c(b,arguments)};return e(f,{prototype:{value:d.prototype},toString:{value:()=>"function Function() { [shim code] }",writable:!1,enumerable:!1,configurable:!0}}),f}})`),na=/(?:<!--|-->)/,oa=/\bimport\s*(?:\(|\/[/*])/,pa=/\beval\s*(?:\(|\/[/*])/,qa={rewrite(a){return v(a.src),a}},ra=new WeakMap,sa={initRootRealm:function(a,b,c){const{shims:d,transforms:f,sloppyGlobals:g}=c,h=Z(a.allShims,d),i=m(h),j=e(i,sa);i.sharedGlobalDescs.Realm={value:j,writable:!0,configurable:!0};const k=G(i,f,g),{safeEvalWhichTakesEndowments:l}=k;for(const d of h)l(d);E(b,k)},initCompartment:function(a,b,c={}){const{transforms:d,sloppyGlobals:e}=c,f=G(a,d,e);E(b,f)},getRealmGlobal:function(a){const{safeGlobal:b}=D(a);return b},realmEvaluate:function(a,b,c={},d={}){const{safeEvalWhichTakesEndowments:e}=D(a);return e(b,c,d)}},ta=function(){const a=(0,eval)(da);return h(),i(),l(a)}(),ua=d(ta,sa);return ua});
/src/dist/realms-shim.umd.min.js-10-//# sourceMappingURL=realms-shim.umd.min.js.map

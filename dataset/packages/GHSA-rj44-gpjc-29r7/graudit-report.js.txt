/src/tags.js-28-    hex: (_, body) => maybeParseInt(body, 0, 16),
/src/tags.js:29:    json: (_, body) => JSON.parse(unescape(body)),
/src/tags.js-30-    list: (_, body) => body.split(/[\n\r\t ]+/g).map(unescape),
##############################################
/src/README.md-67-| `#base64` | Base64 encoded binary data                      | `Uint8Array` |
/src/README.md:68:| `#date`   | `Date.parse()` compatible string (e.g. ISO8601) | `Date`       |
/src/README.md-69-| `#file`   | File path to read value from                    | `string`     |
##############################################
/src/lib/index.js-160-    hex: (_, body) => strings.maybeParseInt(body, 0, 16),
/src/lib/index.js:161:    json: (_, body) => JSON.parse(strings.unescape(body)),
/src/lib/index.js-162-    list: (_, body) => body.split(/[\n\r\t ]+/g).map(strings.unescape),
##############################################
/src/lib/index.umd.js:1:!function(e,i){"object"==typeof exports&&"undefined"!=typeof module?i(exports,require("@thi.ng/checks"),require("@thi.ng/errors"),require("@thi.ng/transducers-binary"),require("@thi.ng/associative"),require("@thi.ng/dot"),require("@thi.ng/strings"),require("@thi.ng/api"),require("@thi.ng/prefixes"),require("fs"),require("path"),require("child_process")):"function"==typeof define&&define.amd?define(["exports","@thi.ng/checks","@thi.ng/errors","@thi.ng/transducers-binary","@thi.ng/associative","@thi.ng/dot","@thi.ng/strings","@thi.ng/api","@thi.ng/prefixes","fs","path","child_process"],i):i(((e="undefined"!=typeof globalThis?globalThis:e||self).thi=e.thi||{},e.thi.ng=e.thi.ng||{},e.thi.ng.egf={}),e.thi.ng.checks,e.thi.ng.errors,e.thi.ng.transducersBinary,e.thi.ng.associative,e.thi.ng.dot,e.thi.ng.strings,e.thi.ng.api,e.thi.ng.prefixes,e.fs,e.path,e.child_process)}(this,(function(e,i,t,s,n,r,o,a,l,f,g,c){"use strict";const u=i.isNode(),d=()=>t.unsupported("only available in NodeJS"),p=e=>i.isPlainObject(e)&&"$id"in e,h=e=>i.isPlainObject(e)&&"$ref"in e,b=e=>i.implementsFunction(e,"toEGF"),x=/^([a-z0-9-_$]*):([a-z0-9-_$.+]+)$/i,$=(e,i)=>{if("<"===i[0]&&">"===i[i.length-1])return i.substring(1,i.length-1);if(-1!==i.indexOf(":")){const s=x.exec(i);if(s){const n=e[s[1]];return n?n+s[2]:t.illegalArgs(`unknown prefix: ${i}`)}}return i},O=e=>{const i=new n.TrieMap;return Object.entries(e).forEach((([e,t])=>i.set(t,e))),e=>{const t=i.knownPrefix(e);return t?i.get(t)+":"+e.substr(t.length):void 0}},y=(e,t,s=j)=>{if(b(e))return e.toEGF();const n=[t(e.$id)||e.$id],r=(e,i,r)=>n.push(`\t${i} `+(p(r)?`-> ${t(r.$id)||r.$id}`:h(r)?`-> ${t(r.$ref)||r.$ref}`:b(r)?r.toEGF():s(e,r)));for(let s in e){if("$id"===s)continue;const n=t(s)||s,o=e[s];if(i.isArray(o))for(let e of o)r(s,n,e);else r(s,n,o)}return n.join("\n")},j=(e,t)=>i.isString(t)?t.indexOf("\n")>=0?`>>>${t}<<<`:t:i.isNumber(t)?`#num ${t}`:i.isDate(t)?`#date ${t.toISOString()}`:i.isTypedArray(t)?`#base64 ${s.base64Encode(new Uint8Array(t.buffer,t.byteOffset,t.byteLength))}`:i.isArray(t)||i.isPlainObject(t)?`#json ${JSON.stringify(t)}`:String(t),m={base64:u?(e,i)=>Buffer.from(i,"base64"):(e,i)=>new Uint8Array([...s.base64Decode(i)]),date:(e,i)=>new Date(i),file:(e,i,t)=>u&&t.opts.includes?(i=g.resolve(t.opts.root,o.unescape(i)),t.logger.debug("loading value from:",i),f.readFileSync(i).toString()):(t.logger.debug("skipping file value:",i),i),gpg:u?(e,i,t)=>(t.opts.decrypt?c.execSync(`echo "${i}" | gpg --decrypt`).toString():i).trim():d,hex:(e,i)=>o.maybeParseInt(i,0,16),json:(e,i)=>JSON.parse(o.unescape(i)),list:(e,i)=>i.split(/[\n\r\t ]+/g).map(o.unescape),num:(e,i)=>o.maybeParseFloat(i,0)},S="@include ",v="@prefix ",E=(e,i)=>{const s=e.split(/\r?\n/),n=i.nodes,r=i.opts.prefixes;for(let e=0,a=s.length;e<a;){let l=s[e++];if(!l.length||";"===l[0])continue;if("@"===l[0]){if(l.startsWith(S)){F(l,i);continue}if(l.startsWith(v)){r&&N(l,i);continue}}l=o.unescape(l),r&&(l=$(i.prefixes,l));const f=n[l]||(n[l]={$id:l});for(;e<a;){let n=s[e];if("\t"===n[0]||n.startsWith("    "))e=k(f,i,n,s,e);else{if(!n.length){e++;break}";"===n[0]?e++:t.illegalState(`expected property or comment @ line: ${e}`)}}}return i.opts.resolve&&i.opts.prune&&G(i),i},F=(e,i)=>{const t=o.unescape(e.substr(S.length));u&&i.opts.includes?T(t,Object.assign(Object.assign({},i),{cwd:g.dirname(i.file),prefixes:Object.assign({},i.prefixes),opts:Object.assign(Object.assign({},i.opts),{prune:!1})})):i.logger.debug("skipping include:",t)},q=/^([a-z0-9-_$]*)$/i,N=(e,i)=>{const s=e.indexOf(": ",v.length);if(s>0){const t=o.unescape(e.substring(v.length,s));if(q.test(t)){const n=o.unescape(e.substr(s+2).trim());if(n.length)return i.logger.debug(`declare prefix: ${t} = ${n}`),void(i.prefixes[t]=n)}}t.illegalState(`invalid prefix decl: ${e}`)},k=(e,i,s,n,r)=>{const a="\t"===s[0]?1:4;if(";"===s[a])return++r;let l,f,g=s.indexOf(" ",a),c=o.unescape(s.substring(a,g));if(i.opts.prefixes&&(c=$(i.prefixes,c)),g++,"-"===s[g]&&">"===s[g+1])return w(i.index,e,c,_(o.unescape(s.substr(g+2).trim()),i)),++r;if("#"===s[g]){const e=g+1;g=s.indexOf(" ",e),l=o.unescape(s.substring(e,g)),g++}if(">"===s[g]&&">"===s[g+1]&&">"===s[g+2])if(f=s.substr(g+3),g=f.indexOf("<<<"),g<0){const e=n.length;let i=!1;for(;++r<e;){if(g=(s=n[r]).indexOf("<<<"),g>=0){f+="\n"+s.substr(0,g),i=!0,r++;break}f+="\n"+s}!i&&t.illegalState("unterminated value, EOF reached")}else f=f.substr(0,g),r++;else f=s.substr(g),r++;return f=f.trim(),w(i.index,e,c,l?((e,i,s)=>{const n=s.tags[e]||s.defaultTag;return n?n(e,i,s):t.unsupported(`missing parser for tag: ${e}`)})(l,f,i):o.unescape(f)),r},w=(e,i,t,s)=>{const n=i[t],r=i.$id+"~"+t;void 0!==n?++e[r]>2?n.push(s):i[t]=[n,s]:(i[t]=s,e[r]=1)},_=(e,i)=>(i.opts.prefixes&&(e=$(i.prefixes,e)),i.opts.resolve?i.nodes[e]||(i.nodes[e]={$id:e}):{$ref:e,deref:()=>i.nodes[e],equiv(e){return null!=e&&e.$ref===this.$ref}}),G=({nodes:e,logger:i})=>{for(let t in e){const s=Object.keys(e[t]);1===s.length&&"$id"===s[0]&&(i.debug("pruning node:",t),delete e[t])}},P=(e={})=>{const i=Object.assign({decrypt:!1,includes:!0,prefixes:!1,prune:!1,resolve:!1},e.opts);return{cwd:e.cwd||".",file:e.file||"",files:e.files||[],nodes:e.nodes||{},index:e.index||{},tags:Object.assign(Object.assign({},m),e.tags),defaultTag:e.defaultTag,prefixes:e.prefixes?Object.assign({},e.prefixes):Object.assign(Object.assign({},l),{void:l.VOID}),logger:e.logger||a.NULL_LOGGER,opts:i}},T=(e,i)=>{const t=P(i);return t.file=e=g.resolve(t.cwd,e),t.files.includes(e)?(t.logger.warn("file already processed, skipping:",e),t):(t.files.push(e),t.logger.debug("loading file:",e),E(f.readFileSync(e).toString(),t))};e.$parseFile=T,e.BUILTINS=m,e.IS_NODE=u,e.NODE_ONLY=d,e.defPrefixer=O,e.defVocab=e=>(i="")=>e+i,e.isNode=p,e.isRef=h,e.isToEGF=b,e.parse=E,e.parseFile=(e,i)=>{const t=T(e,i);return{nodes:t.nodes,prefixes:t.prefixes}},e.parseString=(e,i)=>{const t=E(e,P(i));return{nodes:t.nodes,prefixes:t.prefixes}},e.qualifiedID=$,e.toDot=(e,t)=>{const s={},n=[],a=t.filter||(()=>!0),l=(e,i,t)=>{if(h(t))n.push({src:e,dest:t.$ref,label:i});else if(t.$id)n.push({src:e,dest:t.$id,label:i});else{const r=`lit-${o.slugify(String(t))}`;s[r]={label:String(t).replace(/\n/g,"\\n")},n.push({src:e,dest:r,label:i})}};return Object.entries(e).forEach((([e,t])=>{s[e]={label:t.name||t.$id},Object.entries(t).forEach((([s,n])=>{a(s,t)&&(i.isArray(n)?n.forEach((i=>l(e,s,i))):l(e,s,n))}))})),r.serializeGraph({attribs:t.attribs,nodes:s,edges:n})},e.toEGF=(e,i={},t)=>{const s=O(i),n=[];for(let e in i)n.push(`@prefix ${e}: ${i[e]}`);n.push("");for(let i of e)n.push(y(i,s,t),"");return n.join("\n")},e.toEGFNode=y,e.toEGFProp=j,Object.defineProperty(e,"__esModule",{value:!0})}));

/src/README.md-14-
/src/README.md:15:* All code evaluated inside a Realm runs in strict mode.
/src/README.md:16:* Direct eval is not supported.
/src/README.md:17:* `let`, global function declarations and any other feature that relies on new bindings in global contour are not preserved between difference invocations of eval, instead we create a new contour everytime.
/src/README.md-18-
##############################################
/src/dist/realms-shim.umd.min.js.map:1:{"version":3,"file":"realms-shim.umd.min.js","sources":["../src/utilities.js","../src/realmFacade.js","../src/stdlib.js","../src/repair/accessors.js","../src/repair/functions.js","../src/unsafeRec.js","../src/optimizer.js","../src/scopeHandler.js","../src/sourceParser.js","../src/evaluators.js","../src/realm.js","../src/commons.js"],"sourcesContent":["// we'd like to abandon, but we can't, so just scream and break a lot of\n// stuff. However, since we aren't really aborting the process, be careful to\n// not throw an Error object which could be captured by child-Realm code and\n// used to access the (too-powerful) primal-realm Error object.\n\nexport function throwTantrum(s, err = undefined) {\n  const msg = `please report internal shim error: ${s}`;\n\n  // we want to log these 'should never happen' things.\n  // eslint-disable-next-line no-console\n  console.error(msg);\n  if (err) {\n    // eslint-disable-next-line no-console\n    console.error(`${err}`);\n    // eslint-disable-next-line no-console\n    console.error(`${err.stack}`);\n  }\n\n  // eslint-disable-next-line no-debugger\n  debugger;\n  throw msg;\n}\n\nexport function assert(condition, message) {\n  if (!condition) {\n    throwTantrum(message);\n  }\n}\n\n// Remove code modifications.\nexport function cleanupSource(src) {\n  /* START_TESTS_ONLY */\n\n  // Restore eval which is modified by esm module.\n  src = src.replace(/\\(0,[^)]+\\)/g, '(0, eval)');\n\n  // Remove code coverage which is injected by nyc module.\n  src = src.replace(/cov_[^+]+\\+\\+[;,]/g, '');\n\n  /* END_TESTS_ONLY */\n  return src;\n}\n","import { cleanupSource } from './utilities';\n\n// buildChildRealm is immediately turned into a string, and this function is\n// never referenced again, because it closes over the wrong intrinsics\n\nexport function buildChildRealm(unsafeRec, BaseRealm) {\n  const {\n    initRootRealm,\n    initCompartment,\n    getRealmGlobal,\n    realmEvaluate\n  } = BaseRealm;\n\n  // This Object and Reflect are brand new, from a new unsafeRec, so no user\n  // code has been run or had a chance to manipulate them. We extract these\n  // properties for brevity, not for security. Don't ever run this function\n  // *after* user code has had a chance to pollute its environment, or it\n  // could be used to gain access to BaseRealm and primal-realm Error\n  // objects.\n  const { create, defineProperties } = Object;\n\n  const errorConstructors = new Map([\n    ['EvalError', EvalError],\n    ['RangeError', RangeError],\n    ['ReferenceError', ReferenceError],\n    ['SyntaxError', SyntaxError],\n    ['TypeError', TypeError],\n    ['URIError', URIError]\n  ]);\n\n  // Like Realm.apply except that it catches anything thrown and rethrows it\n  // as an Error from this realm\n  function callAndWrapError(target, ...args) {\n    try {\n      return target(...args);\n    } catch (err) {\n      if (Object(err) !== err) {\n        // err is a primitive value, which is safe to rethrow\n        throw err;\n      }\n      let eName, eMessage, eStack;\n      try {\n        // The child environment might seek to use 'err' to reach the\n        // parent's intrinsics and corrupt them. `${err.name}` will cause\n        // string coercion of 'err.name'. If err.name is an object (probably\n        // a String of the parent Realm), the coercion uses\n        // err.name.toString(), which is under the control of the parent. If\n        // err.name were a primitive (e.g. a number), it would use\n        // Number.toString(err.name), using the child's version of Number\n        // (which the child could modify to capture its argument for later\n        // use), however primitives don't have properties like .prototype so\n        // they aren't useful for an attack.\n        eName = `${err.name}`;\n        eMessage = `${err.message}`;\n        eStack = `${err.stack || eMessage}`;\n        // eName/eMessage/eStack are now child-realm primitive strings, and\n        // safe to expose\n      } catch (ignored) {\n        // if err.name.toString() throws, keep the (parent realm) Error away\n        // from the child\n        throw new Error('unknown error');\n      }\n      const ErrorConstructor = errorConstructors.get(eName) || Error;\n      try {\n        throw new ErrorConstructor(eMessage);\n      } catch (err2) {\n        err2.stack = eStack; // replace with the captured inner stack\n        throw err2;\n      }\n    }\n  }\n\n  class Realm {\n    constructor() {\n      // The Realm constructor is not intended to be used with the new operator\n      // or to be subclassed. It may be used as the value of an extends clause\n      // of a class definition but a super call to the Realm constructor will\n      // cause an exception.\n\n      // When Realm is called as a function, an exception is also raised because\n      // a class constructor cannot be invoked without 'new'.\n      throw new TypeError('Realm is not a constructor');\n    }\n\n    static makeRootRealm(options = {}) {\n      // This is the exposed interface.\n\n      // Bypass the constructor.\n      const r = create(Realm.prototype);\n      callAndWrapError(initRootRealm, unsafeRec, r, options);\n      return r;\n    }\n\n    static makeCompartment(options = {}) {\n      // Bypass the constructor.\n      const r = create(Realm.prototype);\n      callAndWrapError(initCompartment, unsafeRec, r, options);\n      return r;\n    }\n\n    // we omit the constructor because it is empty. All the personalization\n    // takes place in one of the two static methods,\n    // makeRootRealm/makeCompartment\n\n    get global() {\n      // this is safe against being called with strange 'this' because\n      // baseGetGlobal immediately does a trademark check (it fails unless\n      // this 'this' is present in a weakmap that is only populated with\n      // legitimate Realm instances)\n      return callAndWrapError(getRealmGlobal, this);\n    }\n\n    evaluate(x, endowments, options = {}) {\n      // safe against strange 'this', as above\n      return callAndWrapError(realmEvaluate, this, x, endowments, options);\n    }\n  }\n\n  defineProperties(Realm, {\n    toString: {\n      value: () => 'function Realm() { [shim code] }',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  defineProperties(Realm.prototype, {\n    toString: {\n      value: () => '[object Realm]',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  return Realm;\n}\n\n// The parentheses means we don't bind the 'buildChildRealm' name inside the\n// child's namespace. this would accept an anonymous function declaration.\n// function expression (not a declaration) so it has a completion value.\nconst buildChildRealmString = cleanupSource(\n  `'use strict'; (${buildChildRealm})`\n);\n\nexport function createRealmFacade(unsafeRec, BaseRealm) {\n  const { unsafeEval } = unsafeRec;\n\n  // The BaseRealm is the Realm class created by\n  // the shim. It's only valid for the context where\n  // it was parsed.\n\n  // The Realm facade is a lightweight class built in the\n  // context a different context, that provide a fully\n  // functional Realm class using the intrisics\n  // of that context.\n\n  // This process is simplified because all methods\n  // and properties on a realm instance already return\n  // values using the intrinsics of the realm's context.\n\n  // Invoke the BaseRealm constructor with Realm as the prototype.\n  return unsafeEval(buildChildRealmString)(unsafeRec, BaseRealm);\n}\n","import { getOwnPropertyDescriptor } from './commons';\nimport { assert } from './utilities';\n\n// These value properties of the global object are non-writable,\n// non-configurable data properties.\nconst frozenGlobalPropertyNames = [\n  // *** 18.1 Value Properties of the Global Object\n\n  'Infinity',\n  'NaN',\n  'undefined'\n];\n\n// All the following stdlib items have the same name on both our intrinsics\n// object and on the global object. Unlike Infinity/NaN/undefined, these\n// should all be writable and configurable. This is divided into two\n// sets. The stable ones are those the shim can freeze early because\n// we don't expect anyone will want to mutate them. The unstable ones\n// are the ones that we correctly initialize to writable and\n// configurable so that they can still be replaced or removed.\nconst stableGlobalPropertyNames = [\n  // *** 18.2 Function Properties of the Global Object\n\n  // 'eval', // comes from safeEval instead\n  'isFinite',\n  'isNaN',\n  'parseFloat',\n  'parseInt',\n\n  'decodeURI',\n  'decodeURIComponent',\n  'encodeURI',\n  'encodeURIComponent',\n\n  // *** 18.3 Constructor Properties of the Global Object\n\n  'Array',\n  'ArrayBuffer',\n  'Boolean',\n  'DataView',\n  // 'Date',  // Unstable\n  // 'Error',  // Unstable\n  'EvalError',\n  'Float32Array',\n  'Float64Array',\n  // 'Function',  // comes from safeFunction instead\n  'Int8Array',\n  'Int16Array',\n  'Int32Array',\n  'Map',\n  'Number',\n  'Object',\n  // 'Promise',  // Unstable\n  // 'Proxy',  // Unstable\n  'RangeError',\n  'ReferenceError',\n  // 'RegExp',  // Unstable\n  'Set',\n  // 'SharedArrayBuffer'  // removed on Jan 5, 2018\n  'String',\n  'Symbol',\n  'SyntaxError',\n  'TypeError',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Uint16Array',\n  'Uint32Array',\n  'URIError',\n  'WeakMap',\n  'WeakSet',\n\n  // *** 18.4 Other Properties of the Global Object\n\n  // 'Atomics', // removed on Jan 5, 2018\n  'JSON',\n  'Math',\n  'Reflect',\n\n  // *** Annex B\n\n  'escape',\n  'unescape'\n\n  // *** ECMA-402\n\n  // 'Intl'  // Unstable\n\n  // *** ESNext\n\n  // 'Realm' // Comes from createRealmGlobalObject()\n];\n\nconst unstableGlobalPropertyNames = [\n  'Date',\n  'Error',\n  'Promise',\n  'Proxy',\n  'RegExp',\n  'Intl'\n];\n\nexport function getSharedGlobalDescs(unsafeGlobal) {\n  const descriptors = {};\n\n  function describe(names, writable, enumerable, configurable) {\n    for (const name of names) {\n      const desc = getOwnPropertyDescriptor(unsafeGlobal, name);\n      if (desc) {\n        // Abort if an accessor is found on the unsafe global object\n        // instead of a data property. We should never get into this\n        // non standard situation.\n        assert(\n          'value' in desc,\n          `unexpected accessor on global property: ${name}`\n        );\n\n        descriptors[name] = {\n          value: desc.value,\n          writable,\n          enumerable,\n          configurable\n        };\n      }\n    }\n  }\n\n  describe(frozenGlobalPropertyNames, false, false, false);\n  // The following is correct but expensive.\n  // describe(stableGlobalPropertyNames, true, false, true);\n  // Instead, for now, we let these get optimized.\n  //\n  // TODO: We should provide an option to turn this optimization off,\n  // by feeding \"true, false, true\" here instead.\n  describe(stableGlobalPropertyNames, false, false, false);\n  // These we keep replaceable and removable, because we expect\n  // others, e.g., SES, may want to do so.\n  describe(unstableGlobalPropertyNames, true, false, true);\n\n  return descriptors;\n}\n","// Adapted from SES/Caja - Copyright (C) 2011 Google Inc.\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js\n\n/**\n * Replace the legacy accessors of Object to comply with strict mode\n * and ES2016 semantics, we do this by redefining them while in 'use strict'.\n *\n * todo: list the issues resolved\n *\n * This function can be used in two ways: (1) invoked directly to fix the primal\n * realm's Object.prototype, and (2) converted to a string to be executed\n * inside each new RootRealm to fix their Object.prototypes. Evaluation requires\n * the function to have no dependencies, so don't import anything from\n * the outside.\n */\n\n// todo: this file should be moved out to a separate repo and npm module.\nexport function repairAccessors() {\n  const {\n    defineProperty,\n    defineProperties,\n    getOwnPropertyDescriptor,\n    getPrototypeOf,\n    prototype: objectPrototype\n  } = Object;\n\n  // On some platforms, the implementation of these functions act as\n  // if they are in sloppy mode: if they're invoked badly, they will\n  // expose the global object, so we need to repair these for\n  // security. Thus it is our responsibility to fix this, and we need\n  // to include repairAccessors. E.g. Chrome in 2016.\n\n  try {\n    // Verify that the method is not callable.\n    // eslint-disable-next-line no-restricted-properties, no-underscore-dangle\n    (0, objectPrototype.__lookupGetter__)('x');\n  } catch (ignore) {\n    // Throws, no need to patch.\n    return;\n  }\n\n  function toObject(obj) {\n    if (obj === undefined || obj === null) {\n      throw new TypeError(`can't convert undefined or null to object`);\n    }\n    return Object(obj);\n  }\n\n  function asPropertyName(obj) {\n    if (typeof obj === 'symbol') {\n      return obj;\n    }\n    return `${obj}`;\n  }\n\n  function aFunction(obj, accessor) {\n    if (typeof obj !== 'function') {\n      throw TypeError(`invalid ${accessor} usage`);\n    }\n    return obj;\n  }\n\n  defineProperties(objectPrototype, {\n    __defineGetter__: {\n      value: function __defineGetter__(prop, func) {\n        const O = toObject(this);\n        defineProperty(O, prop, {\n          get: aFunction(func, 'getter'),\n          enumerable: true,\n          configurable: true\n        });\n      }\n    },\n    __defineSetter__: {\n      value: function __defineSetter__(prop, func) {\n        const O = toObject(this);\n        defineProperty(O, prop, {\n          set: aFunction(func, 'setter'),\n          enumerable: true,\n          configurable: true\n        });\n      }\n    },\n    __lookupGetter__: {\n      value: function __lookupGetter__(prop) {\n        let O = toObject(this);\n        prop = asPropertyName(prop);\n        let desc;\n        while (O && !(desc = getOwnPropertyDescriptor(O, prop))) {\n          O = getPrototypeOf(O);\n        }\n        return desc && desc.get;\n      }\n    },\n    __lookupSetter__: {\n      value: function __lookupSetter__(prop) {\n        let O = toObject(this);\n        prop = asPropertyName(prop);\n        let desc;\n        while (O && !(desc = getOwnPropertyDescriptor(O, prop))) {\n          O = getPrototypeOf(O);\n        }\n        return desc && desc.set;\n      }\n    }\n  });\n}\n","// Adapted from SES/Caja\n// Copyright (C) 2011 Google Inc.\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js\n\n/**\n * This block replaces the original Function constructor, and the original\n * %GeneratorFunction% %AsyncFunction% and %AsyncGeneratorFunction%, with\n * safe replacements that throw if invoked.\n *\n * These are all reachable via syntax, so it isn't sufficient to just\n * replace global properties with safe versions. Our main goal is to prevent\n * access to the Function constructor through these starting points.\n\n * After this block is done, the originals must no longer be reachable, unless\n * a copy has been made, and funtions can only be created by syntax (using eval)\n * or by invoking a previously saved reference to the originals.\n */\n\n// todo: this file should be moved out to a separate repo and npm module.\nconst globalEval = eval;\nexport function repairFunctions() {\n  const { defineProperties, getPrototypeOf, setPrototypeOf } = Object;\n\n  /**\n   * The process to repair constructors:\n   * 1. Create an instance of the function by evaluating syntax\n   * 2. Obtain the prototype from the instance\n   * 3. Create a substitute tamed constructor\n   * 4. Replace the original constructor with the tamed constructor\n   * 5. Replace tamed constructor prototype property with the original one\n   * 6. Replace its [[Prototype]] slot with the tamed constructor of Function\n   */\n  function repairFunction(name, declaration) {\n    let FunctionInstance;\n    try {\n      // eslint-disable-next-line no-new-func\n      FunctionInstance = globalEval(declaration);\n    } catch (e) {\n      if (e instanceof SyntaxError) {\n        // Prevent failure on platforms where async and/or generators\n        // are not supported.\n        return;\n      }\n      // Re-throw\n      throw e;\n    }\n    const FunctionPrototype = getPrototypeOf(FunctionInstance);\n\n    // Prevents the evaluation of source when calling constructor on the\n    // prototype of functions.\n    const TamedFunction = function() {\n      throw new TypeError('Not available');\n    };\n    defineProperties(TamedFunction, { name: { value: name } });\n\n    // (new Error()).constructors does not inherit from Function, because Error\n    // was defined before ES6 classes. So we don't need to repair it too.\n\n    // (Error()).constructor inherit from Function, which gets a tamed\n    // constructor here.\n\n    // todo: in an ES6 class that does not inherit from anything, what does its\n    // constructor inherit from? We worry that it inherits from Function, in\n    // which case instances could give access to unsafeFunction. markm says\n    // we're fine: the constructor inherits from Object.prototype\n\n    // This line replaces the original constructor in the prototype chain\n    // with the tamed one. No copy of the original is peserved.\n    defineProperties(FunctionPrototype, {\n      constructor: { value: TamedFunction }\n    });\n\n    // This line sets the tamed constructor's prototype data property to\n    // the original one.\n    defineProperties(TamedFunction, {\n      prototype: { value: FunctionPrototype }\n    });\n\n    if (TamedFunction !== Function.prototype.constructor) {\n      // Ensures that all functions meet \"instanceof Function\" in a realm.\n      setPrototypeOf(TamedFunction, Function.prototype.constructor);\n    }\n  }\n\n  // Here, the order of operation is important: Function needs to be repaired\n  // first since the other repaired constructors need to inherit from the tamed\n  // Function function constructor.\n\n  // note: this really wants to be part of the standard, because new\n  // constructors may be added in the future, reachable from syntax, and this\n  // list must be updated to match.\n\n  // \"plain arrow functions\" inherit from Function.prototype\n\n  repairFunction('Function', '(function(){})');\n  repairFunction('GeneratorFunction', '(function*(){})');\n  repairFunction('AsyncFunction', '(async function(){})');\n  repairFunction('AsyncGeneratorFunction', '(async function*(){})');\n}\n","// this module must never be importable outside the Realm shim itself\nimport { getSharedGlobalDescs } from './stdlib';\nimport { repairAccessors } from './repair/accessors';\nimport { repairFunctions } from './repair/functions';\nimport { cleanupSource } from './utilities';\nimport { freeze } from './commons';\n\n// A \"context\" is a fresh unsafe Realm as given to us by existing platforms.\n// We need this to implement the shim. However, when Realms land for real,\n// this feature will be provided by the underlying engine instead.\n\n// note: in a node module, the top-level 'this' is not the global object\n// (it's *something* but we aren't sure what), however an indirect eval of\n// 'this' will be the correct global object.\n\nconst unsafeGlobalSrc = \"'use strict'; this\";\nconst unsafeGlobalEvalSrc = `(0, eval)(\"'use strict'; this\")`;\n\n// This method is only exported for testing purposes.\nexport function createNewUnsafeGlobalForNode() {\n  // Note that webpack and others will shim 'vm' including the method\n  // 'runInNewContext', so the presence of vm is not a useful check\n\n  // TODO: Find a better test that works with bundlers\n  // eslint-disable-next-line no-new-func\n  const isNode = new Function(\n    'try {return this===global}catch(e){return false}'\n  )();\n\n  if (!isNode) {\n    return undefined;\n  }\n\n  // eslint-disable-next-line global-require\n  const vm = require('vm');\n\n  // Use unsafeGlobalEvalSrc to ensure we get the right 'this'.\n  const unsafeGlobal = vm.runInNewContext(unsafeGlobalEvalSrc);\n\n  return unsafeGlobal;\n}\n\n// This method is only exported for testing purposes.\nexport function createNewUnsafeGlobalForBrowser() {\n  if (typeof document === 'undefined') {\n    return undefined;\n  }\n  const iframe = document.createElement('iframe');\n  iframe.style.display = 'none';\n\n  document.body.appendChild(iframe);\n  const unsafeGlobal = iframe.contentWindow.eval(unsafeGlobalSrc);\n\n  // We keep the iframe attached to the DOM because removing it\n  // causes its global object to lose intrinsics, its eval()\n  // function to evaluate code, etc.\n\n  // TODO: can we remove and garbage-collect the iframes?\n\n  return unsafeGlobal;\n}\n\nconst getNewUnsafeGlobal = () => {\n  const newUnsafeGlobalForBrowser = createNewUnsafeGlobalForBrowser();\n  const newUnsafeGlobalForNode = createNewUnsafeGlobalForNode();\n  if (\n    (!newUnsafeGlobalForBrowser && !newUnsafeGlobalForNode) ||\n    (newUnsafeGlobalForBrowser && newUnsafeGlobalForNode)\n  ) {\n    throw new Error('unexpected platform, unable to create Realm');\n  }\n  return newUnsafeGlobalForBrowser || newUnsafeGlobalForNode;\n};\n\n// The unsafeRec is shim-specific. It acts as the mechanism to obtain a fresh\n// set of intrinsics together with their associated eval and Function\n// evaluators. These must be used as a matched set, since the evaluators are\n// tied to a set of intrinsics, aka the \"undeniables\". If it were possible to\n// mix-and-match them from different contexts, that would enable some\n// attacks.\nfunction createUnsafeRec(unsafeGlobal, allShims = []) {\n  const sharedGlobalDescs = getSharedGlobalDescs(unsafeGlobal);\n\n  return freeze({\n    unsafeGlobal,\n    sharedGlobalDescs,\n    unsafeEval: unsafeGlobal.eval,\n    unsafeFunction: unsafeGlobal.Function,\n    allShims\n  });\n}\n\nconst repairAccessorsShim = cleanupSource(\n  `\"use strict\"; (${repairAccessors})();`\n);\nconst repairFunctionsShim = cleanupSource(\n  `\"use strict\"; const globalEval = eval; (${repairFunctions})();`\n);\n\n// Create a new unsafeRec from a brand new context, with new intrinsics and a\n// new global object\nexport function createNewUnsafeRec(allShims) {\n  const unsafeGlobal = getNewUnsafeGlobal();\n  unsafeGlobal.eval(repairAccessorsShim);\n  unsafeGlobal.eval(repairFunctionsShim);\n  return createUnsafeRec(unsafeGlobal, allShims);\n}\n\n// Create a new unsafeRec from the current context, where the Realm shim is\n// being parsed and executed, aka the \"Primal Realm\"\nexport function createCurrentUnsafeRec() {\n  const unsafeGlobal = (0, eval)(unsafeGlobalSrc);\n  repairAccessors();\n  repairFunctions();\n  return createUnsafeRec(unsafeGlobal);\n}\n","import {\n  arrayFilter,\n  getOwnPropertyDescriptors,\n  getOwnPropertyNames,\n  objectHasOwnProperty,\n  regexpTest\n} from './commons';\n\n// todo: think about how this interacts with endowments, check for conflicts\n// between the names being optimized and the ones added by endowments\n\n/**\n * Simplified validation of indentifier names: may only contain alphanumeric\n * characters (or \"$\" or \"_\"), and may not start with a digit. This is safe\n * and does not reduces the compatibility of the shim. The motivation for\n * this limitation was to decrease the complexity of the implementation,\n * and to maintain a resonable level of performance.\n * Note: \\w is equivalent [a-zA-Z_0-9]\n * See 11.6.1 Identifier Names\n */\nconst identifierPattern = /^[a-zA-Z_$][\\w$]*$/;\n\n/**\n * In JavaScript you cannot use these reserved words as variables.\n * See 11.6.1 Identifier Names\n */\nconst keywords = new Set([\n  // 11.6.2.1 Keywords\n  'await',\n  'break',\n  'case',\n  'catch',\n  'class',\n  'const',\n  'continue',\n  'debugger',\n  'default',\n  'delete',\n  'do',\n  'else',\n  'export',\n  'extends',\n  'finally',\n  'for',\n  'function',\n  'if',\n  'import',\n  'in',\n  'instanceof',\n  'new',\n  'return',\n  'super',\n  'switch',\n  'this',\n  'throw',\n  'try',\n  'typeof',\n  'var',\n  'void',\n  'while',\n  'with',\n  'yield',\n\n  // Also reserved when parsing strict mode code\n  'let',\n  'static',\n\n  // 11.6.2.2 Future Reserved Words\n  'enum',\n\n  // Also reserved when parsing strict mode code\n  'implements',\n  'package',\n  'protected',\n  'interface',\n  'private',\n  'public',\n\n  // Reserved but not mentioned in specs\n  'await',\n\n  'null',\n  'true',\n  'false',\n\n  'this',\n  'arguments'\n]);\n\n/**\n * getOptimizableGlobals()\n * What variable names might it bring into scope? These include all\n * property names which can be variable names, including the names\n * of inherited properties. It excludes symbols and names which are\n * keywords. We drop symbols safely. Currently, this shim refuses\n * service if any of the names are keywords or keyword-like. This is\n * safe and only prevent performance optimization.\n */\nexport function getOptimizableGlobals(safeGlobal) {\n  const descs = getOwnPropertyDescriptors(safeGlobal);\n\n  // getOwnPropertyNames does ignore Symbols so we don't need this extra check:\n  // typeof name === 'string' &&\n  const constants = arrayFilter(getOwnPropertyNames(descs), name => {\n    // Ensure we have a valid identifier. We use regexpTest rather than\n    // /../.test() to guard against the case where RegExp has been poisoned.\n    if (\n      name === 'eval' ||\n      keywords.has(name) ||\n      !regexpTest(identifierPattern, name)\n    ) {\n      return false;\n    }\n\n    const desc = descs[name];\n    return (\n      //\n      // The getters will not have .writable, don't let the falsyness of\n      // 'undefined' trick us: test with === false, not ! . However descriptors\n      // inherit from the (potentially poisoned) global object, so we might see\n      // extra properties which weren't really there. Accessor properties have\n      // 'get/set/enumerable/configurable', while data properties have\n      // 'value/writable/enumerable/configurable'.\n      desc.configurable === false &&\n      desc.writable === false &&\n      //\n      // Checks for data properties because they're the only ones we can\n      // optimize (accessors are most likely non-constant). Descriptors can't\n      // can't have accessors and value properties at the same time, therefore\n      // this check is sufficient. Using explicit own property deal with the\n      // case where Object.prototype has been poisoned.\n      objectHasOwnProperty(desc, 'value')\n    );\n  });\n\n  return constants;\n}\n","import { freeze, objectHasOwnProperty } from './commons';\nimport { throwTantrum } from './utilities';\n\n/**\n * alwaysThrowHandler is a proxy handler which throws on any trap called.\n * It's made from a proxy with a get trap that throws. Its target is\n * an immutable (frozen) object and is safe to share.\n */\nconst alwaysThrowHandler = new Proxy(freeze({}), {\n  get(target, prop) {\n    throwTantrum(`unexpected scope handler trap called: ${prop}`);\n  }\n});\n\n/**\n * ScopeHandler manages a Proxy which serves as the global scope for the\n * safeEvaluator operation (the Proxy is the argument of a 'with' binding).\n * As described in createSafeEvaluator(), it has several functions:\n * - allow the very first (and only the very first) use of 'eval' to map to\n *   the real (unsafe) eval function, so it acts as a 'direct eval' and can\n *    access its lexical scope (which maps to the 'with' binding, which the\n *   ScopeHandler also controls).\n * - ensure that all subsequent uses of 'eval' map to the safeEvaluator,\n *   which lives as the 'eval' property of the safeGlobal.\n * - route all other property lookups at the safeGlobal.\n * - hide the unsafeGlobal which lives on the scope chain above the 'with'.\n * - ensure the Proxy invariants despite some global properties being frozen.\n */\nexport function createScopeHandler(unsafeRec, safeGlobal, sloppyGlobals) {\n  const { unsafeGlobal, unsafeEval } = unsafeRec;\n\n  // This flag allow us to determine if the eval() call is an done by the\n  // realm's code or if it is user-land invocation, so we can react differently.\n  let useUnsafeEvaluator = false;\n\n  return {\n    // The scope handler throws if any trap other than get/set/has are run\n    // (e.g. getOwnPropertyDescriptors, apply, getPrototypeOf).\n    // eslint-disable-next-line no-proto\n    __proto__: alwaysThrowHandler,\n\n    allowUnsafeEvaluatorOnce() {\n      useUnsafeEvaluator = true;\n    },\n\n    unsafeEvaluatorAllowed() {\n      return useUnsafeEvaluator;\n    },\n\n    get(target, prop) {\n      // Special treatment for eval. The very first lookup of 'eval' gets the\n      // unsafe (real direct) eval, so it will get the lexical scope that uses\n      // the 'with' context.\n      if (prop === 'eval') {\n        // test that it is true rather than merely truthy\n        if (useUnsafeEvaluator === true) {\n          // revoke before use\n          useUnsafeEvaluator = false;\n          return unsafeEval;\n        }\n        return target.eval;\n      }\n\n      // todo: shim integrity, capture Symbol.unscopables\n      if (prop === Symbol.unscopables) {\n        // Safe to return a primal realm Object here because the only code that\n        // can do a get() on a non-string is the internals of with() itself,\n        // and the only thing it does is to look for properties on it. User\n        // code cannot do a lookup on non-strings.\n        return undefined;\n      }\n\n      // Properties of the global.\n      if (prop in target) {\n        return target[prop];\n      }\n\n      // Prevent the lookup for other properties.\n      return undefined;\n    },\n\n    // eslint-disable-next-line class-methods-use-this\n    set(target, prop, value) {\n      // todo: allow modifications when target.hasOwnProperty(prop) and it\n      // is writable, assuming we've already rejected overlap (see\n      // createSafeEvaluatorFactory.factory). This TypeError gets replaced with\n      // target[prop] = value\n      if (objectHasOwnProperty(target, prop)) {\n        // todo: shim integrity: TypeError, String\n        throw new TypeError(`do not modify endowments like ${String(prop)}`);\n      }\n\n      safeGlobal[prop] = value;\n\n      // Return true after successful set.\n      return true;\n    },\n\n    // we need has() to return false for some names to prevent the lookup  from\n    // climbing the scope chain and eventually reaching the unsafeGlobal\n    // object, which is bad.\n\n    // note: unscopables! every string in Object[Symbol.unscopables]\n\n    // todo: we'd like to just have has() return true for everything, and then\n    // use get() to raise a ReferenceError for anything not on the safe global.\n    // But we want to be compatible with ReferenceError in the normal case and\n    // the lack of ReferenceError in the 'typeof' case. Must either reliably\n    // distinguish these two cases (the trap behavior might be different), or\n    // we rely on a mandatory source-to-source transform to change 'typeof abc'\n    // to XXX. We already need a mandatory parse to prevent the 'import',\n    // since it's a special form instead of merely being a global variable/\n\n    // note: if we make has() return true always, then we must implement a\n    // set() trap to avoid subverting the protection of strict mode (it would\n    // accept assignments to undefined globals, when it ought to throw\n    // ReferenceError for such assignments)\n\n    has(target, prop) {\n      // proxies stringify 'prop', so no TOCTTOU danger here\n\n      if (sloppyGlobals) {\n        // Everything is potentially available.\n        return true;\n      }\n\n      // unsafeGlobal: hide all properties of unsafeGlobal at the\n      // expense of 'typeof' being wrong for those properties. For\n      // example, in the browser, evaluating 'document = 3', will add\n      // a property to safeGlobal instead of throwing a\n      // ReferenceError.\n      if (prop === 'eval' || prop in target || prop in unsafeGlobal) {\n        return true;\n      }\n\n      return false;\n    }\n  };\n}\n","// https://www.ecma-international.org/ecma-262/9.0/index.html#sec-html-like-comments\n// explains that JavaScript parsers may or may not recognize html\n// comment tokens \"<\" immediately followed by \"!--\" and \"--\"\n// immediately followed by \">\" in non-module source text, and treat\n// them as a kind of line comment. Since otherwise both of these can\n// appear in normal JavaScript source code as a sequence of operators,\n// we have the terrifying possibility of the same source code parsing\n// one way on one correct JavaScript implementation, and another way\n// on another.\n//\n// This shim takes the conservative strategy of just rejecting source\n// text that contains these strings anywhere. Note that this very\n// source file is written strangely to avoid mentioning these\n// character strings explicitly.\n\n// We do not write the regexp in a straightforward way, so that an\n// apparennt html comment does not appear in this file. Thus, we avoid\n// rejection by the overly eager rejectDangerousSources.\nconst htmlCommentPattern = new RegExp(`(?:${'<'}!--|--${'>'})`);\n\nfunction rejectHtmlComments(s) {\n  const index = s.search(htmlCommentPattern);\n  if (index !== -1) {\n    const linenum = s.slice(0, index).split('\\n').length; // more or less\n    throw new SyntaxError(\n      `possible html comment syntax rejected around line ${linenum}`\n    );\n  }\n}\n\n// The proposed dynamic import expression is the only syntax currently\n// proposed, that can appear in non-module JavaScript code, that\n// enables direct access to the outside world that cannot be\n// surpressed or intercepted without parsing and rewriting. Instead,\n// this shim conservatively rejects any source text that seems to\n// contain such an expression. To do this safely without parsing, we\n// must also reject some valid programs, i.e., those containing\n// apparent import expressions in literal strings or comments.\n\n// The current conservative rule looks for the identifier \"import\"\n// followed by either an open paren or something that looks like the\n// beginning of a comment. We assume that we do not need to worry\n// about html comment syntax because that was already rejected by\n// rejectHtmlComments.\n\n// this \\s *must* match all kinds of syntax-defined whitespace. If e.g.\n// U+2028 (LINE SEPARATOR) or U+2029 (PARAGRAPH SEPARATOR) is treated as\n// whitespace by the parser, but not matched by /\\s/, then this would admit\n// an attack like: import\\u2028('power.js') . We're trying to distinguish\n// something like that from something like importnotreally('power.js') which\n// is perfectly safe.\n\nconst importPattern = /\\bimport\\s*(?:\\(|\\/[/*])/;\n\nfunction rejectImportExpressions(s) {\n  const index = s.search(importPattern);\n  if (index !== -1) {\n    const linenum = s.slice(0, index).split('\\n').length; // more or less\n    throw new SyntaxError(\n      `possible import expression rejected around line ${linenum}`\n    );\n  }\n}\n\n// The shim cannot correctly emulate a direct eval as explained at\n// https://github.com/Agoric/realms-shim/issues/12\n// Without rejecting apparent direct eval syntax, we would\n// accidentally evaluate these with an emulation of indirect eval. Tp\n// prevent future compatibility problems, in shifting from use of the\n// shim to genuine platform support for the proposal, we should\n// instead statically reject code that seems to contain a direct eval\n// expression.\n//\n// As with the dynamic import expression, to avoid a full parse, we do\n// this approximately with a regexp, that will also reject strings\n// that appear safely in comments or strings. Unlike dynamic import,\n// if we miss some, this only creates future compat problems, not\n// security problems. Thus, we are only trying to catch innocent\n// occurrences, not malicious one. In particular, `(eval)(...)` is\n// direct eval syntax that would not be caught by the following regexp.\n\nconst someDirectEvalPattern = /\\beval\\s*(?:\\(|\\/[/*])/;\n\nfunction rejectSomeDirectEvalExpressions(s) {\n  const index = s.search(someDirectEvalPattern);\n  if (index !== -1) {\n    const linenum = s.slice(0, index).split('\\n').length; // more or less\n    throw new SyntaxError(\n      `possible direct eval expression rejected around line ${linenum}`\n    );\n  }\n}\n\nexport function rejectDangerousSources(s) {\n  rejectHtmlComments(s);\n  rejectImportExpressions(s);\n  rejectSomeDirectEvalExpressions(s);\n}\n\n// Export a rewriter transform.\nexport const rejectDangerousSourcesTransform = {\n  rewrite(rs) {\n    rejectDangerousSources(rs.src);\n    return rs;\n  }\n};\n","// Portions adapted from V8 - Copyright 2016 the V8 project authors.\n// https://github.com/v8/v8/blob/master/src/builtins/builtins-function.cc\n\nimport {\n  apply,\n  arrayJoin,\n  arrayPop,\n  create,\n  defineProperties,\n  getOwnPropertyDescriptors,\n  getPrototypeOf,\n  regexpTest,\n  setPrototypeOf,\n  stringIncludes\n} from './commons';\nimport { getOptimizableGlobals } from './optimizer';\nimport { createScopeHandler } from './scopeHandler';\nimport { rejectDangerousSourcesTransform } from './sourceParser';\nimport { assert, throwTantrum } from './utilities';\n\nfunction buildOptimizer(constants) {\n  // No need to build an oprimizer when there are no constants.\n  if (constants.length === 0) return '';\n  // Use 'this' to avoid going through the scope proxy, which is unecessary\n  // since the optimizer only needs references to the safe global.\n  return `const {${arrayJoin(constants, ',')}} = this;`;\n}\n\nfunction createScopedEvaluatorFactory(unsafeRec, constants) {\n  const { unsafeFunction } = unsafeRec;\n\n  const optimizer = buildOptimizer(constants);\n\n  // Create a function in sloppy mode, so that we can use 'with'. It returns\n  // a function in strict mode that evaluates the provided code using direct\n  // eval, and thus in strict mode in the same scope. We must be very careful\n  // to not create new names in this scope\n\n  // 1: we use 'with' (around a Proxy) to catch all free variable names. The\n  // first 'arguments[0]' holds the Proxy which safely wraps the safeGlobal\n  // 2: 'optimizer' catches common variable names for speed\n  // 3: The inner strict function is effectively passed two parameters:\n  //    a) its arguments[0] is the source to be directly evaluated.\n  //    b) its 'this' is the this binding seen by the code being\n  //       directly evaluated.\n\n  // everything in the 'optimizer' string is looked up in the proxy\n  // (including an 'arguments[0]', which points at the Proxy). 'function' is\n  // a keyword, not a variable, so it is not looked up. then 'eval' is looked\n  // up in the proxy, that's the first time it is looked up after\n  // useUnsafeEvaluator is turned on, so the proxy returns the real the\n  // unsafeEval, which satisfies the IsDirectEvalTrap predicate, so it uses\n  // the direct eval and gets the lexical scope. The second 'arguments[0]' is\n  // looked up in the context of the inner function. The *contents* of\n  // arguments[0], because we're using direct eval, are looked up in the\n  // Proxy, by which point the useUnsafeEvaluator switch has been flipped\n  // back to 'false', so any instances of 'eval' in that string will get the\n  // safe evaluator.\n\n  return unsafeFunction(`\n    with (arguments[0]) {\n      ${optimizer}\n      return function() {\n        'use strict';\n        return eval(arguments[0]);\n      };\n    }\n  `);\n}\n\nexport function createSafeEvaluatorFactory(\n  unsafeRec,\n  safeGlobal,\n  transforms,\n  sloppyGlobals\n) {\n  const { unsafeFunction } = unsafeRec;\n\n  const constants = getOptimizableGlobals(safeGlobal);\n  const scopedEvaluatorFactory = createScopedEvaluatorFactory(\n    unsafeRec,\n    constants\n  );\n\n  function factory(endowments = {}, options = {}) {\n    const localTransforms = options.transforms || [];\n    const realmTransforms = transforms || [];\n\n    const mandatoryTransforms = [rejectDangerousSourcesTransform];\n    const allTransforms = [\n      ...localTransforms,\n      ...realmTransforms,\n      ...mandatoryTransforms\n    ];\n\n    // We use the the concise method syntax to create an eval without a\n    // [[Construct]] behavior (such that the invocation \"new eval()\" throws\n    // TypeError: eval is not a constructor\"), but which still accepts a\n    // 'this' binding.\n    const safeEval = {\n      eval(src) {\n        src = `${src}`;\n        // Rewrite the source, threading through rewriter state as necessary.\n        const rewriterState = allTransforms.reduce(\n          (rs, transform) => (transform.rewrite ? transform.rewrite(rs) : rs),\n          { src, endowments }\n        );\n        src = rewriterState.src;\n\n        const scopeTarget = create(\n          safeGlobal,\n          getOwnPropertyDescriptors(rewriterState.endowments)\n        );\n\n        const scopeHandler = createScopeHandler(\n          unsafeRec,\n          safeGlobal,\n          sloppyGlobals\n        );\n        const scopeProxy = new Proxy(scopeTarget, scopeHandler);\n        const scopedEvaluator = apply(scopedEvaluatorFactory, safeGlobal, [\n          scopeProxy\n        ]);\n\n        scopeHandler.allowUnsafeEvaluatorOnce();\n        let err;\n        try {\n          // Ensure that \"this\" resolves to the safe global.\n          return apply(scopedEvaluator, safeGlobal, [src]);\n        } catch (e) {\n          // stash the child-code error in hopes of debugging the internal failure\n          err = e;\n          throw e;\n        } finally {\n          // belt and suspenders: the proxy switches this off immediately after\n          // the first access, but if that's not the case we abort.\n          if (scopeHandler.unsafeEvaluatorAllowed()) {\n            throwTantrum('handler did not revoke useUnsafeEvaluator', err);\n          }\n        }\n      }\n    }.eval;\n\n    // safeEval's prototype is currently the primal realm's\n    // Function.prototype, which we must not let escape. To make 'eval\n    // instanceof Function' be true inside the realm, we need to point it at\n    // the RootRealm's value.\n\n    // Ensure that eval from any compartment in a root realm is an instance\n    // of Function in any compartment of the same root realm.\n    setPrototypeOf(safeEval, unsafeFunction.prototype);\n\n    assert(getPrototypeOf(safeEval).constructor !== Function, 'hide Function');\n    assert(\n      getPrototypeOf(safeEval).constructor !== unsafeFunction,\n      'hide unsafeFunction'\n    );\n\n    // note: be careful to not leak our primal Function.prototype by setting\n    // this to a plain arrow function. Now that we have safeEval, use it.\n    defineProperties(safeEval, {\n      toString: {\n        // We break up the following literal string so that an\n        // apparent direct eval syntax does not appear in this\n        // file. Thus, we avoid rejection by the overly eager\n        // rejectDangerousSources.\n        value: safeEval(\"() => 'function eval' + '() { [shim code] }'\"),\n        writable: false,\n        enumerable: false,\n        configurable: true\n      }\n    });\n\n    return safeEval;\n  }\n\n  return factory;\n}\n\nexport function createSafeEvaluator(safeEvaluatorFactory) {\n  return safeEvaluatorFactory();\n}\n\nexport function createSafeEvaluatorWhichTakesEndowments(safeEvaluatorFactory) {\n  return (x, endowments, options = {}) =>\n    safeEvaluatorFactory(endowments, options)(x);\n}\n\n/**\n * A safe version of the native Function which relies on\n * the safety of evalEvaluator for confinement.\n */\nexport function createFunctionEvaluator(unsafeRec, safeEval) {\n  const { unsafeFunction, unsafeGlobal } = unsafeRec;\n\n  const safeFunction = function Function(...params) {\n    const functionBody = `${arrayPop(params) || ''}`;\n    let functionParams = `${arrayJoin(params, ',')}`;\n    if (!regexpTest(/^[\\w\\s,]*$/, functionParams)) {\n      throw new unsafeGlobal.SyntaxError(\n        'shim limitation: Function arg must be simple ASCII identifiers, possibly separated by commas: no default values, pattern matches, or non-ASCII parameter names'\n      );\n      // this protects against Matt Austin's clever attack:\n      // Function(\"arg=`\", \"/*body`){});({x: this/**/\")\n      // which would turn into\n      //     (function(arg=`\n      //     /*``*/){\n      //      /*body`){});({x: this/**/\n      //     })\n      // which parses as a default argument of `\\n/*``*/){\\n/*body` , which\n      // is a pair of template literals back-to-back (so the first one\n      // nominally evaluates to the parser to use on the second one), which\n      // can't actually execute (because the first literal evals to a string,\n      // which can't be a parser function), but that doesn't matter because\n      // the function is bypassed entirely. When that gets evaluated, it\n      // defines (but does not invoke) a function, then evaluates a simple\n      // {x: this} expression, giving access to the safe global.\n    }\n\n    // Is this a real functionBody, or is someone attempting an injection\n    // attack? This will throw a SyntaxError if the string is not actually a\n    // function body. We coerce the body into a real string above to prevent\n    // someone from passing an object with a toString() that returns a safe\n    // string the first time, but an evil string the second time.\n    // eslint-disable-next-line no-new, new-cap\n    new unsafeFunction(functionBody);\n\n    if (stringIncludes(functionParams, ')')) {\n      // If the formal parameters string include ) - an illegal\n      // character - it may make the combined function expression\n      // compile. We avoid this problem by checking for this early on.\n\n      // note: v8 throws just like this does, but chrome accepts\n      // e.g. 'a = new Date()'\n      throw new unsafeGlobal.SyntaxError(\n        'shim limitation: Function arg string contains parenthesis'\n      );\n      // todo: shim integrity threat if they change SyntaxError\n    }\n\n    // todo: check to make sure this .length is safe. markm says safe.\n    if (functionParams.length > 0) {\n      // If the formal parameters include an unbalanced block comment, the\n      // function must be rejected. Since JavaScript does not allow nested\n      // comments we can include a trailing block comment to catch this.\n      functionParams += '\\n/*``*/';\n    }\n\n    const src = `(function(${functionParams}){\\n${functionBody}\\n})`;\n\n    return safeEval(src);\n  };\n\n  // Ensure that Function from any compartment in a root realm can be used\n  // with instance checks in any compartment of the same root realm.\n  setPrototypeOf(safeFunction, unsafeFunction.prototype);\n\n  assert(\n    getPrototypeOf(safeFunction).constructor !== Function,\n    'hide Function'\n  );\n  assert(\n    getPrototypeOf(safeFunction).constructor !== unsafeFunction,\n    'hide unsafeFunction'\n  );\n\n  defineProperties(safeFunction, {\n    // Ensure that any function created in any compartment in a root realm is an\n    // instance of Function in any compartment of the same root ralm.\n    prototype: { value: unsafeFunction.prototype },\n\n    // Provide a custom output without overwriting the\n    // Function.prototype.toString which is called by some third-party\n    // libraries.\n    toString: {\n      value: safeEval(\"() => 'function Function() { [shim code] }'\"),\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  return safeFunction;\n}\n","import { createRealmFacade, buildChildRealm } from './realmFacade';\nimport { createNewUnsafeRec, createCurrentUnsafeRec } from './unsafeRec';\nimport {\n  createSafeEvaluatorFactory,\n  createSafeEvaluator,\n  createSafeEvaluatorWhichTakesEndowments,\n  createFunctionEvaluator\n} from './evaluators';\nimport { assert } from './utilities';\nimport { create, defineProperties, freeze, arrayConcat } from './commons';\n\n// Mimic private members on the realm instances.\n// We define it in the same module and do not export it.\nconst RealmRecForRealmInstance = new WeakMap();\n\nfunction getRealmRecForRealmInstance(realm) {\n  // Detect non-objects.\n  assert(Object(realm) === realm, 'bad object, not a Realm instance');\n  // Realm instance has no realmRec. Should not proceed.\n  assert(RealmRecForRealmInstance.has(realm), 'Realm instance has no record');\n\n  return RealmRecForRealmInstance.get(realm);\n}\n\nfunction registerRealmRecForRealmInstance(realm, realmRec) {\n  // Detect non-objects.\n  assert(Object(realm) === realm, 'bad object, not a Realm instance');\n  // Attempt to change an existing realmRec on a realm instance. Should not proceed.\n  assert(\n    !RealmRecForRealmInstance.has(realm),\n    'Realm instance already has a record'\n  );\n\n  RealmRecForRealmInstance.set(realm, realmRec);\n}\n\n// Initialize the global variables for the new Realm.\nfunction setDefaultBindings(safeGlobal, safeEval, safeFunction) {\n  defineProperties(safeGlobal, {\n    eval: {\n      value: safeEval,\n      writable: true,\n      configurable: true\n    },\n    Function: {\n      value: safeFunction,\n      writable: true,\n      configurable: true\n    }\n  });\n}\n\nfunction createRealmRec(unsafeRec, transforms, sloppyGlobals) {\n  const { sharedGlobalDescs, unsafeGlobal } = unsafeRec;\n\n  const safeGlobal = create(unsafeGlobal.Object.prototype, sharedGlobalDescs);\n\n  const safeEvaluatorFactory = createSafeEvaluatorFactory(\n    unsafeRec,\n    safeGlobal,\n    transforms,\n    sloppyGlobals\n  );\n  const safeEval = createSafeEvaluator(safeEvaluatorFactory);\n  const safeEvalWhichTakesEndowments = createSafeEvaluatorWhichTakesEndowments(\n    safeEvaluatorFactory\n  );\n  const safeFunction = createFunctionEvaluator(unsafeRec, safeEval);\n\n  setDefaultBindings(safeGlobal, safeEval, safeFunction);\n\n  const realmRec = freeze({\n    safeGlobal,\n    safeEval,\n    safeEvalWhichTakesEndowments,\n    safeFunction\n  });\n\n  return realmRec;\n}\n\n/**\n * A root realm uses a fresh set of new intrinics. Here we first create\n * a new unsafe record, which inherits the shims. Then we proceed with\n * the creation of the realm record, and we apply the shims.\n */\nfunction initRootRealm(parentUnsafeRec, self, options) {\n  // note: 'self' is the instance of the Realm.\n\n  // todo: investigate attacks via Array.species\n  // todo: this accepts newShims='string', but it should reject that\n  const { shims: newShims, transforms, sloppyGlobals } = options;\n  const allShims = arrayConcat(parentUnsafeRec.allShims, newShims);\n\n  // The unsafe record is created already repaired.\n  const unsafeRec = createNewUnsafeRec(allShims);\n\n  // eslint-disable-next-line no-use-before-define\n  const Realm = createRealmFacade(unsafeRec, BaseRealm);\n\n  // Add a Realm descriptor to sharedGlobalDescs, so it can be defined onto the\n  // safeGlobal like the rest of the globals.\n  unsafeRec.sharedGlobalDescs.Realm = {\n    value: Realm,\n    writable: true,\n    configurable: true\n  };\n\n  // Creating the realmRec provides the global object, eval() and Function()\n  // to the realm.\n  const realmRec = createRealmRec(unsafeRec, transforms, sloppyGlobals);\n\n  // Apply all shims in the new RootRealm. We don't do this for compartments.\n  const { safeEvalWhichTakesEndowments } = realmRec;\n  for (const shim of allShims) {\n    safeEvalWhichTakesEndowments(shim);\n  }\n\n  // The realmRec acts as a private field on the realm instance.\n  registerRealmRecForRealmInstance(self, realmRec);\n}\n\n/**\n * A compartment shares the intrinsics of its root realm. Here, only a\n * realmRec is necessary to hold the global object, eval() and Function().\n */\nfunction initCompartment(unsafeRec, self, options = {}) {\n  // note: 'self' is the instance of the Realm.\n\n  const { transforms, sloppyGlobals } = options;\n  const realmRec = createRealmRec(unsafeRec, transforms, sloppyGlobals);\n\n  // The realmRec acts as a private field on the realm instance.\n  registerRealmRecForRealmInstance(self, realmRec);\n}\n\nfunction getRealmGlobal(self) {\n  const { safeGlobal } = getRealmRecForRealmInstance(self);\n  return safeGlobal;\n}\n\nfunction realmEvaluate(self, x, endowments = {}, options = {}) {\n  // todo: don't pass in primal-realm objects like {}, for safety. OTOH its\n  // properties are copied onto the new global 'target'.\n  // todo: figure out a way to membrane away the contents to safety.\n  const { safeEvalWhichTakesEndowments } = getRealmRecForRealmInstance(self);\n  return safeEvalWhichTakesEndowments(x, endowments, options);\n}\n\nconst BaseRealm = {\n  initRootRealm,\n  initCompartment,\n  getRealmGlobal,\n  realmEvaluate\n};\n\n// Create the current unsafeRec from the current \"primal\" environment (the realm\n// where the Realm shim is loaded and executed).\nconst currentUnsafeRec = createCurrentUnsafeRec();\n\n/**\n * The \"primal\" realm class is defined in the current \"primal\" environment,\n * and is part of the shim. There is no need to facade this class via evaluation\n * because both share the same intrinsics.\n */\nconst Realm = buildChildRealm(currentUnsafeRec, BaseRealm);\n\nexport default Realm;\n","// Declare shorthand functions. Sharing these declarations across modules\n// improves both consistency and minification. Unused declarations are\n// dropped by the tree shaking process.\n\n// we capture these, not just for brevity, but for security. If any code\n// modifies Object to change what 'assign' points to, the Realm shim would be\n// corrupted.\n\nexport const {\n  assign,\n  create,\n  freeze,\n  defineProperties, // Object.defineProperty is allowed to fail\n  // silentlty, use Object.defineProperties instead.\n  getOwnPropertyDescriptor,\n  getOwnPropertyDescriptors,\n  getOwnPropertyNames,\n  getPrototypeOf,\n  setPrototypeOf\n} = Object;\n\nexport const {\n  apply,\n  ownKeys // Reflect.ownKeys includes Symbols and unenumerables,\n  // unlike Object.keys()\n} = Reflect;\n\n/**\n * uncurryThis() See\n * http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\n * which only lives at\n * http://web.archive.org/web/20160805225710/http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\n *\n * Performance:\n * 1. The native call is about 10x faster on FF than chrome\n * 2. The version using Function.bind() is about 100x slower on FF,\n *    equal on chrome, 2x slower on Safari\n * 3. The version using a spread and Reflect.apply() is about 10x\n *    slower on FF, equal on chrome, 2x slower on Safari\n *\n * const bind = Function.prototype.bind;\n * const uncurryThis = bind.bind(bind.call);\n */\nconst uncurryThis = fn => (thisArg, ...args) => apply(fn, thisArg, args);\n\n// We also capture these for security: changes to Array.prototype after the\n// Realm shim runs shouldn't affect subsequent Realm operations.\nexport const objectHasOwnProperty = uncurryThis(\n    Object.prototype.hasOwnProperty\n  ),\n  arrayForEach = uncurryThis(Array.prototype.forEach),\n  arrayFilter = uncurryThis(Array.prototype.filter),\n  arrayPush = uncurryThis(Array.prototype.push),\n  arrayPop = uncurryThis(Array.prototype.pop),\n  arrayJoin = uncurryThis(Array.prototype.join),\n  arrayConcat = uncurryThis(Array.prototype.concat),\n  regexpTest = uncurryThis(RegExp.prototype.test),\n  stringMatch = uncurryThis(String.prototype.match),\n  stringIncludes = uncurryThis(String.prototype.includes);\n"],"names":["throwTantrum","s","err","msg","console","error","stack","assert","condition","message","cleanupSource","src","buildChildRealm","unsafeRec","BaseRealm","callAndWrapError","target","args","Object","eName","eMessage","eStack","name","ignored","Error","ErrorConstructor","errorConstructors","get","err2","initRootRealm","initCompartment","getRealmGlobal","realmEvaluate","create","defineProperties","Map","EvalError","RangeError","ReferenceError","SyntaxError","TypeError","URIError","Realm","constructor","makeRootRealm","options","r","prototype","makeCompartment","global","evaluate","x","endowments","toString","value","writable","enumerable","configurable","createRealmFacade","unsafeEval","buildChildRealmString","getSharedGlobalDescs","unsafeGlobal","describe","names","desc","getOwnPropertyDescriptor","descriptors","frozenGlobalPropertyNames","stableGlobalPropertyNames","unstableGlobalPropertyNames","repairAccessors","toObject","obj","asPropertyName","aFunction","accessor","defineProperty","getPrototypeOf","objectPrototype","__lookupGetter__","ignore","__defineGetter__","prop","func","O","__defineSetter__","set","__lookupSetter__","repairFunctions","repairFunction","declaration","FunctionInstance","globalEval","e","FunctionPrototype","TamedFunction","Function","setPrototypeOf","createNewUnsafeGlobalForNode","isNode","vm","require","runInNewContext","unsafeGlobalEvalSrc","createNewUnsafeGlobalForBrowser","document","iframe","createElement","style","display","body","appendChild","contentWindow","eval","unsafeGlobalSrc","createUnsafeRec","allShims","sharedGlobalDescs","freeze","unsafeFunction","createNewUnsafeRec","getNewUnsafeGlobal","repairAccessorsShim","repairFunctionsShim","getOptimizableGlobals","safeGlobal","descs","getOwnPropertyDescriptors","constants","arrayFilter","getOwnPropertyNames","keywords","has","regexpTest","identifierPattern","objectHasOwnProperty","createScopeHandler","sloppyGlobals","useUnsafeEvaluator","__proto__","alwaysThrowHandler","allowUnsafeEvaluatorOnce","unsafeEvaluatorAllowed","Symbol","unscopables","rejectHtmlComments","index","search","htmlCommentPattern","linenum","slice","split","length","rejectImportExpressions","importPattern","rejectSomeDirectEvalExpressions","someDirectEvalPattern","rejectDangerousSources","buildOptimizer","arrayJoin","createScopedEvaluatorFactory","optimizer","createSafeEvaluatorFactory","transforms","scopedEvaluatorFactory","localTransforms","allTransforms","rejectDangerousSourcesTransform","safeEval","rewriterState","reduce","rs","transform","rewrite","scopeTarget","scopeHandler","scopeProxy","Proxy","scopedEvaluator","apply","createSafeEvaluator","safeEvaluatorFactory","createSafeEvaluatorWhichTakesEndowments","createFunctionEvaluator","safeFunction","params","functionBody","arrayPop","functionParams","stringIncludes","getRealmRecForRealmInstance","realm","RealmRecForRealmInstance","registerRealmRecForRealmInstance","realmRec","setDefaultBindings","createRealmRec","safeEvalWhichTakesEndowments","assign","ownKeys","Reflect","uncurryThis","fn","thisArg","hasOwnProperty","Array","filter","pop","join","arrayConcat","concat","RegExp","test","String","includes","newUnsafeGlobalForBrowser","newUnsafeGlobalForNode","Set","WeakMap","parentUnsafeRec","self","shims","newShims","shim","currentUnsafeRec"],"mappings":"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"}
##############################################
/src/dist/realms-shim.esm.js.map:1:{"version":3,"file":"realms-shim.esm.js","sources":["../src/utilities.js","../src/realmFacade.js","../src/commons.js","../src/stdlib.js","../src/repair/accessors.js","../src/repair/functions.js","../src/unsafeRec.js","../src/optimizer.js","../src/scopeHandler.js","../src/sourceParser.js","../src/evaluators.js","../src/realm.js"],"sourcesContent":["// we'd like to abandon, but we can't, so just scream and break a lot of\n// stuff. However, since we aren't really aborting the process, be careful to\n// not throw an Error object which could be captured by child-Realm code and\n// used to access the (too-powerful) primal-realm Error object.\n\nexport function throwTantrum(s, err = undefined) {\n  const msg = `please report internal shim error: ${s}`;\n\n  // we want to log these 'should never happen' things.\n  // eslint-disable-next-line no-console\n  console.error(msg);\n  if (err) {\n    // eslint-disable-next-line no-console\n    console.error(`${err}`);\n    // eslint-disable-next-line no-console\n    console.error(`${err.stack}`);\n  }\n\n  // eslint-disable-next-line no-debugger\n  debugger;\n  throw msg;\n}\n\nexport function assert(condition, message) {\n  if (!condition) {\n    throwTantrum(message);\n  }\n}\n\n// Remove code modifications.\nexport function cleanupSource(src) {\n  /* START_TESTS_ONLY */\n\n  // Restore eval which is modified by esm module.\n  src = src.replace(/\\(0,[^)]+\\)/g, '(0, eval)');\n\n  // Remove code coverage which is injected by nyc module.\n  src = src.replace(/cov_[^+]+\\+\\+[;,]/g, '');\n\n  /* END_TESTS_ONLY */\n  return src;\n}\n","import { cleanupSource } from './utilities';\n\n// buildChildRealm is immediately turned into a string, and this function is\n// never referenced again, because it closes over the wrong intrinsics\n\nexport function buildChildRealm(unsafeRec, BaseRealm) {\n  const {\n    initRootRealm,\n    initCompartment,\n    getRealmGlobal,\n    realmEvaluate\n  } = BaseRealm;\n\n  // This Object and Reflect are brand new, from a new unsafeRec, so no user\n  // code has been run or had a chance to manipulate them. We extract these\n  // properties for brevity, not for security. Don't ever run this function\n  // *after* user code has had a chance to pollute its environment, or it\n  // could be used to gain access to BaseRealm and primal-realm Error\n  // objects.\n  const { create, defineProperties } = Object;\n\n  const errorConstructors = new Map([\n    ['EvalError', EvalError],\n    ['RangeError', RangeError],\n    ['ReferenceError', ReferenceError],\n    ['SyntaxError', SyntaxError],\n    ['TypeError', TypeError],\n    ['URIError', URIError]\n  ]);\n\n  // Like Realm.apply except that it catches anything thrown and rethrows it\n  // as an Error from this realm\n  function callAndWrapError(target, ...args) {\n    try {\n      return target(...args);\n    } catch (err) {\n      if (Object(err) !== err) {\n        // err is a primitive value, which is safe to rethrow\n        throw err;\n      }\n      let eName, eMessage, eStack;\n      try {\n        // The child environment might seek to use 'err' to reach the\n        // parent's intrinsics and corrupt them. `${err.name}` will cause\n        // string coercion of 'err.name'. If err.name is an object (probably\n        // a String of the parent Realm), the coercion uses\n        // err.name.toString(), which is under the control of the parent. If\n        // err.name were a primitive (e.g. a number), it would use\n        // Number.toString(err.name), using the child's version of Number\n        // (which the child could modify to capture its argument for later\n        // use), however primitives don't have properties like .prototype so\n        // they aren't useful for an attack.\n        eName = `${err.name}`;\n        eMessage = `${err.message}`;\n        eStack = `${err.stack || eMessage}`;\n        // eName/eMessage/eStack are now child-realm primitive strings, and\n        // safe to expose\n      } catch (ignored) {\n        // if err.name.toString() throws, keep the (parent realm) Error away\n        // from the child\n        throw new Error('unknown error');\n      }\n      const ErrorConstructor = errorConstructors.get(eName) || Error;\n      try {\n        throw new ErrorConstructor(eMessage);\n      } catch (err2) {\n        err2.stack = eStack; // replace with the captured inner stack\n        throw err2;\n      }\n    }\n  }\n\n  class Realm {\n    constructor() {\n      // The Realm constructor is not intended to be used with the new operator\n      // or to be subclassed. It may be used as the value of an extends clause\n      // of a class definition but a super call to the Realm constructor will\n      // cause an exception.\n\n      // When Realm is called as a function, an exception is also raised because\n      // a class constructor cannot be invoked without 'new'.\n      throw new TypeError('Realm is not a constructor');\n    }\n\n    static makeRootRealm(options = {}) {\n      // This is the exposed interface.\n\n      // Bypass the constructor.\n      const r = create(Realm.prototype);\n      callAndWrapError(initRootRealm, unsafeRec, r, options);\n      return r;\n    }\n\n    static makeCompartment(options = {}) {\n      // Bypass the constructor.\n      const r = create(Realm.prototype);\n      callAndWrapError(initCompartment, unsafeRec, r, options);\n      return r;\n    }\n\n    // we omit the constructor because it is empty. All the personalization\n    // takes place in one of the two static methods,\n    // makeRootRealm/makeCompartment\n\n    get global() {\n      // this is safe against being called with strange 'this' because\n      // baseGetGlobal immediately does a trademark check (it fails unless\n      // this 'this' is present in a weakmap that is only populated with\n      // legitimate Realm instances)\n      return callAndWrapError(getRealmGlobal, this);\n    }\n\n    evaluate(x, endowments, options = {}) {\n      // safe against strange 'this', as above\n      return callAndWrapError(realmEvaluate, this, x, endowments, options);\n    }\n  }\n\n  defineProperties(Realm, {\n    toString: {\n      value: () => 'function Realm() { [shim code] }',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  defineProperties(Realm.prototype, {\n    toString: {\n      value: () => '[object Realm]',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  return Realm;\n}\n\n// The parentheses means we don't bind the 'buildChildRealm' name inside the\n// child's namespace. this would accept an anonymous function declaration.\n// function expression (not a declaration) so it has a completion value.\nconst buildChildRealmString = cleanupSource(\n  `'use strict'; (${buildChildRealm})`\n);\n\nexport function createRealmFacade(unsafeRec, BaseRealm) {\n  const { unsafeEval } = unsafeRec;\n\n  // The BaseRealm is the Realm class created by\n  // the shim. It's only valid for the context where\n  // it was parsed.\n\n  // The Realm facade is a lightweight class built in the\n  // context a different context, that provide a fully\n  // functional Realm class using the intrisics\n  // of that context.\n\n  // This process is simplified because all methods\n  // and properties on a realm instance already return\n  // values using the intrinsics of the realm's context.\n\n  // Invoke the BaseRealm constructor with Realm as the prototype.\n  return unsafeEval(buildChildRealmString)(unsafeRec, BaseRealm);\n}\n","// Declare shorthand functions. Sharing these declarations across modules\n// improves both consistency and minification. Unused declarations are\n// dropped by the tree shaking process.\n\n// we capture these, not just for brevity, but for security. If any code\n// modifies Object to change what 'assign' points to, the Realm shim would be\n// corrupted.\n\nexport const {\n  assign,\n  create,\n  freeze,\n  defineProperties, // Object.defineProperty is allowed to fail\n  // silentlty, use Object.defineProperties instead.\n  getOwnPropertyDescriptor,\n  getOwnPropertyDescriptors,\n  getOwnPropertyNames,\n  getPrototypeOf,\n  setPrototypeOf\n} = Object;\n\nexport const {\n  apply,\n  ownKeys // Reflect.ownKeys includes Symbols and unenumerables,\n  // unlike Object.keys()\n} = Reflect;\n\n/**\n * uncurryThis() See\n * http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\n * which only lives at\n * http://web.archive.org/web/20160805225710/http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\n *\n * Performance:\n * 1. The native call is about 10x faster on FF than chrome\n * 2. The version using Function.bind() is about 100x slower on FF,\n *    equal on chrome, 2x slower on Safari\n * 3. The version using a spread and Reflect.apply() is about 10x\n *    slower on FF, equal on chrome, 2x slower on Safari\n *\n * const bind = Function.prototype.bind;\n * const uncurryThis = bind.bind(bind.call);\n */\nconst uncurryThis = fn => (thisArg, ...args) => apply(fn, thisArg, args);\n\n// We also capture these for security: changes to Array.prototype after the\n// Realm shim runs shouldn't affect subsequent Realm operations.\nexport const objectHasOwnProperty = uncurryThis(\n    Object.prototype.hasOwnProperty\n  ),\n  arrayForEach = uncurryThis(Array.prototype.forEach),\n  arrayFilter = uncurryThis(Array.prototype.filter),\n  arrayPush = uncurryThis(Array.prototype.push),\n  arrayPop = uncurryThis(Array.prototype.pop),\n  arrayJoin = uncurryThis(Array.prototype.join),\n  arrayConcat = uncurryThis(Array.prototype.concat),\n  regexpTest = uncurryThis(RegExp.prototype.test),\n  stringMatch = uncurryThis(String.prototype.match),\n  stringIncludes = uncurryThis(String.prototype.includes);\n","import { getOwnPropertyDescriptor } from './commons';\nimport { assert } from './utilities';\n\n// These value properties of the global object are non-writable,\n// non-configurable data properties.\nconst frozenGlobalPropertyNames = [\n  // *** 18.1 Value Properties of the Global Object\n\n  'Infinity',\n  'NaN',\n  'undefined'\n];\n\n// All the following stdlib items have the same name on both our intrinsics\n// object and on the global object. Unlike Infinity/NaN/undefined, these\n// should all be writable and configurable. This is divided into two\n// sets. The stable ones are those the shim can freeze early because\n// we don't expect anyone will want to mutate them. The unstable ones\n// are the ones that we correctly initialize to writable and\n// configurable so that they can still be replaced or removed.\nconst stableGlobalPropertyNames = [\n  // *** 18.2 Function Properties of the Global Object\n\n  // 'eval', // comes from safeEval instead\n  'isFinite',\n  'isNaN',\n  'parseFloat',\n  'parseInt',\n\n  'decodeURI',\n  'decodeURIComponent',\n  'encodeURI',\n  'encodeURIComponent',\n\n  // *** 18.3 Constructor Properties of the Global Object\n\n  'Array',\n  'ArrayBuffer',\n  'Boolean',\n  'DataView',\n  // 'Date',  // Unstable\n  // 'Error',  // Unstable\n  'EvalError',\n  'Float32Array',\n  'Float64Array',\n  // 'Function',  // comes from safeFunction instead\n  'Int8Array',\n  'Int16Array',\n  'Int32Array',\n  'Map',\n  'Number',\n  'Object',\n  // 'Promise',  // Unstable\n  // 'Proxy',  // Unstable\n  'RangeError',\n  'ReferenceError',\n  // 'RegExp',  // Unstable\n  'Set',\n  // 'SharedArrayBuffer'  // removed on Jan 5, 2018\n  'String',\n  'Symbol',\n  'SyntaxError',\n  'TypeError',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Uint16Array',\n  'Uint32Array',\n  'URIError',\n  'WeakMap',\n  'WeakSet',\n\n  // *** 18.4 Other Properties of the Global Object\n\n  // 'Atomics', // removed on Jan 5, 2018\n  'JSON',\n  'Math',\n  'Reflect',\n\n  // *** Annex B\n\n  'escape',\n  'unescape'\n\n  // *** ECMA-402\n\n  // 'Intl'  // Unstable\n\n  // *** ESNext\n\n  // 'Realm' // Comes from createRealmGlobalObject()\n];\n\nconst unstableGlobalPropertyNames = [\n  'Date',\n  'Error',\n  'Promise',\n  'Proxy',\n  'RegExp',\n  'Intl'\n];\n\nexport function getSharedGlobalDescs(unsafeGlobal) {\n  const descriptors = {};\n\n  function describe(names, writable, enumerable, configurable) {\n    for (const name of names) {\n      const desc = getOwnPropertyDescriptor(unsafeGlobal, name);\n      if (desc) {\n        // Abort if an accessor is found on the unsafe global object\n        // instead of a data property. We should never get into this\n        // non standard situation.\n        assert(\n          'value' in desc,\n          `unexpected accessor on global property: ${name}`\n        );\n\n        descriptors[name] = {\n          value: desc.value,\n          writable,\n          enumerable,\n          configurable\n        };\n      }\n    }\n  }\n\n  describe(frozenGlobalPropertyNames, false, false, false);\n  // The following is correct but expensive.\n  // describe(stableGlobalPropertyNames, true, false, true);\n  // Instead, for now, we let these get optimized.\n  //\n  // TODO: We should provide an option to turn this optimization off,\n  // by feeding \"true, false, true\" here instead.\n  describe(stableGlobalPropertyNames, false, false, false);\n  // These we keep replaceable and removable, because we expect\n  // others, e.g., SES, may want to do so.\n  describe(unstableGlobalPropertyNames, true, false, true);\n\n  return descriptors;\n}\n","// Adapted from SES/Caja - Copyright (C) 2011 Google Inc.\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js\n\n/**\n * Replace the legacy accessors of Object to comply with strict mode\n * and ES2016 semantics, we do this by redefining them while in 'use strict'.\n *\n * todo: list the issues resolved\n *\n * This function can be used in two ways: (1) invoked directly to fix the primal\n * realm's Object.prototype, and (2) converted to a string to be executed\n * inside each new RootRealm to fix their Object.prototypes. Evaluation requires\n * the function to have no dependencies, so don't import anything from\n * the outside.\n */\n\n// todo: this file should be moved out to a separate repo and npm module.\nexport function repairAccessors() {\n  const {\n    defineProperty,\n    defineProperties,\n    getOwnPropertyDescriptor,\n    getPrototypeOf,\n    prototype: objectPrototype\n  } = Object;\n\n  // On some platforms, the implementation of these functions act as\n  // if they are in sloppy mode: if they're invoked badly, they will\n  // expose the global object, so we need to repair these for\n  // security. Thus it is our responsibility to fix this, and we need\n  // to include repairAccessors. E.g. Chrome in 2016.\n\n  try {\n    // Verify that the method is not callable.\n    // eslint-disable-next-line no-restricted-properties, no-underscore-dangle\n    (0, objectPrototype.__lookupGetter__)('x');\n  } catch (ignore) {\n    // Throws, no need to patch.\n    return;\n  }\n\n  function toObject(obj) {\n    if (obj === undefined || obj === null) {\n      throw new TypeError(`can't convert undefined or null to object`);\n    }\n    return Object(obj);\n  }\n\n  function asPropertyName(obj) {\n    if (typeof obj === 'symbol') {\n      return obj;\n    }\n    return `${obj}`;\n  }\n\n  function aFunction(obj, accessor) {\n    if (typeof obj !== 'function') {\n      throw TypeError(`invalid ${accessor} usage`);\n    }\n    return obj;\n  }\n\n  defineProperties(objectPrototype, {\n    __defineGetter__: {\n      value: function __defineGetter__(prop, func) {\n        const O = toObject(this);\n        defineProperty(O, prop, {\n          get: aFunction(func, 'getter'),\n          enumerable: true,\n          configurable: true\n        });\n      }\n    },\n    __defineSetter__: {\n      value: function __defineSetter__(prop, func) {\n        const O = toObject(this);\n        defineProperty(O, prop, {\n          set: aFunction(func, 'setter'),\n          enumerable: true,\n          configurable: true\n        });\n      }\n    },\n    __lookupGetter__: {\n      value: function __lookupGetter__(prop) {\n        let O = toObject(this);\n        prop = asPropertyName(prop);\n        let desc;\n        while (O && !(desc = getOwnPropertyDescriptor(O, prop))) {\n          O = getPrototypeOf(O);\n        }\n        return desc && desc.get;\n      }\n    },\n    __lookupSetter__: {\n      value: function __lookupSetter__(prop) {\n        let O = toObject(this);\n        prop = asPropertyName(prop);\n        let desc;\n        while (O && !(desc = getOwnPropertyDescriptor(O, prop))) {\n          O = getPrototypeOf(O);\n        }\n        return desc && desc.set;\n      }\n    }\n  });\n}\n","// Adapted from SES/Caja\n// Copyright (C) 2011 Google Inc.\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js\n\n/**\n * This block replaces the original Function constructor, and the original\n * %GeneratorFunction% %AsyncFunction% and %AsyncGeneratorFunction%, with\n * safe replacements that throw if invoked.\n *\n * These are all reachable via syntax, so it isn't sufficient to just\n * replace global properties with safe versions. Our main goal is to prevent\n * access to the Function constructor through these starting points.\n\n * After this block is done, the originals must no longer be reachable, unless\n * a copy has been made, and funtions can only be created by syntax (using eval)\n * or by invoking a previously saved reference to the originals.\n */\n\n// todo: this file should be moved out to a separate repo and npm module.\nconst globalEval = eval;\nexport function repairFunctions() {\n  const { defineProperties, getPrototypeOf, setPrototypeOf } = Object;\n\n  /**\n   * The process to repair constructors:\n   * 1. Create an instance of the function by evaluating syntax\n   * 2. Obtain the prototype from the instance\n   * 3. Create a substitute tamed constructor\n   * 4. Replace the original constructor with the tamed constructor\n   * 5. Replace tamed constructor prototype property with the original one\n   * 6. Replace its [[Prototype]] slot with the tamed constructor of Function\n   */\n  function repairFunction(name, declaration) {\n    let FunctionInstance;\n    try {\n      // eslint-disable-next-line no-new-func\n      FunctionInstance = globalEval(declaration);\n    } catch (e) {\n      if (e instanceof SyntaxError) {\n        // Prevent failure on platforms where async and/or generators\n        // are not supported.\n        return;\n      }\n      // Re-throw\n      throw e;\n    }\n    const FunctionPrototype = getPrototypeOf(FunctionInstance);\n\n    // Prevents the evaluation of source when calling constructor on the\n    // prototype of functions.\n    const TamedFunction = function() {\n      throw new TypeError('Not available');\n    };\n    defineProperties(TamedFunction, { name: { value: name } });\n\n    // (new Error()).constructors does not inherit from Function, because Error\n    // was defined before ES6 classes. So we don't need to repair it too.\n\n    // (Error()).constructor inherit from Function, which gets a tamed\n    // constructor here.\n\n    // todo: in an ES6 class that does not inherit from anything, what does its\n    // constructor inherit from? We worry that it inherits from Function, in\n    // which case instances could give access to unsafeFunction. markm says\n    // we're fine: the constructor inherits from Object.prototype\n\n    // This line replaces the original constructor in the prototype chain\n    // with the tamed one. No copy of the original is peserved.\n    defineProperties(FunctionPrototype, {\n      constructor: { value: TamedFunction }\n    });\n\n    // This line sets the tamed constructor's prototype data property to\n    // the original one.\n    defineProperties(TamedFunction, {\n      prototype: { value: FunctionPrototype }\n    });\n\n    if (TamedFunction !== Function.prototype.constructor) {\n      // Ensures that all functions meet \"instanceof Function\" in a realm.\n      setPrototypeOf(TamedFunction, Function.prototype.constructor);\n    }\n  }\n\n  // Here, the order of operation is important: Function needs to be repaired\n  // first since the other repaired constructors need to inherit from the tamed\n  // Function function constructor.\n\n  // note: this really wants to be part of the standard, because new\n  // constructors may be added in the future, reachable from syntax, and this\n  // list must be updated to match.\n\n  // \"plain arrow functions\" inherit from Function.prototype\n\n  repairFunction('Function', '(function(){})');\n  repairFunction('GeneratorFunction', '(function*(){})');\n  repairFunction('AsyncFunction', '(async function(){})');\n  repairFunction('AsyncGeneratorFunction', '(async function*(){})');\n}\n","// this module must never be importable outside the Realm shim itself\nimport { getSharedGlobalDescs } from './stdlib';\nimport { repairAccessors } from './repair/accessors';\nimport { repairFunctions } from './repair/functions';\nimport { cleanupSource } from './utilities';\nimport { freeze } from './commons';\n\n// A \"context\" is a fresh unsafe Realm as given to us by existing platforms.\n// We need this to implement the shim. However, when Realms land for real,\n// this feature will be provided by the underlying engine instead.\n\n// note: in a node module, the top-level 'this' is not the global object\n// (it's *something* but we aren't sure what), however an indirect eval of\n// 'this' will be the correct global object.\n\nconst unsafeGlobalSrc = \"'use strict'; this\";\nconst unsafeGlobalEvalSrc = `(0, eval)(\"'use strict'; this\")`;\n\n// This method is only exported for testing purposes.\nexport function createNewUnsafeGlobalForNode() {\n  // Note that webpack and others will shim 'vm' including the method\n  // 'runInNewContext', so the presence of vm is not a useful check\n\n  // TODO: Find a better test that works with bundlers\n  // eslint-disable-next-line no-new-func\n  const isNode = new Function(\n    'try {return this===global}catch(e){return false}'\n  )();\n\n  if (!isNode) {\n    return undefined;\n  }\n\n  // eslint-disable-next-line global-require\n  const vm = require('vm');\n\n  // Use unsafeGlobalEvalSrc to ensure we get the right 'this'.\n  const unsafeGlobal = vm.runInNewContext(unsafeGlobalEvalSrc);\n\n  return unsafeGlobal;\n}\n\n// This method is only exported for testing purposes.\nexport function createNewUnsafeGlobalForBrowser() {\n  if (typeof document === 'undefined') {\n    return undefined;\n  }\n  const iframe = document.createElement('iframe');\n  iframe.style.display = 'none';\n\n  document.body.appendChild(iframe);\n  const unsafeGlobal = iframe.contentWindow.eval(unsafeGlobalSrc);\n\n  // We keep the iframe attached to the DOM because removing it\n  // causes its global object to lose intrinsics, its eval()\n  // function to evaluate code, etc.\n\n  // TODO: can we remove and garbage-collect the iframes?\n\n  return unsafeGlobal;\n}\n\nconst getNewUnsafeGlobal = () => {\n  const newUnsafeGlobalForBrowser = createNewUnsafeGlobalForBrowser();\n  const newUnsafeGlobalForNode = createNewUnsafeGlobalForNode();\n  if (\n    (!newUnsafeGlobalForBrowser && !newUnsafeGlobalForNode) ||\n    (newUnsafeGlobalForBrowser && newUnsafeGlobalForNode)\n  ) {\n    throw new Error('unexpected platform, unable to create Realm');\n  }\n  return newUnsafeGlobalForBrowser || newUnsafeGlobalForNode;\n};\n\n// The unsafeRec is shim-specific. It acts as the mechanism to obtain a fresh\n// set of intrinsics together with their associated eval and Function\n// evaluators. These must be used as a matched set, since the evaluators are\n// tied to a set of intrinsics, aka the \"undeniables\". If it were possible to\n// mix-and-match them from different contexts, that would enable some\n// attacks.\nfunction createUnsafeRec(unsafeGlobal, allShims = []) {\n  const sharedGlobalDescs = getSharedGlobalDescs(unsafeGlobal);\n\n  return freeze({\n    unsafeGlobal,\n    sharedGlobalDescs,\n    unsafeEval: unsafeGlobal.eval,\n    unsafeFunction: unsafeGlobal.Function,\n    allShims\n  });\n}\n\nconst repairAccessorsShim = cleanupSource(\n  `\"use strict\"; (${repairAccessors})();`\n);\nconst repairFunctionsShim = cleanupSource(\n  `\"use strict\"; const globalEval = eval; (${repairFunctions})();`\n);\n\n// Create a new unsafeRec from a brand new context, with new intrinsics and a\n// new global object\nexport function createNewUnsafeRec(allShims) {\n  const unsafeGlobal = getNewUnsafeGlobal();\n  unsafeGlobal.eval(repairAccessorsShim);\n  unsafeGlobal.eval(repairFunctionsShim);\n  return createUnsafeRec(unsafeGlobal, allShims);\n}\n\n// Create a new unsafeRec from the current context, where the Realm shim is\n// being parsed and executed, aka the \"Primal Realm\"\nexport function createCurrentUnsafeRec() {\n  const unsafeGlobal = (0, eval)(unsafeGlobalSrc);\n  repairAccessors();\n  repairFunctions();\n  return createUnsafeRec(unsafeGlobal);\n}\n","import {\n  arrayFilter,\n  getOwnPropertyDescriptors,\n  getOwnPropertyNames,\n  objectHasOwnProperty,\n  regexpTest\n} from './commons';\n\n// todo: think about how this interacts with endowments, check for conflicts\n// between the names being optimized and the ones added by endowments\n\n/**\n * Simplified validation of indentifier names: may only contain alphanumeric\n * characters (or \"$\" or \"_\"), and may not start with a digit. This is safe\n * and does not reduces the compatibility of the shim. The motivation for\n * this limitation was to decrease the complexity of the implementation,\n * and to maintain a resonable level of performance.\n * Note: \\w is equivalent [a-zA-Z_0-9]\n * See 11.6.1 Identifier Names\n */\nconst identifierPattern = /^[a-zA-Z_$][\\w$]*$/;\n\n/**\n * In JavaScript you cannot use these reserved words as variables.\n * See 11.6.1 Identifier Names\n */\nconst keywords = new Set([\n  // 11.6.2.1 Keywords\n  'await',\n  'break',\n  'case',\n  'catch',\n  'class',\n  'const',\n  'continue',\n  'debugger',\n  'default',\n  'delete',\n  'do',\n  'else',\n  'export',\n  'extends',\n  'finally',\n  'for',\n  'function',\n  'if',\n  'import',\n  'in',\n  'instanceof',\n  'new',\n  'return',\n  'super',\n  'switch',\n  'this',\n  'throw',\n  'try',\n  'typeof',\n  'var',\n  'void',\n  'while',\n  'with',\n  'yield',\n\n  // Also reserved when parsing strict mode code\n  'let',\n  'static',\n\n  // 11.6.2.2 Future Reserved Words\n  'enum',\n\n  // Also reserved when parsing strict mode code\n  'implements',\n  'package',\n  'protected',\n  'interface',\n  'private',\n  'public',\n\n  // Reserved but not mentioned in specs\n  'await',\n\n  'null',\n  'true',\n  'false',\n\n  'this',\n  'arguments'\n]);\n\n/**\n * getOptimizableGlobals()\n * What variable names might it bring into scope? These include all\n * property names which can be variable names, including the names\n * of inherited properties. It excludes symbols and names which are\n * keywords. We drop symbols safely. Currently, this shim refuses\n * service if any of the names are keywords or keyword-like. This is\n * safe and only prevent performance optimization.\n */\nexport function getOptimizableGlobals(safeGlobal) {\n  const descs = getOwnPropertyDescriptors(safeGlobal);\n\n  // getOwnPropertyNames does ignore Symbols so we don't need this extra check:\n  // typeof name === 'string' &&\n  const constants = arrayFilter(getOwnPropertyNames(descs), name => {\n    // Ensure we have a valid identifier. We use regexpTest rather than\n    // /../.test() to guard against the case where RegExp has been poisoned.\n    if (\n      name === 'eval' ||\n      keywords.has(name) ||\n      !regexpTest(identifierPattern, name)\n    ) {\n      return false;\n    }\n\n    const desc = descs[name];\n    return (\n      //\n      // The getters will not have .writable, don't let the falsyness of\n      // 'undefined' trick us: test with === false, not ! . However descriptors\n      // inherit from the (potentially poisoned) global object, so we might see\n      // extra properties which weren't really there. Accessor properties have\n      // 'get/set/enumerable/configurable', while data properties have\n      // 'value/writable/enumerable/configurable'.\n      desc.configurable === false &&\n      desc.writable === false &&\n      //\n      // Checks for data properties because they're the only ones we can\n      // optimize (accessors are most likely non-constant). Descriptors can't\n      // can't have accessors and value properties at the same time, therefore\n      // this check is sufficient. Using explicit own property deal with the\n      // case where Object.prototype has been poisoned.\n      objectHasOwnProperty(desc, 'value')\n    );\n  });\n\n  return constants;\n}\n","import { freeze, objectHasOwnProperty } from './commons';\nimport { throwTantrum } from './utilities';\n\n/**\n * alwaysThrowHandler is a proxy handler which throws on any trap called.\n * It's made from a proxy with a get trap that throws. Its target is\n * an immutable (frozen) object and is safe to share.\n */\nconst alwaysThrowHandler = new Proxy(freeze({}), {\n  get(target, prop) {\n    throwTantrum(`unexpected scope handler trap called: ${prop}`);\n  }\n});\n\n/**\n * ScopeHandler manages a Proxy which serves as the global scope for the\n * safeEvaluator operation (the Proxy is the argument of a 'with' binding).\n * As described in createSafeEvaluator(), it has several functions:\n * - allow the very first (and only the very first) use of 'eval' to map to\n *   the real (unsafe) eval function, so it acts as a 'direct eval' and can\n *    access its lexical scope (which maps to the 'with' binding, which the\n *   ScopeHandler also controls).\n * - ensure that all subsequent uses of 'eval' map to the safeEvaluator,\n *   which lives as the 'eval' property of the safeGlobal.\n * - route all other property lookups at the safeGlobal.\n * - hide the unsafeGlobal which lives on the scope chain above the 'with'.\n * - ensure the Proxy invariants despite some global properties being frozen.\n */\nexport function createScopeHandler(unsafeRec, safeGlobal, sloppyGlobals) {\n  const { unsafeGlobal, unsafeEval } = unsafeRec;\n\n  // This flag allow us to determine if the eval() call is an done by the\n  // realm's code or if it is user-land invocation, so we can react differently.\n  let useUnsafeEvaluator = false;\n\n  return {\n    // The scope handler throws if any trap other than get/set/has are run\n    // (e.g. getOwnPropertyDescriptors, apply, getPrototypeOf).\n    // eslint-disable-next-line no-proto\n    __proto__: alwaysThrowHandler,\n\n    allowUnsafeEvaluatorOnce() {\n      useUnsafeEvaluator = true;\n    },\n\n    unsafeEvaluatorAllowed() {\n      return useUnsafeEvaluator;\n    },\n\n    get(target, prop) {\n      // Special treatment for eval. The very first lookup of 'eval' gets the\n      // unsafe (real direct) eval, so it will get the lexical scope that uses\n      // the 'with' context.\n      if (prop === 'eval') {\n        // test that it is true rather than merely truthy\n        if (useUnsafeEvaluator === true) {\n          // revoke before use\n          useUnsafeEvaluator = false;\n          return unsafeEval;\n        }\n        return target.eval;\n      }\n\n      // todo: shim integrity, capture Symbol.unscopables\n      if (prop === Symbol.unscopables) {\n        // Safe to return a primal realm Object here because the only code that\n        // can do a get() on a non-string is the internals of with() itself,\n        // and the only thing it does is to look for properties on it. User\n        // code cannot do a lookup on non-strings.\n        return undefined;\n      }\n\n      // Properties of the global.\n      if (prop in target) {\n        return target[prop];\n      }\n\n      // Prevent the lookup for other properties.\n      return undefined;\n    },\n\n    // eslint-disable-next-line class-methods-use-this\n    set(target, prop, value) {\n      // todo: allow modifications when target.hasOwnProperty(prop) and it\n      // is writable, assuming we've already rejected overlap (see\n      // createSafeEvaluatorFactory.factory). This TypeError gets replaced with\n      // target[prop] = value\n      if (objectHasOwnProperty(target, prop)) {\n        // todo: shim integrity: TypeError, String\n        throw new TypeError(`do not modify endowments like ${String(prop)}`);\n      }\n\n      safeGlobal[prop] = value;\n\n      // Return true after successful set.\n      return true;\n    },\n\n    // we need has() to return false for some names to prevent the lookup  from\n    // climbing the scope chain and eventually reaching the unsafeGlobal\n    // object, which is bad.\n\n    // note: unscopables! every string in Object[Symbol.unscopables]\n\n    // todo: we'd like to just have has() return true for everything, and then\n    // use get() to raise a ReferenceError for anything not on the safe global.\n    // But we want to be compatible with ReferenceError in the normal case and\n    // the lack of ReferenceError in the 'typeof' case. Must either reliably\n    // distinguish these two cases (the trap behavior might be different), or\n    // we rely on a mandatory source-to-source transform to change 'typeof abc'\n    // to XXX. We already need a mandatory parse to prevent the 'import',\n    // since it's a special form instead of merely being a global variable/\n\n    // note: if we make has() return true always, then we must implement a\n    // set() trap to avoid subverting the protection of strict mode (it would\n    // accept assignments to undefined globals, when it ought to throw\n    // ReferenceError for such assignments)\n\n    has(target, prop) {\n      // proxies stringify 'prop', so no TOCTTOU danger here\n\n      if (sloppyGlobals) {\n        // Everything is potentially available.\n        return true;\n      }\n\n      // unsafeGlobal: hide all properties of unsafeGlobal at the\n      // expense of 'typeof' being wrong for those properties. For\n      // example, in the browser, evaluating 'document = 3', will add\n      // a property to safeGlobal instead of throwing a\n      // ReferenceError.\n      if (prop === 'eval' || prop in target || prop in unsafeGlobal) {\n        return true;\n      }\n\n      return false;\n    }\n  };\n}\n","// https://www.ecma-international.org/ecma-262/9.0/index.html#sec-html-like-comments\n// explains that JavaScript parsers may or may not recognize html\n// comment tokens \"<\" immediately followed by \"!--\" and \"--\"\n// immediately followed by \">\" in non-module source text, and treat\n// them as a kind of line comment. Since otherwise both of these can\n// appear in normal JavaScript source code as a sequence of operators,\n// we have the terrifying possibility of the same source code parsing\n// one way on one correct JavaScript implementation, and another way\n// on another.\n//\n// This shim takes the conservative strategy of just rejecting source\n// text that contains these strings anywhere. Note that this very\n// source file is written strangely to avoid mentioning these\n// character strings explicitly.\n\n// We do not write the regexp in a straightforward way, so that an\n// apparennt html comment does not appear in this file. Thus, we avoid\n// rejection by the overly eager rejectDangerousSources.\nconst htmlCommentPattern = new RegExp(`(?:${'<'}!--|--${'>'})`);\n\nfunction rejectHtmlComments(s) {\n  const index = s.search(htmlCommentPattern);\n  if (index !== -1) {\n    const linenum = s.slice(0, index).split('\\n').length; // more or less\n    throw new SyntaxError(\n      `possible html comment syntax rejected around line ${linenum}`\n    );\n  }\n}\n\n// The proposed dynamic import expression is the only syntax currently\n// proposed, that can appear in non-module JavaScript code, that\n// enables direct access to the outside world that cannot be\n// surpressed or intercepted without parsing and rewriting. Instead,\n// this shim conservatively rejects any source text that seems to\n// contain such an expression. To do this safely without parsing, we\n// must also reject some valid programs, i.e., those containing\n// apparent import expressions in literal strings or comments.\n\n// The current conservative rule looks for the identifier \"import\"\n// followed by either an open paren or something that looks like the\n// beginning of a comment. We assume that we do not need to worry\n// about html comment syntax because that was already rejected by\n// rejectHtmlComments.\n\n// this \\s *must* match all kinds of syntax-defined whitespace. If e.g.\n// U+2028 (LINE SEPARATOR) or U+2029 (PARAGRAPH SEPARATOR) is treated as\n// whitespace by the parser, but not matched by /\\s/, then this would admit\n// an attack like: import\\u2028('power.js') . We're trying to distinguish\n// something like that from something like importnotreally('power.js') which\n// is perfectly safe.\n\nconst importPattern = /\\bimport\\s*(?:\\(|\\/[/*])/;\n\nfunction rejectImportExpressions(s) {\n  const index = s.search(importPattern);\n  if (index !== -1) {\n    const linenum = s.slice(0, index).split('\\n').length; // more or less\n    throw new SyntaxError(\n      `possible import expression rejected around line ${linenum}`\n    );\n  }\n}\n\n// The shim cannot correctly emulate a direct eval as explained at\n// https://github.com/Agoric/realms-shim/issues/12\n// Without rejecting apparent direct eval syntax, we would\n// accidentally evaluate these with an emulation of indirect eval. Tp\n// prevent future compatibility problems, in shifting from use of the\n// shim to genuine platform support for the proposal, we should\n// instead statically reject code that seems to contain a direct eval\n// expression.\n//\n// As with the dynamic import expression, to avoid a full parse, we do\n// this approximately with a regexp, that will also reject strings\n// that appear safely in comments or strings. Unlike dynamic import,\n// if we miss some, this only creates future compat problems, not\n// security problems. Thus, we are only trying to catch innocent\n// occurrences, not malicious one. In particular, `(eval)(...)` is\n// direct eval syntax that would not be caught by the following regexp.\n\nconst someDirectEvalPattern = /\\beval\\s*(?:\\(|\\/[/*])/;\n\nfunction rejectSomeDirectEvalExpressions(s) {\n  const index = s.search(someDirectEvalPattern);\n  if (index !== -1) {\n    const linenum = s.slice(0, index).split('\\n').length; // more or less\n    throw new SyntaxError(\n      `possible direct eval expression rejected around line ${linenum}`\n    );\n  }\n}\n\nexport function rejectDangerousSources(s) {\n  rejectHtmlComments(s);\n  rejectImportExpressions(s);\n  rejectSomeDirectEvalExpressions(s);\n}\n\n// Export a rewriter transform.\nexport const rejectDangerousSourcesTransform = {\n  rewrite(rs) {\n    rejectDangerousSources(rs.src);\n    return rs;\n  }\n};\n","// Portions adapted from V8 - Copyright 2016 the V8 project authors.\n// https://github.com/v8/v8/blob/master/src/builtins/builtins-function.cc\n\nimport {\n  apply,\n  arrayJoin,\n  arrayPop,\n  create,\n  defineProperties,\n  getOwnPropertyDescriptors,\n  getPrototypeOf,\n  regexpTest,\n  setPrototypeOf,\n  stringIncludes\n} from './commons';\nimport { getOptimizableGlobals } from './optimizer';\nimport { createScopeHandler } from './scopeHandler';\nimport { rejectDangerousSourcesTransform } from './sourceParser';\nimport { assert, throwTantrum } from './utilities';\n\nfunction buildOptimizer(constants) {\n  // No need to build an oprimizer when there are no constants.\n  if (constants.length === 0) return '';\n  // Use 'this' to avoid going through the scope proxy, which is unecessary\n  // since the optimizer only needs references to the safe global.\n  return `const {${arrayJoin(constants, ',')}} = this;`;\n}\n\nfunction createScopedEvaluatorFactory(unsafeRec, constants) {\n  const { unsafeFunction } = unsafeRec;\n\n  const optimizer = buildOptimizer(constants);\n\n  // Create a function in sloppy mode, so that we can use 'with'. It returns\n  // a function in strict mode that evaluates the provided code using direct\n  // eval, and thus in strict mode in the same scope. We must be very careful\n  // to not create new names in this scope\n\n  // 1: we use 'with' (around a Proxy) to catch all free variable names. The\n  // first 'arguments[0]' holds the Proxy which safely wraps the safeGlobal\n  // 2: 'optimizer' catches common variable names for speed\n  // 3: The inner strict function is effectively passed two parameters:\n  //    a) its arguments[0] is the source to be directly evaluated.\n  //    b) its 'this' is the this binding seen by the code being\n  //       directly evaluated.\n\n  // everything in the 'optimizer' string is looked up in the proxy\n  // (including an 'arguments[0]', which points at the Proxy). 'function' is\n  // a keyword, not a variable, so it is not looked up. then 'eval' is looked\n  // up in the proxy, that's the first time it is looked up after\n  // useUnsafeEvaluator is turned on, so the proxy returns the real the\n  // unsafeEval, which satisfies the IsDirectEvalTrap predicate, so it uses\n  // the direct eval and gets the lexical scope. The second 'arguments[0]' is\n  // looked up in the context of the inner function. The *contents* of\n  // arguments[0], because we're using direct eval, are looked up in the\n  // Proxy, by which point the useUnsafeEvaluator switch has been flipped\n  // back to 'false', so any instances of 'eval' in that string will get the\n  // safe evaluator.\n\n  return unsafeFunction(`\n    with (arguments[0]) {\n      ${optimizer}\n      return function() {\n        'use strict';\n        return eval(arguments[0]);\n      };\n    }\n  `);\n}\n\nexport function createSafeEvaluatorFactory(\n  unsafeRec,\n  safeGlobal,\n  transforms,\n  sloppyGlobals\n) {\n  const { unsafeFunction } = unsafeRec;\n\n  const constants = getOptimizableGlobals(safeGlobal);\n  const scopedEvaluatorFactory = createScopedEvaluatorFactory(\n    unsafeRec,\n    constants\n  );\n\n  function factory(endowments = {}, options = {}) {\n    const localTransforms = options.transforms || [];\n    const realmTransforms = transforms || [];\n\n    const mandatoryTransforms = [rejectDangerousSourcesTransform];\n    const allTransforms = [\n      ...localTransforms,\n      ...realmTransforms,\n      ...mandatoryTransforms\n    ];\n\n    // We use the the concise method syntax to create an eval without a\n    // [[Construct]] behavior (such that the invocation \"new eval()\" throws\n    // TypeError: eval is not a constructor\"), but which still accepts a\n    // 'this' binding.\n    const safeEval = {\n      eval(src) {\n        src = `${src}`;\n        // Rewrite the source, threading through rewriter state as necessary.\n        const rewriterState = allTransforms.reduce(\n          (rs, transform) => (transform.rewrite ? transform.rewrite(rs) : rs),\n          { src, endowments }\n        );\n        src = rewriterState.src;\n\n        const scopeTarget = create(\n          safeGlobal,\n          getOwnPropertyDescriptors(rewriterState.endowments)\n        );\n\n        const scopeHandler = createScopeHandler(\n          unsafeRec,\n          safeGlobal,\n          sloppyGlobals\n        );\n        const scopeProxy = new Proxy(scopeTarget, scopeHandler);\n        const scopedEvaluator = apply(scopedEvaluatorFactory, safeGlobal, [\n          scopeProxy\n        ]);\n\n        scopeHandler.allowUnsafeEvaluatorOnce();\n        let err;\n        try {\n          // Ensure that \"this\" resolves to the safe global.\n          return apply(scopedEvaluator, safeGlobal, [src]);\n        } catch (e) {\n          // stash the child-code error in hopes of debugging the internal failure\n          err = e;\n          throw e;\n        } finally {\n          // belt and suspenders: the proxy switches this off immediately after\n          // the first access, but if that's not the case we abort.\n          if (scopeHandler.unsafeEvaluatorAllowed()) {\n            throwTantrum('handler did not revoke useUnsafeEvaluator', err);\n          }\n        }\n      }\n    }.eval;\n\n    // safeEval's prototype is currently the primal realm's\n    // Function.prototype, which we must not let escape. To make 'eval\n    // instanceof Function' be true inside the realm, we need to point it at\n    // the RootRealm's value.\n\n    // Ensure that eval from any compartment in a root realm is an instance\n    // of Function in any compartment of the same root realm.\n    setPrototypeOf(safeEval, unsafeFunction.prototype);\n\n    assert(getPrototypeOf(safeEval).constructor !== Function, 'hide Function');\n    assert(\n      getPrototypeOf(safeEval).constructor !== unsafeFunction,\n      'hide unsafeFunction'\n    );\n\n    // note: be careful to not leak our primal Function.prototype by setting\n    // this to a plain arrow function. Now that we have safeEval, use it.\n    defineProperties(safeEval, {\n      toString: {\n        // We break up the following literal string so that an\n        // apparent direct eval syntax does not appear in this\n        // file. Thus, we avoid rejection by the overly eager\n        // rejectDangerousSources.\n        value: safeEval(\"() => 'function eval' + '() { [shim code] }'\"),\n        writable: false,\n        enumerable: false,\n        configurable: true\n      }\n    });\n\n    return safeEval;\n  }\n\n  return factory;\n}\n\nexport function createSafeEvaluator(safeEvaluatorFactory) {\n  return safeEvaluatorFactory();\n}\n\nexport function createSafeEvaluatorWhichTakesEndowments(safeEvaluatorFactory) {\n  return (x, endowments, options = {}) =>\n    safeEvaluatorFactory(endowments, options)(x);\n}\n\n/**\n * A safe version of the native Function which relies on\n * the safety of evalEvaluator for confinement.\n */\nexport function createFunctionEvaluator(unsafeRec, safeEval) {\n  const { unsafeFunction, unsafeGlobal } = unsafeRec;\n\n  const safeFunction = function Function(...params) {\n    const functionBody = `${arrayPop(params) || ''}`;\n    let functionParams = `${arrayJoin(params, ',')}`;\n    if (!regexpTest(/^[\\w\\s,]*$/, functionParams)) {\n      throw new unsafeGlobal.SyntaxError(\n        'shim limitation: Function arg must be simple ASCII identifiers, possibly separated by commas: no default values, pattern matches, or non-ASCII parameter names'\n      );\n      // this protects against Matt Austin's clever attack:\n      // Function(\"arg=`\", \"/*body`){});({x: this/**/\")\n      // which would turn into\n      //     (function(arg=`\n      //     /*``*/){\n      //      /*body`){});({x: this/**/\n      //     })\n      // which parses as a default argument of `\\n/*``*/){\\n/*body` , which\n      // is a pair of template literals back-to-back (so the first one\n      // nominally evaluates to the parser to use on the second one), which\n      // can't actually execute (because the first literal evals to a string,\n      // which can't be a parser function), but that doesn't matter because\n      // the function is bypassed entirely. When that gets evaluated, it\n      // defines (but does not invoke) a function, then evaluates a simple\n      // {x: this} expression, giving access to the safe global.\n    }\n\n    // Is this a real functionBody, or is someone attempting an injection\n    // attack? This will throw a SyntaxError if the string is not actually a\n    // function body. We coerce the body into a real string above to prevent\n    // someone from passing an object with a toString() that returns a safe\n    // string the first time, but an evil string the second time.\n    // eslint-disable-next-line no-new, new-cap\n    new unsafeFunction(functionBody);\n\n    if (stringIncludes(functionParams, ')')) {\n      // If the formal parameters string include ) - an illegal\n      // character - it may make the combined function expression\n      // compile. We avoid this problem by checking for this early on.\n\n      // note: v8 throws just like this does, but chrome accepts\n      // e.g. 'a = new Date()'\n      throw new unsafeGlobal.SyntaxError(\n        'shim limitation: Function arg string contains parenthesis'\n      );\n      // todo: shim integrity threat if they change SyntaxError\n    }\n\n    // todo: check to make sure this .length is safe. markm says safe.\n    if (functionParams.length > 0) {\n      // If the formal parameters include an unbalanced block comment, the\n      // function must be rejected. Since JavaScript does not allow nested\n      // comments we can include a trailing block comment to catch this.\n      functionParams += '\\n/*``*/';\n    }\n\n    const src = `(function(${functionParams}){\\n${functionBody}\\n})`;\n\n    return safeEval(src);\n  };\n\n  // Ensure that Function from any compartment in a root realm can be used\n  // with instance checks in any compartment of the same root realm.\n  setPrototypeOf(safeFunction, unsafeFunction.prototype);\n\n  assert(\n    getPrototypeOf(safeFunction).constructor !== Function,\n    'hide Function'\n  );\n  assert(\n    getPrototypeOf(safeFunction).constructor !== unsafeFunction,\n    'hide unsafeFunction'\n  );\n\n  defineProperties(safeFunction, {\n    // Ensure that any function created in any compartment in a root realm is an\n    // instance of Function in any compartment of the same root ralm.\n    prototype: { value: unsafeFunction.prototype },\n\n    // Provide a custom output without overwriting the\n    // Function.prototype.toString which is called by some third-party\n    // libraries.\n    toString: {\n      value: safeEval(\"() => 'function Function() { [shim code] }'\"),\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  return safeFunction;\n}\n","import { createRealmFacade, buildChildRealm } from './realmFacade';\nimport { createNewUnsafeRec, createCurrentUnsafeRec } from './unsafeRec';\nimport {\n  createSafeEvaluatorFactory,\n  createSafeEvaluator,\n  createSafeEvaluatorWhichTakesEndowments,\n  createFunctionEvaluator\n} from './evaluators';\nimport { assert } from './utilities';\nimport { create, defineProperties, freeze, arrayConcat } from './commons';\n\n// Mimic private members on the realm instances.\n// We define it in the same module and do not export it.\nconst RealmRecForRealmInstance = new WeakMap();\n\nfunction getRealmRecForRealmInstance(realm) {\n  // Detect non-objects.\n  assert(Object(realm) === realm, 'bad object, not a Realm instance');\n  // Realm instance has no realmRec. Should not proceed.\n  assert(RealmRecForRealmInstance.has(realm), 'Realm instance has no record');\n\n  return RealmRecForRealmInstance.get(realm);\n}\n\nfunction registerRealmRecForRealmInstance(realm, realmRec) {\n  // Detect non-objects.\n  assert(Object(realm) === realm, 'bad object, not a Realm instance');\n  // Attempt to change an existing realmRec on a realm instance. Should not proceed.\n  assert(\n    !RealmRecForRealmInstance.has(realm),\n    'Realm instance already has a record'\n  );\n\n  RealmRecForRealmInstance.set(realm, realmRec);\n}\n\n// Initialize the global variables for the new Realm.\nfunction setDefaultBindings(safeGlobal, safeEval, safeFunction) {\n  defineProperties(safeGlobal, {\n    eval: {\n      value: safeEval,\n      writable: true,\n      configurable: true\n    },\n    Function: {\n      value: safeFunction,\n      writable: true,\n      configurable: true\n    }\n  });\n}\n\nfunction createRealmRec(unsafeRec, transforms, sloppyGlobals) {\n  const { sharedGlobalDescs, unsafeGlobal } = unsafeRec;\n\n  const safeGlobal = create(unsafeGlobal.Object.prototype, sharedGlobalDescs);\n\n  const safeEvaluatorFactory = createSafeEvaluatorFactory(\n    unsafeRec,\n    safeGlobal,\n    transforms,\n    sloppyGlobals\n  );\n  const safeEval = createSafeEvaluator(safeEvaluatorFactory);\n  const safeEvalWhichTakesEndowments = createSafeEvaluatorWhichTakesEndowments(\n    safeEvaluatorFactory\n  );\n  const safeFunction = createFunctionEvaluator(unsafeRec, safeEval);\n\n  setDefaultBindings(safeGlobal, safeEval, safeFunction);\n\n  const realmRec = freeze({\n    safeGlobal,\n    safeEval,\n    safeEvalWhichTakesEndowments,\n    safeFunction\n  });\n\n  return realmRec;\n}\n\n/**\n * A root realm uses a fresh set of new intrinics. Here we first create\n * a new unsafe record, which inherits the shims. Then we proceed with\n * the creation of the realm record, and we apply the shims.\n */\nfunction initRootRealm(parentUnsafeRec, self, options) {\n  // note: 'self' is the instance of the Realm.\n\n  // todo: investigate attacks via Array.species\n  // todo: this accepts newShims='string', but it should reject that\n  const { shims: newShims, transforms, sloppyGlobals } = options;\n  const allShims = arrayConcat(parentUnsafeRec.allShims, newShims);\n\n  // The unsafe record is created already repaired.\n  const unsafeRec = createNewUnsafeRec(allShims);\n\n  // eslint-disable-next-line no-use-before-define\n  const Realm = createRealmFacade(unsafeRec, BaseRealm);\n\n  // Add a Realm descriptor to sharedGlobalDescs, so it can be defined onto the\n  // safeGlobal like the rest of the globals.\n  unsafeRec.sharedGlobalDescs.Realm = {\n    value: Realm,\n    writable: true,\n    configurable: true\n  };\n\n  // Creating the realmRec provides the global object, eval() and Function()\n  // to the realm.\n  const realmRec = createRealmRec(unsafeRec, transforms, sloppyGlobals);\n\n  // Apply all shims in the new RootRealm. We don't do this for compartments.\n  const { safeEvalWhichTakesEndowments } = realmRec;\n  for (const shim of allShims) {\n    safeEvalWhichTakesEndowments(shim);\n  }\n\n  // The realmRec acts as a private field on the realm instance.\n  registerRealmRecForRealmInstance(self, realmRec);\n}\n\n/**\n * A compartment shares the intrinsics of its root realm. Here, only a\n * realmRec is necessary to hold the global object, eval() and Function().\n */\nfunction initCompartment(unsafeRec, self, options = {}) {\n  // note: 'self' is the instance of the Realm.\n\n  const { transforms, sloppyGlobals } = options;\n  const realmRec = createRealmRec(unsafeRec, transforms, sloppyGlobals);\n\n  // The realmRec acts as a private field on the realm instance.\n  registerRealmRecForRealmInstance(self, realmRec);\n}\n\nfunction getRealmGlobal(self) {\n  const { safeGlobal } = getRealmRecForRealmInstance(self);\n  return safeGlobal;\n}\n\nfunction realmEvaluate(self, x, endowments = {}, options = {}) {\n  // todo: don't pass in primal-realm objects like {}, for safety. OTOH its\n  // properties are copied onto the new global 'target'.\n  // todo: figure out a way to membrane away the contents to safety.\n  const { safeEvalWhichTakesEndowments } = getRealmRecForRealmInstance(self);\n  return safeEvalWhichTakesEndowments(x, endowments, options);\n}\n\nconst BaseRealm = {\n  initRootRealm,\n  initCompartment,\n  getRealmGlobal,\n  realmEvaluate\n};\n\n// Create the current unsafeRec from the current \"primal\" environment (the realm\n// where the Realm shim is loaded and executed).\nconst currentUnsafeRec = createCurrentUnsafeRec();\n\n/**\n * The \"primal\" realm class is defined in the current \"primal\" environment,\n * and is part of the shim. There is no need to facade this class via evaluation\n * because both share the same intrinsics.\n */\nconst Realm = buildChildRealm(currentUnsafeRec, BaseRealm);\n\nexport default Realm;\n"],"names":[],"mappings":"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"}
##############################################
/src/dist/realms-shim.esm.js-144-
/src/dist/realms-shim.esm.js:145:    evaluate(x, endowments, options = {}) {
/src/dist/realms-shim.esm.js-146-      // safe against strange 'this', as above
##############################################
/src/dist/realms-shim.esm.js-275-
/src/dist/realms-shim.esm.js:276:  // 'eval', // comes from safeEval instead
/src/dist/realms-shim.esm.js-277-  'isFinite',
##############################################
/src/dist/realms-shim.esm.js-517- * After this block is done, the originals must no longer be reachable, unless
/src/dist/realms-shim.esm.js:518: * a copy has been made, and funtions can only be created by syntax (using eval)
/src/dist/realms-shim.esm.js-519- * or by invoking a previously saved reference to the originals.
##############################################
/src/dist/realms-shim.esm.js-522-// todo: this file should be moved out to a separate repo and npm module.
/src/dist/realms-shim.esm.js:523:const globalEval = eval;
/src/dist/realms-shim.esm.js-524-function repairFunctions() {
##############################################
/src/dist/realms-shim.esm.js-528-   * The process to repair constructors:
/src/dist/realms-shim.esm.js:529:   * 1. Create an instance of the function by evaluating syntax
/src/dist/realms-shim.esm.js-530-   * 2. Obtain the prototype from the instance
##############################################
/src/dist/realms-shim.esm.js-551-
/src/dist/realms-shim.esm.js:552:    // Prevents the evaluation of source when calling constructor on the
/src/dist/realms-shim.esm.js-553-    // prototype of functions.
##############################################
/src/dist/realms-shim.esm.js-610-// note: in a node module, the top-level 'this' is not the global object
/src/dist/realms-shim.esm.js:611:// (it's *something* but we aren't sure what), however an indirect eval of
/src/dist/realms-shim.esm.js-612-// 'this' will be the correct global object.
##############################################
/src/dist/realms-shim.esm.js-614-const unsafeGlobalSrc = "'use strict'; this";
/src/dist/realms-shim.esm.js:615:const unsafeGlobalEvalSrc = `(0, eval)("'use strict'; this")`;
/src/dist/realms-shim.esm.js-616-
##############################################
/src/dist/realms-shim.esm.js-645-  }
/src/dist/realms-shim.esm.js:646:  const iframe = document.createElement('iframe');
/src/dist/realms-shim.esm.js-647-  iframe.style.display = 'none';
/src/dist/realms-shim.esm.js-648-
/src/dist/realms-shim.esm.js:649:  document.body.appendChild(iframe);
/src/dist/realms-shim.esm.js:650:  const unsafeGlobal = iframe.contentWindow.eval(unsafeGlobalSrc);
/src/dist/realms-shim.esm.js-651-
/src/dist/realms-shim.esm.js-652-  // We keep the iframe attached to the DOM because removing it
/src/dist/realms-shim.esm.js:653:  // causes its global object to lose intrinsics, its eval()
/src/dist/realms-shim.esm.js:654:  // function to evaluate code, etc.
/src/dist/realms-shim.esm.js-655-
##############################################
/src/dist/realms-shim.esm.js-673-// The unsafeRec is shim-specific. It acts as the mechanism to obtain a fresh
/src/dist/realms-shim.esm.js:674:// set of intrinsics together with their associated eval and Function
/src/dist/realms-shim.esm.js:675:// evaluators. These must be used as a matched set, since the evaluators are
/src/dist/realms-shim.esm.js-676-// tied to a set of intrinsics, aka the "undeniables". If it were possible to
##############################################
/src/dist/realms-shim.esm.js-684-    sharedGlobalDescs,
/src/dist/realms-shim.esm.js:685:    unsafeEval: unsafeGlobal.eval,
/src/dist/realms-shim.esm.js-686-    unsafeFunction: unsafeGlobal.Function,
##############################################
/src/dist/realms-shim.esm.js-694-const repairFunctionsShim = cleanupSource(
/src/dist/realms-shim.esm.js:695:  `"use strict"; const globalEval = eval; (${repairFunctions})();`
/src/dist/realms-shim.esm.js-696-);
##############################################
/src/dist/realms-shim.esm.js-701-  const unsafeGlobal = getNewUnsafeGlobal();
/src/dist/realms-shim.esm.js:702:  unsafeGlobal.eval(repairAccessorsShim);
/src/dist/realms-shim.esm.js:703:  unsafeGlobal.eval(repairFunctionsShim);
/src/dist/realms-shim.esm.js-704-  return createUnsafeRec(unsafeGlobal, allShims);
##############################################
/src/dist/realms-shim.esm.js-709-function createCurrentUnsafeRec() {
/src/dist/realms-shim.esm.js:710:  const unsafeGlobal = (0, eval)(unsafeGlobalSrc);
/src/dist/realms-shim.esm.js-711-  repairAccessors();
##############################################
/src/dist/realms-shim.esm.js-814-    if (
/src/dist/realms-shim.esm.js:815:      name === 'eval' ||
/src/dist/realms-shim.esm.js-816-      keywords.has(name) ||
##############################################
/src/dist/realms-shim.esm.js-860- * As described in createSafeEvaluator(), it has several functions:
/src/dist/realms-shim.esm.js:861: * - allow the very first (and only the very first) use of 'eval' to map to
/src/dist/realms-shim.esm.js:862: *   the real (unsafe) eval function, so it acts as a 'direct eval' and can
/src/dist/realms-shim.esm.js-863- *    access its lexical scope (which maps to the 'with' binding, which the
/src/dist/realms-shim.esm.js-864- *   ScopeHandler also controls).
/src/dist/realms-shim.esm.js:865: * - ensure that all subsequent uses of 'eval' map to the safeEvaluator,
/src/dist/realms-shim.esm.js:866: *   which lives as the 'eval' property of the safeGlobal.
/src/dist/realms-shim.esm.js-867- * - route all other property lookups at the safeGlobal.
##############################################
/src/dist/realms-shim.esm.js-873-
/src/dist/realms-shim.esm.js:874:  // This flag allow us to determine if the eval() call is an done by the
/src/dist/realms-shim.esm.js-875-  // realm's code or if it is user-land invocation, so we can react differently.
##############################################
/src/dist/realms-shim.esm.js-892-    get(target, prop) {
/src/dist/realms-shim.esm.js:893:      // Special treatment for eval. The very first lookup of 'eval' gets the
/src/dist/realms-shim.esm.js:894:      // unsafe (real direct) eval, so it will get the lexical scope that uses
/src/dist/realms-shim.esm.js-895-      // the 'with' context.
/src/dist/realms-shim.esm.js:896:      if (prop === 'eval') {
/src/dist/realms-shim.esm.js-897-        // test that it is true rather than merely truthy
##############################################
/src/dist/realms-shim.esm.js-902-        }
/src/dist/realms-shim.esm.js:903:        return target.eval;
/src/dist/realms-shim.esm.js-904-      }
##############################################
/src/dist/realms-shim.esm.js-970-      // expense of 'typeof' being wrong for those properties. For
/src/dist/realms-shim.esm.js:971:      // example, in the browser, evaluating 'document = 3', will add
/src/dist/realms-shim.esm.js-972-      // a property to safeGlobal instead of throwing a
/src/dist/realms-shim.esm.js-973-      // ReferenceError.
/src/dist/realms-shim.esm.js:974:      if (prop === 'eval' || prop in target || prop in unsafeGlobal) {
/src/dist/realms-shim.esm.js-975-        return true;
##############################################
/src/dist/realms-shim.esm.js-1046-
/src/dist/realms-shim.esm.js:1047:// The shim cannot correctly emulate a direct eval as explained at
/src/dist/realms-shim.esm.js-1048-// https://github.com/Agoric/realms-shim/issues/12
/src/dist/realms-shim.esm.js:1049:// Without rejecting apparent direct eval syntax, we would
/src/dist/realms-shim.esm.js:1050:// accidentally evaluate these with an emulation of indirect eval. Tp
/src/dist/realms-shim.esm.js-1051-// prevent future compatibility problems, in shifting from use of the
/src/dist/realms-shim.esm.js-1052-// shim to genuine platform support for the proposal, we should
/src/dist/realms-shim.esm.js:1053:// instead statically reject code that seems to contain a direct eval
/src/dist/realms-shim.esm.js-1054-// expression.
##############################################
/src/dist/realms-shim.esm.js-1060-// security problems. Thus, we are only trying to catch innocent
/src/dist/realms-shim.esm.js:1061:// occurrences, not malicious one. In particular, `(eval)(...)` is
/src/dist/realms-shim.esm.js:1062:// direct eval syntax that would not be caught by the following regexp.
/src/dist/realms-shim.esm.js-1063-
/src/dist/realms-shim.esm.js:1064:const someDirectEvalPattern = /\beval\s*(?:\(|\/[/*])/;
/src/dist/realms-shim.esm.js-1065-
##############################################
/src/dist/realms-shim.esm.js-1070-    throw new SyntaxError(
/src/dist/realms-shim.esm.js:1071:      `possible direct eval expression rejected around line ${linenum}`
/src/dist/realms-shim.esm.js-1072-    );
##############################################
/src/dist/realms-shim.esm.js-1105-  // Create a function in sloppy mode, so that we can use 'with'. It returns
/src/dist/realms-shim.esm.js:1106:  // a function in strict mode that evaluates the provided code using direct
/src/dist/realms-shim.esm.js:1107:  // eval, and thus in strict mode in the same scope. We must be very careful
/src/dist/realms-shim.esm.js-1108-  // to not create new names in this scope
##############################################
/src/dist/realms-shim.esm.js-1113-  // 3: The inner strict function is effectively passed two parameters:
/src/dist/realms-shim.esm.js:1114:  //    a) its arguments[0] is the source to be directly evaluated.
/src/dist/realms-shim.esm.js-1115-  //    b) its 'this' is the this binding seen by the code being
/src/dist/realms-shim.esm.js:1116:  //       directly evaluated.
/src/dist/realms-shim.esm.js-1117-
##############################################
/src/dist/realms-shim.esm.js-1119-  // (including an 'arguments[0]', which points at the Proxy). 'function' is
/src/dist/realms-shim.esm.js:1120:  // a keyword, not a variable, so it is not looked up. then 'eval' is looked
/src/dist/realms-shim.esm.js-1121-  // up in the proxy, that's the first time it is looked up after
##############################################
/src/dist/realms-shim.esm.js-1123-  // unsafeEval, which satisfies the IsDirectEvalTrap predicate, so it uses
/src/dist/realms-shim.esm.js:1124:  // the direct eval and gets the lexical scope. The second 'arguments[0]' is
/src/dist/realms-shim.esm.js-1125-  // looked up in the context of the inner function. The *contents* of
/src/dist/realms-shim.esm.js:1126:  // arguments[0], because we're using direct eval, are looked up in the
/src/dist/realms-shim.esm.js-1127-  // Proxy, by which point the useUnsafeEvaluator switch has been flipped
/src/dist/realms-shim.esm.js:1128:  // back to 'false', so any instances of 'eval' in that string will get the
/src/dist/realms-shim.esm.js:1129:  // safe evaluator.
/src/dist/realms-shim.esm.js-1130-
##############################################
/src/dist/realms-shim.esm.js-1135-        'use strict';
/src/dist/realms-shim.esm.js:1136:        return eval(arguments[0]);
/src/dist/realms-shim.esm.js-1137-      };
##############################################
/src/dist/realms-shim.esm.js-1166-
/src/dist/realms-shim.esm.js:1167:    // We use the the concise method syntax to create an eval without a
/src/dist/realms-shim.esm.js:1168:    // [[Construct]] behavior (such that the invocation "new eval()" throws
/src/dist/realms-shim.esm.js:1169:    // TypeError: eval is not a constructor"), but which still accepts a
/src/dist/realms-shim.esm.js-1170-    // 'this' binding.
/src/dist/realms-shim.esm.js-1171-    const safeEval = {
/src/dist/realms-shim.esm.js:1172:      eval(src) {
/src/dist/realms-shim.esm.js-1173-        src = `${src}`;
##############################################
/src/dist/realms-shim.esm.js-1212-      }
/src/dist/realms-shim.esm.js:1213:    }.eval;
/src/dist/realms-shim.esm.js-1214-
/src/dist/realms-shim.esm.js-1215-    // safeEval's prototype is currently the primal realm's
/src/dist/realms-shim.esm.js:1216:    // Function.prototype, which we must not let escape. To make 'eval
/src/dist/realms-shim.esm.js-1217-    // instanceof Function' be true inside the realm, we need to point it at
##############################################
/src/dist/realms-shim.esm.js-1219-
/src/dist/realms-shim.esm.js:1220:    // Ensure that eval from any compartment in a root realm is an instance
/src/dist/realms-shim.esm.js-1221-    // of Function in any compartment of the same root realm.
##############################################
/src/dist/realms-shim.esm.js-1234-        // We break up the following literal string so that an
/src/dist/realms-shim.esm.js:1235:        // apparent direct eval syntax does not appear in this
/src/dist/realms-shim.esm.js-1236-        // file. Thus, we avoid rejection by the overly eager
/src/dist/realms-shim.esm.js-1237-        // rejectDangerousSources.
/src/dist/realms-shim.esm.js:1238:        value: safeEval("() => 'function eval' + '() { [shim code] }'"),
/src/dist/realms-shim.esm.js-1239-        writable: false,
##############################################
/src/dist/realms-shim.esm.js-1261- * A safe version of the native Function which relies on
/src/dist/realms-shim.esm.js:1262: * the safety of evalEvaluator for confinement.
/src/dist/realms-shim.esm.js-1263- */
##############################################
/src/dist/realms-shim.esm.js-1282-      // is a pair of template literals back-to-back (so the first one
/src/dist/realms-shim.esm.js:1283:      // nominally evaluates to the parser to use on the second one), which
/src/dist/realms-shim.esm.js:1284:      // can't actually execute (because the first literal evals to a string,
/src/dist/realms-shim.esm.js-1285-      // which can't be a parser function), but that doesn't matter because
/src/dist/realms-shim.esm.js:1286:      // the function is bypassed entirely. When that gets evaluated, it
/src/dist/realms-shim.esm.js:1287:      // defines (but does not invoke) a function, then evaluates a simple
/src/dist/realms-shim.esm.js-1288-      // {x: this} expression, giving access to the safe global.
##############################################
/src/dist/realms-shim.esm.js-1384-  defineProperties(safeGlobal, {
/src/dist/realms-shim.esm.js:1385:    eval: {
/src/dist/realms-shim.esm.js-1386-      value: safeEval,
##############################################
/src/dist/realms-shim.esm.js-1453-
/src/dist/realms-shim.esm.js:1454:  // Creating the realmRec provides the global object, eval() and Function()
/src/dist/realms-shim.esm.js-1455-  // to the realm.
##############################################
/src/dist/realms-shim.esm.js-1469- * A compartment shares the intrinsics of its root realm. Here, only a
/src/dist/realms-shim.esm.js:1470: * realmRec is necessary to hold the global object, eval() and Function().
/src/dist/realms-shim.esm.js-1471- */
##############################################
/src/dist/realms-shim.esm.js-1507- * The "primal" realm class is defined in the current "primal" environment,
/src/dist/realms-shim.esm.js:1508: * and is part of the shim. There is no need to facade this class via evaluation
/src/dist/realms-shim.esm.js-1509- * because both share the same intrinsics.
##############################################
/src/dist/realms-shim.umd.js-150-
/src/dist/realms-shim.umd.js:151:      evaluate(x, endowments, options = {}) {
/src/dist/realms-shim.umd.js-152-        // safe against strange 'this', as above
##############################################
/src/dist/realms-shim.umd.js-281-
/src/dist/realms-shim.umd.js:282:    // 'eval', // comes from safeEval instead
/src/dist/realms-shim.umd.js-283-    'isFinite',
##############################################
/src/dist/realms-shim.umd.js-523-   * After this block is done, the originals must no longer be reachable, unless
/src/dist/realms-shim.umd.js:524:   * a copy has been made, and funtions can only be created by syntax (using eval)
/src/dist/realms-shim.umd.js-525-   * or by invoking a previously saved reference to the originals.
##############################################
/src/dist/realms-shim.umd.js-528-  // todo: this file should be moved out to a separate repo and npm module.
/src/dist/realms-shim.umd.js:529:  const globalEval = eval;
/src/dist/realms-shim.umd.js-530-  function repairFunctions() {
##############################################
/src/dist/realms-shim.umd.js-534-     * The process to repair constructors:
/src/dist/realms-shim.umd.js:535:     * 1. Create an instance of the function by evaluating syntax
/src/dist/realms-shim.umd.js-536-     * 2. Obtain the prototype from the instance
##############################################
/src/dist/realms-shim.umd.js-557-
/src/dist/realms-shim.umd.js:558:      // Prevents the evaluation of source when calling constructor on the
/src/dist/realms-shim.umd.js-559-      // prototype of functions.
##############################################
/src/dist/realms-shim.umd.js-616-  // note: in a node module, the top-level 'this' is not the global object
/src/dist/realms-shim.umd.js:617:  // (it's *something* but we aren't sure what), however an indirect eval of
/src/dist/realms-shim.umd.js-618-  // 'this' will be the correct global object.
##############################################
/src/dist/realms-shim.umd.js-620-  const unsafeGlobalSrc = "'use strict'; this";
/src/dist/realms-shim.umd.js:621:  const unsafeGlobalEvalSrc = `(0, eval)("'use strict'; this")`;
/src/dist/realms-shim.umd.js-622-
##############################################
/src/dist/realms-shim.umd.js-651-    }
/src/dist/realms-shim.umd.js:652:    const iframe = document.createElement('iframe');
/src/dist/realms-shim.umd.js-653-    iframe.style.display = 'none';
/src/dist/realms-shim.umd.js-654-
/src/dist/realms-shim.umd.js:655:    document.body.appendChild(iframe);
/src/dist/realms-shim.umd.js:656:    const unsafeGlobal = iframe.contentWindow.eval(unsafeGlobalSrc);
/src/dist/realms-shim.umd.js-657-
/src/dist/realms-shim.umd.js-658-    // We keep the iframe attached to the DOM because removing it
/src/dist/realms-shim.umd.js:659:    // causes its global object to lose intrinsics, its eval()
/src/dist/realms-shim.umd.js:660:    // function to evaluate code, etc.
/src/dist/realms-shim.umd.js-661-
##############################################
/src/dist/realms-shim.umd.js-679-  // The unsafeRec is shim-specific. It acts as the mechanism to obtain a fresh
/src/dist/realms-shim.umd.js:680:  // set of intrinsics together with their associated eval and Function
/src/dist/realms-shim.umd.js:681:  // evaluators. These must be used as a matched set, since the evaluators are
/src/dist/realms-shim.umd.js-682-  // tied to a set of intrinsics, aka the "undeniables". If it were possible to
##############################################
/src/dist/realms-shim.umd.js-690-      sharedGlobalDescs,
/src/dist/realms-shim.umd.js:691:      unsafeEval: unsafeGlobal.eval,
/src/dist/realms-shim.umd.js-692-      unsafeFunction: unsafeGlobal.Function,
##############################################
/src/dist/realms-shim.umd.js-700-  const repairFunctionsShim = cleanupSource(
/src/dist/realms-shim.umd.js:701:    `"use strict"; const globalEval = eval; (${repairFunctions})();`
/src/dist/realms-shim.umd.js-702-  );
##############################################
/src/dist/realms-shim.umd.js-707-    const unsafeGlobal = getNewUnsafeGlobal();
/src/dist/realms-shim.umd.js:708:    unsafeGlobal.eval(repairAccessorsShim);
/src/dist/realms-shim.umd.js:709:    unsafeGlobal.eval(repairFunctionsShim);
/src/dist/realms-shim.umd.js-710-    return createUnsafeRec(unsafeGlobal, allShims);
##############################################
/src/dist/realms-shim.umd.js-715-  function createCurrentUnsafeRec() {
/src/dist/realms-shim.umd.js:716:    const unsafeGlobal = (0, eval)(unsafeGlobalSrc);
/src/dist/realms-shim.umd.js-717-    repairAccessors();
##############################################
/src/dist/realms-shim.umd.js-820-      if (
/src/dist/realms-shim.umd.js:821:        name === 'eval' ||
/src/dist/realms-shim.umd.js-822-        keywords.has(name) ||
##############################################
/src/dist/realms-shim.umd.js-866-   * As described in createSafeEvaluator(), it has several functions:
/src/dist/realms-shim.umd.js:867:   * - allow the very first (and only the very first) use of 'eval' to map to
/src/dist/realms-shim.umd.js:868:   *   the real (unsafe) eval function, so it acts as a 'direct eval' and can
/src/dist/realms-shim.umd.js-869-   *    access its lexical scope (which maps to the 'with' binding, which the
/src/dist/realms-shim.umd.js-870-   *   ScopeHandler also controls).
/src/dist/realms-shim.umd.js:871:   * - ensure that all subsequent uses of 'eval' map to the safeEvaluator,
/src/dist/realms-shim.umd.js:872:   *   which lives as the 'eval' property of the safeGlobal.
/src/dist/realms-shim.umd.js-873-   * - route all other property lookups at the safeGlobal.
##############################################
/src/dist/realms-shim.umd.js-879-
/src/dist/realms-shim.umd.js:880:    // This flag allow us to determine if the eval() call is an done by the
/src/dist/realms-shim.umd.js-881-    // realm's code or if it is user-land invocation, so we can react differently.
##############################################
/src/dist/realms-shim.umd.js-898-      get(target, prop) {
/src/dist/realms-shim.umd.js:899:        // Special treatment for eval. The very first lookup of 'eval' gets the
/src/dist/realms-shim.umd.js:900:        // unsafe (real direct) eval, so it will get the lexical scope that uses
/src/dist/realms-shim.umd.js-901-        // the 'with' context.
/src/dist/realms-shim.umd.js:902:        if (prop === 'eval') {
/src/dist/realms-shim.umd.js-903-          // test that it is true rather than merely truthy
##############################################
/src/dist/realms-shim.umd.js-908-          }
/src/dist/realms-shim.umd.js:909:          return target.eval;
/src/dist/realms-shim.umd.js-910-        }
##############################################
/src/dist/realms-shim.umd.js-976-        // expense of 'typeof' being wrong for those properties. For
/src/dist/realms-shim.umd.js:977:        // example, in the browser, evaluating 'document = 3', will add
/src/dist/realms-shim.umd.js-978-        // a property to safeGlobal instead of throwing a
/src/dist/realms-shim.umd.js-979-        // ReferenceError.
/src/dist/realms-shim.umd.js:980:        if (prop === 'eval' || prop in target || prop in unsafeGlobal) {
/src/dist/realms-shim.umd.js-981-          return true;
##############################################
/src/dist/realms-shim.umd.js-1052-
/src/dist/realms-shim.umd.js:1053:  // The shim cannot correctly emulate a direct eval as explained at
/src/dist/realms-shim.umd.js-1054-  // https://github.com/Agoric/realms-shim/issues/12
/src/dist/realms-shim.umd.js:1055:  // Without rejecting apparent direct eval syntax, we would
/src/dist/realms-shim.umd.js:1056:  // accidentally evaluate these with an emulation of indirect eval. Tp
/src/dist/realms-shim.umd.js-1057-  // prevent future compatibility problems, in shifting from use of the
/src/dist/realms-shim.umd.js-1058-  // shim to genuine platform support for the proposal, we should
/src/dist/realms-shim.umd.js:1059:  // instead statically reject code that seems to contain a direct eval
/src/dist/realms-shim.umd.js-1060-  // expression.
##############################################
/src/dist/realms-shim.umd.js-1066-  // security problems. Thus, we are only trying to catch innocent
/src/dist/realms-shim.umd.js:1067:  // occurrences, not malicious one. In particular, `(eval)(...)` is
/src/dist/realms-shim.umd.js:1068:  // direct eval syntax that would not be caught by the following regexp.
/src/dist/realms-shim.umd.js-1069-
/src/dist/realms-shim.umd.js:1070:  const someDirectEvalPattern = /\beval\s*(?:\(|\/[/*])/;
/src/dist/realms-shim.umd.js-1071-
##############################################
/src/dist/realms-shim.umd.js-1076-      throw new SyntaxError(
/src/dist/realms-shim.umd.js:1077:        `possible direct eval expression rejected around line ${linenum}`
/src/dist/realms-shim.umd.js-1078-      );
##############################################
/src/dist/realms-shim.umd.js-1111-    // Create a function in sloppy mode, so that we can use 'with'. It returns
/src/dist/realms-shim.umd.js:1112:    // a function in strict mode that evaluates the provided code using direct
/src/dist/realms-shim.umd.js:1113:    // eval, and thus in strict mode in the same scope. We must be very careful
/src/dist/realms-shim.umd.js-1114-    // to not create new names in this scope
##############################################
/src/dist/realms-shim.umd.js-1119-    // 3: The inner strict function is effectively passed two parameters:
/src/dist/realms-shim.umd.js:1120:    //    a) its arguments[0] is the source to be directly evaluated.
/src/dist/realms-shim.umd.js-1121-    //    b) its 'this' is the this binding seen by the code being
/src/dist/realms-shim.umd.js:1122:    //       directly evaluated.
/src/dist/realms-shim.umd.js-1123-
##############################################
/src/dist/realms-shim.umd.js-1125-    // (including an 'arguments[0]', which points at the Proxy). 'function' is
/src/dist/realms-shim.umd.js:1126:    // a keyword, not a variable, so it is not looked up. then 'eval' is looked
/src/dist/realms-shim.umd.js-1127-    // up in the proxy, that's the first time it is looked up after
##############################################
/src/dist/realms-shim.umd.js-1129-    // unsafeEval, which satisfies the IsDirectEvalTrap predicate, so it uses
/src/dist/realms-shim.umd.js:1130:    // the direct eval and gets the lexical scope. The second 'arguments[0]' is
/src/dist/realms-shim.umd.js-1131-    // looked up in the context of the inner function. The *contents* of
/src/dist/realms-shim.umd.js:1132:    // arguments[0], because we're using direct eval, are looked up in the
/src/dist/realms-shim.umd.js-1133-    // Proxy, by which point the useUnsafeEvaluator switch has been flipped
/src/dist/realms-shim.umd.js:1134:    // back to 'false', so any instances of 'eval' in that string will get the
/src/dist/realms-shim.umd.js:1135:    // safe evaluator.
/src/dist/realms-shim.umd.js-1136-
##############################################
/src/dist/realms-shim.umd.js-1141-        'use strict';
/src/dist/realms-shim.umd.js:1142:        return eval(arguments[0]);
/src/dist/realms-shim.umd.js-1143-      };
##############################################
/src/dist/realms-shim.umd.js-1172-
/src/dist/realms-shim.umd.js:1173:      // We use the the concise method syntax to create an eval without a
/src/dist/realms-shim.umd.js:1174:      // [[Construct]] behavior (such that the invocation "new eval()" throws
/src/dist/realms-shim.umd.js:1175:      // TypeError: eval is not a constructor"), but which still accepts a
/src/dist/realms-shim.umd.js-1176-      // 'this' binding.
/src/dist/realms-shim.umd.js-1177-      const safeEval = {
/src/dist/realms-shim.umd.js:1178:        eval(src) {
/src/dist/realms-shim.umd.js-1179-          src = `${src}`;
##############################################
/src/dist/realms-shim.umd.js-1218-        }
/src/dist/realms-shim.umd.js:1219:      }.eval;
/src/dist/realms-shim.umd.js-1220-
/src/dist/realms-shim.umd.js-1221-      // safeEval's prototype is currently the primal realm's
/src/dist/realms-shim.umd.js:1222:      // Function.prototype, which we must not let escape. To make 'eval
/src/dist/realms-shim.umd.js-1223-      // instanceof Function' be true inside the realm, we need to point it at
##############################################
/src/dist/realms-shim.umd.js-1225-
/src/dist/realms-shim.umd.js:1226:      // Ensure that eval from any compartment in a root realm is an instance
/src/dist/realms-shim.umd.js-1227-      // of Function in any compartment of the same root realm.
##############################################
/src/dist/realms-shim.umd.js-1240-          // We break up the following literal string so that an
/src/dist/realms-shim.umd.js:1241:          // apparent direct eval syntax does not appear in this
/src/dist/realms-shim.umd.js-1242-          // file. Thus, we avoid rejection by the overly eager
/src/dist/realms-shim.umd.js-1243-          // rejectDangerousSources.
/src/dist/realms-shim.umd.js:1244:          value: safeEval("() => 'function eval' + '() { [shim code] }'"),
/src/dist/realms-shim.umd.js-1245-          writable: false,
##############################################
/src/dist/realms-shim.umd.js-1267-   * A safe version of the native Function which relies on
/src/dist/realms-shim.umd.js:1268:   * the safety of evalEvaluator for confinement.
/src/dist/realms-shim.umd.js-1269-   */
##############################################
/src/dist/realms-shim.umd.js-1288-        // is a pair of template literals back-to-back (so the first one
/src/dist/realms-shim.umd.js:1289:        // nominally evaluates to the parser to use on the second one), which
/src/dist/realms-shim.umd.js:1290:        // can't actually execute (because the first literal evals to a string,
/src/dist/realms-shim.umd.js-1291-        // which can't be a parser function), but that doesn't matter because
/src/dist/realms-shim.umd.js:1292:        // the function is bypassed entirely. When that gets evaluated, it
/src/dist/realms-shim.umd.js:1293:        // defines (but does not invoke) a function, then evaluates a simple
/src/dist/realms-shim.umd.js-1294-        // {x: this} expression, giving access to the safe global.
##############################################
/src/dist/realms-shim.umd.js-1390-    defineProperties(safeGlobal, {
/src/dist/realms-shim.umd.js:1391:      eval: {
/src/dist/realms-shim.umd.js-1392-        value: safeEval,
##############################################
/src/dist/realms-shim.umd.js-1459-
/src/dist/realms-shim.umd.js:1460:    // Creating the realmRec provides the global object, eval() and Function()
/src/dist/realms-shim.umd.js-1461-    // to the realm.
##############################################
/src/dist/realms-shim.umd.js-1475-   * A compartment shares the intrinsics of its root realm. Here, only a
/src/dist/realms-shim.umd.js:1476:   * realmRec is necessary to hold the global object, eval() and Function().
/src/dist/realms-shim.umd.js-1477-   */
##############################################
/src/dist/realms-shim.umd.js-1513-   * The "primal" realm class is defined in the current "primal" environment,
/src/dist/realms-shim.umd.js:1514:   * and is part of the shim. There is no need to facade this class via evaluation
/src/dist/realms-shim.umd.js-1515-   * because both share the same intrinsics.
##############################################
/src/dist/realms-shim.umd.js.map:1:{"version":3,"file":"realms-shim.umd.js","sources":["../src/utilities.js","../src/realmFacade.js","../src/commons.js","../src/stdlib.js","../src/repair/accessors.js","../src/repair/functions.js","../src/unsafeRec.js","../src/optimizer.js","../src/scopeHandler.js","../src/sourceParser.js","../src/evaluators.js","../src/realm.js"],"sourcesContent":["// we'd like to abandon, but we can't, so just scream and break a lot of\n// stuff. However, since we aren't really aborting the process, be careful to\n// not throw an Error object which could be captured by child-Realm code and\n// used to access the (too-powerful) primal-realm Error object.\n\nexport function throwTantrum(s, err = undefined) {\n  const msg = `please report internal shim error: ${s}`;\n\n  // we want to log these 'should never happen' things.\n  // eslint-disable-next-line no-console\n  console.error(msg);\n  if (err) {\n    // eslint-disable-next-line no-console\n    console.error(`${err}`);\n    // eslint-disable-next-line no-console\n    console.error(`${err.stack}`);\n  }\n\n  // eslint-disable-next-line no-debugger\n  debugger;\n  throw msg;\n}\n\nexport function assert(condition, message) {\n  if (!condition) {\n    throwTantrum(message);\n  }\n}\n\n// Remove code modifications.\nexport function cleanupSource(src) {\n  /* START_TESTS_ONLY */\n\n  // Restore eval which is modified by esm module.\n  src = src.replace(/\\(0,[^)]+\\)/g, '(0, eval)');\n\n  // Remove code coverage which is injected by nyc module.\n  src = src.replace(/cov_[^+]+\\+\\+[;,]/g, '');\n\n  /* END_TESTS_ONLY */\n  return src;\n}\n","import { cleanupSource } from './utilities';\n\n// buildChildRealm is immediately turned into a string, and this function is\n// never referenced again, because it closes over the wrong intrinsics\n\nexport function buildChildRealm(unsafeRec, BaseRealm) {\n  const {\n    initRootRealm,\n    initCompartment,\n    getRealmGlobal,\n    realmEvaluate\n  } = BaseRealm;\n\n  // This Object and Reflect are brand new, from a new unsafeRec, so no user\n  // code has been run or had a chance to manipulate them. We extract these\n  // properties for brevity, not for security. Don't ever run this function\n  // *after* user code has had a chance to pollute its environment, or it\n  // could be used to gain access to BaseRealm and primal-realm Error\n  // objects.\n  const { create, defineProperties } = Object;\n\n  const errorConstructors = new Map([\n    ['EvalError', EvalError],\n    ['RangeError', RangeError],\n    ['ReferenceError', ReferenceError],\n    ['SyntaxError', SyntaxError],\n    ['TypeError', TypeError],\n    ['URIError', URIError]\n  ]);\n\n  // Like Realm.apply except that it catches anything thrown and rethrows it\n  // as an Error from this realm\n  function callAndWrapError(target, ...args) {\n    try {\n      return target(...args);\n    } catch (err) {\n      if (Object(err) !== err) {\n        // err is a primitive value, which is safe to rethrow\n        throw err;\n      }\n      let eName, eMessage, eStack;\n      try {\n        // The child environment might seek to use 'err' to reach the\n        // parent's intrinsics and corrupt them. `${err.name}` will cause\n        // string coercion of 'err.name'. If err.name is an object (probably\n        // a String of the parent Realm), the coercion uses\n        // err.name.toString(), which is under the control of the parent. If\n        // err.name were a primitive (e.g. a number), it would use\n        // Number.toString(err.name), using the child's version of Number\n        // (which the child could modify to capture its argument for later\n        // use), however primitives don't have properties like .prototype so\n        // they aren't useful for an attack.\n        eName = `${err.name}`;\n        eMessage = `${err.message}`;\n        eStack = `${err.stack || eMessage}`;\n        // eName/eMessage/eStack are now child-realm primitive strings, and\n        // safe to expose\n      } catch (ignored) {\n        // if err.name.toString() throws, keep the (parent realm) Error away\n        // from the child\n        throw new Error('unknown error');\n      }\n      const ErrorConstructor = errorConstructors.get(eName) || Error;\n      try {\n        throw new ErrorConstructor(eMessage);\n      } catch (err2) {\n        err2.stack = eStack; // replace with the captured inner stack\n        throw err2;\n      }\n    }\n  }\n\n  class Realm {\n    constructor() {\n      // The Realm constructor is not intended to be used with the new operator\n      // or to be subclassed. It may be used as the value of an extends clause\n      // of a class definition but a super call to the Realm constructor will\n      // cause an exception.\n\n      // When Realm is called as a function, an exception is also raised because\n      // a class constructor cannot be invoked without 'new'.\n      throw new TypeError('Realm is not a constructor');\n    }\n\n    static makeRootRealm(options = {}) {\n      // This is the exposed interface.\n\n      // Bypass the constructor.\n      const r = create(Realm.prototype);\n      callAndWrapError(initRootRealm, unsafeRec, r, options);\n      return r;\n    }\n\n    static makeCompartment(options = {}) {\n      // Bypass the constructor.\n      const r = create(Realm.prototype);\n      callAndWrapError(initCompartment, unsafeRec, r, options);\n      return r;\n    }\n\n    // we omit the constructor because it is empty. All the personalization\n    // takes place in one of the two static methods,\n    // makeRootRealm/makeCompartment\n\n    get global() {\n      // this is safe against being called with strange 'this' because\n      // baseGetGlobal immediately does a trademark check (it fails unless\n      // this 'this' is present in a weakmap that is only populated with\n      // legitimate Realm instances)\n      return callAndWrapError(getRealmGlobal, this);\n    }\n\n    evaluate(x, endowments, options = {}) {\n      // safe against strange 'this', as above\n      return callAndWrapError(realmEvaluate, this, x, endowments, options);\n    }\n  }\n\n  defineProperties(Realm, {\n    toString: {\n      value: () => 'function Realm() { [shim code] }',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  defineProperties(Realm.prototype, {\n    toString: {\n      value: () => '[object Realm]',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  return Realm;\n}\n\n// The parentheses means we don't bind the 'buildChildRealm' name inside the\n// child's namespace. this would accept an anonymous function declaration.\n// function expression (not a declaration) so it has a completion value.\nconst buildChildRealmString = cleanupSource(\n  `'use strict'; (${buildChildRealm})`\n);\n\nexport function createRealmFacade(unsafeRec, BaseRealm) {\n  const { unsafeEval } = unsafeRec;\n\n  // The BaseRealm is the Realm class created by\n  // the shim. It's only valid for the context where\n  // it was parsed.\n\n  // The Realm facade is a lightweight class built in the\n  // context a different context, that provide a fully\n  // functional Realm class using the intrisics\n  // of that context.\n\n  // This process is simplified because all methods\n  // and properties on a realm instance already return\n  // values using the intrinsics of the realm's context.\n\n  // Invoke the BaseRealm constructor with Realm as the prototype.\n  return unsafeEval(buildChildRealmString)(unsafeRec, BaseRealm);\n}\n","// Declare shorthand functions. Sharing these declarations across modules\n// improves both consistency and minification. Unused declarations are\n// dropped by the tree shaking process.\n\n// we capture these, not just for brevity, but for security. If any code\n// modifies Object to change what 'assign' points to, the Realm shim would be\n// corrupted.\n\nexport const {\n  assign,\n  create,\n  freeze,\n  defineProperties, // Object.defineProperty is allowed to fail\n  // silentlty, use Object.defineProperties instead.\n  getOwnPropertyDescriptor,\n  getOwnPropertyDescriptors,\n  getOwnPropertyNames,\n  getPrototypeOf,\n  setPrototypeOf\n} = Object;\n\nexport const {\n  apply,\n  ownKeys // Reflect.ownKeys includes Symbols and unenumerables,\n  // unlike Object.keys()\n} = Reflect;\n\n/**\n * uncurryThis() See\n * http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\n * which only lives at\n * http://web.archive.org/web/20160805225710/http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\n *\n * Performance:\n * 1. The native call is about 10x faster on FF than chrome\n * 2. The version using Function.bind() is about 100x slower on FF,\n *    equal on chrome, 2x slower on Safari\n * 3. The version using a spread and Reflect.apply() is about 10x\n *    slower on FF, equal on chrome, 2x slower on Safari\n *\n * const bind = Function.prototype.bind;\n * const uncurryThis = bind.bind(bind.call);\n */\nconst uncurryThis = fn => (thisArg, ...args) => apply(fn, thisArg, args);\n\n// We also capture these for security: changes to Array.prototype after the\n// Realm shim runs shouldn't affect subsequent Realm operations.\nexport const objectHasOwnProperty = uncurryThis(\n    Object.prototype.hasOwnProperty\n  ),\n  arrayForEach = uncurryThis(Array.prototype.forEach),\n  arrayFilter = uncurryThis(Array.prototype.filter),\n  arrayPush = uncurryThis(Array.prototype.push),\n  arrayPop = uncurryThis(Array.prototype.pop),\n  arrayJoin = uncurryThis(Array.prototype.join),\n  arrayConcat = uncurryThis(Array.prototype.concat),\n  regexpTest = uncurryThis(RegExp.prototype.test),\n  stringMatch = uncurryThis(String.prototype.match),\n  stringIncludes = uncurryThis(String.prototype.includes);\n","import { getOwnPropertyDescriptor } from './commons';\nimport { assert } from './utilities';\n\n// These value properties of the global object are non-writable,\n// non-configurable data properties.\nconst frozenGlobalPropertyNames = [\n  // *** 18.1 Value Properties of the Global Object\n\n  'Infinity',\n  'NaN',\n  'undefined'\n];\n\n// All the following stdlib items have the same name on both our intrinsics\n// object and on the global object. Unlike Infinity/NaN/undefined, these\n// should all be writable and configurable. This is divided into two\n// sets. The stable ones are those the shim can freeze early because\n// we don't expect anyone will want to mutate them. The unstable ones\n// are the ones that we correctly initialize to writable and\n// configurable so that they can still be replaced or removed.\nconst stableGlobalPropertyNames = [\n  // *** 18.2 Function Properties of the Global Object\n\n  // 'eval', // comes from safeEval instead\n  'isFinite',\n  'isNaN',\n  'parseFloat',\n  'parseInt',\n\n  'decodeURI',\n  'decodeURIComponent',\n  'encodeURI',\n  'encodeURIComponent',\n\n  // *** 18.3 Constructor Properties of the Global Object\n\n  'Array',\n  'ArrayBuffer',\n  'Boolean',\n  'DataView',\n  // 'Date',  // Unstable\n  // 'Error',  // Unstable\n  'EvalError',\n  'Float32Array',\n  'Float64Array',\n  // 'Function',  // comes from safeFunction instead\n  'Int8Array',\n  'Int16Array',\n  'Int32Array',\n  'Map',\n  'Number',\n  'Object',\n  // 'Promise',  // Unstable\n  // 'Proxy',  // Unstable\n  'RangeError',\n  'ReferenceError',\n  // 'RegExp',  // Unstable\n  'Set',\n  // 'SharedArrayBuffer'  // removed on Jan 5, 2018\n  'String',\n  'Symbol',\n  'SyntaxError',\n  'TypeError',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Uint16Array',\n  'Uint32Array',\n  'URIError',\n  'WeakMap',\n  'WeakSet',\n\n  // *** 18.4 Other Properties of the Global Object\n\n  // 'Atomics', // removed on Jan 5, 2018\n  'JSON',\n  'Math',\n  'Reflect',\n\n  // *** Annex B\n\n  'escape',\n  'unescape'\n\n  // *** ECMA-402\n\n  // 'Intl'  // Unstable\n\n  // *** ESNext\n\n  // 'Realm' // Comes from createRealmGlobalObject()\n];\n\nconst unstableGlobalPropertyNames = [\n  'Date',\n  'Error',\n  'Promise',\n  'Proxy',\n  'RegExp',\n  'Intl'\n];\n\nexport function getSharedGlobalDescs(unsafeGlobal) {\n  const descriptors = {};\n\n  function describe(names, writable, enumerable, configurable) {\n    for (const name of names) {\n      const desc = getOwnPropertyDescriptor(unsafeGlobal, name);\n      if (desc) {\n        // Abort if an accessor is found on the unsafe global object\n        // instead of a data property. We should never get into this\n        // non standard situation.\n        assert(\n          'value' in desc,\n          `unexpected accessor on global property: ${name}`\n        );\n\n        descriptors[name] = {\n          value: desc.value,\n          writable,\n          enumerable,\n          configurable\n        };\n      }\n    }\n  }\n\n  describe(frozenGlobalPropertyNames, false, false, false);\n  // The following is correct but expensive.\n  // describe(stableGlobalPropertyNames, true, false, true);\n  // Instead, for now, we let these get optimized.\n  //\n  // TODO: We should provide an option to turn this optimization off,\n  // by feeding \"true, false, true\" here instead.\n  describe(stableGlobalPropertyNames, false, false, false);\n  // These we keep replaceable and removable, because we expect\n  // others, e.g., SES, may want to do so.\n  describe(unstableGlobalPropertyNames, true, false, true);\n\n  return descriptors;\n}\n","// Adapted from SES/Caja - Copyright (C) 2011 Google Inc.\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js\n\n/**\n * Replace the legacy accessors of Object to comply with strict mode\n * and ES2016 semantics, we do this by redefining them while in 'use strict'.\n *\n * todo: list the issues resolved\n *\n * This function can be used in two ways: (1) invoked directly to fix the primal\n * realm's Object.prototype, and (2) converted to a string to be executed\n * inside each new RootRealm to fix their Object.prototypes. Evaluation requires\n * the function to have no dependencies, so don't import anything from\n * the outside.\n */\n\n// todo: this file should be moved out to a separate repo and npm module.\nexport function repairAccessors() {\n  const {\n    defineProperty,\n    defineProperties,\n    getOwnPropertyDescriptor,\n    getPrototypeOf,\n    prototype: objectPrototype\n  } = Object;\n\n  // On some platforms, the implementation of these functions act as\n  // if they are in sloppy mode: if they're invoked badly, they will\n  // expose the global object, so we need to repair these for\n  // security. Thus it is our responsibility to fix this, and we need\n  // to include repairAccessors. E.g. Chrome in 2016.\n\n  try {\n    // Verify that the method is not callable.\n    // eslint-disable-next-line no-restricted-properties, no-underscore-dangle\n    (0, objectPrototype.__lookupGetter__)('x');\n  } catch (ignore) {\n    // Throws, no need to patch.\n    return;\n  }\n\n  function toObject(obj) {\n    if (obj === undefined || obj === null) {\n      throw new TypeError(`can't convert undefined or null to object`);\n    }\n    return Object(obj);\n  }\n\n  function asPropertyName(obj) {\n    if (typeof obj === 'symbol') {\n      return obj;\n    }\n    return `${obj}`;\n  }\n\n  function aFunction(obj, accessor) {\n    if (typeof obj !== 'function') {\n      throw TypeError(`invalid ${accessor} usage`);\n    }\n    return obj;\n  }\n\n  defineProperties(objectPrototype, {\n    __defineGetter__: {\n      value: function __defineGetter__(prop, func) {\n        const O = toObject(this);\n        defineProperty(O, prop, {\n          get: aFunction(func, 'getter'),\n          enumerable: true,\n          configurable: true\n        });\n      }\n    },\n    __defineSetter__: {\n      value: function __defineSetter__(prop, func) {\n        const O = toObject(this);\n        defineProperty(O, prop, {\n          set: aFunction(func, 'setter'),\n          enumerable: true,\n          configurable: true\n        });\n      }\n    },\n    __lookupGetter__: {\n      value: function __lookupGetter__(prop) {\n        let O = toObject(this);\n        prop = asPropertyName(prop);\n        let desc;\n        while (O && !(desc = getOwnPropertyDescriptor(O, prop))) {\n          O = getPrototypeOf(O);\n        }\n        return desc && desc.get;\n      }\n    },\n    __lookupSetter__: {\n      value: function __lookupSetter__(prop) {\n        let O = toObject(this);\n        prop = asPropertyName(prop);\n        let desc;\n        while (O && !(desc = getOwnPropertyDescriptor(O, prop))) {\n          O = getPrototypeOf(O);\n        }\n        return desc && desc.set;\n      }\n    }\n  });\n}\n","// Adapted from SES/Caja\n// Copyright (C) 2011 Google Inc.\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js\n\n/**\n * This block replaces the original Function constructor, and the original\n * %GeneratorFunction% %AsyncFunction% and %AsyncGeneratorFunction%, with\n * safe replacements that throw if invoked.\n *\n * These are all reachable via syntax, so it isn't sufficient to just\n * replace global properties with safe versions. Our main goal is to prevent\n * access to the Function constructor through these starting points.\n\n * After this block is done, the originals must no longer be reachable, unless\n * a copy has been made, and funtions can only be created by syntax (using eval)\n * or by invoking a previously saved reference to the originals.\n */\n\n// todo: this file should be moved out to a separate repo and npm module.\nconst globalEval = eval;\nexport function repairFunctions() {\n  const { defineProperties, getPrototypeOf, setPrototypeOf } = Object;\n\n  /**\n   * The process to repair constructors:\n   * 1. Create an instance of the function by evaluating syntax\n   * 2. Obtain the prototype from the instance\n   * 3. Create a substitute tamed constructor\n   * 4. Replace the original constructor with the tamed constructor\n   * 5. Replace tamed constructor prototype property with the original one\n   * 6. Replace its [[Prototype]] slot with the tamed constructor of Function\n   */\n  function repairFunction(name, declaration) {\n    let FunctionInstance;\n    try {\n      // eslint-disable-next-line no-new-func\n      FunctionInstance = globalEval(declaration);\n    } catch (e) {\n      if (e instanceof SyntaxError) {\n        // Prevent failure on platforms where async and/or generators\n        // are not supported.\n        return;\n      }\n      // Re-throw\n      throw e;\n    }\n    const FunctionPrototype = getPrototypeOf(FunctionInstance);\n\n    // Prevents the evaluation of source when calling constructor on the\n    // prototype of functions.\n    const TamedFunction = function() {\n      throw new TypeError('Not available');\n    };\n    defineProperties(TamedFunction, { name: { value: name } });\n\n    // (new Error()).constructors does not inherit from Function, because Error\n    // was defined before ES6 classes. So we don't need to repair it too.\n\n    // (Error()).constructor inherit from Function, which gets a tamed\n    // constructor here.\n\n    // todo: in an ES6 class that does not inherit from anything, what does its\n    // constructor inherit from? We worry that it inherits from Function, in\n    // which case instances could give access to unsafeFunction. markm says\n    // we're fine: the constructor inherits from Object.prototype\n\n    // This line replaces the original constructor in the prototype chain\n    // with the tamed one. No copy of the original is peserved.\n    defineProperties(FunctionPrototype, {\n      constructor: { value: TamedFunction }\n    });\n\n    // This line sets the tamed constructor's prototype data property to\n    // the original one.\n    defineProperties(TamedFunction, {\n      prototype: { value: FunctionPrototype }\n    });\n\n    if (TamedFunction !== Function.prototype.constructor) {\n      // Ensures that all functions meet \"instanceof Function\" in a realm.\n      setPrototypeOf(TamedFunction, Function.prototype.constructor);\n    }\n  }\n\n  // Here, the order of operation is important: Function needs to be repaired\n  // first since the other repaired constructors need to inherit from the tamed\n  // Function function constructor.\n\n  // note: this really wants to be part of the standard, because new\n  // constructors may be added in the future, reachable from syntax, and this\n  // list must be updated to match.\n\n  // \"plain arrow functions\" inherit from Function.prototype\n\n  repairFunction('Function', '(function(){})');\n  repairFunction('GeneratorFunction', '(function*(){})');\n  repairFunction('AsyncFunction', '(async function(){})');\n  repairFunction('AsyncGeneratorFunction', '(async function*(){})');\n}\n","// this module must never be importable outside the Realm shim itself\nimport { getSharedGlobalDescs } from './stdlib';\nimport { repairAccessors } from './repair/accessors';\nimport { repairFunctions } from './repair/functions';\nimport { cleanupSource } from './utilities';\nimport { freeze } from './commons';\n\n// A \"context\" is a fresh unsafe Realm as given to us by existing platforms.\n// We need this to implement the shim. However, when Realms land for real,\n// this feature will be provided by the underlying engine instead.\n\n// note: in a node module, the top-level 'this' is not the global object\n// (it's *something* but we aren't sure what), however an indirect eval of\n// 'this' will be the correct global object.\n\nconst unsafeGlobalSrc = \"'use strict'; this\";\nconst unsafeGlobalEvalSrc = `(0, eval)(\"'use strict'; this\")`;\n\n// This method is only exported for testing purposes.\nexport function createNewUnsafeGlobalForNode() {\n  // Note that webpack and others will shim 'vm' including the method\n  // 'runInNewContext', so the presence of vm is not a useful check\n\n  // TODO: Find a better test that works with bundlers\n  // eslint-disable-next-line no-new-func\n  const isNode = new Function(\n    'try {return this===global}catch(e){return false}'\n  )();\n\n  if (!isNode) {\n    return undefined;\n  }\n\n  // eslint-disable-next-line global-require\n  const vm = require('vm');\n\n  // Use unsafeGlobalEvalSrc to ensure we get the right 'this'.\n  const unsafeGlobal = vm.runInNewContext(unsafeGlobalEvalSrc);\n\n  return unsafeGlobal;\n}\n\n// This method is only exported for testing purposes.\nexport function createNewUnsafeGlobalForBrowser() {\n  if (typeof document === 'undefined') {\n    return undefined;\n  }\n  const iframe = document.createElement('iframe');\n  iframe.style.display = 'none';\n\n  document.body.appendChild(iframe);\n  const unsafeGlobal = iframe.contentWindow.eval(unsafeGlobalSrc);\n\n  // We keep the iframe attached to the DOM because removing it\n  // causes its global object to lose intrinsics, its eval()\n  // function to evaluate code, etc.\n\n  // TODO: can we remove and garbage-collect the iframes?\n\n  return unsafeGlobal;\n}\n\nconst getNewUnsafeGlobal = () => {\n  const newUnsafeGlobalForBrowser = createNewUnsafeGlobalForBrowser();\n  const newUnsafeGlobalForNode = createNewUnsafeGlobalForNode();\n  if (\n    (!newUnsafeGlobalForBrowser && !newUnsafeGlobalForNode) ||\n    (newUnsafeGlobalForBrowser && newUnsafeGlobalForNode)\n  ) {\n    throw new Error('unexpected platform, unable to create Realm');\n  }\n  return newUnsafeGlobalForBrowser || newUnsafeGlobalForNode;\n};\n\n// The unsafeRec is shim-specific. It acts as the mechanism to obtain a fresh\n// set of intrinsics together with their associated eval and Function\n// evaluators. These must be used as a matched set, since the evaluators are\n// tied to a set of intrinsics, aka the \"undeniables\". If it were possible to\n// mix-and-match them from different contexts, that would enable some\n// attacks.\nfunction createUnsafeRec(unsafeGlobal, allShims = []) {\n  const sharedGlobalDescs = getSharedGlobalDescs(unsafeGlobal);\n\n  return freeze({\n    unsafeGlobal,\n    sharedGlobalDescs,\n    unsafeEval: unsafeGlobal.eval,\n    unsafeFunction: unsafeGlobal.Function,\n    allShims\n  });\n}\n\nconst repairAccessorsShim = cleanupSource(\n  `\"use strict\"; (${repairAccessors})();`\n);\nconst repairFunctionsShim = cleanupSource(\n  `\"use strict\"; const globalEval = eval; (${repairFunctions})();`\n);\n\n// Create a new unsafeRec from a brand new context, with new intrinsics and a\n// new global object\nexport function createNewUnsafeRec(allShims) {\n  const unsafeGlobal = getNewUnsafeGlobal();\n  unsafeGlobal.eval(repairAccessorsShim);\n  unsafeGlobal.eval(repairFunctionsShim);\n  return createUnsafeRec(unsafeGlobal, allShims);\n}\n\n// Create a new unsafeRec from the current context, where the Realm shim is\n// being parsed and executed, aka the \"Primal Realm\"\nexport function createCurrentUnsafeRec() {\n  const unsafeGlobal = (0, eval)(unsafeGlobalSrc);\n  repairAccessors();\n  repairFunctions();\n  return createUnsafeRec(unsafeGlobal);\n}\n","import {\n  arrayFilter,\n  getOwnPropertyDescriptors,\n  getOwnPropertyNames,\n  objectHasOwnProperty,\n  regexpTest\n} from './commons';\n\n// todo: think about how this interacts with endowments, check for conflicts\n// between the names being optimized and the ones added by endowments\n\n/**\n * Simplified validation of indentifier names: may only contain alphanumeric\n * characters (or \"$\" or \"_\"), and may not start with a digit. This is safe\n * and does not reduces the compatibility of the shim. The motivation for\n * this limitation was to decrease the complexity of the implementation,\n * and to maintain a resonable level of performance.\n * Note: \\w is equivalent [a-zA-Z_0-9]\n * See 11.6.1 Identifier Names\n */\nconst identifierPattern = /^[a-zA-Z_$][\\w$]*$/;\n\n/**\n * In JavaScript you cannot use these reserved words as variables.\n * See 11.6.1 Identifier Names\n */\nconst keywords = new Set([\n  // 11.6.2.1 Keywords\n  'await',\n  'break',\n  'case',\n  'catch',\n  'class',\n  'const',\n  'continue',\n  'debugger',\n  'default',\n  'delete',\n  'do',\n  'else',\n  'export',\n  'extends',\n  'finally',\n  'for',\n  'function',\n  'if',\n  'import',\n  'in',\n  'instanceof',\n  'new',\n  'return',\n  'super',\n  'switch',\n  'this',\n  'throw',\n  'try',\n  'typeof',\n  'var',\n  'void',\n  'while',\n  'with',\n  'yield',\n\n  // Also reserved when parsing strict mode code\n  'let',\n  'static',\n\n  // 11.6.2.2 Future Reserved Words\n  'enum',\n\n  // Also reserved when parsing strict mode code\n  'implements',\n  'package',\n  'protected',\n  'interface',\n  'private',\n  'public',\n\n  // Reserved but not mentioned in specs\n  'await',\n\n  'null',\n  'true',\n  'false',\n\n  'this',\n  'arguments'\n]);\n\n/**\n * getOptimizableGlobals()\n * What variable names might it bring into scope? These include all\n * property names which can be variable names, including the names\n * of inherited properties. It excludes symbols and names which are\n * keywords. We drop symbols safely. Currently, this shim refuses\n * service if any of the names are keywords or keyword-like. This is\n * safe and only prevent performance optimization.\n */\nexport function getOptimizableGlobals(safeGlobal) {\n  const descs = getOwnPropertyDescriptors(safeGlobal);\n\n  // getOwnPropertyNames does ignore Symbols so we don't need this extra check:\n  // typeof name === 'string' &&\n  const constants = arrayFilter(getOwnPropertyNames(descs), name => {\n    // Ensure we have a valid identifier. We use regexpTest rather than\n    // /../.test() to guard against the case where RegExp has been poisoned.\n    if (\n      name === 'eval' ||\n      keywords.has(name) ||\n      !regexpTest(identifierPattern, name)\n    ) {\n      return false;\n    }\n\n    const desc = descs[name];\n    return (\n      //\n      // The getters will not have .writable, don't let the falsyness of\n      // 'undefined' trick us: test with === false, not ! . However descriptors\n      // inherit from the (potentially poisoned) global object, so we might see\n      // extra properties which weren't really there. Accessor properties have\n      // 'get/set/enumerable/configurable', while data properties have\n      // 'value/writable/enumerable/configurable'.\n      desc.configurable === false &&\n      desc.writable === false &&\n      //\n      // Checks for data properties because they're the only ones we can\n      // optimize (accessors are most likely non-constant). Descriptors can't\n      // can't have accessors and value properties at the same time, therefore\n      // this check is sufficient. Using explicit own property deal with the\n      // case where Object.prototype has been poisoned.\n      objectHasOwnProperty(desc, 'value')\n    );\n  });\n\n  return constants;\n}\n","import { freeze, objectHasOwnProperty } from './commons';\nimport { throwTantrum } from './utilities';\n\n/**\n * alwaysThrowHandler is a proxy handler which throws on any trap called.\n * It's made from a proxy with a get trap that throws. Its target is\n * an immutable (frozen) object and is safe to share.\n */\nconst alwaysThrowHandler = new Proxy(freeze({}), {\n  get(target, prop) {\n    throwTantrum(`unexpected scope handler trap called: ${prop}`);\n  }\n});\n\n/**\n * ScopeHandler manages a Proxy which serves as the global scope for the\n * safeEvaluator operation (the Proxy is the argument of a 'with' binding).\n * As described in createSafeEvaluator(), it has several functions:\n * - allow the very first (and only the very first) use of 'eval' to map to\n *   the real (unsafe) eval function, so it acts as a 'direct eval' and can\n *    access its lexical scope (which maps to the 'with' binding, which the\n *   ScopeHandler also controls).\n * - ensure that all subsequent uses of 'eval' map to the safeEvaluator,\n *   which lives as the 'eval' property of the safeGlobal.\n * - route all other property lookups at the safeGlobal.\n * - hide the unsafeGlobal which lives on the scope chain above the 'with'.\n * - ensure the Proxy invariants despite some global properties being frozen.\n */\nexport function createScopeHandler(unsafeRec, safeGlobal, sloppyGlobals) {\n  const { unsafeGlobal, unsafeEval } = unsafeRec;\n\n  // This flag allow us to determine if the eval() call is an done by the\n  // realm's code or if it is user-land invocation, so we can react differently.\n  let useUnsafeEvaluator = false;\n\n  return {\n    // The scope handler throws if any trap other than get/set/has are run\n    // (e.g. getOwnPropertyDescriptors, apply, getPrototypeOf).\n    // eslint-disable-next-line no-proto\n    __proto__: alwaysThrowHandler,\n\n    allowUnsafeEvaluatorOnce() {\n      useUnsafeEvaluator = true;\n    },\n\n    unsafeEvaluatorAllowed() {\n      return useUnsafeEvaluator;\n    },\n\n    get(target, prop) {\n      // Special treatment for eval. The very first lookup of 'eval' gets the\n      // unsafe (real direct) eval, so it will get the lexical scope that uses\n      // the 'with' context.\n      if (prop === 'eval') {\n        // test that it is true rather than merely truthy\n        if (useUnsafeEvaluator === true) {\n          // revoke before use\n          useUnsafeEvaluator = false;\n          return unsafeEval;\n        }\n        return target.eval;\n      }\n\n      // todo: shim integrity, capture Symbol.unscopables\n      if (prop === Symbol.unscopables) {\n        // Safe to return a primal realm Object here because the only code that\n        // can do a get() on a non-string is the internals of with() itself,\n        // and the only thing it does is to look for properties on it. User\n        // code cannot do a lookup on non-strings.\n        return undefined;\n      }\n\n      // Properties of the global.\n      if (prop in target) {\n        return target[prop];\n      }\n\n      // Prevent the lookup for other properties.\n      return undefined;\n    },\n\n    // eslint-disable-next-line class-methods-use-this\n    set(target, prop, value) {\n      // todo: allow modifications when target.hasOwnProperty(prop) and it\n      // is writable, assuming we've already rejected overlap (see\n      // createSafeEvaluatorFactory.factory). This TypeError gets replaced with\n      // target[prop] = value\n      if (objectHasOwnProperty(target, prop)) {\n        // todo: shim integrity: TypeError, String\n        throw new TypeError(`do not modify endowments like ${String(prop)}`);\n      }\n\n      safeGlobal[prop] = value;\n\n      // Return true after successful set.\n      return true;\n    },\n\n    // we need has() to return false for some names to prevent the lookup  from\n    // climbing the scope chain and eventually reaching the unsafeGlobal\n    // object, which is bad.\n\n    // note: unscopables! every string in Object[Symbol.unscopables]\n\n    // todo: we'd like to just have has() return true for everything, and then\n    // use get() to raise a ReferenceError for anything not on the safe global.\n    // But we want to be compatible with ReferenceError in the normal case and\n    // the lack of ReferenceError in the 'typeof' case. Must either reliably\n    // distinguish these two cases (the trap behavior might be different), or\n    // we rely on a mandatory source-to-source transform to change 'typeof abc'\n    // to XXX. We already need a mandatory parse to prevent the 'import',\n    // since it's a special form instead of merely being a global variable/\n\n    // note: if we make has() return true always, then we must implement a\n    // set() trap to avoid subverting the protection of strict mode (it would\n    // accept assignments to undefined globals, when it ought to throw\n    // ReferenceError for such assignments)\n\n    has(target, prop) {\n      // proxies stringify 'prop', so no TOCTTOU danger here\n\n      if (sloppyGlobals) {\n        // Everything is potentially available.\n        return true;\n      }\n\n      // unsafeGlobal: hide all properties of unsafeGlobal at the\n      // expense of 'typeof' being wrong for those properties. For\n      // example, in the browser, evaluating 'document = 3', will add\n      // a property to safeGlobal instead of throwing a\n      // ReferenceError.\n      if (prop === 'eval' || prop in target || prop in unsafeGlobal) {\n        return true;\n      }\n\n      return false;\n    }\n  };\n}\n","// https://www.ecma-international.org/ecma-262/9.0/index.html#sec-html-like-comments\n// explains that JavaScript parsers may or may not recognize html\n// comment tokens \"<\" immediately followed by \"!--\" and \"--\"\n// immediately followed by \">\" in non-module source text, and treat\n// them as a kind of line comment. Since otherwise both of these can\n// appear in normal JavaScript source code as a sequence of operators,\n// we have the terrifying possibility of the same source code parsing\n// one way on one correct JavaScript implementation, and another way\n// on another.\n//\n// This shim takes the conservative strategy of just rejecting source\n// text that contains these strings anywhere. Note that this very\n// source file is written strangely to avoid mentioning these\n// character strings explicitly.\n\n// We do not write the regexp in a straightforward way, so that an\n// apparennt html comment does not appear in this file. Thus, we avoid\n// rejection by the overly eager rejectDangerousSources.\nconst htmlCommentPattern = new RegExp(`(?:${'<'}!--|--${'>'})`);\n\nfunction rejectHtmlComments(s) {\n  const index = s.search(htmlCommentPattern);\n  if (index !== -1) {\n    const linenum = s.slice(0, index).split('\\n').length; // more or less\n    throw new SyntaxError(\n      `possible html comment syntax rejected around line ${linenum}`\n    );\n  }\n}\n\n// The proposed dynamic import expression is the only syntax currently\n// proposed, that can appear in non-module JavaScript code, that\n// enables direct access to the outside world that cannot be\n// surpressed or intercepted without parsing and rewriting. Instead,\n// this shim conservatively rejects any source text that seems to\n// contain such an expression. To do this safely without parsing, we\n// must also reject some valid programs, i.e., those containing\n// apparent import expressions in literal strings or comments.\n\n// The current conservative rule looks for the identifier \"import\"\n// followed by either an open paren or something that looks like the\n// beginning of a comment. We assume that we do not need to worry\n// about html comment syntax because that was already rejected by\n// rejectHtmlComments.\n\n// this \\s *must* match all kinds of syntax-defined whitespace. If e.g.\n// U+2028 (LINE SEPARATOR) or U+2029 (PARAGRAPH SEPARATOR) is treated as\n// whitespace by the parser, but not matched by /\\s/, then this would admit\n// an attack like: import\\u2028('power.js') . We're trying to distinguish\n// something like that from something like importnotreally('power.js') which\n// is perfectly safe.\n\nconst importPattern = /\\bimport\\s*(?:\\(|\\/[/*])/;\n\nfunction rejectImportExpressions(s) {\n  const index = s.search(importPattern);\n  if (index !== -1) {\n    const linenum = s.slice(0, index).split('\\n').length; // more or less\n    throw new SyntaxError(\n      `possible import expression rejected around line ${linenum}`\n    );\n  }\n}\n\n// The shim cannot correctly emulate a direct eval as explained at\n// https://github.com/Agoric/realms-shim/issues/12\n// Without rejecting apparent direct eval syntax, we would\n// accidentally evaluate these with an emulation of indirect eval. Tp\n// prevent future compatibility problems, in shifting from use of the\n// shim to genuine platform support for the proposal, we should\n// instead statically reject code that seems to contain a direct eval\n// expression.\n//\n// As with the dynamic import expression, to avoid a full parse, we do\n// this approximately with a regexp, that will also reject strings\n// that appear safely in comments or strings. Unlike dynamic import,\n// if we miss some, this only creates future compat problems, not\n// security problems. Thus, we are only trying to catch innocent\n// occurrences, not malicious one. In particular, `(eval)(...)` is\n// direct eval syntax that would not be caught by the following regexp.\n\nconst someDirectEvalPattern = /\\beval\\s*(?:\\(|\\/[/*])/;\n\nfunction rejectSomeDirectEvalExpressions(s) {\n  const index = s.search(someDirectEvalPattern);\n  if (index !== -1) {\n    const linenum = s.slice(0, index).split('\\n').length; // more or less\n    throw new SyntaxError(\n      `possible direct eval expression rejected around line ${linenum}`\n    );\n  }\n}\n\nexport function rejectDangerousSources(s) {\n  rejectHtmlComments(s);\n  rejectImportExpressions(s);\n  rejectSomeDirectEvalExpressions(s);\n}\n\n// Export a rewriter transform.\nexport const rejectDangerousSourcesTransform = {\n  rewrite(rs) {\n    rejectDangerousSources(rs.src);\n    return rs;\n  }\n};\n","// Portions adapted from V8 - Copyright 2016 the V8 project authors.\n// https://github.com/v8/v8/blob/master/src/builtins/builtins-function.cc\n\nimport {\n  apply,\n  arrayJoin,\n  arrayPop,\n  create,\n  defineProperties,\n  getOwnPropertyDescriptors,\n  getPrototypeOf,\n  regexpTest,\n  setPrototypeOf,\n  stringIncludes\n} from './commons';\nimport { getOptimizableGlobals } from './optimizer';\nimport { createScopeHandler } from './scopeHandler';\nimport { rejectDangerousSourcesTransform } from './sourceParser';\nimport { assert, throwTantrum } from './utilities';\n\nfunction buildOptimizer(constants) {\n  // No need to build an oprimizer when there are no constants.\n  if (constants.length === 0) return '';\n  // Use 'this' to avoid going through the scope proxy, which is unecessary\n  // since the optimizer only needs references to the safe global.\n  return `const {${arrayJoin(constants, ',')}} = this;`;\n}\n\nfunction createScopedEvaluatorFactory(unsafeRec, constants) {\n  const { unsafeFunction } = unsafeRec;\n\n  const optimizer = buildOptimizer(constants);\n\n  // Create a function in sloppy mode, so that we can use 'with'. It returns\n  // a function in strict mode that evaluates the provided code using direct\n  // eval, and thus in strict mode in the same scope. We must be very careful\n  // to not create new names in this scope\n\n  // 1: we use 'with' (around a Proxy) to catch all free variable names. The\n  // first 'arguments[0]' holds the Proxy which safely wraps the safeGlobal\n  // 2: 'optimizer' catches common variable names for speed\n  // 3: The inner strict function is effectively passed two parameters:\n  //    a) its arguments[0] is the source to be directly evaluated.\n  //    b) its 'this' is the this binding seen by the code being\n  //       directly evaluated.\n\n  // everything in the 'optimizer' string is looked up in the proxy\n  // (including an 'arguments[0]', which points at the Proxy). 'function' is\n  // a keyword, not a variable, so it is not looked up. then 'eval' is looked\n  // up in the proxy, that's the first time it is looked up after\n  // useUnsafeEvaluator is turned on, so the proxy returns the real the\n  // unsafeEval, which satisfies the IsDirectEvalTrap predicate, so it uses\n  // the direct eval and gets the lexical scope. The second 'arguments[0]' is\n  // looked up in the context of the inner function. The *contents* of\n  // arguments[0], because we're using direct eval, are looked up in the\n  // Proxy, by which point the useUnsafeEvaluator switch has been flipped\n  // back to 'false', so any instances of 'eval' in that string will get the\n  // safe evaluator.\n\n  return unsafeFunction(`\n    with (arguments[0]) {\n      ${optimizer}\n      return function() {\n        'use strict';\n        return eval(arguments[0]);\n      };\n    }\n  `);\n}\n\nexport function createSafeEvaluatorFactory(\n  unsafeRec,\n  safeGlobal,\n  transforms,\n  sloppyGlobals\n) {\n  const { unsafeFunction } = unsafeRec;\n\n  const constants = getOptimizableGlobals(safeGlobal);\n  const scopedEvaluatorFactory = createScopedEvaluatorFactory(\n    unsafeRec,\n    constants\n  );\n\n  function factory(endowments = {}, options = {}) {\n    const localTransforms = options.transforms || [];\n    const realmTransforms = transforms || [];\n\n    const mandatoryTransforms = [rejectDangerousSourcesTransform];\n    const allTransforms = [\n      ...localTransforms,\n      ...realmTransforms,\n      ...mandatoryTransforms\n    ];\n\n    // We use the the concise method syntax to create an eval without a\n    // [[Construct]] behavior (such that the invocation \"new eval()\" throws\n    // TypeError: eval is not a constructor\"), but which still accepts a\n    // 'this' binding.\n    const safeEval = {\n      eval(src) {\n        src = `${src}`;\n        // Rewrite the source, threading through rewriter state as necessary.\n        const rewriterState = allTransforms.reduce(\n          (rs, transform) => (transform.rewrite ? transform.rewrite(rs) : rs),\n          { src, endowments }\n        );\n        src = rewriterState.src;\n\n        const scopeTarget = create(\n          safeGlobal,\n          getOwnPropertyDescriptors(rewriterState.endowments)\n        );\n\n        const scopeHandler = createScopeHandler(\n          unsafeRec,\n          safeGlobal,\n          sloppyGlobals\n        );\n        const scopeProxy = new Proxy(scopeTarget, scopeHandler);\n        const scopedEvaluator = apply(scopedEvaluatorFactory, safeGlobal, [\n          scopeProxy\n        ]);\n\n        scopeHandler.allowUnsafeEvaluatorOnce();\n        let err;\n        try {\n          // Ensure that \"this\" resolves to the safe global.\n          return apply(scopedEvaluator, safeGlobal, [src]);\n        } catch (e) {\n          // stash the child-code error in hopes of debugging the internal failure\n          err = e;\n          throw e;\n        } finally {\n          // belt and suspenders: the proxy switches this off immediately after\n          // the first access, but if that's not the case we abort.\n          if (scopeHandler.unsafeEvaluatorAllowed()) {\n            throwTantrum('handler did not revoke useUnsafeEvaluator', err);\n          }\n        }\n      }\n    }.eval;\n\n    // safeEval's prototype is currently the primal realm's\n    // Function.prototype, which we must not let escape. To make 'eval\n    // instanceof Function' be true inside the realm, we need to point it at\n    // the RootRealm's value.\n\n    // Ensure that eval from any compartment in a root realm is an instance\n    // of Function in any compartment of the same root realm.\n    setPrototypeOf(safeEval, unsafeFunction.prototype);\n\n    assert(getPrototypeOf(safeEval).constructor !== Function, 'hide Function');\n    assert(\n      getPrototypeOf(safeEval).constructor !== unsafeFunction,\n      'hide unsafeFunction'\n    );\n\n    // note: be careful to not leak our primal Function.prototype by setting\n    // this to a plain arrow function. Now that we have safeEval, use it.\n    defineProperties(safeEval, {\n      toString: {\n        // We break up the following literal string so that an\n        // apparent direct eval syntax does not appear in this\n        // file. Thus, we avoid rejection by the overly eager\n        // rejectDangerousSources.\n        value: safeEval(\"() => 'function eval' + '() { [shim code] }'\"),\n        writable: false,\n        enumerable: false,\n        configurable: true\n      }\n    });\n\n    return safeEval;\n  }\n\n  return factory;\n}\n\nexport function createSafeEvaluator(safeEvaluatorFactory) {\n  return safeEvaluatorFactory();\n}\n\nexport function createSafeEvaluatorWhichTakesEndowments(safeEvaluatorFactory) {\n  return (x, endowments, options = {}) =>\n    safeEvaluatorFactory(endowments, options)(x);\n}\n\n/**\n * A safe version of the native Function which relies on\n * the safety of evalEvaluator for confinement.\n */\nexport function createFunctionEvaluator(unsafeRec, safeEval) {\n  const { unsafeFunction, unsafeGlobal } = unsafeRec;\n\n  const safeFunction = function Function(...params) {\n    const functionBody = `${arrayPop(params) || ''}`;\n    let functionParams = `${arrayJoin(params, ',')}`;\n    if (!regexpTest(/^[\\w\\s,]*$/, functionParams)) {\n      throw new unsafeGlobal.SyntaxError(\n        'shim limitation: Function arg must be simple ASCII identifiers, possibly separated by commas: no default values, pattern matches, or non-ASCII parameter names'\n      );\n      // this protects against Matt Austin's clever attack:\n      // Function(\"arg=`\", \"/*body`){});({x: this/**/\")\n      // which would turn into\n      //     (function(arg=`\n      //     /*``*/){\n      //      /*body`){});({x: this/**/\n      //     })\n      // which parses as a default argument of `\\n/*``*/){\\n/*body` , which\n      // is a pair of template literals back-to-back (so the first one\n      // nominally evaluates to the parser to use on the second one), which\n      // can't actually execute (because the first literal evals to a string,\n      // which can't be a parser function), but that doesn't matter because\n      // the function is bypassed entirely. When that gets evaluated, it\n      // defines (but does not invoke) a function, then evaluates a simple\n      // {x: this} expression, giving access to the safe global.\n    }\n\n    // Is this a real functionBody, or is someone attempting an injection\n    // attack? This will throw a SyntaxError if the string is not actually a\n    // function body. We coerce the body into a real string above to prevent\n    // someone from passing an object with a toString() that returns a safe\n    // string the first time, but an evil string the second time.\n    // eslint-disable-next-line no-new, new-cap\n    new unsafeFunction(functionBody);\n\n    if (stringIncludes(functionParams, ')')) {\n      // If the formal parameters string include ) - an illegal\n      // character - it may make the combined function expression\n      // compile. We avoid this problem by checking for this early on.\n\n      // note: v8 throws just like this does, but chrome accepts\n      // e.g. 'a = new Date()'\n      throw new unsafeGlobal.SyntaxError(\n        'shim limitation: Function arg string contains parenthesis'\n      );\n      // todo: shim integrity threat if they change SyntaxError\n    }\n\n    // todo: check to make sure this .length is safe. markm says safe.\n    if (functionParams.length > 0) {\n      // If the formal parameters include an unbalanced block comment, the\n      // function must be rejected. Since JavaScript does not allow nested\n      // comments we can include a trailing block comment to catch this.\n      functionParams += '\\n/*``*/';\n    }\n\n    const src = `(function(${functionParams}){\\n${functionBody}\\n})`;\n\n    return safeEval(src);\n  };\n\n  // Ensure that Function from any compartment in a root realm can be used\n  // with instance checks in any compartment of the same root realm.\n  setPrototypeOf(safeFunction, unsafeFunction.prototype);\n\n  assert(\n    getPrototypeOf(safeFunction).constructor !== Function,\n    'hide Function'\n  );\n  assert(\n    getPrototypeOf(safeFunction).constructor !== unsafeFunction,\n    'hide unsafeFunction'\n  );\n\n  defineProperties(safeFunction, {\n    // Ensure that any function created in any compartment in a root realm is an\n    // instance of Function in any compartment of the same root ralm.\n    prototype: { value: unsafeFunction.prototype },\n\n    // Provide a custom output without overwriting the\n    // Function.prototype.toString which is called by some third-party\n    // libraries.\n    toString: {\n      value: safeEval(\"() => 'function Function() { [shim code] }'\"),\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  return safeFunction;\n}\n","import { createRealmFacade, buildChildRealm } from './realmFacade';\nimport { createNewUnsafeRec, createCurrentUnsafeRec } from './unsafeRec';\nimport {\n  createSafeEvaluatorFactory,\n  createSafeEvaluator,\n  createSafeEvaluatorWhichTakesEndowments,\n  createFunctionEvaluator\n} from './evaluators';\nimport { assert } from './utilities';\nimport { create, defineProperties, freeze, arrayConcat } from './commons';\n\n// Mimic private members on the realm instances.\n// We define it in the same module and do not export it.\nconst RealmRecForRealmInstance = new WeakMap();\n\nfunction getRealmRecForRealmInstance(realm) {\n  // Detect non-objects.\n  assert(Object(realm) === realm, 'bad object, not a Realm instance');\n  // Realm instance has no realmRec. Should not proceed.\n  assert(RealmRecForRealmInstance.has(realm), 'Realm instance has no record');\n\n  return RealmRecForRealmInstance.get(realm);\n}\n\nfunction registerRealmRecForRealmInstance(realm, realmRec) {\n  // Detect non-objects.\n  assert(Object(realm) === realm, 'bad object, not a Realm instance');\n  // Attempt to change an existing realmRec on a realm instance. Should not proceed.\n  assert(\n    !RealmRecForRealmInstance.has(realm),\n    'Realm instance already has a record'\n  );\n\n  RealmRecForRealmInstance.set(realm, realmRec);\n}\n\n// Initialize the global variables for the new Realm.\nfunction setDefaultBindings(safeGlobal, safeEval, safeFunction) {\n  defineProperties(safeGlobal, {\n    eval: {\n      value: safeEval,\n      writable: true,\n      configurable: true\n    },\n    Function: {\n      value: safeFunction,\n      writable: true,\n      configurable: true\n    }\n  });\n}\n\nfunction createRealmRec(unsafeRec, transforms, sloppyGlobals) {\n  const { sharedGlobalDescs, unsafeGlobal } = unsafeRec;\n\n  const safeGlobal = create(unsafeGlobal.Object.prototype, sharedGlobalDescs);\n\n  const safeEvaluatorFactory = createSafeEvaluatorFactory(\n    unsafeRec,\n    safeGlobal,\n    transforms,\n    sloppyGlobals\n  );\n  const safeEval = createSafeEvaluator(safeEvaluatorFactory);\n  const safeEvalWhichTakesEndowments = createSafeEvaluatorWhichTakesEndowments(\n    safeEvaluatorFactory\n  );\n  const safeFunction = createFunctionEvaluator(unsafeRec, safeEval);\n\n  setDefaultBindings(safeGlobal, safeEval, safeFunction);\n\n  const realmRec = freeze({\n    safeGlobal,\n    safeEval,\n    safeEvalWhichTakesEndowments,\n    safeFunction\n  });\n\n  return realmRec;\n}\n\n/**\n * A root realm uses a fresh set of new intrinics. Here we first create\n * a new unsafe record, which inherits the shims. Then we proceed with\n * the creation of the realm record, and we apply the shims.\n */\nfunction initRootRealm(parentUnsafeRec, self, options) {\n  // note: 'self' is the instance of the Realm.\n\n  // todo: investigate attacks via Array.species\n  // todo: this accepts newShims='string', but it should reject that\n  const { shims: newShims, transforms, sloppyGlobals } = options;\n  const allShims = arrayConcat(parentUnsafeRec.allShims, newShims);\n\n  // The unsafe record is created already repaired.\n  const unsafeRec = createNewUnsafeRec(allShims);\n\n  // eslint-disable-next-line no-use-before-define\n  const Realm = createRealmFacade(unsafeRec, BaseRealm);\n\n  // Add a Realm descriptor to sharedGlobalDescs, so it can be defined onto the\n  // safeGlobal like the rest of the globals.\n  unsafeRec.sharedGlobalDescs.Realm = {\n    value: Realm,\n    writable: true,\n    configurable: true\n  };\n\n  // Creating the realmRec provides the global object, eval() and Function()\n  // to the realm.\n  const realmRec = createRealmRec(unsafeRec, transforms, sloppyGlobals);\n\n  // Apply all shims in the new RootRealm. We don't do this for compartments.\n  const { safeEvalWhichTakesEndowments } = realmRec;\n  for (const shim of allShims) {\n    safeEvalWhichTakesEndowments(shim);\n  }\n\n  // The realmRec acts as a private field on the realm instance.\n  registerRealmRecForRealmInstance(self, realmRec);\n}\n\n/**\n * A compartment shares the intrinsics of its root realm. Here, only a\n * realmRec is necessary to hold the global object, eval() and Function().\n */\nfunction initCompartment(unsafeRec, self, options = {}) {\n  // note: 'self' is the instance of the Realm.\n\n  const { transforms, sloppyGlobals } = options;\n  const realmRec = createRealmRec(unsafeRec, transforms, sloppyGlobals);\n\n  // The realmRec acts as a private field on the realm instance.\n  registerRealmRecForRealmInstance(self, realmRec);\n}\n\nfunction getRealmGlobal(self) {\n  const { safeGlobal } = getRealmRecForRealmInstance(self);\n  return safeGlobal;\n}\n\nfunction realmEvaluate(self, x, endowments = {}, options = {}) {\n  // todo: don't pass in primal-realm objects like {}, for safety. OTOH its\n  // properties are copied onto the new global 'target'.\n  // todo: figure out a way to membrane away the contents to safety.\n  const { safeEvalWhichTakesEndowments } = getRealmRecForRealmInstance(self);\n  return safeEvalWhichTakesEndowments(x, endowments, options);\n}\n\nconst BaseRealm = {\n  initRootRealm,\n  initCompartment,\n  getRealmGlobal,\n  realmEvaluate\n};\n\n// Create the current unsafeRec from the current \"primal\" environment (the realm\n// where the Realm shim is loaded and executed).\nconst currentUnsafeRec = createCurrentUnsafeRec();\n\n/**\n * The \"primal\" realm class is defined in the current \"primal\" environment,\n * and is part of the shim. There is no need to facade this class via evaluation\n * because both share the same intrinsics.\n */\nconst Realm = buildChildRealm(currentUnsafeRec, BaseRealm);\n\nexport default Realm;\n"],"names":[],"mappings":"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"}
##############################################
/src/dist/realms-shim.esm.min.js.map:1:{"version":3,"file":"realms-shim.esm.min.js","sources":["../src/utilities.js","../src/realmFacade.js","../src/commons.js","../src/stdlib.js","../src/repair/accessors.js","../src/repair/functions.js","../src/unsafeRec.js","../src/optimizer.js","../src/scopeHandler.js","../src/sourceParser.js","../src/evaluators.js","../src/realm.js"],"sourcesContent":["// we'd like to abandon, but we can't, so just scream and break a lot of\n// stuff. However, since we aren't really aborting the process, be careful to\n// not throw an Error object which could be captured by child-Realm code and\n// used to access the (too-powerful) primal-realm Error object.\n\nexport function throwTantrum(s, err = undefined) {\n  const msg = `please report internal shim error: ${s}`;\n\n  // we want to log these 'should never happen' things.\n  // eslint-disable-next-line no-console\n  console.error(msg);\n  if (err) {\n    // eslint-disable-next-line no-console\n    console.error(`${err}`);\n    // eslint-disable-next-line no-console\n    console.error(`${err.stack}`);\n  }\n\n  // eslint-disable-next-line no-debugger\n  debugger;\n  throw msg;\n}\n\nexport function assert(condition, message) {\n  if (!condition) {\n    throwTantrum(message);\n  }\n}\n\n// Remove code modifications.\nexport function cleanupSource(src) {\n  /* START_TESTS_ONLY */\n\n  // Restore eval which is modified by esm module.\n  src = src.replace(/\\(0,[^)]+\\)/g, '(0, eval)');\n\n  // Remove code coverage which is injected by nyc module.\n  src = src.replace(/cov_[^+]+\\+\\+[;,]/g, '');\n\n  /* END_TESTS_ONLY */\n  return src;\n}\n","import { cleanupSource } from './utilities';\n\n// buildChildRealm is immediately turned into a string, and this function is\n// never referenced again, because it closes over the wrong intrinsics\n\nexport function buildChildRealm(unsafeRec, BaseRealm) {\n  const {\n    initRootRealm,\n    initCompartment,\n    getRealmGlobal,\n    realmEvaluate\n  } = BaseRealm;\n\n  // This Object and Reflect are brand new, from a new unsafeRec, so no user\n  // code has been run or had a chance to manipulate them. We extract these\n  // properties for brevity, not for security. Don't ever run this function\n  // *after* user code has had a chance to pollute its environment, or it\n  // could be used to gain access to BaseRealm and primal-realm Error\n  // objects.\n  const { create, defineProperties } = Object;\n\n  const errorConstructors = new Map([\n    ['EvalError', EvalError],\n    ['RangeError', RangeError],\n    ['ReferenceError', ReferenceError],\n    ['SyntaxError', SyntaxError],\n    ['TypeError', TypeError],\n    ['URIError', URIError]\n  ]);\n\n  // Like Realm.apply except that it catches anything thrown and rethrows it\n  // as an Error from this realm\n  function callAndWrapError(target, ...args) {\n    try {\n      return target(...args);\n    } catch (err) {\n      if (Object(err) !== err) {\n        // err is a primitive value, which is safe to rethrow\n        throw err;\n      }\n      let eName, eMessage, eStack;\n      try {\n        // The child environment might seek to use 'err' to reach the\n        // parent's intrinsics and corrupt them. `${err.name}` will cause\n        // string coercion of 'err.name'. If err.name is an object (probably\n        // a String of the parent Realm), the coercion uses\n        // err.name.toString(), which is under the control of the parent. If\n        // err.name were a primitive (e.g. a number), it would use\n        // Number.toString(err.name), using the child's version of Number\n        // (which the child could modify to capture its argument for later\n        // use), however primitives don't have properties like .prototype so\n        // they aren't useful for an attack.\n        eName = `${err.name}`;\n        eMessage = `${err.message}`;\n        eStack = `${err.stack || eMessage}`;\n        // eName/eMessage/eStack are now child-realm primitive strings, and\n        // safe to expose\n      } catch (ignored) {\n        // if err.name.toString() throws, keep the (parent realm) Error away\n        // from the child\n        throw new Error('unknown error');\n      }\n      const ErrorConstructor = errorConstructors.get(eName) || Error;\n      try {\n        throw new ErrorConstructor(eMessage);\n      } catch (err2) {\n        err2.stack = eStack; // replace with the captured inner stack\n        throw err2;\n      }\n    }\n  }\n\n  class Realm {\n    constructor() {\n      // The Realm constructor is not intended to be used with the new operator\n      // or to be subclassed. It may be used as the value of an extends clause\n      // of a class definition but a super call to the Realm constructor will\n      // cause an exception.\n\n      // When Realm is called as a function, an exception is also raised because\n      // a class constructor cannot be invoked without 'new'.\n      throw new TypeError('Realm is not a constructor');\n    }\n\n    static makeRootRealm(options = {}) {\n      // This is the exposed interface.\n\n      // Bypass the constructor.\n      const r = create(Realm.prototype);\n      callAndWrapError(initRootRealm, unsafeRec, r, options);\n      return r;\n    }\n\n    static makeCompartment(options = {}) {\n      // Bypass the constructor.\n      const r = create(Realm.prototype);\n      callAndWrapError(initCompartment, unsafeRec, r, options);\n      return r;\n    }\n\n    // we omit the constructor because it is empty. All the personalization\n    // takes place in one of the two static methods,\n    // makeRootRealm/makeCompartment\n\n    get global() {\n      // this is safe against being called with strange 'this' because\n      // baseGetGlobal immediately does a trademark check (it fails unless\n      // this 'this' is present in a weakmap that is only populated with\n      // legitimate Realm instances)\n      return callAndWrapError(getRealmGlobal, this);\n    }\n\n    evaluate(x, endowments, options = {}) {\n      // safe against strange 'this', as above\n      return callAndWrapError(realmEvaluate, this, x, endowments, options);\n    }\n  }\n\n  defineProperties(Realm, {\n    toString: {\n      value: () => 'function Realm() { [shim code] }',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  defineProperties(Realm.prototype, {\n    toString: {\n      value: () => '[object Realm]',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  return Realm;\n}\n\n// The parentheses means we don't bind the 'buildChildRealm' name inside the\n// child's namespace. this would accept an anonymous function declaration.\n// function expression (not a declaration) so it has a completion value.\nconst buildChildRealmString = cleanupSource(\n  `'use strict'; (${buildChildRealm})`\n);\n\nexport function createRealmFacade(unsafeRec, BaseRealm) {\n  const { unsafeEval } = unsafeRec;\n\n  // The BaseRealm is the Realm class created by\n  // the shim. It's only valid for the context where\n  // it was parsed.\n\n  // The Realm facade is a lightweight class built in the\n  // context a different context, that provide a fully\n  // functional Realm class using the intrisics\n  // of that context.\n\n  // This process is simplified because all methods\n  // and properties on a realm instance already return\n  // values using the intrinsics of the realm's context.\n\n  // Invoke the BaseRealm constructor with Realm as the prototype.\n  return unsafeEval(buildChildRealmString)(unsafeRec, BaseRealm);\n}\n","// Declare shorthand functions. Sharing these declarations across modules\n// improves both consistency and minification. Unused declarations are\n// dropped by the tree shaking process.\n\n// we capture these, not just for brevity, but for security. If any code\n// modifies Object to change what 'assign' points to, the Realm shim would be\n// corrupted.\n\nexport const {\n  assign,\n  create,\n  freeze,\n  defineProperties, // Object.defineProperty is allowed to fail\n  // silentlty, use Object.defineProperties instead.\n  getOwnPropertyDescriptor,\n  getOwnPropertyDescriptors,\n  getOwnPropertyNames,\n  getPrototypeOf,\n  setPrototypeOf\n} = Object;\n\nexport const {\n  apply,\n  ownKeys // Reflect.ownKeys includes Symbols and unenumerables,\n  // unlike Object.keys()\n} = Reflect;\n\n/**\n * uncurryThis() See\n * http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\n * which only lives at\n * http://web.archive.org/web/20160805225710/http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\n *\n * Performance:\n * 1. The native call is about 10x faster on FF than chrome\n * 2. The version using Function.bind() is about 100x slower on FF,\n *    equal on chrome, 2x slower on Safari\n * 3. The version using a spread and Reflect.apply() is about 10x\n *    slower on FF, equal on chrome, 2x slower on Safari\n *\n * const bind = Function.prototype.bind;\n * const uncurryThis = bind.bind(bind.call);\n */\nconst uncurryThis = fn => (thisArg, ...args) => apply(fn, thisArg, args);\n\n// We also capture these for security: changes to Array.prototype after the\n// Realm shim runs shouldn't affect subsequent Realm operations.\nexport const objectHasOwnProperty = uncurryThis(\n    Object.prototype.hasOwnProperty\n  ),\n  arrayForEach = uncurryThis(Array.prototype.forEach),\n  arrayFilter = uncurryThis(Array.prototype.filter),\n  arrayPush = uncurryThis(Array.prototype.push),\n  arrayPop = uncurryThis(Array.prototype.pop),\n  arrayJoin = uncurryThis(Array.prototype.join),\n  arrayConcat = uncurryThis(Array.prototype.concat),\n  regexpTest = uncurryThis(RegExp.prototype.test),\n  stringMatch = uncurryThis(String.prototype.match),\n  stringIncludes = uncurryThis(String.prototype.includes);\n","import { getOwnPropertyDescriptor } from './commons';\nimport { assert } from './utilities';\n\n// These value properties of the global object are non-writable,\n// non-configurable data properties.\nconst frozenGlobalPropertyNames = [\n  // *** 18.1 Value Properties of the Global Object\n\n  'Infinity',\n  'NaN',\n  'undefined'\n];\n\n// All the following stdlib items have the same name on both our intrinsics\n// object and on the global object. Unlike Infinity/NaN/undefined, these\n// should all be writable and configurable. This is divided into two\n// sets. The stable ones are those the shim can freeze early because\n// we don't expect anyone will want to mutate them. The unstable ones\n// are the ones that we correctly initialize to writable and\n// configurable so that they can still be replaced or removed.\nconst stableGlobalPropertyNames = [\n  // *** 18.2 Function Properties of the Global Object\n\n  // 'eval', // comes from safeEval instead\n  'isFinite',\n  'isNaN',\n  'parseFloat',\n  'parseInt',\n\n  'decodeURI',\n  'decodeURIComponent',\n  'encodeURI',\n  'encodeURIComponent',\n\n  // *** 18.3 Constructor Properties of the Global Object\n\n  'Array',\n  'ArrayBuffer',\n  'Boolean',\n  'DataView',\n  // 'Date',  // Unstable\n  // 'Error',  // Unstable\n  'EvalError',\n  'Float32Array',\n  'Float64Array',\n  // 'Function',  // comes from safeFunction instead\n  'Int8Array',\n  'Int16Array',\n  'Int32Array',\n  'Map',\n  'Number',\n  'Object',\n  // 'Promise',  // Unstable\n  // 'Proxy',  // Unstable\n  'RangeError',\n  'ReferenceError',\n  // 'RegExp',  // Unstable\n  'Set',\n  // 'SharedArrayBuffer'  // removed on Jan 5, 2018\n  'String',\n  'Symbol',\n  'SyntaxError',\n  'TypeError',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Uint16Array',\n  'Uint32Array',\n  'URIError',\n  'WeakMap',\n  'WeakSet',\n\n  // *** 18.4 Other Properties of the Global Object\n\n  // 'Atomics', // removed on Jan 5, 2018\n  'JSON',\n  'Math',\n  'Reflect',\n\n  // *** Annex B\n\n  'escape',\n  'unescape'\n\n  // *** ECMA-402\n\n  // 'Intl'  // Unstable\n\n  // *** ESNext\n\n  // 'Realm' // Comes from createRealmGlobalObject()\n];\n\nconst unstableGlobalPropertyNames = [\n  'Date',\n  'Error',\n  'Promise',\n  'Proxy',\n  'RegExp',\n  'Intl'\n];\n\nexport function getSharedGlobalDescs(unsafeGlobal) {\n  const descriptors = {};\n\n  function describe(names, writable, enumerable, configurable) {\n    for (const name of names) {\n      const desc = getOwnPropertyDescriptor(unsafeGlobal, name);\n      if (desc) {\n        // Abort if an accessor is found on the unsafe global object\n        // instead of a data property. We should never get into this\n        // non standard situation.\n        assert(\n          'value' in desc,\n          `unexpected accessor on global property: ${name}`\n        );\n\n        descriptors[name] = {\n          value: desc.value,\n          writable,\n          enumerable,\n          configurable\n        };\n      }\n    }\n  }\n\n  describe(frozenGlobalPropertyNames, false, false, false);\n  // The following is correct but expensive.\n  // describe(stableGlobalPropertyNames, true, false, true);\n  // Instead, for now, we let these get optimized.\n  //\n  // TODO: We should provide an option to turn this optimization off,\n  // by feeding \"true, false, true\" here instead.\n  describe(stableGlobalPropertyNames, false, false, false);\n  // These we keep replaceable and removable, because we expect\n  // others, e.g., SES, may want to do so.\n  describe(unstableGlobalPropertyNames, true, false, true);\n\n  return descriptors;\n}\n","// Adapted from SES/Caja - Copyright (C) 2011 Google Inc.\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js\n\n/**\n * Replace the legacy accessors of Object to comply with strict mode\n * and ES2016 semantics, we do this by redefining them while in 'use strict'.\n *\n * todo: list the issues resolved\n *\n * This function can be used in two ways: (1) invoked directly to fix the primal\n * realm's Object.prototype, and (2) converted to a string to be executed\n * inside each new RootRealm to fix their Object.prototypes. Evaluation requires\n * the function to have no dependencies, so don't import anything from\n * the outside.\n */\n\n// todo: this file should be moved out to a separate repo and npm module.\nexport function repairAccessors() {\n  const {\n    defineProperty,\n    defineProperties,\n    getOwnPropertyDescriptor,\n    getPrototypeOf,\n    prototype: objectPrototype\n  } = Object;\n\n  // On some platforms, the implementation of these functions act as\n  // if they are in sloppy mode: if they're invoked badly, they will\n  // expose the global object, so we need to repair these for\n  // security. Thus it is our responsibility to fix this, and we need\n  // to include repairAccessors. E.g. Chrome in 2016.\n\n  try {\n    // Verify that the method is not callable.\n    // eslint-disable-next-line no-restricted-properties, no-underscore-dangle\n    (0, objectPrototype.__lookupGetter__)('x');\n  } catch (ignore) {\n    // Throws, no need to patch.\n    return;\n  }\n\n  function toObject(obj) {\n    if (obj === undefined || obj === null) {\n      throw new TypeError(`can't convert undefined or null to object`);\n    }\n    return Object(obj);\n  }\n\n  function asPropertyName(obj) {\n    if (typeof obj === 'symbol') {\n      return obj;\n    }\n    return `${obj}`;\n  }\n\n  function aFunction(obj, accessor) {\n    if (typeof obj !== 'function') {\n      throw TypeError(`invalid ${accessor} usage`);\n    }\n    return obj;\n  }\n\n  defineProperties(objectPrototype, {\n    __defineGetter__: {\n      value: function __defineGetter__(prop, func) {\n        const O = toObject(this);\n        defineProperty(O, prop, {\n          get: aFunction(func, 'getter'),\n          enumerable: true,\n          configurable: true\n        });\n      }\n    },\n    __defineSetter__: {\n      value: function __defineSetter__(prop, func) {\n        const O = toObject(this);\n        defineProperty(O, prop, {\n          set: aFunction(func, 'setter'),\n          enumerable: true,\n          configurable: true\n        });\n      }\n    },\n    __lookupGetter__: {\n      value: function __lookupGetter__(prop) {\n        let O = toObject(this);\n        prop = asPropertyName(prop);\n        let desc;\n        while (O && !(desc = getOwnPropertyDescriptor(O, prop))) {\n          O = getPrototypeOf(O);\n        }\n        return desc && desc.get;\n      }\n    },\n    __lookupSetter__: {\n      value: function __lookupSetter__(prop) {\n        let O = toObject(this);\n        prop = asPropertyName(prop);\n        let desc;\n        while (O && !(desc = getOwnPropertyDescriptor(O, prop))) {\n          O = getPrototypeOf(O);\n        }\n        return desc && desc.set;\n      }\n    }\n  });\n}\n","// Adapted from SES/Caja\n// Copyright (C) 2011 Google Inc.\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js\n\n/**\n * This block replaces the original Function constructor, and the original\n * %GeneratorFunction% %AsyncFunction% and %AsyncGeneratorFunction%, with\n * safe replacements that throw if invoked.\n *\n * These are all reachable via syntax, so it isn't sufficient to just\n * replace global properties with safe versions. Our main goal is to prevent\n * access to the Function constructor through these starting points.\n\n * After this block is done, the originals must no longer be reachable, unless\n * a copy has been made, and funtions can only be created by syntax (using eval)\n * or by invoking a previously saved reference to the originals.\n */\n\n// todo: this file should be moved out to a separate repo and npm module.\nconst globalEval = eval;\nexport function repairFunctions() {\n  const { defineProperties, getPrototypeOf, setPrototypeOf } = Object;\n\n  /**\n   * The process to repair constructors:\n   * 1. Create an instance of the function by evaluating syntax\n   * 2. Obtain the prototype from the instance\n   * 3. Create a substitute tamed constructor\n   * 4. Replace the original constructor with the tamed constructor\n   * 5. Replace tamed constructor prototype property with the original one\n   * 6. Replace its [[Prototype]] slot with the tamed constructor of Function\n   */\n  function repairFunction(name, declaration) {\n    let FunctionInstance;\n    try {\n      // eslint-disable-next-line no-new-func\n      FunctionInstance = globalEval(declaration);\n    } catch (e) {\n      if (e instanceof SyntaxError) {\n        // Prevent failure on platforms where async and/or generators\n        // are not supported.\n        return;\n      }\n      // Re-throw\n      throw e;\n    }\n    const FunctionPrototype = getPrototypeOf(FunctionInstance);\n\n    // Prevents the evaluation of source when calling constructor on the\n    // prototype of functions.\n    const TamedFunction = function() {\n      throw new TypeError('Not available');\n    };\n    defineProperties(TamedFunction, { name: { value: name } });\n\n    // (new Error()).constructors does not inherit from Function, because Error\n    // was defined before ES6 classes. So we don't need to repair it too.\n\n    // (Error()).constructor inherit from Function, which gets a tamed\n    // constructor here.\n\n    // todo: in an ES6 class that does not inherit from anything, what does its\n    // constructor inherit from? We worry that it inherits from Function, in\n    // which case instances could give access to unsafeFunction. markm says\n    // we're fine: the constructor inherits from Object.prototype\n\n    // This line replaces the original constructor in the prototype chain\n    // with the tamed one. No copy of the original is peserved.\n    defineProperties(FunctionPrototype, {\n      constructor: { value: TamedFunction }\n    });\n\n    // This line sets the tamed constructor's prototype data property to\n    // the original one.\n    defineProperties(TamedFunction, {\n      prototype: { value: FunctionPrototype }\n    });\n\n    if (TamedFunction !== Function.prototype.constructor) {\n      // Ensures that all functions meet \"instanceof Function\" in a realm.\n      setPrototypeOf(TamedFunction, Function.prototype.constructor);\n    }\n  }\n\n  // Here, the order of operation is important: Function needs to be repaired\n  // first since the other repaired constructors need to inherit from the tamed\n  // Function function constructor.\n\n  // note: this really wants to be part of the standard, because new\n  // constructors may be added in the future, reachable from syntax, and this\n  // list must be updated to match.\n\n  // \"plain arrow functions\" inherit from Function.prototype\n\n  repairFunction('Function', '(function(){})');\n  repairFunction('GeneratorFunction', '(function*(){})');\n  repairFunction('AsyncFunction', '(async function(){})');\n  repairFunction('AsyncGeneratorFunction', '(async function*(){})');\n}\n","// this module must never be importable outside the Realm shim itself\nimport { getSharedGlobalDescs } from './stdlib';\nimport { repairAccessors } from './repair/accessors';\nimport { repairFunctions } from './repair/functions';\nimport { cleanupSource } from './utilities';\nimport { freeze } from './commons';\n\n// A \"context\" is a fresh unsafe Realm as given to us by existing platforms.\n// We need this to implement the shim. However, when Realms land for real,\n// this feature will be provided by the underlying engine instead.\n\n// note: in a node module, the top-level 'this' is not the global object\n// (it's *something* but we aren't sure what), however an indirect eval of\n// 'this' will be the correct global object.\n\nconst unsafeGlobalSrc = \"'use strict'; this\";\nconst unsafeGlobalEvalSrc = `(0, eval)(\"'use strict'; this\")`;\n\n// This method is only exported for testing purposes.\nexport function createNewUnsafeGlobalForNode() {\n  // Note that webpack and others will shim 'vm' including the method\n  // 'runInNewContext', so the presence of vm is not a useful check\n\n  // TODO: Find a better test that works with bundlers\n  // eslint-disable-next-line no-new-func\n  const isNode = new Function(\n    'try {return this===global}catch(e){return false}'\n  )();\n\n  if (!isNode) {\n    return undefined;\n  }\n\n  // eslint-disable-next-line global-require\n  const vm = require('vm');\n\n  // Use unsafeGlobalEvalSrc to ensure we get the right 'this'.\n  const unsafeGlobal = vm.runInNewContext(unsafeGlobalEvalSrc);\n\n  return unsafeGlobal;\n}\n\n// This method is only exported for testing purposes.\nexport function createNewUnsafeGlobalForBrowser() {\n  if (typeof document === 'undefined') {\n    return undefined;\n  }\n  const iframe = document.createElement('iframe');\n  iframe.style.display = 'none';\n\n  document.body.appendChild(iframe);\n  const unsafeGlobal = iframe.contentWindow.eval(unsafeGlobalSrc);\n\n  // We keep the iframe attached to the DOM because removing it\n  // causes its global object to lose intrinsics, its eval()\n  // function to evaluate code, etc.\n\n  // TODO: can we remove and garbage-collect the iframes?\n\n  return unsafeGlobal;\n}\n\nconst getNewUnsafeGlobal = () => {\n  const newUnsafeGlobalForBrowser = createNewUnsafeGlobalForBrowser();\n  const newUnsafeGlobalForNode = createNewUnsafeGlobalForNode();\n  if (\n    (!newUnsafeGlobalForBrowser && !newUnsafeGlobalForNode) ||\n    (newUnsafeGlobalForBrowser && newUnsafeGlobalForNode)\n  ) {\n    throw new Error('unexpected platform, unable to create Realm');\n  }\n  return newUnsafeGlobalForBrowser || newUnsafeGlobalForNode;\n};\n\n// The unsafeRec is shim-specific. It acts as the mechanism to obtain a fresh\n// set of intrinsics together with their associated eval and Function\n// evaluators. These must be used as a matched set, since the evaluators are\n// tied to a set of intrinsics, aka the \"undeniables\". If it were possible to\n// mix-and-match them from different contexts, that would enable some\n// attacks.\nfunction createUnsafeRec(unsafeGlobal, allShims = []) {\n  const sharedGlobalDescs = getSharedGlobalDescs(unsafeGlobal);\n\n  return freeze({\n    unsafeGlobal,\n    sharedGlobalDescs,\n    unsafeEval: unsafeGlobal.eval,\n    unsafeFunction: unsafeGlobal.Function,\n    allShims\n  });\n}\n\nconst repairAccessorsShim = cleanupSource(\n  `\"use strict\"; (${repairAccessors})();`\n);\nconst repairFunctionsShim = cleanupSource(\n  `\"use strict\"; const globalEval = eval; (${repairFunctions})();`\n);\n\n// Create a new unsafeRec from a brand new context, with new intrinsics and a\n// new global object\nexport function createNewUnsafeRec(allShims) {\n  const unsafeGlobal = getNewUnsafeGlobal();\n  unsafeGlobal.eval(repairAccessorsShim);\n  unsafeGlobal.eval(repairFunctionsShim);\n  return createUnsafeRec(unsafeGlobal, allShims);\n}\n\n// Create a new unsafeRec from the current context, where the Realm shim is\n// being parsed and executed, aka the \"Primal Realm\"\nexport function createCurrentUnsafeRec() {\n  const unsafeGlobal = (0, eval)(unsafeGlobalSrc);\n  repairAccessors();\n  repairFunctions();\n  return createUnsafeRec(unsafeGlobal);\n}\n","import {\n  arrayFilter,\n  getOwnPropertyDescriptors,\n  getOwnPropertyNames,\n  objectHasOwnProperty,\n  regexpTest\n} from './commons';\n\n// todo: think about how this interacts with endowments, check for conflicts\n// between the names being optimized and the ones added by endowments\n\n/**\n * Simplified validation of indentifier names: may only contain alphanumeric\n * characters (or \"$\" or \"_\"), and may not start with a digit. This is safe\n * and does not reduces the compatibility of the shim. The motivation for\n * this limitation was to decrease the complexity of the implementation,\n * and to maintain a resonable level of performance.\n * Note: \\w is equivalent [a-zA-Z_0-9]\n * See 11.6.1 Identifier Names\n */\nconst identifierPattern = /^[a-zA-Z_$][\\w$]*$/;\n\n/**\n * In JavaScript you cannot use these reserved words as variables.\n * See 11.6.1 Identifier Names\n */\nconst keywords = new Set([\n  // 11.6.2.1 Keywords\n  'await',\n  'break',\n  'case',\n  'catch',\n  'class',\n  'const',\n  'continue',\n  'debugger',\n  'default',\n  'delete',\n  'do',\n  'else',\n  'export',\n  'extends',\n  'finally',\n  'for',\n  'function',\n  'if',\n  'import',\n  'in',\n  'instanceof',\n  'new',\n  'return',\n  'super',\n  'switch',\n  'this',\n  'throw',\n  'try',\n  'typeof',\n  'var',\n  'void',\n  'while',\n  'with',\n  'yield',\n\n  // Also reserved when parsing strict mode code\n  'let',\n  'static',\n\n  // 11.6.2.2 Future Reserved Words\n  'enum',\n\n  // Also reserved when parsing strict mode code\n  'implements',\n  'package',\n  'protected',\n  'interface',\n  'private',\n  'public',\n\n  // Reserved but not mentioned in specs\n  'await',\n\n  'null',\n  'true',\n  'false',\n\n  'this',\n  'arguments'\n]);\n\n/**\n * getOptimizableGlobals()\n * What variable names might it bring into scope? These include all\n * property names which can be variable names, including the names\n * of inherited properties. It excludes symbols and names which are\n * keywords. We drop symbols safely. Currently, this shim refuses\n * service if any of the names are keywords or keyword-like. This is\n * safe and only prevent performance optimization.\n */\nexport function getOptimizableGlobals(safeGlobal) {\n  const descs = getOwnPropertyDescriptors(safeGlobal);\n\n  // getOwnPropertyNames does ignore Symbols so we don't need this extra check:\n  // typeof name === 'string' &&\n  const constants = arrayFilter(getOwnPropertyNames(descs), name => {\n    // Ensure we have a valid identifier. We use regexpTest rather than\n    // /../.test() to guard against the case where RegExp has been poisoned.\n    if (\n      name === 'eval' ||\n      keywords.has(name) ||\n      !regexpTest(identifierPattern, name)\n    ) {\n      return false;\n    }\n\n    const desc = descs[name];\n    return (\n      //\n      // The getters will not have .writable, don't let the falsyness of\n      // 'undefined' trick us: test with === false, not ! . However descriptors\n      // inherit from the (potentially poisoned) global object, so we might see\n      // extra properties which weren't really there. Accessor properties have\n      // 'get/set/enumerable/configurable', while data properties have\n      // 'value/writable/enumerable/configurable'.\n      desc.configurable === false &&\n      desc.writable === false &&\n      //\n      // Checks for data properties because they're the only ones we can\n      // optimize (accessors are most likely non-constant). Descriptors can't\n      // can't have accessors and value properties at the same time, therefore\n      // this check is sufficient. Using explicit own property deal with the\n      // case where Object.prototype has been poisoned.\n      objectHasOwnProperty(desc, 'value')\n    );\n  });\n\n  return constants;\n}\n","import { freeze, objectHasOwnProperty } from './commons';\nimport { throwTantrum } from './utilities';\n\n/**\n * alwaysThrowHandler is a proxy handler which throws on any trap called.\n * It's made from a proxy with a get trap that throws. Its target is\n * an immutable (frozen) object and is safe to share.\n */\nconst alwaysThrowHandler = new Proxy(freeze({}), {\n  get(target, prop) {\n    throwTantrum(`unexpected scope handler trap called: ${prop}`);\n  }\n});\n\n/**\n * ScopeHandler manages a Proxy which serves as the global scope for the\n * safeEvaluator operation (the Proxy is the argument of a 'with' binding).\n * As described in createSafeEvaluator(), it has several functions:\n * - allow the very first (and only the very first) use of 'eval' to map to\n *   the real (unsafe) eval function, so it acts as a 'direct eval' and can\n *    access its lexical scope (which maps to the 'with' binding, which the\n *   ScopeHandler also controls).\n * - ensure that all subsequent uses of 'eval' map to the safeEvaluator,\n *   which lives as the 'eval' property of the safeGlobal.\n * - route all other property lookups at the safeGlobal.\n * - hide the unsafeGlobal which lives on the scope chain above the 'with'.\n * - ensure the Proxy invariants despite some global properties being frozen.\n */\nexport function createScopeHandler(unsafeRec, safeGlobal, sloppyGlobals) {\n  const { unsafeGlobal, unsafeEval } = unsafeRec;\n\n  // This flag allow us to determine if the eval() call is an done by the\n  // realm's code or if it is user-land invocation, so we can react differently.\n  let useUnsafeEvaluator = false;\n\n  return {\n    // The scope handler throws if any trap other than get/set/has are run\n    // (e.g. getOwnPropertyDescriptors, apply, getPrototypeOf).\n    // eslint-disable-next-line no-proto\n    __proto__: alwaysThrowHandler,\n\n    allowUnsafeEvaluatorOnce() {\n      useUnsafeEvaluator = true;\n    },\n\n    unsafeEvaluatorAllowed() {\n      return useUnsafeEvaluator;\n    },\n\n    get(target, prop) {\n      // Special treatment for eval. The very first lookup of 'eval' gets the\n      // unsafe (real direct) eval, so it will get the lexical scope that uses\n      // the 'with' context.\n      if (prop === 'eval') {\n        // test that it is true rather than merely truthy\n        if (useUnsafeEvaluator === true) {\n          // revoke before use\n          useUnsafeEvaluator = false;\n          return unsafeEval;\n        }\n        return target.eval;\n      }\n\n      // todo: shim integrity, capture Symbol.unscopables\n      if (prop === Symbol.unscopables) {\n        // Safe to return a primal realm Object here because the only code that\n        // can do a get() on a non-string is the internals of with() itself,\n        // and the only thing it does is to look for properties on it. User\n        // code cannot do a lookup on non-strings.\n        return undefined;\n      }\n\n      // Properties of the global.\n      if (prop in target) {\n        return target[prop];\n      }\n\n      // Prevent the lookup for other properties.\n      return undefined;\n    },\n\n    // eslint-disable-next-line class-methods-use-this\n    set(target, prop, value) {\n      // todo: allow modifications when target.hasOwnProperty(prop) and it\n      // is writable, assuming we've already rejected overlap (see\n      // createSafeEvaluatorFactory.factory). This TypeError gets replaced with\n      // target[prop] = value\n      if (objectHasOwnProperty(target, prop)) {\n        // todo: shim integrity: TypeError, String\n        throw new TypeError(`do not modify endowments like ${String(prop)}`);\n      }\n\n      safeGlobal[prop] = value;\n\n      // Return true after successful set.\n      return true;\n    },\n\n    // we need has() to return false for some names to prevent the lookup  from\n    // climbing the scope chain and eventually reaching the unsafeGlobal\n    // object, which is bad.\n\n    // note: unscopables! every string in Object[Symbol.unscopables]\n\n    // todo: we'd like to just have has() return true for everything, and then\n    // use get() to raise a ReferenceError for anything not on the safe global.\n    // But we want to be compatible with ReferenceError in the normal case and\n    // the lack of ReferenceError in the 'typeof' case. Must either reliably\n    // distinguish these two cases (the trap behavior might be different), or\n    // we rely on a mandatory source-to-source transform to change 'typeof abc'\n    // to XXX. We already need a mandatory parse to prevent the 'import',\n    // since it's a special form instead of merely being a global variable/\n\n    // note: if we make has() return true always, then we must implement a\n    // set() trap to avoid subverting the protection of strict mode (it would\n    // accept assignments to undefined globals, when it ought to throw\n    // ReferenceError for such assignments)\n\n    has(target, prop) {\n      // proxies stringify 'prop', so no TOCTTOU danger here\n\n      if (sloppyGlobals) {\n        // Everything is potentially available.\n        return true;\n      }\n\n      // unsafeGlobal: hide all properties of unsafeGlobal at the\n      // expense of 'typeof' being wrong for those properties. For\n      // example, in the browser, evaluating 'document = 3', will add\n      // a property to safeGlobal instead of throwing a\n      // ReferenceError.\n      if (prop === 'eval' || prop in target || prop in unsafeGlobal) {\n        return true;\n      }\n\n      return false;\n    }\n  };\n}\n","// https://www.ecma-international.org/ecma-262/9.0/index.html#sec-html-like-comments\n// explains that JavaScript parsers may or may not recognize html\n// comment tokens \"<\" immediately followed by \"!--\" and \"--\"\n// immediately followed by \">\" in non-module source text, and treat\n// them as a kind of line comment. Since otherwise both of these can\n// appear in normal JavaScript source code as a sequence of operators,\n// we have the terrifying possibility of the same source code parsing\n// one way on one correct JavaScript implementation, and another way\n// on another.\n//\n// This shim takes the conservative strategy of just rejecting source\n// text that contains these strings anywhere. Note that this very\n// source file is written strangely to avoid mentioning these\n// character strings explicitly.\n\n// We do not write the regexp in a straightforward way, so that an\n// apparennt html comment does not appear in this file. Thus, we avoid\n// rejection by the overly eager rejectDangerousSources.\nconst htmlCommentPattern = new RegExp(`(?:${'<'}!--|--${'>'})`);\n\nfunction rejectHtmlComments(s) {\n  const index = s.search(htmlCommentPattern);\n  if (index !== -1) {\n    const linenum = s.slice(0, index).split('\\n').length; // more or less\n    throw new SyntaxError(\n      `possible html comment syntax rejected around line ${linenum}`\n    );\n  }\n}\n\n// The proposed dynamic import expression is the only syntax currently\n// proposed, that can appear in non-module JavaScript code, that\n// enables direct access to the outside world that cannot be\n// surpressed or intercepted without parsing and rewriting. Instead,\n// this shim conservatively rejects any source text that seems to\n// contain such an expression. To do this safely without parsing, we\n// must also reject some valid programs, i.e., those containing\n// apparent import expressions in literal strings or comments.\n\n// The current conservative rule looks for the identifier \"import\"\n// followed by either an open paren or something that looks like the\n// beginning of a comment. We assume that we do not need to worry\n// about html comment syntax because that was already rejected by\n// rejectHtmlComments.\n\n// this \\s *must* match all kinds of syntax-defined whitespace. If e.g.\n// U+2028 (LINE SEPARATOR) or U+2029 (PARAGRAPH SEPARATOR) is treated as\n// whitespace by the parser, but not matched by /\\s/, then this would admit\n// an attack like: import\\u2028('power.js') . We're trying to distinguish\n// something like that from something like importnotreally('power.js') which\n// is perfectly safe.\n\nconst importPattern = /\\bimport\\s*(?:\\(|\\/[/*])/;\n\nfunction rejectImportExpressions(s) {\n  const index = s.search(importPattern);\n  if (index !== -1) {\n    const linenum = s.slice(0, index).split('\\n').length; // more or less\n    throw new SyntaxError(\n      `possible import expression rejected around line ${linenum}`\n    );\n  }\n}\n\n// The shim cannot correctly emulate a direct eval as explained at\n// https://github.com/Agoric/realms-shim/issues/12\n// Without rejecting apparent direct eval syntax, we would\n// accidentally evaluate these with an emulation of indirect eval. Tp\n// prevent future compatibility problems, in shifting from use of the\n// shim to genuine platform support for the proposal, we should\n// instead statically reject code that seems to contain a direct eval\n// expression.\n//\n// As with the dynamic import expression, to avoid a full parse, we do\n// this approximately with a regexp, that will also reject strings\n// that appear safely in comments or strings. Unlike dynamic import,\n// if we miss some, this only creates future compat problems, not\n// security problems. Thus, we are only trying to catch innocent\n// occurrences, not malicious one. In particular, `(eval)(...)` is\n// direct eval syntax that would not be caught by the following regexp.\n\nconst someDirectEvalPattern = /\\beval\\s*(?:\\(|\\/[/*])/;\n\nfunction rejectSomeDirectEvalExpressions(s) {\n  const index = s.search(someDirectEvalPattern);\n  if (index !== -1) {\n    const linenum = s.slice(0, index).split('\\n').length; // more or less\n    throw new SyntaxError(\n      `possible direct eval expression rejected around line ${linenum}`\n    );\n  }\n}\n\nexport function rejectDangerousSources(s) {\n  rejectHtmlComments(s);\n  rejectImportExpressions(s);\n  rejectSomeDirectEvalExpressions(s);\n}\n\n// Export a rewriter transform.\nexport const rejectDangerousSourcesTransform = {\n  rewrite(rs) {\n    rejectDangerousSources(rs.src);\n    return rs;\n  }\n};\n","// Portions adapted from V8 - Copyright 2016 the V8 project authors.\n// https://github.com/v8/v8/blob/master/src/builtins/builtins-function.cc\n\nimport {\n  apply,\n  arrayJoin,\n  arrayPop,\n  create,\n  defineProperties,\n  getOwnPropertyDescriptors,\n  getPrototypeOf,\n  regexpTest,\n  setPrototypeOf,\n  stringIncludes\n} from './commons';\nimport { getOptimizableGlobals } from './optimizer';\nimport { createScopeHandler } from './scopeHandler';\nimport { rejectDangerousSourcesTransform } from './sourceParser';\nimport { assert, throwTantrum } from './utilities';\n\nfunction buildOptimizer(constants) {\n  // No need to build an oprimizer when there are no constants.\n  if (constants.length === 0) return '';\n  // Use 'this' to avoid going through the scope proxy, which is unecessary\n  // since the optimizer only needs references to the safe global.\n  return `const {${arrayJoin(constants, ',')}} = this;`;\n}\n\nfunction createScopedEvaluatorFactory(unsafeRec, constants) {\n  const { unsafeFunction } = unsafeRec;\n\n  const optimizer = buildOptimizer(constants);\n\n  // Create a function in sloppy mode, so that we can use 'with'. It returns\n  // a function in strict mode that evaluates the provided code using direct\n  // eval, and thus in strict mode in the same scope. We must be very careful\n  // to not create new names in this scope\n\n  // 1: we use 'with' (around a Proxy) to catch all free variable names. The\n  // first 'arguments[0]' holds the Proxy which safely wraps the safeGlobal\n  // 2: 'optimizer' catches common variable names for speed\n  // 3: The inner strict function is effectively passed two parameters:\n  //    a) its arguments[0] is the source to be directly evaluated.\n  //    b) its 'this' is the this binding seen by the code being\n  //       directly evaluated.\n\n  // everything in the 'optimizer' string is looked up in the proxy\n  // (including an 'arguments[0]', which points at the Proxy). 'function' is\n  // a keyword, not a variable, so it is not looked up. then 'eval' is looked\n  // up in the proxy, that's the first time it is looked up after\n  // useUnsafeEvaluator is turned on, so the proxy returns the real the\n  // unsafeEval, which satisfies the IsDirectEvalTrap predicate, so it uses\n  // the direct eval and gets the lexical scope. The second 'arguments[0]' is\n  // looked up in the context of the inner function. The *contents* of\n  // arguments[0], because we're using direct eval, are looked up in the\n  // Proxy, by which point the useUnsafeEvaluator switch has been flipped\n  // back to 'false', so any instances of 'eval' in that string will get the\n  // safe evaluator.\n\n  return unsafeFunction(`\n    with (arguments[0]) {\n      ${optimizer}\n      return function() {\n        'use strict';\n        return eval(arguments[0]);\n      };\n    }\n  `);\n}\n\nexport function createSafeEvaluatorFactory(\n  unsafeRec,\n  safeGlobal,\n  transforms,\n  sloppyGlobals\n) {\n  const { unsafeFunction } = unsafeRec;\n\n  const constants = getOptimizableGlobals(safeGlobal);\n  const scopedEvaluatorFactory = createScopedEvaluatorFactory(\n    unsafeRec,\n    constants\n  );\n\n  function factory(endowments = {}, options = {}) {\n    const localTransforms = options.transforms || [];\n    const realmTransforms = transforms || [];\n\n    const mandatoryTransforms = [rejectDangerousSourcesTransform];\n    const allTransforms = [\n      ...localTransforms,\n      ...realmTransforms,\n      ...mandatoryTransforms\n    ];\n\n    // We use the the concise method syntax to create an eval without a\n    // [[Construct]] behavior (such that the invocation \"new eval()\" throws\n    // TypeError: eval is not a constructor\"), but which still accepts a\n    // 'this' binding.\n    const safeEval = {\n      eval(src) {\n        src = `${src}`;\n        // Rewrite the source, threading through rewriter state as necessary.\n        const rewriterState = allTransforms.reduce(\n          (rs, transform) => (transform.rewrite ? transform.rewrite(rs) : rs),\n          { src, endowments }\n        );\n        src = rewriterState.src;\n\n        const scopeTarget = create(\n          safeGlobal,\n          getOwnPropertyDescriptors(rewriterState.endowments)\n        );\n\n        const scopeHandler = createScopeHandler(\n          unsafeRec,\n          safeGlobal,\n          sloppyGlobals\n        );\n        const scopeProxy = new Proxy(scopeTarget, scopeHandler);\n        const scopedEvaluator = apply(scopedEvaluatorFactory, safeGlobal, [\n          scopeProxy\n        ]);\n\n        scopeHandler.allowUnsafeEvaluatorOnce();\n        let err;\n        try {\n          // Ensure that \"this\" resolves to the safe global.\n          return apply(scopedEvaluator, safeGlobal, [src]);\n        } catch (e) {\n          // stash the child-code error in hopes of debugging the internal failure\n          err = e;\n          throw e;\n        } finally {\n          // belt and suspenders: the proxy switches this off immediately after\n          // the first access, but if that's not the case we abort.\n          if (scopeHandler.unsafeEvaluatorAllowed()) {\n            throwTantrum('handler did not revoke useUnsafeEvaluator', err);\n          }\n        }\n      }\n    }.eval;\n\n    // safeEval's prototype is currently the primal realm's\n    // Function.prototype, which we must not let escape. To make 'eval\n    // instanceof Function' be true inside the realm, we need to point it at\n    // the RootRealm's value.\n\n    // Ensure that eval from any compartment in a root realm is an instance\n    // of Function in any compartment of the same root realm.\n    setPrototypeOf(safeEval, unsafeFunction.prototype);\n\n    assert(getPrototypeOf(safeEval).constructor !== Function, 'hide Function');\n    assert(\n      getPrototypeOf(safeEval).constructor !== unsafeFunction,\n      'hide unsafeFunction'\n    );\n\n    // note: be careful to not leak our primal Function.prototype by setting\n    // this to a plain arrow function. Now that we have safeEval, use it.\n    defineProperties(safeEval, {\n      toString: {\n        // We break up the following literal string so that an\n        // apparent direct eval syntax does not appear in this\n        // file. Thus, we avoid rejection by the overly eager\n        // rejectDangerousSources.\n        value: safeEval(\"() => 'function eval' + '() { [shim code] }'\"),\n        writable: false,\n        enumerable: false,\n        configurable: true\n      }\n    });\n\n    return safeEval;\n  }\n\n  return factory;\n}\n\nexport function createSafeEvaluator(safeEvaluatorFactory) {\n  return safeEvaluatorFactory();\n}\n\nexport function createSafeEvaluatorWhichTakesEndowments(safeEvaluatorFactory) {\n  return (x, endowments, options = {}) =>\n    safeEvaluatorFactory(endowments, options)(x);\n}\n\n/**\n * A safe version of the native Function which relies on\n * the safety of evalEvaluator for confinement.\n */\nexport function createFunctionEvaluator(unsafeRec, safeEval) {\n  const { unsafeFunction, unsafeGlobal } = unsafeRec;\n\n  const safeFunction = function Function(...params) {\n    const functionBody = `${arrayPop(params) || ''}`;\n    let functionParams = `${arrayJoin(params, ',')}`;\n    if (!regexpTest(/^[\\w\\s,]*$/, functionParams)) {\n      throw new unsafeGlobal.SyntaxError(\n        'shim limitation: Function arg must be simple ASCII identifiers, possibly separated by commas: no default values, pattern matches, or non-ASCII parameter names'\n      );\n      // this protects against Matt Austin's clever attack:\n      // Function(\"arg=`\", \"/*body`){});({x: this/**/\")\n      // which would turn into\n      //     (function(arg=`\n      //     /*``*/){\n      //      /*body`){});({x: this/**/\n      //     })\n      // which parses as a default argument of `\\n/*``*/){\\n/*body` , which\n      // is a pair of template literals back-to-back (so the first one\n      // nominally evaluates to the parser to use on the second one), which\n      // can't actually execute (because the first literal evals to a string,\n      // which can't be a parser function), but that doesn't matter because\n      // the function is bypassed entirely. When that gets evaluated, it\n      // defines (but does not invoke) a function, then evaluates a simple\n      // {x: this} expression, giving access to the safe global.\n    }\n\n    // Is this a real functionBody, or is someone attempting an injection\n    // attack? This will throw a SyntaxError if the string is not actually a\n    // function body. We coerce the body into a real string above to prevent\n    // someone from passing an object with a toString() that returns a safe\n    // string the first time, but an evil string the second time.\n    // eslint-disable-next-line no-new, new-cap\n    new unsafeFunction(functionBody);\n\n    if (stringIncludes(functionParams, ')')) {\n      // If the formal parameters string include ) - an illegal\n      // character - it may make the combined function expression\n      // compile. We avoid this problem by checking for this early on.\n\n      // note: v8 throws just like this does, but chrome accepts\n      // e.g. 'a = new Date()'\n      throw new unsafeGlobal.SyntaxError(\n        'shim limitation: Function arg string contains parenthesis'\n      );\n      // todo: shim integrity threat if they change SyntaxError\n    }\n\n    // todo: check to make sure this .length is safe. markm says safe.\n    if (functionParams.length > 0) {\n      // If the formal parameters include an unbalanced block comment, the\n      // function must be rejected. Since JavaScript does not allow nested\n      // comments we can include a trailing block comment to catch this.\n      functionParams += '\\n/*``*/';\n    }\n\n    const src = `(function(${functionParams}){\\n${functionBody}\\n})`;\n\n    return safeEval(src);\n  };\n\n  // Ensure that Function from any compartment in a root realm can be used\n  // with instance checks in any compartment of the same root realm.\n  setPrototypeOf(safeFunction, unsafeFunction.prototype);\n\n  assert(\n    getPrototypeOf(safeFunction).constructor !== Function,\n    'hide Function'\n  );\n  assert(\n    getPrototypeOf(safeFunction).constructor !== unsafeFunction,\n    'hide unsafeFunction'\n  );\n\n  defineProperties(safeFunction, {\n    // Ensure that any function created in any compartment in a root realm is an\n    // instance of Function in any compartment of the same root ralm.\n    prototype: { value: unsafeFunction.prototype },\n\n    // Provide a custom output without overwriting the\n    // Function.prototype.toString which is called by some third-party\n    // libraries.\n    toString: {\n      value: safeEval(\"() => 'function Function() { [shim code] }'\"),\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  return safeFunction;\n}\n","import { createRealmFacade, buildChildRealm } from './realmFacade';\nimport { createNewUnsafeRec, createCurrentUnsafeRec } from './unsafeRec';\nimport {\n  createSafeEvaluatorFactory,\n  createSafeEvaluator,\n  createSafeEvaluatorWhichTakesEndowments,\n  createFunctionEvaluator\n} from './evaluators';\nimport { assert } from './utilities';\nimport { create, defineProperties, freeze, arrayConcat } from './commons';\n\n// Mimic private members on the realm instances.\n// We define it in the same module and do not export it.\nconst RealmRecForRealmInstance = new WeakMap();\n\nfunction getRealmRecForRealmInstance(realm) {\n  // Detect non-objects.\n  assert(Object(realm) === realm, 'bad object, not a Realm instance');\n  // Realm instance has no realmRec. Should not proceed.\n  assert(RealmRecForRealmInstance.has(realm), 'Realm instance has no record');\n\n  return RealmRecForRealmInstance.get(realm);\n}\n\nfunction registerRealmRecForRealmInstance(realm, realmRec) {\n  // Detect non-objects.\n  assert(Object(realm) === realm, 'bad object, not a Realm instance');\n  // Attempt to change an existing realmRec on a realm instance. Should not proceed.\n  assert(\n    !RealmRecForRealmInstance.has(realm),\n    'Realm instance already has a record'\n  );\n\n  RealmRecForRealmInstance.set(realm, realmRec);\n}\n\n// Initialize the global variables for the new Realm.\nfunction setDefaultBindings(safeGlobal, safeEval, safeFunction) {\n  defineProperties(safeGlobal, {\n    eval: {\n      value: safeEval,\n      writable: true,\n      configurable: true\n    },\n    Function: {\n      value: safeFunction,\n      writable: true,\n      configurable: true\n    }\n  });\n}\n\nfunction createRealmRec(unsafeRec, transforms, sloppyGlobals) {\n  const { sharedGlobalDescs, unsafeGlobal } = unsafeRec;\n\n  const safeGlobal = create(unsafeGlobal.Object.prototype, sharedGlobalDescs);\n\n  const safeEvaluatorFactory = createSafeEvaluatorFactory(\n    unsafeRec,\n    safeGlobal,\n    transforms,\n    sloppyGlobals\n  );\n  const safeEval = createSafeEvaluator(safeEvaluatorFactory);\n  const safeEvalWhichTakesEndowments = createSafeEvaluatorWhichTakesEndowments(\n    safeEvaluatorFactory\n  );\n  const safeFunction = createFunctionEvaluator(unsafeRec, safeEval);\n\n  setDefaultBindings(safeGlobal, safeEval, safeFunction);\n\n  const realmRec = freeze({\n    safeGlobal,\n    safeEval,\n    safeEvalWhichTakesEndowments,\n    safeFunction\n  });\n\n  return realmRec;\n}\n\n/**\n * A root realm uses a fresh set of new intrinics. Here we first create\n * a new unsafe record, which inherits the shims. Then we proceed with\n * the creation of the realm record, and we apply the shims.\n */\nfunction initRootRealm(parentUnsafeRec, self, options) {\n  // note: 'self' is the instance of the Realm.\n\n  // todo: investigate attacks via Array.species\n  // todo: this accepts newShims='string', but it should reject that\n  const { shims: newShims, transforms, sloppyGlobals } = options;\n  const allShims = arrayConcat(parentUnsafeRec.allShims, newShims);\n\n  // The unsafe record is created already repaired.\n  const unsafeRec = createNewUnsafeRec(allShims);\n\n  // eslint-disable-next-line no-use-before-define\n  const Realm = createRealmFacade(unsafeRec, BaseRealm);\n\n  // Add a Realm descriptor to sharedGlobalDescs, so it can be defined onto the\n  // safeGlobal like the rest of the globals.\n  unsafeRec.sharedGlobalDescs.Realm = {\n    value: Realm,\n    writable: true,\n    configurable: true\n  };\n\n  // Creating the realmRec provides the global object, eval() and Function()\n  // to the realm.\n  const realmRec = createRealmRec(unsafeRec, transforms, sloppyGlobals);\n\n  // Apply all shims in the new RootRealm. We don't do this for compartments.\n  const { safeEvalWhichTakesEndowments } = realmRec;\n  for (const shim of allShims) {\n    safeEvalWhichTakesEndowments(shim);\n  }\n\n  // The realmRec acts as a private field on the realm instance.\n  registerRealmRecForRealmInstance(self, realmRec);\n}\n\n/**\n * A compartment shares the intrinsics of its root realm. Here, only a\n * realmRec is necessary to hold the global object, eval() and Function().\n */\nfunction initCompartment(unsafeRec, self, options = {}) {\n  // note: 'self' is the instance of the Realm.\n\n  const { transforms, sloppyGlobals } = options;\n  const realmRec = createRealmRec(unsafeRec, transforms, sloppyGlobals);\n\n  // The realmRec acts as a private field on the realm instance.\n  registerRealmRecForRealmInstance(self, realmRec);\n}\n\nfunction getRealmGlobal(self) {\n  const { safeGlobal } = getRealmRecForRealmInstance(self);\n  return safeGlobal;\n}\n\nfunction realmEvaluate(self, x, endowments = {}, options = {}) {\n  // todo: don't pass in primal-realm objects like {}, for safety. OTOH its\n  // properties are copied onto the new global 'target'.\n  // todo: figure out a way to membrane away the contents to safety.\n  const { safeEvalWhichTakesEndowments } = getRealmRecForRealmInstance(self);\n  return safeEvalWhichTakesEndowments(x, endowments, options);\n}\n\nconst BaseRealm = {\n  initRootRealm,\n  initCompartment,\n  getRealmGlobal,\n  realmEvaluate\n};\n\n// Create the current unsafeRec from the current \"primal\" environment (the realm\n// where the Realm shim is loaded and executed).\nconst currentUnsafeRec = createCurrentUnsafeRec();\n\n/**\n * The \"primal\" realm class is defined in the current \"primal\" environment,\n * and is part of the shim. There is no need to facade this class via evaluation\n * because both share the same intrinsics.\n */\nconst Realm = buildChildRealm(currentUnsafeRec, BaseRealm);\n\nexport default Realm;\n"],"names":["throwTantrum","s","err","msg","console","error","stack","assert","condition","message","cleanupSource","src","buildChildRealm","unsafeRec","BaseRealm","callAndWrapError","target","args","Object","eName","eMessage","eStack","name","ignored","Error","ErrorConstructor","errorConstructors","get","err2","initRootRealm","initCompartment","getRealmGlobal","realmEvaluate","create","defineProperties","Map","EvalError","RangeError","ReferenceError","SyntaxError","TypeError","URIError","Realm","constructor","makeRootRealm","options","r","prototype","makeCompartment","global","evaluate","x","endowments","toString","value","writable","enumerable","configurable","buildChildRealmString","createRealmFacade","unsafeEval","assign","freeze","getOwnPropertyDescriptor","getOwnPropertyDescriptors","getOwnPropertyNames","getPrototypeOf","setPrototypeOf","apply","ownKeys","Reflect","uncurryThis","fn","thisArg","objectHasOwnProperty","hasOwnProperty","arrayFilter","Array","filter","arrayPop","pop","arrayJoin","join","arrayConcat","concat","regexpTest","RegExp","test","stringIncludes","String","includes","frozenGlobalPropertyNames","stableGlobalPropertyNames","unstableGlobalPropertyNames","getSharedGlobalDescs","unsafeGlobal","describe","names","desc","descriptors","repairAccessors","toObject","obj","asPropertyName","aFunction","accessor","defineProperty","objectPrototype","__lookupGetter__","ignore","__defineGetter__","prop","func","O","__defineSetter__","set","__lookupSetter__","globalEval","eval","repairFunctions","repairFunction","declaration","FunctionInstance","e","FunctionPrototype","TamedFunction","Function","unsafeGlobalSrc","unsafeGlobalEvalSrc","createNewUnsafeGlobalForNode","isNode","vm","require","runInNewContext","createNewUnsafeGlobalForBrowser","document","iframe","createElement","style","display","body","appendChild","contentWindow","getNewUnsafeGlobal","newUnsafeGlobalForBrowser","newUnsafeGlobalForNode","createUnsafeRec","allShims","sharedGlobalDescs","unsafeFunction","repairAccessorsShim","repairFunctionsShim","createNewUnsafeRec","createCurrentUnsafeRec","identifierPattern","keywords","Set","getOptimizableGlobals","safeGlobal","descs","constants","has","alwaysThrowHandler","Proxy","createScopeHandler","sloppyGlobals","useUnsafeEvaluator","__proto__","allowUnsafeEvaluatorOnce","unsafeEvaluatorAllowed","Symbol","unscopables","htmlCommentPattern","rejectHtmlComments","index","search","linenum","slice","split","length","importPattern","rejectImportExpressions","someDirectEvalPattern","rejectSomeDirectEvalExpressions","rejectDangerousSources","rejectDangerousSourcesTransform","rewrite","rs","buildOptimizer","createScopedEvaluatorFactory","optimizer","createSafeEvaluatorFactory","transforms","scopedEvaluatorFactory","localTransforms","allTransforms","safeEval","rewriterState","reduce","transform","scopeTarget","scopeHandler","scopeProxy","scopedEvaluator","createSafeEvaluator","safeEvaluatorFactory","createSafeEvaluatorWhichTakesEndowments","createFunctionEvaluator","safeFunction","params","functionBody","functionParams","RealmRecForRealmInstance","WeakMap","getRealmRecForRealmInstance","realm","registerRealmRecForRealmInstance","realmRec","setDefaultBindings","createRealmRec","safeEvalWhichTakesEndowments","parentUnsafeRec","self","shims","newShims","shim","currentUnsafeRec"],"mappings":"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"}
##############################################
/src/dist/realms-shim.esm.min.js:1:function throwTantrum(a,b=void 0){const c=`please report internal shim error: ${a}`;console.error(c),b&&(console.error(`${b}`),console.error(`${b.stack}`));debugger;throw c}function assert(a,b){a||throwTantrum(b)}function cleanupSource(a){return a}function buildChildRealm(a,b){function c(a,...b){try{return a(...b)}catch(a){if(Object(a)!==a)throw a;let b,c,d;try{b=`${a.name}`,c=`${a.message}`,d=`${a.stack||c}`}catch(a){throw new Error("unknown error")}const e=j.get(b)||Error;try{throw new e(c)}catch(a){throw a.stack=d,a}}}const{initRootRealm:d,initCompartment:e,getRealmGlobal:f,realmEvaluate:g}=b,{create:h,defineProperties:i}=Object,j=new Map([["EvalError",EvalError],["RangeError",RangeError],["ReferenceError",ReferenceError],["SyntaxError",SyntaxError],["TypeError",TypeError],["URIError",URIError]]);class k{constructor(){throw new TypeError("Realm is not a constructor")}static makeRootRealm(b={}){const e=h(k.prototype);return c(d,a,e,b),e}static makeCompartment(b={}){const d=h(k.prototype);return c(e,a,d,b),d}get global(){return c(f,this)}evaluate(a,b,d={}){return c(g,this,a,b,d)}}return i(k,{toString:{value:()=>"function Realm() { [shim code] }",writable:!1,enumerable:!1,configurable:!0}}),i(k.prototype,{toString:{value:()=>"[object Realm]",writable:!1,enumerable:!1,configurable:!0}}),k}const buildChildRealmString=cleanupSource(`'use strict'; (${buildChildRealm})`);function createRealmFacade(a,b){const{unsafeEval:c}=a;return c(buildChildRealmString)(a,b)}const{assign,create,freeze,defineProperties,getOwnPropertyDescriptor,getOwnPropertyDescriptors,getOwnPropertyNames,getPrototypeOf,setPrototypeOf}=Object,{apply,ownKeys}=Reflect,uncurryThis=a=>(b,...c)=>apply(a,b,c),objectHasOwnProperty=uncurryThis(Object.prototype.hasOwnProperty),arrayFilter=uncurryThis(Array.prototype.filter),arrayPop=uncurryThis(Array.prototype.pop),arrayJoin=uncurryThis(Array.prototype.join),arrayConcat=uncurryThis(Array.prototype.concat),regexpTest=uncurryThis(RegExp.prototype.test),stringIncludes=uncurryThis(String.prototype.includes),frozenGlobalPropertyNames=["Infinity","NaN","undefined"],stableGlobalPropertyNames=["isFinite","isNaN","parseFloat","parseInt","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","Array","ArrayBuffer","Boolean","DataView","EvalError","Float32Array","Float64Array","Int8Array","Int16Array","Int32Array","Map","Number","Object","RangeError","ReferenceError","Set","String","Symbol","SyntaxError","TypeError","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","URIError","WeakMap","WeakSet","JSON","Math","Reflect","escape","unescape"],unstableGlobalPropertyNames=["Date","Error","Promise","Proxy","RegExp","Intl"];function getSharedGlobalDescs(a){function b(b,d,e,f){for(const g of b){const b=getOwnPropertyDescriptor(a,g);b&&(assert("value"in b,`unexpected accessor on global property: ${g}`),c[g]={value:b.value,writable:d,enumerable:e,configurable:f})}}const c={};return b(frozenGlobalPropertyNames,!1,!1,!1),b(stableGlobalPropertyNames,!1,!1,!1),b(unstableGlobalPropertyNames,!0,!1,!0),c}function repairAccessors(){function a(a){if(a===void 0||null===a)throw new TypeError(`can't convert undefined or null to object`);return Object(a)}function b(a){return"symbol"==typeof a?a:`${a}`}function c(a,b){if("function"!=typeof a)throw TypeError(`invalid ${b} usage`);return a}const{defineProperty:d,defineProperties:e,getOwnPropertyDescriptor:f,getPrototypeOf:g,prototype:h}=Object;try{(0,h.__lookupGetter__)("x")}catch(a){return}e(h,{__defineGetter__:{value:function(b,e){const f=a(this);d(f,b,{get:c(e,"getter"),enumerable:!0,configurable:!0})}},__defineSetter__:{value:function(b,e){const f=a(this);d(f,b,{set:c(e,"setter"),enumerable:!0,configurable:!0})}},__lookupGetter__:{value:function(c){let d=a(this);c=b(c);let e;for(;d&&!(e=f(d,c));)d=g(d);return e&&e.get}},__lookupSetter__:{value:function(c){let d=a(this);c=b(c);let e;for(;d&&!(e=f(d,c));)d=g(d);return e&&e.set}}})}const globalEval=eval;function repairFunctions(){function a(a,e){let f;try{f=globalEval(e)}catch(a){if(a instanceof SyntaxError)return;throw a}const g=c(f),h=function(){throw new TypeError("Not available")};b(h,{name:{value:a}}),b(g,{constructor:{value:h}}),b(h,{prototype:{value:g}}),h!==Function.prototype.constructor&&d(h,Function.prototype.constructor)}const{defineProperties:b,getPrototypeOf:c,setPrototypeOf:d}=Object;a("Function","(function(){})"),a("GeneratorFunction","(function*(){})"),a("AsyncFunction","(async function(){})"),a("AsyncGeneratorFunction","(async function*(){})")}const unsafeGlobalSrc="'use strict'; this",unsafeGlobalEvalSrc=`(0, eval)("'use strict'; this")`;function createNewUnsafeGlobalForNode(){const a=new Function("try {return this===global}catch(e){return false}")();if(!a)return;const b=require("vm"),c=b.runInNewContext(unsafeGlobalEvalSrc);return c}function createNewUnsafeGlobalForBrowser(){if("undefined"!=typeof document){const a=document.createElement("iframe");a.style.display="none",document.body.appendChild(a);const b=a.contentWindow.eval(unsafeGlobalSrc);return b}}const getNewUnsafeGlobal=()=>{const a=createNewUnsafeGlobalForBrowser(),b=createNewUnsafeGlobalForNode();if(!a&&!b||a&&b)throw new Error("unexpected platform, unable to create Realm");return a||b};function createUnsafeRec(a,b=[]){const c=getSharedGlobalDescs(a);return freeze({unsafeGlobal:a,sharedGlobalDescs:c,unsafeEval:a.eval,unsafeFunction:a.Function,allShims:b})}const repairAccessorsShim=cleanupSource(`"use strict"; (${repairAccessors})();`),repairFunctionsShim=cleanupSource(`"use strict"; const globalEval = eval; (${repairFunctions})();`);function createNewUnsafeRec(a){const b=getNewUnsafeGlobal();return b.eval(repairAccessorsShim),b.eval(repairFunctionsShim),createUnsafeRec(b,a)}function createCurrentUnsafeRec(){const a=(0,eval)(unsafeGlobalSrc);return repairAccessors(),repairFunctions(),createUnsafeRec(a)}const identifierPattern=/^[a-zA-Z_$][\w$]*$/,keywords=new Set(["await","break","case","catch","class","const","continue","debugger","default","delete","do","else","export","extends","finally","for","function","if","import","in","instanceof","new","return","super","switch","this","throw","try","typeof","var","void","while","with","yield","let","static","enum","implements","package","protected","interface","private","public","await","null","true","false","this","arguments"]);function getOptimizableGlobals(a){const b=getOwnPropertyDescriptors(a),c=arrayFilter(getOwnPropertyNames(b),a=>{if("eval"===a||keywords.has(a)||!regexpTest(identifierPattern,a))return!1;const c=b[a];return!1===c.configurable&&!1===c.writable&&objectHasOwnProperty(c,"value")});return c}const alwaysThrowHandler=new Proxy(freeze({}),{get(a,b){throwTantrum(`unexpected scope handler trap called: ${b}`)}});function createScopeHandler(a,b,c){const{unsafeGlobal:d,unsafeEval:e}=a;let f=!1;return{__proto__:alwaysThrowHandler,allowUnsafeEvaluatorOnce(){f=!0},unsafeEvaluatorAllowed(){return f},get(a,b){return"eval"===b?!0===f?(f=!1,e):a.eval:b===Symbol.unscopables?void 0:b in a?a[b]:void 0},set(a,c,d){if(objectHasOwnProperty(a,c))throw new TypeError(`do not modify endowments like ${c+""}`);return b[c]=d,!0},has(a,b){return!!c||!!("eval"===b||b in a||b in d)}}}const htmlCommentPattern=/(?:<!--|-->)/;function rejectHtmlComments(a){const b=a.search(htmlCommentPattern);if(-1!==b){const c=a.slice(0,b).split("\n").length;throw new SyntaxError(`possible html comment syntax rejected around line ${c}`)}}const importPattern=/\bimport\s*(?:\(|\/[/*])/;function rejectImportExpressions(a){const b=a.search(importPattern);if(-1!==b){const c=a.slice(0,b).split("\n").length;throw new SyntaxError(`possible import expression rejected around line ${c}`)}}const someDirectEvalPattern=/\beval\s*(?:\(|\/[/*])/;function rejectSomeDirectEvalExpressions(a){const b=a.search(someDirectEvalPattern);if(-1!==b){const c=a.slice(0,b).split("\n").length;throw new SyntaxError(`possible direct eval expression rejected around line ${c}`)}}function rejectDangerousSources(a){rejectHtmlComments(a),rejectImportExpressions(a),rejectSomeDirectEvalExpressions(a)}const rejectDangerousSourcesTransform={rewrite(a){return rejectDangerousSources(a.src),a}};function buildOptimizer(a){return 0===a.length?"":`const {${arrayJoin(a,",")}} = this;`}function createScopedEvaluatorFactory(a,b){const{unsafeFunction:c}=a,d=buildOptimizer(b);return c(`
/src/dist/realms-shim.esm.min.js-2-    with (arguments[0]) {
##############################################
/src/dist/realms-shim.esm.min.js-5-        'use strict';
/src/dist/realms-shim.esm.min.js:6:        return eval(arguments[0]);
/src/dist/realms-shim.esm.min.js-7-      };
/src/dist/realms-shim.esm.min.js-8-    }
/src/dist/realms-shim.esm.min.js:9:  `)}function createSafeEvaluatorFactory(a,b,c,d){const{unsafeFunction:e}=a,f=getOptimizableGlobals(b),g=createScopedEvaluatorFactory(a,f);return function(f={},h={}){const i=h.transforms||[],j=[...i,...(c||[]),...[rejectDangerousSourcesTransform]],k={eval(c){c=`${c}`;const e=j.reduce((a,b)=>b.rewrite?b.rewrite(a):a,{src:c,endowments:f});c=e.src;const h=create(b,getOwnPropertyDescriptors(e.endowments)),i=createScopeHandler(a,b,d),k=new Proxy(h,i),l=apply(g,b,[k]);i.allowUnsafeEvaluatorOnce();let m;try{return apply(l,b,[c])}catch(a){throw m=a,a}finally{i.unsafeEvaluatorAllowed()&&throwTantrum("handler did not revoke useUnsafeEvaluator",m)}}}.eval;return setPrototypeOf(k,e.prototype),assert(getPrototypeOf(k).constructor!==Function,"hide Function"),assert(getPrototypeOf(k).constructor!==e,"hide unsafeFunction"),defineProperties(k,{toString:{value:k("() => 'function eval' + '() { [shim code] }'"),writable:!1,enumerable:!1,configurable:!0}}),k}}function createSafeEvaluator(a){return a()}function createSafeEvaluatorWhichTakesEndowments(a){return(b,c,d={})=>a(c,d)(b)}function createFunctionEvaluator(a,b){const{unsafeFunction:c,unsafeGlobal:d}=a,e=function(...a){const e=`${arrayPop(a)||""}`;let f=`${arrayJoin(a,",")}`;if(!regexpTest(/^[\w\s,]*$/,f))throw new d.SyntaxError("shim limitation: Function arg must be simple ASCII identifiers, possibly separated by commas: no default values, pattern matches, or non-ASCII parameter names");if(new c(e),stringIncludes(f,")"))throw new d.SyntaxError("shim limitation: Function arg string contains parenthesis");0<f.length&&(f+="\n/*``*/");const g=`(function(${f}){\n${e}\n})`;return b(g)};return setPrototypeOf(e,c.prototype),assert(getPrototypeOf(e).constructor!==Function,"hide Function"),assert(getPrototypeOf(e).constructor!==c,"hide unsafeFunction"),defineProperties(e,{prototype:{value:c.prototype},toString:{value:b("() => 'function Function() { [shim code] }'"),writable:!1,enumerable:!1,configurable:!0}}),e}const RealmRecForRealmInstance=new WeakMap;function getRealmRecForRealmInstance(a){return assert(Object(a)===a,"bad object, not a Realm instance"),assert(RealmRecForRealmInstance.has(a),"Realm instance has no record"),RealmRecForRealmInstance.get(a)}function registerRealmRecForRealmInstance(a,b){assert(Object(a)===a,"bad object, not a Realm instance"),assert(!RealmRecForRealmInstance.has(a),"Realm instance already has a record"),RealmRecForRealmInstance.set(a,b)}function setDefaultBindings(a,b,c){defineProperties(a,{eval:{value:b,writable:!0,configurable:!0},Function:{value:c,writable:!0,configurable:!0}})}function createRealmRec(a,b,c){const{sharedGlobalDescs:d,unsafeGlobal:e}=a,f=create(e.Object.prototype,d),g=createSafeEvaluatorFactory(a,f,b,c),h=createSafeEvaluator(g),i=createSafeEvaluatorWhichTakesEndowments(g),j=createFunctionEvaluator(a,h);setDefaultBindings(f,h,j);const k=freeze({safeGlobal:f,safeEval:h,safeEvalWhichTakesEndowments:i,safeFunction:j});return k}function initRootRealm(a,b,c){const{shims:d,transforms:e,sloppyGlobals:f}=c,g=arrayConcat(a.allShims,d),h=createNewUnsafeRec(g),i=createRealmFacade(h,BaseRealm);h.sharedGlobalDescs.Realm={value:i,writable:!0,configurable:!0};const j=createRealmRec(h,e,f),{safeEvalWhichTakesEndowments:k}=j;for(const d of g)k(d);registerRealmRecForRealmInstance(b,j)}function initCompartment(a,b,c={}){const{transforms:d,sloppyGlobals:e}=c,f=createRealmRec(a,d,e);registerRealmRecForRealmInstance(b,f)}function getRealmGlobal(a){const{safeGlobal:b}=getRealmRecForRealmInstance(a);return b}function realmEvaluate(a,b,c={},d={}){const{safeEvalWhichTakesEndowments:e}=getRealmRecForRealmInstance(a);return e(b,c,d)}const BaseRealm={initRootRealm,initCompartment,getRealmGlobal,realmEvaluate},currentUnsafeRec=createCurrentUnsafeRec(),Realm=buildChildRealm(currentUnsafeRec,BaseRealm);export default Realm;
/src/dist/realms-shim.esm.min.js-10-//# sourceMappingURL=realms-shim.esm.min.js.map
##############################################
/src/dist/realms-shim.cjs.js.map:1:{"version":3,"file":"realms-shim.cjs.js","sources":["../src/utilities.js","../src/realmFacade.js","../src/commons.js","../src/stdlib.js","../src/repair/accessors.js","../src/repair/functions.js","../src/unsafeRec.js","../src/optimizer.js","../src/scopeHandler.js","../src/sourceParser.js","../src/evaluators.js","../src/realm.js"],"sourcesContent":["// we'd like to abandon, but we can't, so just scream and break a lot of\n// stuff. However, since we aren't really aborting the process, be careful to\n// not throw an Error object which could be captured by child-Realm code and\n// used to access the (too-powerful) primal-realm Error object.\n\nexport function throwTantrum(s, err = undefined) {\n  const msg = `please report internal shim error: ${s}`;\n\n  // we want to log these 'should never happen' things.\n  // eslint-disable-next-line no-console\n  console.error(msg);\n  if (err) {\n    // eslint-disable-next-line no-console\n    console.error(`${err}`);\n    // eslint-disable-next-line no-console\n    console.error(`${err.stack}`);\n  }\n\n  // eslint-disable-next-line no-debugger\n  debugger;\n  throw msg;\n}\n\nexport function assert(condition, message) {\n  if (!condition) {\n    throwTantrum(message);\n  }\n}\n\n// Remove code modifications.\nexport function cleanupSource(src) {\n  /* START_TESTS_ONLY */\n\n  // Restore eval which is modified by esm module.\n  src = src.replace(/\\(0,[^)]+\\)/g, '(0, eval)');\n\n  // Remove code coverage which is injected by nyc module.\n  src = src.replace(/cov_[^+]+\\+\\+[;,]/g, '');\n\n  /* END_TESTS_ONLY */\n  return src;\n}\n","import { cleanupSource } from './utilities';\n\n// buildChildRealm is immediately turned into a string, and this function is\n// never referenced again, because it closes over the wrong intrinsics\n\nexport function buildChildRealm(unsafeRec, BaseRealm) {\n  const {\n    initRootRealm,\n    initCompartment,\n    getRealmGlobal,\n    realmEvaluate\n  } = BaseRealm;\n\n  // This Object and Reflect are brand new, from a new unsafeRec, so no user\n  // code has been run or had a chance to manipulate them. We extract these\n  // properties for brevity, not for security. Don't ever run this function\n  // *after* user code has had a chance to pollute its environment, or it\n  // could be used to gain access to BaseRealm and primal-realm Error\n  // objects.\n  const { create, defineProperties } = Object;\n\n  const errorConstructors = new Map([\n    ['EvalError', EvalError],\n    ['RangeError', RangeError],\n    ['ReferenceError', ReferenceError],\n    ['SyntaxError', SyntaxError],\n    ['TypeError', TypeError],\n    ['URIError', URIError]\n  ]);\n\n  // Like Realm.apply except that it catches anything thrown and rethrows it\n  // as an Error from this realm\n  function callAndWrapError(target, ...args) {\n    try {\n      return target(...args);\n    } catch (err) {\n      if (Object(err) !== err) {\n        // err is a primitive value, which is safe to rethrow\n        throw err;\n      }\n      let eName, eMessage, eStack;\n      try {\n        // The child environment might seek to use 'err' to reach the\n        // parent's intrinsics and corrupt them. `${err.name}` will cause\n        // string coercion of 'err.name'. If err.name is an object (probably\n        // a String of the parent Realm), the coercion uses\n        // err.name.toString(), which is under the control of the parent. If\n        // err.name were a primitive (e.g. a number), it would use\n        // Number.toString(err.name), using the child's version of Number\n        // (which the child could modify to capture its argument for later\n        // use), however primitives don't have properties like .prototype so\n        // they aren't useful for an attack.\n        eName = `${err.name}`;\n        eMessage = `${err.message}`;\n        eStack = `${err.stack || eMessage}`;\n        // eName/eMessage/eStack are now child-realm primitive strings, and\n        // safe to expose\n      } catch (ignored) {\n        // if err.name.toString() throws, keep the (parent realm) Error away\n        // from the child\n        throw new Error('unknown error');\n      }\n      const ErrorConstructor = errorConstructors.get(eName) || Error;\n      try {\n        throw new ErrorConstructor(eMessage);\n      } catch (err2) {\n        err2.stack = eStack; // replace with the captured inner stack\n        throw err2;\n      }\n    }\n  }\n\n  class Realm {\n    constructor() {\n      // The Realm constructor is not intended to be used with the new operator\n      // or to be subclassed. It may be used as the value of an extends clause\n      // of a class definition but a super call to the Realm constructor will\n      // cause an exception.\n\n      // When Realm is called as a function, an exception is also raised because\n      // a class constructor cannot be invoked without 'new'.\n      throw new TypeError('Realm is not a constructor');\n    }\n\n    static makeRootRealm(options = {}) {\n      // This is the exposed interface.\n\n      // Bypass the constructor.\n      const r = create(Realm.prototype);\n      callAndWrapError(initRootRealm, unsafeRec, r, options);\n      return r;\n    }\n\n    static makeCompartment(options = {}) {\n      // Bypass the constructor.\n      const r = create(Realm.prototype);\n      callAndWrapError(initCompartment, unsafeRec, r, options);\n      return r;\n    }\n\n    // we omit the constructor because it is empty. All the personalization\n    // takes place in one of the two static methods,\n    // makeRootRealm/makeCompartment\n\n    get global() {\n      // this is safe against being called with strange 'this' because\n      // baseGetGlobal immediately does a trademark check (it fails unless\n      // this 'this' is present in a weakmap that is only populated with\n      // legitimate Realm instances)\n      return callAndWrapError(getRealmGlobal, this);\n    }\n\n    evaluate(x, endowments, options = {}) {\n      // safe against strange 'this', as above\n      return callAndWrapError(realmEvaluate, this, x, endowments, options);\n    }\n  }\n\n  defineProperties(Realm, {\n    toString: {\n      value: () => 'function Realm() { [shim code] }',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  defineProperties(Realm.prototype, {\n    toString: {\n      value: () => '[object Realm]',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  return Realm;\n}\n\n// The parentheses means we don't bind the 'buildChildRealm' name inside the\n// child's namespace. this would accept an anonymous function declaration.\n// function expression (not a declaration) so it has a completion value.\nconst buildChildRealmString = cleanupSource(\n  `'use strict'; (${buildChildRealm})`\n);\n\nexport function createRealmFacade(unsafeRec, BaseRealm) {\n  const { unsafeEval } = unsafeRec;\n\n  // The BaseRealm is the Realm class created by\n  // the shim. It's only valid for the context where\n  // it was parsed.\n\n  // The Realm facade is a lightweight class built in the\n  // context a different context, that provide a fully\n  // functional Realm class using the intrisics\n  // of that context.\n\n  // This process is simplified because all methods\n  // and properties on a realm instance already return\n  // values using the intrinsics of the realm's context.\n\n  // Invoke the BaseRealm constructor with Realm as the prototype.\n  return unsafeEval(buildChildRealmString)(unsafeRec, BaseRealm);\n}\n","// Declare shorthand functions. Sharing these declarations across modules\n// improves both consistency and minification. Unused declarations are\n// dropped by the tree shaking process.\n\n// we capture these, not just for brevity, but for security. If any code\n// modifies Object to change what 'assign' points to, the Realm shim would be\n// corrupted.\n\nexport const {\n  assign,\n  create,\n  freeze,\n  defineProperties, // Object.defineProperty is allowed to fail\n  // silentlty, use Object.defineProperties instead.\n  getOwnPropertyDescriptor,\n  getOwnPropertyDescriptors,\n  getOwnPropertyNames,\n  getPrototypeOf,\n  setPrototypeOf\n} = Object;\n\nexport const {\n  apply,\n  ownKeys // Reflect.ownKeys includes Symbols and unenumerables,\n  // unlike Object.keys()\n} = Reflect;\n\n/**\n * uncurryThis() See\n * http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\n * which only lives at\n * http://web.archive.org/web/20160805225710/http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\n *\n * Performance:\n * 1. The native call is about 10x faster on FF than chrome\n * 2. The version using Function.bind() is about 100x slower on FF,\n *    equal on chrome, 2x slower on Safari\n * 3. The version using a spread and Reflect.apply() is about 10x\n *    slower on FF, equal on chrome, 2x slower on Safari\n *\n * const bind = Function.prototype.bind;\n * const uncurryThis = bind.bind(bind.call);\n */\nconst uncurryThis = fn => (thisArg, ...args) => apply(fn, thisArg, args);\n\n// We also capture these for security: changes to Array.prototype after the\n// Realm shim runs shouldn't affect subsequent Realm operations.\nexport const objectHasOwnProperty = uncurryThis(\n    Object.prototype.hasOwnProperty\n  ),\n  arrayForEach = uncurryThis(Array.prototype.forEach),\n  arrayFilter = uncurryThis(Array.prototype.filter),\n  arrayPush = uncurryThis(Array.prototype.push),\n  arrayPop = uncurryThis(Array.prototype.pop),\n  arrayJoin = uncurryThis(Array.prototype.join),\n  arrayConcat = uncurryThis(Array.prototype.concat),\n  regexpTest = uncurryThis(RegExp.prototype.test),\n  stringMatch = uncurryThis(String.prototype.match),\n  stringIncludes = uncurryThis(String.prototype.includes);\n","import { getOwnPropertyDescriptor } from './commons';\nimport { assert } from './utilities';\n\n// These value properties of the global object are non-writable,\n// non-configurable data properties.\nconst frozenGlobalPropertyNames = [\n  // *** 18.1 Value Properties of the Global Object\n\n  'Infinity',\n  'NaN',\n  'undefined'\n];\n\n// All the following stdlib items have the same name on both our intrinsics\n// object and on the global object. Unlike Infinity/NaN/undefined, these\n// should all be writable and configurable. This is divided into two\n// sets. The stable ones are those the shim can freeze early because\n// we don't expect anyone will want to mutate them. The unstable ones\n// are the ones that we correctly initialize to writable and\n// configurable so that they can still be replaced or removed.\nconst stableGlobalPropertyNames = [\n  // *** 18.2 Function Properties of the Global Object\n\n  // 'eval', // comes from safeEval instead\n  'isFinite',\n  'isNaN',\n  'parseFloat',\n  'parseInt',\n\n  'decodeURI',\n  'decodeURIComponent',\n  'encodeURI',\n  'encodeURIComponent',\n\n  // *** 18.3 Constructor Properties of the Global Object\n\n  'Array',\n  'ArrayBuffer',\n  'Boolean',\n  'DataView',\n  // 'Date',  // Unstable\n  // 'Error',  // Unstable\n  'EvalError',\n  'Float32Array',\n  'Float64Array',\n  // 'Function',  // comes from safeFunction instead\n  'Int8Array',\n  'Int16Array',\n  'Int32Array',\n  'Map',\n  'Number',\n  'Object',\n  // 'Promise',  // Unstable\n  // 'Proxy',  // Unstable\n  'RangeError',\n  'ReferenceError',\n  // 'RegExp',  // Unstable\n  'Set',\n  // 'SharedArrayBuffer'  // removed on Jan 5, 2018\n  'String',\n  'Symbol',\n  'SyntaxError',\n  'TypeError',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Uint16Array',\n  'Uint32Array',\n  'URIError',\n  'WeakMap',\n  'WeakSet',\n\n  // *** 18.4 Other Properties of the Global Object\n\n  // 'Atomics', // removed on Jan 5, 2018\n  'JSON',\n  'Math',\n  'Reflect',\n\n  // *** Annex B\n\n  'escape',\n  'unescape'\n\n  // *** ECMA-402\n\n  // 'Intl'  // Unstable\n\n  // *** ESNext\n\n  // 'Realm' // Comes from createRealmGlobalObject()\n];\n\nconst unstableGlobalPropertyNames = [\n  'Date',\n  'Error',\n  'Promise',\n  'Proxy',\n  'RegExp',\n  'Intl'\n];\n\nexport function getSharedGlobalDescs(unsafeGlobal) {\n  const descriptors = {};\n\n  function describe(names, writable, enumerable, configurable) {\n    for (const name of names) {\n      const desc = getOwnPropertyDescriptor(unsafeGlobal, name);\n      if (desc) {\n        // Abort if an accessor is found on the unsafe global object\n        // instead of a data property. We should never get into this\n        // non standard situation.\n        assert(\n          'value' in desc,\n          `unexpected accessor on global property: ${name}`\n        );\n\n        descriptors[name] = {\n          value: desc.value,\n          writable,\n          enumerable,\n          configurable\n        };\n      }\n    }\n  }\n\n  describe(frozenGlobalPropertyNames, false, false, false);\n  // The following is correct but expensive.\n  // describe(stableGlobalPropertyNames, true, false, true);\n  // Instead, for now, we let these get optimized.\n  //\n  // TODO: We should provide an option to turn this optimization off,\n  // by feeding \"true, false, true\" here instead.\n  describe(stableGlobalPropertyNames, false, false, false);\n  // These we keep replaceable and removable, because we expect\n  // others, e.g., SES, may want to do so.\n  describe(unstableGlobalPropertyNames, true, false, true);\n\n  return descriptors;\n}\n","// Adapted from SES/Caja - Copyright (C) 2011 Google Inc.\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js\n\n/**\n * Replace the legacy accessors of Object to comply with strict mode\n * and ES2016 semantics, we do this by redefining them while in 'use strict'.\n *\n * todo: list the issues resolved\n *\n * This function can be used in two ways: (1) invoked directly to fix the primal\n * realm's Object.prototype, and (2) converted to a string to be executed\n * inside each new RootRealm to fix their Object.prototypes. Evaluation requires\n * the function to have no dependencies, so don't import anything from\n * the outside.\n */\n\n// todo: this file should be moved out to a separate repo and npm module.\nexport function repairAccessors() {\n  const {\n    defineProperty,\n    defineProperties,\n    getOwnPropertyDescriptor,\n    getPrototypeOf,\n    prototype: objectPrototype\n  } = Object;\n\n  // On some platforms, the implementation of these functions act as\n  // if they are in sloppy mode: if they're invoked badly, they will\n  // expose the global object, so we need to repair these for\n  // security. Thus it is our responsibility to fix this, and we need\n  // to include repairAccessors. E.g. Chrome in 2016.\n\n  try {\n    // Verify that the method is not callable.\n    // eslint-disable-next-line no-restricted-properties, no-underscore-dangle\n    (0, objectPrototype.__lookupGetter__)('x');\n  } catch (ignore) {\n    // Throws, no need to patch.\n    return;\n  }\n\n  function toObject(obj) {\n    if (obj === undefined || obj === null) {\n      throw new TypeError(`can't convert undefined or null to object`);\n    }\n    return Object(obj);\n  }\n\n  function asPropertyName(obj) {\n    if (typeof obj === 'symbol') {\n      return obj;\n    }\n    return `${obj}`;\n  }\n\n  function aFunction(obj, accessor) {\n    if (typeof obj !== 'function') {\n      throw TypeError(`invalid ${accessor} usage`);\n    }\n    return obj;\n  }\n\n  defineProperties(objectPrototype, {\n    __defineGetter__: {\n      value: function __defineGetter__(prop, func) {\n        const O = toObject(this);\n        defineProperty(O, prop, {\n          get: aFunction(func, 'getter'),\n          enumerable: true,\n          configurable: true\n        });\n      }\n    },\n    __defineSetter__: {\n      value: function __defineSetter__(prop, func) {\n        const O = toObject(this);\n        defineProperty(O, prop, {\n          set: aFunction(func, 'setter'),\n          enumerable: true,\n          configurable: true\n        });\n      }\n    },\n    __lookupGetter__: {\n      value: function __lookupGetter__(prop) {\n        let O = toObject(this);\n        prop = asPropertyName(prop);\n        let desc;\n        while (O && !(desc = getOwnPropertyDescriptor(O, prop))) {\n          O = getPrototypeOf(O);\n        }\n        return desc && desc.get;\n      }\n    },\n    __lookupSetter__: {\n      value: function __lookupSetter__(prop) {\n        let O = toObject(this);\n        prop = asPropertyName(prop);\n        let desc;\n        while (O && !(desc = getOwnPropertyDescriptor(O, prop))) {\n          O = getPrototypeOf(O);\n        }\n        return desc && desc.set;\n      }\n    }\n  });\n}\n","// Adapted from SES/Caja\n// Copyright (C) 2011 Google Inc.\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js\n\n/**\n * This block replaces the original Function constructor, and the original\n * %GeneratorFunction% %AsyncFunction% and %AsyncGeneratorFunction%, with\n * safe replacements that throw if invoked.\n *\n * These are all reachable via syntax, so it isn't sufficient to just\n * replace global properties with safe versions. Our main goal is to prevent\n * access to the Function constructor through these starting points.\n\n * After this block is done, the originals must no longer be reachable, unless\n * a copy has been made, and funtions can only be created by syntax (using eval)\n * or by invoking a previously saved reference to the originals.\n */\n\n// todo: this file should be moved out to a separate repo and npm module.\nconst globalEval = eval;\nexport function repairFunctions() {\n  const { defineProperties, getPrototypeOf, setPrototypeOf } = Object;\n\n  /**\n   * The process to repair constructors:\n   * 1. Create an instance of the function by evaluating syntax\n   * 2. Obtain the prototype from the instance\n   * 3. Create a substitute tamed constructor\n   * 4. Replace the original constructor with the tamed constructor\n   * 5. Replace tamed constructor prototype property with the original one\n   * 6. Replace its [[Prototype]] slot with the tamed constructor of Function\n   */\n  function repairFunction(name, declaration) {\n    let FunctionInstance;\n    try {\n      // eslint-disable-next-line no-new-func\n      FunctionInstance = globalEval(declaration);\n    } catch (e) {\n      if (e instanceof SyntaxError) {\n        // Prevent failure on platforms where async and/or generators\n        // are not supported.\n        return;\n      }\n      // Re-throw\n      throw e;\n    }\n    const FunctionPrototype = getPrototypeOf(FunctionInstance);\n\n    // Prevents the evaluation of source when calling constructor on the\n    // prototype of functions.\n    const TamedFunction = function() {\n      throw new TypeError('Not available');\n    };\n    defineProperties(TamedFunction, { name: { value: name } });\n\n    // (new Error()).constructors does not inherit from Function, because Error\n    // was defined before ES6 classes. So we don't need to repair it too.\n\n    // (Error()).constructor inherit from Function, which gets a tamed\n    // constructor here.\n\n    // todo: in an ES6 class that does not inherit from anything, what does its\n    // constructor inherit from? We worry that it inherits from Function, in\n    // which case instances could give access to unsafeFunction. markm says\n    // we're fine: the constructor inherits from Object.prototype\n\n    // This line replaces the original constructor in the prototype chain\n    // with the tamed one. No copy of the original is peserved.\n    defineProperties(FunctionPrototype, {\n      constructor: { value: TamedFunction }\n    });\n\n    // This line sets the tamed constructor's prototype data property to\n    // the original one.\n    defineProperties(TamedFunction, {\n      prototype: { value: FunctionPrototype }\n    });\n\n    if (TamedFunction !== Function.prototype.constructor) {\n      // Ensures that all functions meet \"instanceof Function\" in a realm.\n      setPrototypeOf(TamedFunction, Function.prototype.constructor);\n    }\n  }\n\n  // Here, the order of operation is important: Function needs to be repaired\n  // first since the other repaired constructors need to inherit from the tamed\n  // Function function constructor.\n\n  // note: this really wants to be part of the standard, because new\n  // constructors may be added in the future, reachable from syntax, and this\n  // list must be updated to match.\n\n  // \"plain arrow functions\" inherit from Function.prototype\n\n  repairFunction('Function', '(function(){})');\n  repairFunction('GeneratorFunction', '(function*(){})');\n  repairFunction('AsyncFunction', '(async function(){})');\n  repairFunction('AsyncGeneratorFunction', '(async function*(){})');\n}\n","// this module must never be importable outside the Realm shim itself\nimport { getSharedGlobalDescs } from './stdlib';\nimport { repairAccessors } from './repair/accessors';\nimport { repairFunctions } from './repair/functions';\nimport { cleanupSource } from './utilities';\nimport { freeze } from './commons';\n\n// A \"context\" is a fresh unsafe Realm as given to us by existing platforms.\n// We need this to implement the shim. However, when Realms land for real,\n// this feature will be provided by the underlying engine instead.\n\n// note: in a node module, the top-level 'this' is not the global object\n// (it's *something* but we aren't sure what), however an indirect eval of\n// 'this' will be the correct global object.\n\nconst unsafeGlobalSrc = \"'use strict'; this\";\nconst unsafeGlobalEvalSrc = `(0, eval)(\"'use strict'; this\")`;\n\n// This method is only exported for testing purposes.\nexport function createNewUnsafeGlobalForNode() {\n  // Note that webpack and others will shim 'vm' including the method\n  // 'runInNewContext', so the presence of vm is not a useful check\n\n  // TODO: Find a better test that works with bundlers\n  // eslint-disable-next-line no-new-func\n  const isNode = new Function(\n    'try {return this===global}catch(e){return false}'\n  )();\n\n  if (!isNode) {\n    return undefined;\n  }\n\n  // eslint-disable-next-line global-require\n  const vm = require('vm');\n\n  // Use unsafeGlobalEvalSrc to ensure we get the right 'this'.\n  const unsafeGlobal = vm.runInNewContext(unsafeGlobalEvalSrc);\n\n  return unsafeGlobal;\n}\n\n// This method is only exported for testing purposes.\nexport function createNewUnsafeGlobalForBrowser() {\n  if (typeof document === 'undefined') {\n    return undefined;\n  }\n  const iframe = document.createElement('iframe');\n  iframe.style.display = 'none';\n\n  document.body.appendChild(iframe);\n  const unsafeGlobal = iframe.contentWindow.eval(unsafeGlobalSrc);\n\n  // We keep the iframe attached to the DOM because removing it\n  // causes its global object to lose intrinsics, its eval()\n  // function to evaluate code, etc.\n\n  // TODO: can we remove and garbage-collect the iframes?\n\n  return unsafeGlobal;\n}\n\nconst getNewUnsafeGlobal = () => {\n  const newUnsafeGlobalForBrowser = createNewUnsafeGlobalForBrowser();\n  const newUnsafeGlobalForNode = createNewUnsafeGlobalForNode();\n  if (\n    (!newUnsafeGlobalForBrowser && !newUnsafeGlobalForNode) ||\n    (newUnsafeGlobalForBrowser && newUnsafeGlobalForNode)\n  ) {\n    throw new Error('unexpected platform, unable to create Realm');\n  }\n  return newUnsafeGlobalForBrowser || newUnsafeGlobalForNode;\n};\n\n// The unsafeRec is shim-specific. It acts as the mechanism to obtain a fresh\n// set of intrinsics together with their associated eval and Function\n// evaluators. These must be used as a matched set, since the evaluators are\n// tied to a set of intrinsics, aka the \"undeniables\". If it were possible to\n// mix-and-match them from different contexts, that would enable some\n// attacks.\nfunction createUnsafeRec(unsafeGlobal, allShims = []) {\n  const sharedGlobalDescs = getSharedGlobalDescs(unsafeGlobal);\n\n  return freeze({\n    unsafeGlobal,\n    sharedGlobalDescs,\n    unsafeEval: unsafeGlobal.eval,\n    unsafeFunction: unsafeGlobal.Function,\n    allShims\n  });\n}\n\nconst repairAccessorsShim = cleanupSource(\n  `\"use strict\"; (${repairAccessors})();`\n);\nconst repairFunctionsShim = cleanupSource(\n  `\"use strict\"; const globalEval = eval; (${repairFunctions})();`\n);\n\n// Create a new unsafeRec from a brand new context, with new intrinsics and a\n// new global object\nexport function createNewUnsafeRec(allShims) {\n  const unsafeGlobal = getNewUnsafeGlobal();\n  unsafeGlobal.eval(repairAccessorsShim);\n  unsafeGlobal.eval(repairFunctionsShim);\n  return createUnsafeRec(unsafeGlobal, allShims);\n}\n\n// Create a new unsafeRec from the current context, where the Realm shim is\n// being parsed and executed, aka the \"Primal Realm\"\nexport function createCurrentUnsafeRec() {\n  const unsafeGlobal = (0, eval)(unsafeGlobalSrc);\n  repairAccessors();\n  repairFunctions();\n  return createUnsafeRec(unsafeGlobal);\n}\n","import {\n  arrayFilter,\n  getOwnPropertyDescriptors,\n  getOwnPropertyNames,\n  objectHasOwnProperty,\n  regexpTest\n} from './commons';\n\n// todo: think about how this interacts with endowments, check for conflicts\n// between the names being optimized and the ones added by endowments\n\n/**\n * Simplified validation of indentifier names: may only contain alphanumeric\n * characters (or \"$\" or \"_\"), and may not start with a digit. This is safe\n * and does not reduces the compatibility of the shim. The motivation for\n * this limitation was to decrease the complexity of the implementation,\n * and to maintain a resonable level of performance.\n * Note: \\w is equivalent [a-zA-Z_0-9]\n * See 11.6.1 Identifier Names\n */\nconst identifierPattern = /^[a-zA-Z_$][\\w$]*$/;\n\n/**\n * In JavaScript you cannot use these reserved words as variables.\n * See 11.6.1 Identifier Names\n */\nconst keywords = new Set([\n  // 11.6.2.1 Keywords\n  'await',\n  'break',\n  'case',\n  'catch',\n  'class',\n  'const',\n  'continue',\n  'debugger',\n  'default',\n  'delete',\n  'do',\n  'else',\n  'export',\n  'extends',\n  'finally',\n  'for',\n  'function',\n  'if',\n  'import',\n  'in',\n  'instanceof',\n  'new',\n  'return',\n  'super',\n  'switch',\n  'this',\n  'throw',\n  'try',\n  'typeof',\n  'var',\n  'void',\n  'while',\n  'with',\n  'yield',\n\n  // Also reserved when parsing strict mode code\n  'let',\n  'static',\n\n  // 11.6.2.2 Future Reserved Words\n  'enum',\n\n  // Also reserved when parsing strict mode code\n  'implements',\n  'package',\n  'protected',\n  'interface',\n  'private',\n  'public',\n\n  // Reserved but not mentioned in specs\n  'await',\n\n  'null',\n  'true',\n  'false',\n\n  'this',\n  'arguments'\n]);\n\n/**\n * getOptimizableGlobals()\n * What variable names might it bring into scope? These include all\n * property names which can be variable names, including the names\n * of inherited properties. It excludes symbols and names which are\n * keywords. We drop symbols safely. Currently, this shim refuses\n * service if any of the names are keywords or keyword-like. This is\n * safe and only prevent performance optimization.\n */\nexport function getOptimizableGlobals(safeGlobal) {\n  const descs = getOwnPropertyDescriptors(safeGlobal);\n\n  // getOwnPropertyNames does ignore Symbols so we don't need this extra check:\n  // typeof name === 'string' &&\n  const constants = arrayFilter(getOwnPropertyNames(descs), name => {\n    // Ensure we have a valid identifier. We use regexpTest rather than\n    // /../.test() to guard against the case where RegExp has been poisoned.\n    if (\n      name === 'eval' ||\n      keywords.has(name) ||\n      !regexpTest(identifierPattern, name)\n    ) {\n      return false;\n    }\n\n    const desc = descs[name];\n    return (\n      //\n      // The getters will not have .writable, don't let the falsyness of\n      // 'undefined' trick us: test with === false, not ! . However descriptors\n      // inherit from the (potentially poisoned) global object, so we might see\n      // extra properties which weren't really there. Accessor properties have\n      // 'get/set/enumerable/configurable', while data properties have\n      // 'value/writable/enumerable/configurable'.\n      desc.configurable === false &&\n      desc.writable === false &&\n      //\n      // Checks for data properties because they're the only ones we can\n      // optimize (accessors are most likely non-constant). Descriptors can't\n      // can't have accessors and value properties at the same time, therefore\n      // this check is sufficient. Using explicit own property deal with the\n      // case where Object.prototype has been poisoned.\n      objectHasOwnProperty(desc, 'value')\n    );\n  });\n\n  return constants;\n}\n","import { freeze, objectHasOwnProperty } from './commons';\nimport { throwTantrum } from './utilities';\n\n/**\n * alwaysThrowHandler is a proxy handler which throws on any trap called.\n * It's made from a proxy with a get trap that throws. Its target is\n * an immutable (frozen) object and is safe to share.\n */\nconst alwaysThrowHandler = new Proxy(freeze({}), {\n  get(target, prop) {\n    throwTantrum(`unexpected scope handler trap called: ${prop}`);\n  }\n});\n\n/**\n * ScopeHandler manages a Proxy which serves as the global scope for the\n * safeEvaluator operation (the Proxy is the argument of a 'with' binding).\n * As described in createSafeEvaluator(), it has several functions:\n * - allow the very first (and only the very first) use of 'eval' to map to\n *   the real (unsafe) eval function, so it acts as a 'direct eval' and can\n *    access its lexical scope (which maps to the 'with' binding, which the\n *   ScopeHandler also controls).\n * - ensure that all subsequent uses of 'eval' map to the safeEvaluator,\n *   which lives as the 'eval' property of the safeGlobal.\n * - route all other property lookups at the safeGlobal.\n * - hide the unsafeGlobal which lives on the scope chain above the 'with'.\n * - ensure the Proxy invariants despite some global properties being frozen.\n */\nexport function createScopeHandler(unsafeRec, safeGlobal, sloppyGlobals) {\n  const { unsafeGlobal, unsafeEval } = unsafeRec;\n\n  // This flag allow us to determine if the eval() call is an done by the\n  // realm's code or if it is user-land invocation, so we can react differently.\n  let useUnsafeEvaluator = false;\n\n  return {\n    // The scope handler throws if any trap other than get/set/has are run\n    // (e.g. getOwnPropertyDescriptors, apply, getPrototypeOf).\n    // eslint-disable-next-line no-proto\n    __proto__: alwaysThrowHandler,\n\n    allowUnsafeEvaluatorOnce() {\n      useUnsafeEvaluator = true;\n    },\n\n    unsafeEvaluatorAllowed() {\n      return useUnsafeEvaluator;\n    },\n\n    get(target, prop) {\n      // Special treatment for eval. The very first lookup of 'eval' gets the\n      // unsafe (real direct) eval, so it will get the lexical scope that uses\n      // the 'with' context.\n      if (prop === 'eval') {\n        // test that it is true rather than merely truthy\n        if (useUnsafeEvaluator === true) {\n          // revoke before use\n          useUnsafeEvaluator = false;\n          return unsafeEval;\n        }\n        return target.eval;\n      }\n\n      // todo: shim integrity, capture Symbol.unscopables\n      if (prop === Symbol.unscopables) {\n        // Safe to return a primal realm Object here because the only code that\n        // can do a get() on a non-string is the internals of with() itself,\n        // and the only thing it does is to look for properties on it. User\n        // code cannot do a lookup on non-strings.\n        return undefined;\n      }\n\n      // Properties of the global.\n      if (prop in target) {\n        return target[prop];\n      }\n\n      // Prevent the lookup for other properties.\n      return undefined;\n    },\n\n    // eslint-disable-next-line class-methods-use-this\n    set(target, prop, value) {\n      // todo: allow modifications when target.hasOwnProperty(prop) and it\n      // is writable, assuming we've already rejected overlap (see\n      // createSafeEvaluatorFactory.factory). This TypeError gets replaced with\n      // target[prop] = value\n      if (objectHasOwnProperty(target, prop)) {\n        // todo: shim integrity: TypeError, String\n        throw new TypeError(`do not modify endowments like ${String(prop)}`);\n      }\n\n      safeGlobal[prop] = value;\n\n      // Return true after successful set.\n      return true;\n    },\n\n    // we need has() to return false for some names to prevent the lookup  from\n    // climbing the scope chain and eventually reaching the unsafeGlobal\n    // object, which is bad.\n\n    // note: unscopables! every string in Object[Symbol.unscopables]\n\n    // todo: we'd like to just have has() return true for everything, and then\n    // use get() to raise a ReferenceError for anything not on the safe global.\n    // But we want to be compatible with ReferenceError in the normal case and\n    // the lack of ReferenceError in the 'typeof' case. Must either reliably\n    // distinguish these two cases (the trap behavior might be different), or\n    // we rely on a mandatory source-to-source transform to change 'typeof abc'\n    // to XXX. We already need a mandatory parse to prevent the 'import',\n    // since it's a special form instead of merely being a global variable/\n\n    // note: if we make has() return true always, then we must implement a\n    // set() trap to avoid subverting the protection of strict mode (it would\n    // accept assignments to undefined globals, when it ought to throw\n    // ReferenceError for such assignments)\n\n    has(target, prop) {\n      // proxies stringify 'prop', so no TOCTTOU danger here\n\n      if (sloppyGlobals) {\n        // Everything is potentially available.\n        return true;\n      }\n\n      // unsafeGlobal: hide all properties of unsafeGlobal at the\n      // expense of 'typeof' being wrong for those properties. For\n      // example, in the browser, evaluating 'document = 3', will add\n      // a property to safeGlobal instead of throwing a\n      // ReferenceError.\n      if (prop === 'eval' || prop in target || prop in unsafeGlobal) {\n        return true;\n      }\n\n      return false;\n    }\n  };\n}\n","// https://www.ecma-international.org/ecma-262/9.0/index.html#sec-html-like-comments\n// explains that JavaScript parsers may or may not recognize html\n// comment tokens \"<\" immediately followed by \"!--\" and \"--\"\n// immediately followed by \">\" in non-module source text, and treat\n// them as a kind of line comment. Since otherwise both of these can\n// appear in normal JavaScript source code as a sequence of operators,\n// we have the terrifying possibility of the same source code parsing\n// one way on one correct JavaScript implementation, and another way\n// on another.\n//\n// This shim takes the conservative strategy of just rejecting source\n// text that contains these strings anywhere. Note that this very\n// source file is written strangely to avoid mentioning these\n// character strings explicitly.\n\n// We do not write the regexp in a straightforward way, so that an\n// apparennt html comment does not appear in this file. Thus, we avoid\n// rejection by the overly eager rejectDangerousSources.\nconst htmlCommentPattern = new RegExp(`(?:${'<'}!--|--${'>'})`);\n\nfunction rejectHtmlComments(s) {\n  const index = s.search(htmlCommentPattern);\n  if (index !== -1) {\n    const linenum = s.slice(0, index).split('\\n').length; // more or less\n    throw new SyntaxError(\n      `possible html comment syntax rejected around line ${linenum}`\n    );\n  }\n}\n\n// The proposed dynamic import expression is the only syntax currently\n// proposed, that can appear in non-module JavaScript code, that\n// enables direct access to the outside world that cannot be\n// surpressed or intercepted without parsing and rewriting. Instead,\n// this shim conservatively rejects any source text that seems to\n// contain such an expression. To do this safely without parsing, we\n// must also reject some valid programs, i.e., those containing\n// apparent import expressions in literal strings or comments.\n\n// The current conservative rule looks for the identifier \"import\"\n// followed by either an open paren or something that looks like the\n// beginning of a comment. We assume that we do not need to worry\n// about html comment syntax because that was already rejected by\n// rejectHtmlComments.\n\n// this \\s *must* match all kinds of syntax-defined whitespace. If e.g.\n// U+2028 (LINE SEPARATOR) or U+2029 (PARAGRAPH SEPARATOR) is treated as\n// whitespace by the parser, but not matched by /\\s/, then this would admit\n// an attack like: import\\u2028('power.js') . We're trying to distinguish\n// something like that from something like importnotreally('power.js') which\n// is perfectly safe.\n\nconst importPattern = /\\bimport\\s*(?:\\(|\\/[/*])/;\n\nfunction rejectImportExpressions(s) {\n  const index = s.search(importPattern);\n  if (index !== -1) {\n    const linenum = s.slice(0, index).split('\\n').length; // more or less\n    throw new SyntaxError(\n      `possible import expression rejected around line ${linenum}`\n    );\n  }\n}\n\n// The shim cannot correctly emulate a direct eval as explained at\n// https://github.com/Agoric/realms-shim/issues/12\n// Without rejecting apparent direct eval syntax, we would\n// accidentally evaluate these with an emulation of indirect eval. Tp\n// prevent future compatibility problems, in shifting from use of the\n// shim to genuine platform support for the proposal, we should\n// instead statically reject code that seems to contain a direct eval\n// expression.\n//\n// As with the dynamic import expression, to avoid a full parse, we do\n// this approximately with a regexp, that will also reject strings\n// that appear safely in comments or strings. Unlike dynamic import,\n// if we miss some, this only creates future compat problems, not\n// security problems. Thus, we are only trying to catch innocent\n// occurrences, not malicious one. In particular, `(eval)(...)` is\n// direct eval syntax that would not be caught by the following regexp.\n\nconst someDirectEvalPattern = /\\beval\\s*(?:\\(|\\/[/*])/;\n\nfunction rejectSomeDirectEvalExpressions(s) {\n  const index = s.search(someDirectEvalPattern);\n  if (index !== -1) {\n    const linenum = s.slice(0, index).split('\\n').length; // more or less\n    throw new SyntaxError(\n      `possible direct eval expression rejected around line ${linenum}`\n    );\n  }\n}\n\nexport function rejectDangerousSources(s) {\n  rejectHtmlComments(s);\n  rejectImportExpressions(s);\n  rejectSomeDirectEvalExpressions(s);\n}\n\n// Export a rewriter transform.\nexport const rejectDangerousSourcesTransform = {\n  rewrite(rs) {\n    rejectDangerousSources(rs.src);\n    return rs;\n  }\n};\n","// Portions adapted from V8 - Copyright 2016 the V8 project authors.\n// https://github.com/v8/v8/blob/master/src/builtins/builtins-function.cc\n\nimport {\n  apply,\n  arrayJoin,\n  arrayPop,\n  create,\n  defineProperties,\n  getOwnPropertyDescriptors,\n  getPrototypeOf,\n  regexpTest,\n  setPrototypeOf,\n  stringIncludes\n} from './commons';\nimport { getOptimizableGlobals } from './optimizer';\nimport { createScopeHandler } from './scopeHandler';\nimport { rejectDangerousSourcesTransform } from './sourceParser';\nimport { assert, throwTantrum } from './utilities';\n\nfunction buildOptimizer(constants) {\n  // No need to build an oprimizer when there are no constants.\n  if (constants.length === 0) return '';\n  // Use 'this' to avoid going through the scope proxy, which is unecessary\n  // since the optimizer only needs references to the safe global.\n  return `const {${arrayJoin(constants, ',')}} = this;`;\n}\n\nfunction createScopedEvaluatorFactory(unsafeRec, constants) {\n  const { unsafeFunction } = unsafeRec;\n\n  const optimizer = buildOptimizer(constants);\n\n  // Create a function in sloppy mode, so that we can use 'with'. It returns\n  // a function in strict mode that evaluates the provided code using direct\n  // eval, and thus in strict mode in the same scope. We must be very careful\n  // to not create new names in this scope\n\n  // 1: we use 'with' (around a Proxy) to catch all free variable names. The\n  // first 'arguments[0]' holds the Proxy which safely wraps the safeGlobal\n  // 2: 'optimizer' catches common variable names for speed\n  // 3: The inner strict function is effectively passed two parameters:\n  //    a) its arguments[0] is the source to be directly evaluated.\n  //    b) its 'this' is the this binding seen by the code being\n  //       directly evaluated.\n\n  // everything in the 'optimizer' string is looked up in the proxy\n  // (including an 'arguments[0]', which points at the Proxy). 'function' is\n  // a keyword, not a variable, so it is not looked up. then 'eval' is looked\n  // up in the proxy, that's the first time it is looked up after\n  // useUnsafeEvaluator is turned on, so the proxy returns the real the\n  // unsafeEval, which satisfies the IsDirectEvalTrap predicate, so it uses\n  // the direct eval and gets the lexical scope. The second 'arguments[0]' is\n  // looked up in the context of the inner function. The *contents* of\n  // arguments[0], because we're using direct eval, are looked up in the\n  // Proxy, by which point the useUnsafeEvaluator switch has been flipped\n  // back to 'false', so any instances of 'eval' in that string will get the\n  // safe evaluator.\n\n  return unsafeFunction(`\n    with (arguments[0]) {\n      ${optimizer}\n      return function() {\n        'use strict';\n        return eval(arguments[0]);\n      };\n    }\n  `);\n}\n\nexport function createSafeEvaluatorFactory(\n  unsafeRec,\n  safeGlobal,\n  transforms,\n  sloppyGlobals\n) {\n  const { unsafeFunction } = unsafeRec;\n\n  const constants = getOptimizableGlobals(safeGlobal);\n  const scopedEvaluatorFactory = createScopedEvaluatorFactory(\n    unsafeRec,\n    constants\n  );\n\n  function factory(endowments = {}, options = {}) {\n    const localTransforms = options.transforms || [];\n    const realmTransforms = transforms || [];\n\n    const mandatoryTransforms = [rejectDangerousSourcesTransform];\n    const allTransforms = [\n      ...localTransforms,\n      ...realmTransforms,\n      ...mandatoryTransforms\n    ];\n\n    // We use the the concise method syntax to create an eval without a\n    // [[Construct]] behavior (such that the invocation \"new eval()\" throws\n    // TypeError: eval is not a constructor\"), but which still accepts a\n    // 'this' binding.\n    const safeEval = {\n      eval(src) {\n        src = `${src}`;\n        // Rewrite the source, threading through rewriter state as necessary.\n        const rewriterState = allTransforms.reduce(\n          (rs, transform) => (transform.rewrite ? transform.rewrite(rs) : rs),\n          { src, endowments }\n        );\n        src = rewriterState.src;\n\n        const scopeTarget = create(\n          safeGlobal,\n          getOwnPropertyDescriptors(rewriterState.endowments)\n        );\n\n        const scopeHandler = createScopeHandler(\n          unsafeRec,\n          safeGlobal,\n          sloppyGlobals\n        );\n        const scopeProxy = new Proxy(scopeTarget, scopeHandler);\n        const scopedEvaluator = apply(scopedEvaluatorFactory, safeGlobal, [\n          scopeProxy\n        ]);\n\n        scopeHandler.allowUnsafeEvaluatorOnce();\n        let err;\n        try {\n          // Ensure that \"this\" resolves to the safe global.\n          return apply(scopedEvaluator, safeGlobal, [src]);\n        } catch (e) {\n          // stash the child-code error in hopes of debugging the internal failure\n          err = e;\n          throw e;\n        } finally {\n          // belt and suspenders: the proxy switches this off immediately after\n          // the first access, but if that's not the case we abort.\n          if (scopeHandler.unsafeEvaluatorAllowed()) {\n            throwTantrum('handler did not revoke useUnsafeEvaluator', err);\n          }\n        }\n      }\n    }.eval;\n\n    // safeEval's prototype is currently the primal realm's\n    // Function.prototype, which we must not let escape. To make 'eval\n    // instanceof Function' be true inside the realm, we need to point it at\n    // the RootRealm's value.\n\n    // Ensure that eval from any compartment in a root realm is an instance\n    // of Function in any compartment of the same root realm.\n    setPrototypeOf(safeEval, unsafeFunction.prototype);\n\n    assert(getPrototypeOf(safeEval).constructor !== Function, 'hide Function');\n    assert(\n      getPrototypeOf(safeEval).constructor !== unsafeFunction,\n      'hide unsafeFunction'\n    );\n\n    // note: be careful to not leak our primal Function.prototype by setting\n    // this to a plain arrow function. Now that we have safeEval, use it.\n    defineProperties(safeEval, {\n      toString: {\n        // We break up the following literal string so that an\n        // apparent direct eval syntax does not appear in this\n        // file. Thus, we avoid rejection by the overly eager\n        // rejectDangerousSources.\n        value: safeEval(\"() => 'function eval' + '() { [shim code] }'\"),\n        writable: false,\n        enumerable: false,\n        configurable: true\n      }\n    });\n\n    return safeEval;\n  }\n\n  return factory;\n}\n\nexport function createSafeEvaluator(safeEvaluatorFactory) {\n  return safeEvaluatorFactory();\n}\n\nexport function createSafeEvaluatorWhichTakesEndowments(safeEvaluatorFactory) {\n  return (x, endowments, options = {}) =>\n    safeEvaluatorFactory(endowments, options)(x);\n}\n\n/**\n * A safe version of the native Function which relies on\n * the safety of evalEvaluator for confinement.\n */\nexport function createFunctionEvaluator(unsafeRec, safeEval) {\n  const { unsafeFunction, unsafeGlobal } = unsafeRec;\n\n  const safeFunction = function Function(...params) {\n    const functionBody = `${arrayPop(params) || ''}`;\n    let functionParams = `${arrayJoin(params, ',')}`;\n    if (!regexpTest(/^[\\w\\s,]*$/, functionParams)) {\n      throw new unsafeGlobal.SyntaxError(\n        'shim limitation: Function arg must be simple ASCII identifiers, possibly separated by commas: no default values, pattern matches, or non-ASCII parameter names'\n      );\n      // this protects against Matt Austin's clever attack:\n      // Function(\"arg=`\", \"/*body`){});({x: this/**/\")\n      // which would turn into\n      //     (function(arg=`\n      //     /*``*/){\n      //      /*body`){});({x: this/**/\n      //     })\n      // which parses as a default argument of `\\n/*``*/){\\n/*body` , which\n      // is a pair of template literals back-to-back (so the first one\n      // nominally evaluates to the parser to use on the second one), which\n      // can't actually execute (because the first literal evals to a string,\n      // which can't be a parser function), but that doesn't matter because\n      // the function is bypassed entirely. When that gets evaluated, it\n      // defines (but does not invoke) a function, then evaluates a simple\n      // {x: this} expression, giving access to the safe global.\n    }\n\n    // Is this a real functionBody, or is someone attempting an injection\n    // attack? This will throw a SyntaxError if the string is not actually a\n    // function body. We coerce the body into a real string above to prevent\n    // someone from passing an object with a toString() that returns a safe\n    // string the first time, but an evil string the second time.\n    // eslint-disable-next-line no-new, new-cap\n    new unsafeFunction(functionBody);\n\n    if (stringIncludes(functionParams, ')')) {\n      // If the formal parameters string include ) - an illegal\n      // character - it may make the combined function expression\n      // compile. We avoid this problem by checking for this early on.\n\n      // note: v8 throws just like this does, but chrome accepts\n      // e.g. 'a = new Date()'\n      throw new unsafeGlobal.SyntaxError(\n        'shim limitation: Function arg string contains parenthesis'\n      );\n      // todo: shim integrity threat if they change SyntaxError\n    }\n\n    // todo: check to make sure this .length is safe. markm says safe.\n    if (functionParams.length > 0) {\n      // If the formal parameters include an unbalanced block comment, the\n      // function must be rejected. Since JavaScript does not allow nested\n      // comments we can include a trailing block comment to catch this.\n      functionParams += '\\n/*``*/';\n    }\n\n    const src = `(function(${functionParams}){\\n${functionBody}\\n})`;\n\n    return safeEval(src);\n  };\n\n  // Ensure that Function from any compartment in a root realm can be used\n  // with instance checks in any compartment of the same root realm.\n  setPrototypeOf(safeFunction, unsafeFunction.prototype);\n\n  assert(\n    getPrototypeOf(safeFunction).constructor !== Function,\n    'hide Function'\n  );\n  assert(\n    getPrototypeOf(safeFunction).constructor !== unsafeFunction,\n    'hide unsafeFunction'\n  );\n\n  defineProperties(safeFunction, {\n    // Ensure that any function created in any compartment in a root realm is an\n    // instance of Function in any compartment of the same root ralm.\n    prototype: { value: unsafeFunction.prototype },\n\n    // Provide a custom output without overwriting the\n    // Function.prototype.toString which is called by some third-party\n    // libraries.\n    toString: {\n      value: safeEval(\"() => 'function Function() { [shim code] }'\"),\n      writable: false,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  return safeFunction;\n}\n","import { createRealmFacade, buildChildRealm } from './realmFacade';\nimport { createNewUnsafeRec, createCurrentUnsafeRec } from './unsafeRec';\nimport {\n  createSafeEvaluatorFactory,\n  createSafeEvaluator,\n  createSafeEvaluatorWhichTakesEndowments,\n  createFunctionEvaluator\n} from './evaluators';\nimport { assert } from './utilities';\nimport { create, defineProperties, freeze, arrayConcat } from './commons';\n\n// Mimic private members on the realm instances.\n// We define it in the same module and do not export it.\nconst RealmRecForRealmInstance = new WeakMap();\n\nfunction getRealmRecForRealmInstance(realm) {\n  // Detect non-objects.\n  assert(Object(realm) === realm, 'bad object, not a Realm instance');\n  // Realm instance has no realmRec. Should not proceed.\n  assert(RealmRecForRealmInstance.has(realm), 'Realm instance has no record');\n\n  return RealmRecForRealmInstance.get(realm);\n}\n\nfunction registerRealmRecForRealmInstance(realm, realmRec) {\n  // Detect non-objects.\n  assert(Object(realm) === realm, 'bad object, not a Realm instance');\n  // Attempt to change an existing realmRec on a realm instance. Should not proceed.\n  assert(\n    !RealmRecForRealmInstance.has(realm),\n    'Realm instance already has a record'\n  );\n\n  RealmRecForRealmInstance.set(realm, realmRec);\n}\n\n// Initialize the global variables for the new Realm.\nfunction setDefaultBindings(safeGlobal, safeEval, safeFunction) {\n  defineProperties(safeGlobal, {\n    eval: {\n      value: safeEval,\n      writable: true,\n      configurable: true\n    },\n    Function: {\n      value: safeFunction,\n      writable: true,\n      configurable: true\n    }\n  });\n}\n\nfunction createRealmRec(unsafeRec, transforms, sloppyGlobals) {\n  const { sharedGlobalDescs, unsafeGlobal } = unsafeRec;\n\n  const safeGlobal = create(unsafeGlobal.Object.prototype, sharedGlobalDescs);\n\n  const safeEvaluatorFactory = createSafeEvaluatorFactory(\n    unsafeRec,\n    safeGlobal,\n    transforms,\n    sloppyGlobals\n  );\n  const safeEval = createSafeEvaluator(safeEvaluatorFactory);\n  const safeEvalWhichTakesEndowments = createSafeEvaluatorWhichTakesEndowments(\n    safeEvaluatorFactory\n  );\n  const safeFunction = createFunctionEvaluator(unsafeRec, safeEval);\n\n  setDefaultBindings(safeGlobal, safeEval, safeFunction);\n\n  const realmRec = freeze({\n    safeGlobal,\n    safeEval,\n    safeEvalWhichTakesEndowments,\n    safeFunction\n  });\n\n  return realmRec;\n}\n\n/**\n * A root realm uses a fresh set of new intrinics. Here we first create\n * a new unsafe record, which inherits the shims. Then we proceed with\n * the creation of the realm record, and we apply the shims.\n */\nfunction initRootRealm(parentUnsafeRec, self, options) {\n  // note: 'self' is the instance of the Realm.\n\n  // todo: investigate attacks via Array.species\n  // todo: this accepts newShims='string', but it should reject that\n  const { shims: newShims, transforms, sloppyGlobals } = options;\n  const allShims = arrayConcat(parentUnsafeRec.allShims, newShims);\n\n  // The unsafe record is created already repaired.\n  const unsafeRec = createNewUnsafeRec(allShims);\n\n  // eslint-disable-next-line no-use-before-define\n  const Realm = createRealmFacade(unsafeRec, BaseRealm);\n\n  // Add a Realm descriptor to sharedGlobalDescs, so it can be defined onto the\n  // safeGlobal like the rest of the globals.\n  unsafeRec.sharedGlobalDescs.Realm = {\n    value: Realm,\n    writable: true,\n    configurable: true\n  };\n\n  // Creating the realmRec provides the global object, eval() and Function()\n  // to the realm.\n  const realmRec = createRealmRec(unsafeRec, transforms, sloppyGlobals);\n\n  // Apply all shims in the new RootRealm. We don't do this for compartments.\n  const { safeEvalWhichTakesEndowments } = realmRec;\n  for (const shim of allShims) {\n    safeEvalWhichTakesEndowments(shim);\n  }\n\n  // The realmRec acts as a private field on the realm instance.\n  registerRealmRecForRealmInstance(self, realmRec);\n}\n\n/**\n * A compartment shares the intrinsics of its root realm. Here, only a\n * realmRec is necessary to hold the global object, eval() and Function().\n */\nfunction initCompartment(unsafeRec, self, options = {}) {\n  // note: 'self' is the instance of the Realm.\n\n  const { transforms, sloppyGlobals } = options;\n  const realmRec = createRealmRec(unsafeRec, transforms, sloppyGlobals);\n\n  // The realmRec acts as a private field on the realm instance.\n  registerRealmRecForRealmInstance(self, realmRec);\n}\n\nfunction getRealmGlobal(self) {\n  const { safeGlobal } = getRealmRecForRealmInstance(self);\n  return safeGlobal;\n}\n\nfunction realmEvaluate(self, x, endowments = {}, options = {}) {\n  // todo: don't pass in primal-realm objects like {}, for safety. OTOH its\n  // properties are copied onto the new global 'target'.\n  // todo: figure out a way to membrane away the contents to safety.\n  const { safeEvalWhichTakesEndowments } = getRealmRecForRealmInstance(self);\n  return safeEvalWhichTakesEndowments(x, endowments, options);\n}\n\nconst BaseRealm = {\n  initRootRealm,\n  initCompartment,\n  getRealmGlobal,\n  realmEvaluate\n};\n\n// Create the current unsafeRec from the current \"primal\" environment (the realm\n// where the Realm shim is loaded and executed).\nconst currentUnsafeRec = createCurrentUnsafeRec();\n\n/**\n * The \"primal\" realm class is defined in the current \"primal\" environment,\n * and is part of the shim. There is no need to facade this class via evaluation\n * because both share the same intrinsics.\n */\nconst Realm = buildChildRealm(currentUnsafeRec, BaseRealm);\n\nexport default Realm;\n"],"names":[],"mappings":"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"}
##############################################
/src/dist/realms-shim.cjs.js-146-
/src/dist/realms-shim.cjs.js:147:    evaluate(x, endowments, options = {}) {
/src/dist/realms-shim.cjs.js-148-      // safe against strange 'this', as above
##############################################
/src/dist/realms-shim.cjs.js-277-
/src/dist/realms-shim.cjs.js:278:  // 'eval', // comes from safeEval instead
/src/dist/realms-shim.cjs.js-279-  'isFinite',
##############################################
/src/dist/realms-shim.cjs.js-519- * After this block is done, the originals must no longer be reachable, unless
/src/dist/realms-shim.cjs.js:520: * a copy has been made, and funtions can only be created by syntax (using eval)
/src/dist/realms-shim.cjs.js-521- * or by invoking a previously saved reference to the originals.
##############################################
/src/dist/realms-shim.cjs.js-524-// todo: this file should be moved out to a separate repo and npm module.
/src/dist/realms-shim.cjs.js:525:const globalEval = eval;
/src/dist/realms-shim.cjs.js-526-function repairFunctions() {
##############################################
/src/dist/realms-shim.cjs.js-530-   * The process to repair constructors:
/src/dist/realms-shim.cjs.js:531:   * 1. Create an instance of the function by evaluating syntax
/src/dist/realms-shim.cjs.js-532-   * 2. Obtain the prototype from the instance
##############################################
/src/dist/realms-shim.cjs.js-553-
/src/dist/realms-shim.cjs.js:554:    // Prevents the evaluation of source when calling constructor on the
/src/dist/realms-shim.cjs.js-555-    // prototype of functions.
##############################################
/src/dist/realms-shim.cjs.js-612-// note: in a node module, the top-level 'this' is not the global object
/src/dist/realms-shim.cjs.js:613:// (it's *something* but we aren't sure what), however an indirect eval of
/src/dist/realms-shim.cjs.js-614-// 'this' will be the correct global object.
##############################################
/src/dist/realms-shim.cjs.js-616-const unsafeGlobalSrc = "'use strict'; this";
/src/dist/realms-shim.cjs.js:617:const unsafeGlobalEvalSrc = `(0, eval)("'use strict'; this")`;
/src/dist/realms-shim.cjs.js-618-
##############################################
/src/dist/realms-shim.cjs.js-647-  }
/src/dist/realms-shim.cjs.js:648:  const iframe = document.createElement('iframe');
/src/dist/realms-shim.cjs.js-649-  iframe.style.display = 'none';
/src/dist/realms-shim.cjs.js-650-
/src/dist/realms-shim.cjs.js:651:  document.body.appendChild(iframe);
/src/dist/realms-shim.cjs.js:652:  const unsafeGlobal = iframe.contentWindow.eval(unsafeGlobalSrc);
/src/dist/realms-shim.cjs.js-653-
/src/dist/realms-shim.cjs.js-654-  // We keep the iframe attached to the DOM because removing it
/src/dist/realms-shim.cjs.js:655:  // causes its global object to lose intrinsics, its eval()
/src/dist/realms-shim.cjs.js:656:  // function to evaluate code, etc.
/src/dist/realms-shim.cjs.js-657-
##############################################
/src/dist/realms-shim.cjs.js-675-// The unsafeRec is shim-specific. It acts as the mechanism to obtain a fresh
/src/dist/realms-shim.cjs.js:676:// set of intrinsics together with their associated eval and Function
/src/dist/realms-shim.cjs.js:677:// evaluators. These must be used as a matched set, since the evaluators are
/src/dist/realms-shim.cjs.js-678-// tied to a set of intrinsics, aka the "undeniables". If it were possible to
##############################################
/src/dist/realms-shim.cjs.js-686-    sharedGlobalDescs,
/src/dist/realms-shim.cjs.js:687:    unsafeEval: unsafeGlobal.eval,
/src/dist/realms-shim.cjs.js-688-    unsafeFunction: unsafeGlobal.Function,
##############################################
/src/dist/realms-shim.cjs.js-696-const repairFunctionsShim = cleanupSource(
/src/dist/realms-shim.cjs.js:697:  `"use strict"; const globalEval = eval; (${repairFunctions})();`
/src/dist/realms-shim.cjs.js-698-);
##############################################
/src/dist/realms-shim.cjs.js-703-  const unsafeGlobal = getNewUnsafeGlobal();
/src/dist/realms-shim.cjs.js:704:  unsafeGlobal.eval(repairAccessorsShim);
/src/dist/realms-shim.cjs.js:705:  unsafeGlobal.eval(repairFunctionsShim);
/src/dist/realms-shim.cjs.js-706-  return createUnsafeRec(unsafeGlobal, allShims);
##############################################
/src/dist/realms-shim.cjs.js-711-function createCurrentUnsafeRec() {
/src/dist/realms-shim.cjs.js:712:  const unsafeGlobal = (0, eval)(unsafeGlobalSrc);
/src/dist/realms-shim.cjs.js-713-  repairAccessors();
##############################################
/src/dist/realms-shim.cjs.js-816-    if (
/src/dist/realms-shim.cjs.js:817:      name === 'eval' ||
/src/dist/realms-shim.cjs.js-818-      keywords.has(name) ||
##############################################
/src/dist/realms-shim.cjs.js-862- * As described in createSafeEvaluator(), it has several functions:
/src/dist/realms-shim.cjs.js:863: * - allow the very first (and only the very first) use of 'eval' to map to
/src/dist/realms-shim.cjs.js:864: *   the real (unsafe) eval function, so it acts as a 'direct eval' and can
/src/dist/realms-shim.cjs.js-865- *    access its lexical scope (which maps to the 'with' binding, which the
/src/dist/realms-shim.cjs.js-866- *   ScopeHandler also controls).
/src/dist/realms-shim.cjs.js:867: * - ensure that all subsequent uses of 'eval' map to the safeEvaluator,
/src/dist/realms-shim.cjs.js:868: *   which lives as the 'eval' property of the safeGlobal.
/src/dist/realms-shim.cjs.js-869- * - route all other property lookups at the safeGlobal.
##############################################
/src/dist/realms-shim.cjs.js-875-
/src/dist/realms-shim.cjs.js:876:  // This flag allow us to determine if the eval() call is an done by the
/src/dist/realms-shim.cjs.js-877-  // realm's code or if it is user-land invocation, so we can react differently.
##############################################
/src/dist/realms-shim.cjs.js-894-    get(target, prop) {
/src/dist/realms-shim.cjs.js:895:      // Special treatment for eval. The very first lookup of 'eval' gets the
/src/dist/realms-shim.cjs.js:896:      // unsafe (real direct) eval, so it will get the lexical scope that uses
/src/dist/realms-shim.cjs.js-897-      // the 'with' context.
/src/dist/realms-shim.cjs.js:898:      if (prop === 'eval') {
/src/dist/realms-shim.cjs.js-899-        // test that it is true rather than merely truthy
##############################################
/src/dist/realms-shim.cjs.js-904-        }
/src/dist/realms-shim.cjs.js:905:        return target.eval;
/src/dist/realms-shim.cjs.js-906-      }
##############################################
/src/dist/realms-shim.cjs.js-972-      // expense of 'typeof' being wrong for those properties. For
/src/dist/realms-shim.cjs.js:973:      // example, in the browser, evaluating 'document = 3', will add
/src/dist/realms-shim.cjs.js-974-      // a property to safeGlobal instead of throwing a
/src/dist/realms-shim.cjs.js-975-      // ReferenceError.
/src/dist/realms-shim.cjs.js:976:      if (prop === 'eval' || prop in target || prop in unsafeGlobal) {
/src/dist/realms-shim.cjs.js-977-        return true;
##############################################
/src/dist/realms-shim.cjs.js-1048-
/src/dist/realms-shim.cjs.js:1049:// The shim cannot correctly emulate a direct eval as explained at
/src/dist/realms-shim.cjs.js-1050-// https://github.com/Agoric/realms-shim/issues/12
/src/dist/realms-shim.cjs.js:1051:// Without rejecting apparent direct eval syntax, we would
/src/dist/realms-shim.cjs.js:1052:// accidentally evaluate these with an emulation of indirect eval. Tp
/src/dist/realms-shim.cjs.js-1053-// prevent future compatibility problems, in shifting from use of the
/src/dist/realms-shim.cjs.js-1054-// shim to genuine platform support for the proposal, we should
/src/dist/realms-shim.cjs.js:1055:// instead statically reject code that seems to contain a direct eval
/src/dist/realms-shim.cjs.js-1056-// expression.
##############################################
/src/dist/realms-shim.cjs.js-1062-// security problems. Thus, we are only trying to catch innocent
/src/dist/realms-shim.cjs.js:1063:// occurrences, not malicious one. In particular, `(eval)(...)` is
/src/dist/realms-shim.cjs.js:1064:// direct eval syntax that would not be caught by the following regexp.
/src/dist/realms-shim.cjs.js-1065-
/src/dist/realms-shim.cjs.js:1066:const someDirectEvalPattern = /\beval\s*(?:\(|\/[/*])/;
/src/dist/realms-shim.cjs.js-1067-
##############################################
/src/dist/realms-shim.cjs.js-1072-    throw new SyntaxError(
/src/dist/realms-shim.cjs.js:1073:      `possible direct eval expression rejected around line ${linenum}`
/src/dist/realms-shim.cjs.js-1074-    );
##############################################
/src/dist/realms-shim.cjs.js-1107-  // Create a function in sloppy mode, so that we can use 'with'. It returns
/src/dist/realms-shim.cjs.js:1108:  // a function in strict mode that evaluates the provided code using direct
/src/dist/realms-shim.cjs.js:1109:  // eval, and thus in strict mode in the same scope. We must be very careful
/src/dist/realms-shim.cjs.js-1110-  // to not create new names in this scope
##############################################
/src/dist/realms-shim.cjs.js-1115-  // 3: The inner strict function is effectively passed two parameters:
/src/dist/realms-shim.cjs.js:1116:  //    a) its arguments[0] is the source to be directly evaluated.
/src/dist/realms-shim.cjs.js-1117-  //    b) its 'this' is the this binding seen by the code being
/src/dist/realms-shim.cjs.js:1118:  //       directly evaluated.
/src/dist/realms-shim.cjs.js-1119-
##############################################
/src/dist/realms-shim.cjs.js-1121-  // (including an 'arguments[0]', which points at the Proxy). 'function' is
/src/dist/realms-shim.cjs.js:1122:  // a keyword, not a variable, so it is not looked up. then 'eval' is looked
/src/dist/realms-shim.cjs.js-1123-  // up in the proxy, that's the first time it is looked up after
##############################################
/src/dist/realms-shim.cjs.js-1125-  // unsafeEval, which satisfies the IsDirectEvalTrap predicate, so it uses
/src/dist/realms-shim.cjs.js:1126:  // the direct eval and gets the lexical scope. The second 'arguments[0]' is
/src/dist/realms-shim.cjs.js-1127-  // looked up in the context of the inner function. The *contents* of
/src/dist/realms-shim.cjs.js:1128:  // arguments[0], because we're using direct eval, are looked up in the
/src/dist/realms-shim.cjs.js-1129-  // Proxy, by which point the useUnsafeEvaluator switch has been flipped
/src/dist/realms-shim.cjs.js:1130:  // back to 'false', so any instances of 'eval' in that string will get the
/src/dist/realms-shim.cjs.js:1131:  // safe evaluator.
/src/dist/realms-shim.cjs.js-1132-
##############################################
/src/dist/realms-shim.cjs.js-1137-        'use strict';
/src/dist/realms-shim.cjs.js:1138:        return eval(arguments[0]);
/src/dist/realms-shim.cjs.js-1139-      };
##############################################
/src/dist/realms-shim.cjs.js-1168-
/src/dist/realms-shim.cjs.js:1169:    // We use the the concise method syntax to create an eval without a
/src/dist/realms-shim.cjs.js:1170:    // [[Construct]] behavior (such that the invocation "new eval()" throws
/src/dist/realms-shim.cjs.js:1171:    // TypeError: eval is not a constructor"), but which still accepts a
/src/dist/realms-shim.cjs.js-1172-    // 'this' binding.
/src/dist/realms-shim.cjs.js-1173-    const safeEval = {
/src/dist/realms-shim.cjs.js:1174:      eval(src) {
/src/dist/realms-shim.cjs.js-1175-        src = `${src}`;
##############################################
/src/dist/realms-shim.cjs.js-1214-      }
/src/dist/realms-shim.cjs.js:1215:    }.eval;
/src/dist/realms-shim.cjs.js-1216-
/src/dist/realms-shim.cjs.js-1217-    // safeEval's prototype is currently the primal realm's
/src/dist/realms-shim.cjs.js:1218:    // Function.prototype, which we must not let escape. To make 'eval
/src/dist/realms-shim.cjs.js-1219-    // instanceof Function' be true inside the realm, we need to point it at
##############################################
/src/dist/realms-shim.cjs.js-1221-
/src/dist/realms-shim.cjs.js:1222:    // Ensure that eval from any compartment in a root realm is an instance
/src/dist/realms-shim.cjs.js-1223-    // of Function in any compartment of the same root realm.
##############################################
/src/dist/realms-shim.cjs.js-1236-        // We break up the following literal string so that an
/src/dist/realms-shim.cjs.js:1237:        // apparent direct eval syntax does not appear in this
/src/dist/realms-shim.cjs.js-1238-        // file. Thus, we avoid rejection by the overly eager
/src/dist/realms-shim.cjs.js-1239-        // rejectDangerousSources.
/src/dist/realms-shim.cjs.js:1240:        value: safeEval("() => 'function eval' + '() { [shim code] }'"),
/src/dist/realms-shim.cjs.js-1241-        writable: false,
##############################################
/src/dist/realms-shim.cjs.js-1263- * A safe version of the native Function which relies on
/src/dist/realms-shim.cjs.js:1264: * the safety of evalEvaluator for confinement.
/src/dist/realms-shim.cjs.js-1265- */
##############################################
/src/dist/realms-shim.cjs.js-1284-      // is a pair of template literals back-to-back (so the first one
/src/dist/realms-shim.cjs.js:1285:      // nominally evaluates to the parser to use on the second one), which
/src/dist/realms-shim.cjs.js:1286:      // can't actually execute (because the first literal evals to a string,
/src/dist/realms-shim.cjs.js-1287-      // which can't be a parser function), but that doesn't matter because
/src/dist/realms-shim.cjs.js:1288:      // the function is bypassed entirely. When that gets evaluated, it
/src/dist/realms-shim.cjs.js:1289:      // defines (but does not invoke) a function, then evaluates a simple
/src/dist/realms-shim.cjs.js-1290-      // {x: this} expression, giving access to the safe global.
##############################################
/src/dist/realms-shim.cjs.js-1386-  defineProperties(safeGlobal, {
/src/dist/realms-shim.cjs.js:1387:    eval: {
/src/dist/realms-shim.cjs.js-1388-      value: safeEval,
##############################################
/src/dist/realms-shim.cjs.js-1455-
/src/dist/realms-shim.cjs.js:1456:  // Creating the realmRec provides the global object, eval() and Function()
/src/dist/realms-shim.cjs.js-1457-  // to the realm.
##############################################
/src/dist/realms-shim.cjs.js-1471- * A compartment shares the intrinsics of its root realm. Here, only a
/src/dist/realms-shim.cjs.js:1472: * realmRec is necessary to hold the global object, eval() and Function().
/src/dist/realms-shim.cjs.js-1473- */
##############################################
/src/dist/realms-shim.cjs.js-1509- * The "primal" realm class is defined in the current "primal" environment,
/src/dist/realms-shim.cjs.js:1510: * and is part of the shim. There is no need to facade this class via evaluation
/src/dist/realms-shim.cjs.js-1511- * because both share the same intrinsics.
##############################################
/src/dist/realms-shim.umd.min.js:1:(function(a,b){"object"==typeof exports&&"undefined"!=typeof module?module.exports=b():"function"==typeof define&&define.amd?define(b):(a=a||self,a.Realm=b())})(this,function(){'use strict';function a(a,b=void 0){const c=`please report internal shim error: ${a}`;console.error(c),b&&(console.error(`${b}`),console.error(`${b.stack}`));debugger;throw c}function b(b,c){b||a(c)}function c(a){return a}function d(a,b){function c(a,...b){try{return a(...b)}catch(a){if(Object(a)!==a)throw a;let b,c,d;try{b=`${a.name}`,c=`${a.message}`,d=`${a.stack||c}`}catch(a){throw new Error("unknown error")}const e=j.get(b)||Error;try{throw new e(c)}catch(a){throw a.stack=d,a}}}const{initRootRealm:d,initCompartment:e,getRealmGlobal:f,realmEvaluate:g}=b,{create:h,defineProperties:i}=Object,j=new Map([["EvalError",EvalError],["RangeError",RangeError],["ReferenceError",ReferenceError],["SyntaxError",SyntaxError],["TypeError",TypeError],["URIError",URIError]]);class k{constructor(){throw new TypeError("Realm is not a constructor")}static makeRootRealm(b={}){const e=h(k.prototype);return c(d,a,e,b),e}static makeCompartment(b={}){const d=h(k.prototype);return c(e,a,d,b),d}get global(){return c(f,this)}evaluate(a,b,d={}){return c(g,this,a,b,d)}}return i(k,{toString:{value:()=>"function Realm() { [shim code] }",writable:!1,enumerable:!1,configurable:!0}}),i(k.prototype,{toString:{value:()=>"[object Realm]",writable:!1,enumerable:!1,configurable:!0}}),k}function e(a,b){const{unsafeEval:c}=a;return c(C)(a,b)}function f(a){function c(c,e,f,g){for(const h of c){const c=H(a,h);c&&(b("value"in c,`unexpected accessor on global property: ${h}`),d[h]={value:c.value,writable:e,enumerable:f,configurable:g})}}const d={};return c(W,!1,!1,!1),c(X,!1,!1,!1),c(Y,!0,!1,!0),d}function g(){function a(a){if(a===void 0||null===a)throw new TypeError(`can't convert undefined or null to object`);return Object(a)}function b(a){return"symbol"==typeof a?a:`${a}`}function c(a,b){if("function"!=typeof a)throw TypeError(`invalid ${b} usage`);return a}const{defineProperty:d,defineProperties:e,getOwnPropertyDescriptor:f,getPrototypeOf:g,prototype:h}=Object;try{(0,h.__lookupGetter__)("x")}catch(a){return}e(h,{__defineGetter__:{value:function(b,e){const f=a(this);d(f,b,{get:c(e,"getter"),enumerable:!0,configurable:!0})}},__defineSetter__:{value:function(b,e){const f=a(this);d(f,b,{set:c(e,"setter"),enumerable:!0,configurable:!0})}},__lookupGetter__:{value:function(c){let d=a(this);c=b(c);let e;for(;d&&!(e=f(d,c));)d=g(d);return e&&e.get}},__lookupSetter__:{value:function(c){let d=a(this);c=b(c);let e;for(;d&&!(e=f(d,c));)d=g(d);return e&&e.set}}})}function h(){function a(a,e){let f;try{f=Z(e)}catch(a){if(a instanceof SyntaxError)return;throw a}const g=c(f),h=function(){throw new TypeError("Not available")};b(h,{name:{value:a}}),b(g,{constructor:{value:h}}),b(h,{prototype:{value:g}}),h!==Function.prototype.constructor&&d(h,Function.prototype.constructor)}const{defineProperties:b,getPrototypeOf:c,setPrototypeOf:d}=Object;a("Function","(function(){})"),a("GeneratorFunction","(function*(){})"),a("AsyncFunction","(async function(){})"),a("AsyncGeneratorFunction","(async function*(){})")}function i(){const a=new Function("try {return this===global}catch(e){return false}")();if(!a)return;const b=require("vm"),c=b.runInNewContext(_);return c}function j(){if("undefined"!=typeof document){const a=document.createElement("iframe");a.style.display="none",document.body.appendChild(a);const b=a.contentWindow.eval($);return b}}function k(a,b=[]){const c=f(a);return F({unsafeGlobal:a,sharedGlobalDescs:c,unsafeEval:a.eval,unsafeFunction:a.Function,allShims:b})}function l(a){const b=aa();return b.eval(ba),b.eval(ca),k(b,a)}function m(a){const b=I(a),c=Q(J(b),a=>{if("eval"===a||ea.has(a)||!U(da,a))return!1;const c=b[a];return!1===c.configurable&&!1===c.writable&&P(c,"value")});return c}function n(a,b,c){const{unsafeGlobal:d,unsafeEval:e}=a;let f=!1;return{__proto__:fa,allowUnsafeEvaluatorOnce(){f=!0},unsafeEvaluatorAllowed(){return f},get(a,b){return"eval"===b?!0===f?(f=!1,e):a.eval:b===Symbol.unscopables?void 0:b in a?a[b]:void 0},set(a,c,d){if(P(a,c))throw new TypeError(`do not modify endowments like ${c+""}`);return b[c]=d,!0},has(a,b){return!!c||!!("eval"===b||b in a||b in d)}}}function o(a){const b=a.search(ga);if(-1!==b){const c=a.slice(0,b).split("\n").length;throw new SyntaxError(`possible html comment syntax rejected around line ${c}`)}}function p(a){const b=a.search(ha);if(-1!==b){const c=a.slice(0,b).split("\n").length;throw new SyntaxError(`possible import expression rejected around line ${c}`)}}function q(a){const b=a.search(ia);if(-1!==b){const c=a.slice(0,b).split("\n").length;throw new SyntaxError(`possible direct eval expression rejected around line ${c}`)}}function r(a){o(a),p(a),q(a)}function s(a){return 0===a.length?"":`const {${S(a,",")}} = this;`}function t(a,b){const{unsafeFunction:c}=a,d=s(b);return c(`
/src/dist/realms-shim.umd.min.js-2-    with (arguments[0]) {
##############################################
/src/dist/realms-shim.umd.min.js-5-        'use strict';
/src/dist/realms-shim.umd.min.js:6:        return eval(arguments[0]);
/src/dist/realms-shim.umd.min.js-7-      };
/src/dist/realms-shim.umd.min.js-8-    }
/src/dist/realms-shim.umd.min.js:9:  `)}function u(c,d,e,f){const{unsafeFunction:g}=c,h=m(d),i=t(c,h);return function(h={},j={}){const k=j.transforms||[],l=[...k,...(e||[]),...[ja]],m={eval(b){b=`${b}`;const e=l.reduce((a,b)=>b.rewrite?b.rewrite(a):a,{src:b,endowments:h});b=e.src;const g=E(d,I(e.endowments)),j=n(c,d,f),k=new Proxy(g,j),m=M(i,d,[k]);j.allowUnsafeEvaluatorOnce();let o;try{return M(m,d,[b])}catch(a){throw o=a,a}finally{j.unsafeEvaluatorAllowed()&&a("handler did not revoke useUnsafeEvaluator",o)}}}.eval;return L(m,g.prototype),b(K(m).constructor!==Function,"hide Function"),b(K(m).constructor!==g,"hide unsafeFunction"),G(m,{toString:{value:m("() => 'function eval' + '() { [shim code] }'"),writable:!1,enumerable:!1,configurable:!0}}),m}}function v(a){return a()}function w(a){return(b,c,d={})=>a(c,d)(b)}function x(a,c){const{unsafeFunction:d,unsafeGlobal:e}=a,f=function(...a){const b=`${R(a)||""}`;let f=`${S(a,",")}`;if(!U(/^[\w\s,]*$/,f))throw new e.SyntaxError("shim limitation: Function arg must be simple ASCII identifiers, possibly separated by commas: no default values, pattern matches, or non-ASCII parameter names");if(new d(b),V(f,")"))throw new e.SyntaxError("shim limitation: Function arg string contains parenthesis");0<f.length&&(f+="\n/*``*/");const g=`(function(${f}){\n${b}\n})`;return c(g)};return L(f,d.prototype),b(K(f).constructor!==Function,"hide Function"),b(K(f).constructor!==d,"hide unsafeFunction"),G(f,{prototype:{value:d.prototype},toString:{value:c("() => 'function Function() { [shim code] }'"),writable:!1,enumerable:!1,configurable:!0}}),f}function y(a){return b(Object(a)===a,"bad object, not a Realm instance"),b(ka.has(a),"Realm instance has no record"),ka.get(a)}function z(a,c){b(Object(a)===a,"bad object, not a Realm instance"),b(!ka.has(a),"Realm instance already has a record"),ka.set(a,c)}function A(a,b,c){G(a,{eval:{value:b,writable:!0,configurable:!0},Function:{value:c,writable:!0,configurable:!0}})}function B(a,b,c){const{sharedGlobalDescs:d,unsafeGlobal:e}=a,f=E(e.Object.prototype,d),g=u(a,f,b,c),h=v(g),i=w(g),j=x(a,h);A(f,h,j);const k=F({safeGlobal:f,safeEval:h,safeEvalWhichTakesEndowments:i,safeFunction:j});return k}const C=c(`'use strict'; (${d})`),{assign:D,create:E,freeze:F,defineProperties:G,getOwnPropertyDescriptor:H,getOwnPropertyDescriptors:I,getOwnPropertyNames:J,getPrototypeOf:K,setPrototypeOf:L}=Object,{apply:M,ownKeys:N}=Reflect,O=a=>(b,...c)=>M(a,b,c),P=O(Object.prototype.hasOwnProperty),Q=O(Array.prototype.filter),R=O(Array.prototype.pop),S=O(Array.prototype.join),T=O(Array.prototype.concat),U=O(RegExp.prototype.test),V=O(String.prototype.includes),W=["Infinity","NaN","undefined"],X=["isFinite","isNaN","parseFloat","parseInt","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","Array","ArrayBuffer","Boolean","DataView","EvalError","Float32Array","Float64Array","Int8Array","Int16Array","Int32Array","Map","Number","Object","RangeError","ReferenceError","Set","String","Symbol","SyntaxError","TypeError","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","URIError","WeakMap","WeakSet","JSON","Math","Reflect","escape","unescape"],Y=["Date","Error","Promise","Proxy","RegExp","Intl"],Z=eval,$="'use strict'; this",_=`(0, eval)("'use strict'; this")`,aa=()=>{const a=j(),b=i();if(!a&&!b||a&&b)throw new Error("unexpected platform, unable to create Realm");return a||b},ba=c(`"use strict"; (${g})();`),ca=c(`"use strict"; const globalEval = eval; (${h})();`),da=/^[a-zA-Z_$][\w$]*$/,ea=new Set(["await","break","case","catch","class","const","continue","debugger","default","delete","do","else","export","extends","finally","for","function","if","import","in","instanceof","new","return","super","switch","this","throw","try","typeof","var","void","while","with","yield","let","static","enum","implements","package","protected","interface","private","public","await","null","true","false","this","arguments"]),fa=new Proxy(F({}),{get(b,c){a(`unexpected scope handler trap called: ${c}`)}}),ga=/(?:<!--|-->)/,ha=/\bimport\s*(?:\(|\/[/*])/,ia=/\beval\s*(?:\(|\/[/*])/,ja={rewrite(a){return r(a.src),a}},ka=new WeakMap,la={initRootRealm:function(a,b,c){const{shims:d,transforms:f,sloppyGlobals:g}=c,h=T(a.allShims,d),i=l(h),j=e(i,la);i.sharedGlobalDescs.Realm={value:j,writable:!0,configurable:!0};const k=B(i,f,g),{safeEvalWhichTakesEndowments:m}=k;for(const d of h)m(d);z(b,k)},initCompartment:function(a,b,c={}){const{transforms:d,sloppyGlobals:e}=c,f=B(a,d,e);z(b,f)},getRealmGlobal:function(a){const{safeGlobal:b}=y(a);return b},realmEvaluate:function(a,b,c={},d={}){const{safeEvalWhichTakesEndowments:e}=y(a);return e(b,c,d)}},ma=function(){const a=(0,eval)($);return g(),h(),k(a)}(),na=d(ma,la);return na});
/src/dist/realms-shim.umd.min.js-10-//# sourceMappingURL=realms-shim.umd.min.js.map

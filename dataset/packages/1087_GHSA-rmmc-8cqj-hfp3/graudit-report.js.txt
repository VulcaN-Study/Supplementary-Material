/src/src/utils.js-230-// eslint-disable-next-line no-eval
/src/src/utils.js:231:InternalUtils.require = name => (InternalUtils.isNode ? eval('require')(name) : null);
##############################################
/src/dist/otpauth.js-227-      InternalUtils.require = function(name) {
/src/dist/otpauth.js:228:        return InternalUtils.isNode ? eval("require")(name) : null;
/src/dist/otpauth.js-229-      };
##############################################
/src/dist/otpauth.min.js-13-a.b32.alphabet[d<<5-c&31]);return e};a.b32.encode=function(b){var c=b.toUpperCase();b=new ArrayBuffer(5*b.length/8|0);for(var d=new Uint8Array(b),e=0,l=0,f=0,h=0;h<c.length;h++){var g=a.b32.alphabet.indexOf(c[h]);if(-1===g)throw new TypeError("Invalid character found: "+c[h]);l=l<<5|g;e+=5;8<=e&&(d[f++]=l>>>e-8&255,e-=8)}return b};a.hex={};a.hex.decode=function(a){a=new Uint8Array(a);for(var b="",c=0;c<a.length;c++){var d=a[c].toString(16);b+=1===d.length?"0"+d:d}return b.toUpperCase()};a.hex.encode=
/src/dist/otpauth.min.js:14:function(a){for(var b=new ArrayBuffer(a.length/2),c=new Uint8Array(b),d=0;d<c.length;d++)c[d]=Number.parseInt(a.substr(2*d,2),16);return b};var b={};b.isNode="[object process]"===Object.prototype.toString.call(d.process);b.require=function(a){return b.isNode?eval("require")(a):null}}).call(this,g(3))},function(f,e,g){var d={cipher:{},hash:{},keyexchange:{},mode:{},misc:{},codec:{},exception:{corrupt:function(a){this.toString=function(){return"CORRUPT: "+this.message};this.message=a},invalid:function(a){this.toString=
/src/dist/otpauth.min.js-15-function(){return"INVALID: "+this.message};this.message=a},bug:function(a){this.toString=function(){return"BUG: "+this.message};this.message=a},notReady:function(a){this.toString=function(){return"NOT READY: "+this.message};this.message=a}},bitArray:{bitSlice:function(a,b,c){a=d.bitArray._shiftRight(a.slice(b/32),32-(b&31)).slice(1);return void 0===c?a:d.bitArray.clamp(a,c-b)},extract:function(a,b,c){var d=Math.floor(-b-c&31);return((b+c-1^b)&-32?a[b/32|0]<<32-d^a[b/32+1|0]>>>d:a[b/32|0]>>>d)&(1<<
##############################################
/src/dist/otpauth.js.map:1:{"version":3,"sources":["webpack://OTPAuth/ [synthetic:base] ","webpack://OTPAuth/ [synthetic:es6/util/arrayiterator] ","webpack://OTPAuth/ [synthetic:util/defines] ","webpack://OTPAuth/ [synthetic:util/defineproperty] ","webpack://OTPAuth/ [synthetic:util/global] ","webpack://OTPAuth/ [synthetic:es6/symbol] ","webpack://OTPAuth/ [synthetic:util/polyfill] ","webpack://OTPAuth/ [synthetic:es6/number/parseint] ","webpack://OTPAuth/webpack/universalModuleDefinition","webpack://OTPAuth/otpauth.js","webpack://OTPAuth/webpack/bootstrap","webpack://OTPAuth/./src/utils.js","webpack://OTPAuth//tmp/tmp-9610PJZDsIrC31cP","webpack://OTPAuth/./src/crypto.js","webpack://OTPAuth/(webpack)/buildin/global.js","webpack://OTPAuth/./src/secret.js","webpack://OTPAuth/./src/uri.js","webpack://OTPAuth/./src/otp.js","webpack://OTPAuth/./src/main.js"],"names":["webpackUniversalModuleDefinition","root","factory","exports","module","define","amd","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","__webpack_require__.d","name","getter","o","Object","defineProperty","enumerable","get","r","__webpack_require__.r","Symbol","toStringTag","value","t","__webpack_require__.t","mode","__esModule","ns","create","key","bind","n","__webpack_require__.n","getDefault","getModuleExports","__webpack_require__.o","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","global","Utils","InternalUtils","uint","decode","Utils.uint.decode","buf","arr","Uint8Array","num","length","encode","Utils.uint.encode","ArrayBuffer","acc","raw","Utils.raw.decode","str","String","fromCharCode","Utils.raw.encode","charCodeAt","b32","alphabet","Utils.b32.decode","bits","Utils.b32.encode","strUpp","toUpperCase","index","idx","indexOf","TypeError","hex","Utils.hex.decode","hexByte","toString","Utils.hex.encode","Number","parseInt","substr","isNode","require","InternalUtils.require","eval","sjcl","cipher","hash","keyexchange","misc","codec","exception","corrupt","message","this.toString","invalid","bug","notReady","bitSlice","a","bstart","bend","bitArray","_shiftRight","slice","undefined","clamp","extract","blength","sh","Math","floor","x","concat","a1","a2","last","shift","getPartial","bitLength","len","ceil","partial","_end","round","equal","b","carry","out","push","shift2","last2","pop","_xor4","y","byteswapM","v","globals","globals.ArrayBuffer","DataView","globals.DataView","arrayBuffer","fromBits","padding","padding_count","ol","tmp","setUint32","byteLength","buffer","smallest","setUint8","getUint8","toBits","inView","getUint32","hexDumpBuffer","stringBufferView","string","getUint16","width","Array","join","console","log","sha1","sjcl.hash.sha1","_h","_buffer","_length","reset","sjcl.hash.sha1.hash","data","update","finalize","blockSize","_init","utf8String","nl","Uint32Array","j","_block","subarray","splice","h","_key","_f","_S","words","w","e","sha256","sjcl.hash.sha256","_precompute","sjcl.hash.sha256.hash","frac","prime","factor","isPrime","pow","k","h0","h1","h2","h3","h4","h5","h6","h7","sha512","sjcl.hash.sha512","sjcl.hash.sha512.hash","_initr","_keyr","frac2","h0h","h0l","h1h","h1l","h2h","h2l","h3h","h3l","h4h","h4l","h5h","h5l","h6h","h6l","h7h","h7l","ah","al","bh","bl","ch","cl","dh","dl","eh","el","fh","fl","gh","gl","hh","hl","wrh","wrl","gamma0xh","gamma0xl","gamma0h","gamma0l","gamma1xh","gamma1xl","gamma1h","gamma1l","wr7h","wr16h","wr16l","wr7l","chh","chl","majh","majl","sigma0h","sigma0l","krh","krl","t1l","t1h","t2l","t2h","hmac","sjcl.misc.hmac","Hash","_hash","exKey","bs","_baseHash","_resultHash","encrypt","mac","sjcl.misc.hmac.prototype.mac","_updated","digest","sjcl.misc.hmac.prototype.reset","sjcl.misc.hmac.prototype.update","sjcl.misc.hmac.prototype.digest","result","Crypto","sjcl__WEBPACK_IMPORTED_MODULE_0__","NodeCrypto","_utils__WEBPACK_IMPORTED_MODULE_1__","bufferFrom","Buffer","from","arrbuf","nodeBuf","bufferTo","randomBytes","Crypto.randomBytes","size","buff","hmacDigest","Crypto.hmacDigest","algorithm","createHmac","crypto","getRandomValues","msCrypto","warn","random","toLowerCase","g","Function","window","utils","src_crypto","secret_Secret","constructor","fromRaw","fromB32","fromHex","configurable","writable","OTPURI_REGEX","SECRET_REGEX","ALGORITHM_REGEX","INTEGER_REGEX","POSITIVE_INTEGER_REGEX","uri_URI","parse","uri","uriGroups","match","error","isArray","URIError","uriType","uriLabel","split","map","decodeURIComponent","uriParams","reduce","cur","pairArr","pairKey","pairVal","config","OTP","otp_HOTP","counter","test","otp_TOTP","period","label","issuer","secret","digits","stringify","otp","legacyIssuer","isTOTP","encodeURIComponent","generate","pad","offset","validate","token","searchToken","generatedToken","timestamp","Date","now","version"],"mappings":"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","file":"otpauth.js","sourcesContent":["","","","","","","","","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"OTPAuth\"] = factory();\n\telse\n\t\troot[\"OTPAuth\"] = factory();\n})(this, function() {\nreturn ","/*! otpauth v3.2.7 | (c) Héctor Molinero Fernández <hector@molinero.dev> | https://github.com/hectorm/otpauth | MIT */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"OTPAuth\"] = factory();\n\telse\n\t\troot[\"OTPAuth\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 4);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return Utils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return InternalUtils; });\n/**\n * An object containing some utilities.\n * @type {Object}\n */\nconst Utils = {};\n\n/**\n * UInt conversion.\n * @type {Object}\n */\nUtils.uint = {};\n\n/**\n * Converts an ArrayBuffer to an integer.\n * @param {ArrayBuffer} buf ArrayBuffer.\n * @returns {number} Integer.\n */\nUtils.uint.decode = buf => {\n\tconst arr = new Uint8Array(buf);\n\tlet num = 0;\n\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tif (arr[i] !== 0) {\n\t\t\tnum *= 256;\n\t\t\tnum += arr[i];\n\t\t}\n\t}\n\n\treturn num;\n};\n\n/**\n * Converts an integer to an ArrayBuffer.\n * @param {number} num Integer.\n * @returns {ArrayBuffer} ArrayBuffer.\n */\nUtils.uint.encode = num => {\n\tconst buf = new ArrayBuffer(8);\n\tconst arr = new Uint8Array(buf);\n\tlet acc = num;\n\n\tfor (let i = 7; i >= 0; i--) {\n\t\tif (acc === 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tarr[i] = acc & 255;\n\t\tacc -= arr[i];\n\t\tacc /= 256;\n\t}\n\n\treturn buf;\n};\n\n/**\n * Raw string conversion.\n * @type {Object}\n */\nUtils.raw = {};\n\n/**\n * Converts an ArrayBuffer to a string.\n * @param {ArrayBuffer} buf ArrayBuffer.\n * @returns {string} String.\n */\nUtils.raw.decode = buf => {\n\tconst arr = new Uint8Array(buf);\n\tlet str = '';\n\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tstr += String.fromCharCode(arr[i]);\n\t}\n\n\treturn str;\n};\n\n/**\n * Converts a string to an ArrayBuffer.\n * @param {string} str String.\n * @returns {ArrayBuffer} ArrayBuffer.\n */\nUtils.raw.encode = str => {\n\tconst buf = new ArrayBuffer(str.length);\n\tconst arr = new Uint8Array(buf);\n\n\tfor (let i = 0; i < str.length; i++) {\n\t\tarr[i] = str.charCodeAt(i);\n\t}\n\n\treturn buf;\n};\n\n/**\n * Base32 string conversion.\n * @type {Object}\n */\nUtils.b32 = {};\n\n/**\n * RFC 4648 base32 alphabet without pad.\n * @type {string}\n */\nUtils.b32.alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';\n\n/**\n * Converts an ArrayBuffer to a base32 string (RFC 4648).\n * @see https://github.com/LinusU/base32-decode\n * @param {ArrayBuffer} buf ArrayBuffer.\n * @returns {string} Base32 string.\n */\nUtils.b32.decode = buf => {\n\tconst arr = new Uint8Array(buf);\n\n\tlet bits = 0;\n\tlet value = 0;\n\tlet str = '';\n\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tvalue = (value << 8) | arr[i];\n\t\tbits += 8;\n\n\t\twhile (bits >= 5) {\n\t\t\tstr += Utils.b32.alphabet[(value >>> bits - 5) & 31];\n\t\t\tbits -= 5;\n\t\t}\n\t}\n\n\tif (bits > 0) {\n\t\tstr += Utils.b32.alphabet[(value << 5 - bits) & 31];\n\t}\n\n\treturn str;\n};\n\n/**\n * Converts a base32 string to an ArrayBuffer (RFC 4648).\n * @see https://github.com/LinusU/base32-encode\n * @param {string} str Base32 string.\n * @returns {ArrayBuffer} ArrayBuffer.\n */\nUtils.b32.encode = str => {\n\tconst strUpp = str.toUpperCase();\n\tconst buf = new ArrayBuffer(str.length * 5 / 8 | 0);\n\tconst arr = new Uint8Array(buf);\n\n\tlet bits = 0;\n\tlet value = 0;\n\tlet index = 0;\n\n\tfor (let i = 0; i < strUpp.length; i++) {\n\t\tconst idx = Utils.b32.alphabet.indexOf(strUpp[i]);\n\n\t\tif (idx === -1) {\n\t\t\tthrow new TypeError(`Invalid character found: ${strUpp[i]}`);\n\t\t}\n\n\t\tvalue = (value << 5) | idx;\n\t\tbits += 5;\n\n\t\tif (bits >= 8) {\n\t\t\tarr[index++] = (value >>> bits - 8) & 255;\n\t\t\tbits -= 8;\n\t\t}\n\t}\n\n\treturn buf;\n};\n\n/**\n * Hexadecimal string conversion.\n * @type {Object}\n */\nUtils.hex = {};\n\n/**\n * Converts an ArrayBuffer to a hexadecimal string.\n * @param {ArrayBuffer} buf ArrayBuffer.\n * @returns {string} Hexadecimal string.\n */\nUtils.hex.decode = buf => {\n\tconst arr = new Uint8Array(buf);\n\tlet str = '';\n\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tconst hexByte = arr[i].toString(16);\n\n\t\tstr += hexByte.length === 1\n\t\t\t? `0${hexByte}`\n\t\t\t: hexByte;\n\t}\n\n\treturn str.toUpperCase();\n};\n\n/**\n * Converts a hexadecimal string to an ArrayBuffer.\n * @param {string} str Hexadecimal string.\n * @returns {ArrayBuffer} ArrayBuffer.\n */\nUtils.hex.encode = str => {\n\tconst buf = new ArrayBuffer(str.length / 2);\n\tconst arr = new Uint8Array(buf);\n\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tarr[i] = Number.parseInt(str.substr(i * 2, 2), 16);\n\t}\n\n\treturn buf;\n};\n\n/**\n * An object containing some utilities (for internal use only).\n * @private\n * @type {Object}\n */\nconst InternalUtils = {};\n\n/**\n * Detect if running in \"Node.js\".\n * @type {boolean}\n */\n// eslint-disable-next-line dot-notation\nInternalUtils.isNode = Object.prototype.toString.call(global['process']) === '[object process]';\n\n/**\n * Dynamically import \"Node.js\" modules.\n * @param {string} name Name.\n * @returns {Object} Module.\n */\n// eslint-disable-next-line no-eval\nInternalUtils.require = name => (InternalUtils.isNode ? eval('require')(name) : null);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(3)))\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n\t\t\t\t\t/** @fileOverview Javascript cryptography implementation.\n *\n * Crush to remove comments, shorten variable names and\n * generally reduce transmission size.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n\n/*jslint indent: 2, bitwise: false, nomen: false, plusplus: false, white: false, regexp: false */\n/*global document, window, escape, unescape, module, require, Uint32Array */\n\n/**\n * The Stanford Javascript Crypto Library, top-level namespace.\n * @namespace\n */\nvar sjcl = {\n  /**\n   * Symmetric ciphers.\n   * @namespace\n   */\n  cipher: {},\n\n  /**\n   * Hash functions.  Right now only SHA256 is implemented.\n   * @namespace\n   */\n  hash: {},\n\n  /**\n   * Key exchange functions.  Right now only SRP is implemented.\n   * @namespace\n   */\n  keyexchange: {},\n  \n  /**\n   * Cipher modes of operation.\n   * @namespace\n   */\n  mode: {},\n\n  /**\n   * Miscellaneous.  HMAC and PBKDF2.\n   * @namespace\n   */\n  misc: {},\n  \n  /**\n   * Bit array encoders and decoders.\n   * @namespace\n   *\n   * @description\n   * The members of this namespace are functions which translate between\n   * SJCL's bitArrays and other objects (usually strings).  Because it\n   * isn't always clear which direction is encoding and which is decoding,\n   * the method names are \"fromBits\" and \"toBits\".\n   */\n  codec: {},\n  \n  /**\n   * Exceptions.\n   * @namespace\n   */\n  exception: {\n    /**\n     * Ciphertext is corrupt.\n     * @constructor\n     */\n    corrupt: function(message) {\n      this.toString = function() { return \"CORRUPT: \"+this.message; };\n      this.message = message;\n    },\n    \n    /**\n     * Invalid parameter.\n     * @constructor\n     */\n    invalid: function(message) {\n      this.toString = function() { return \"INVALID: \"+this.message; };\n      this.message = message;\n    },\n    \n    /**\n     * Bug or missing feature in SJCL.\n     * @constructor\n     */\n    bug: function(message) {\n      this.toString = function() { return \"BUG: \"+this.message; };\n      this.message = message;\n    },\n\n    /**\n     * Something isn't ready.\n     * @constructor\n     */\n    notReady: function(message) {\n      this.toString = function() { return \"NOT READY: \"+this.message; };\n      this.message = message;\n    }\n  }\n};\n/** @fileOverview Arrays of bits, encoded as arrays of Numbers.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/**\n * Arrays of bits, encoded as arrays of Numbers.\n * @namespace\n * @description\n * <p>\n * These objects are the currency accepted by SJCL's crypto functions.\n * </p>\n *\n * <p>\n * Most of our crypto primitives operate on arrays of 4-byte words internally,\n * but many of them can take arguments that are not a multiple of 4 bytes.\n * This library encodes arrays of bits (whose size need not be a multiple of 8\n * bits) as arrays of 32-bit words.  The bits are packed, big-endian, into an\n * array of words, 32 bits at a time.  Since the words are double-precision\n * floating point numbers, they fit some extra data.  We use this (in a private,\n * possibly-changing manner) to encode the number of bits actually  present\n * in the last word of the array.\n * </p>\n *\n * <p>\n * Because bitwise ops clear this out-of-band data, these arrays can be passed\n * to ciphers like AES which want arrays of words.\n * </p>\n */\nsjcl.bitArray = {\n  /**\n   * Array slices in units of bits.\n   * @param {bitArray} a The array to slice.\n   * @param {Number} bstart The offset to the start of the slice, in bits.\n   * @param {Number} bend The offset to the end of the slice, in bits.  If this is undefined,\n   * slice until the end of the array.\n   * @return {bitArray} The requested slice.\n   */\n  bitSlice: function (a, bstart, bend) {\n    a = sjcl.bitArray._shiftRight(a.slice(bstart/32), 32 - (bstart & 31)).slice(1);\n    return (bend === undefined) ? a : sjcl.bitArray.clamp(a, bend-bstart);\n  },\n\n  /**\n   * Extract a number packed into a bit array.\n   * @param {bitArray} a The array to slice.\n   * @param {Number} bstart The offset to the start of the slice, in bits.\n   * @param {Number} blength The length of the number to extract.\n   * @return {Number} The requested slice.\n   */\n  extract: function(a, bstart, blength) {\n    // FIXME: this Math.floor is not necessary at all, but for some reason\n    // seems to suppress a bug in the Chromium JIT.\n    var x, sh = Math.floor((-bstart-blength) & 31);\n    if ((bstart + blength - 1 ^ bstart) & -32) {\n      // it crosses a boundary\n      x = (a[bstart/32|0] << (32 - sh)) ^ (a[bstart/32+1|0] >>> sh);\n    } else {\n      // within a single word\n      x = a[bstart/32|0] >>> sh;\n    }\n    return x & ((1<<blength) - 1);\n  },\n\n  /**\n   * Concatenate two bit arrays.\n   * @param {bitArray} a1 The first array.\n   * @param {bitArray} a2 The second array.\n   * @return {bitArray} The concatenation of a1 and a2.\n   */\n  concat: function (a1, a2) {\n    if (a1.length === 0 || a2.length === 0) {\n      return a1.concat(a2);\n    }\n    \n    var last = a1[a1.length-1], shift = sjcl.bitArray.getPartial(last);\n    if (shift === 32) {\n      return a1.concat(a2);\n    } else {\n      return sjcl.bitArray._shiftRight(a2, shift, last|0, a1.slice(0,a1.length-1));\n    }\n  },\n\n  /**\n   * Find the length of an array of bits.\n   * @param {bitArray} a The array.\n   * @return {Number} The length of a, in bits.\n   */\n  bitLength: function (a) {\n    var l = a.length, x;\n    if (l === 0) { return 0; }\n    x = a[l - 1];\n    return (l-1) * 32 + sjcl.bitArray.getPartial(x);\n  },\n\n  /**\n   * Truncate an array.\n   * @param {bitArray} a The array.\n   * @param {Number} len The length to truncate to, in bits.\n   * @return {bitArray} A new array, truncated to len bits.\n   */\n  clamp: function (a, len) {\n    if (a.length * 32 < len) { return a; }\n    a = a.slice(0, Math.ceil(len / 32));\n    var l = a.length;\n    len = len & 31;\n    if (l > 0 && len) {\n      a[l-1] = sjcl.bitArray.partial(len, a[l-1] & 0x80000000 >> (len-1), 1);\n    }\n    return a;\n  },\n\n  /**\n   * Make a partial word for a bit array.\n   * @param {Number} len The number of bits in the word.\n   * @param {Number} x The bits.\n   * @param {Number} [_end=0] Pass 1 if x has already been shifted to the high side.\n   * @return {Number} The partial word.\n   */\n  partial: function (len, x, _end) {\n    if (len === 32) { return x; }\n    return (_end ? x|0 : x << (32-len)) + len * 0x10000000000;\n  },\n\n  /**\n   * Get the number of bits used by a partial word.\n   * @param {Number} x The partial word.\n   * @return {Number} The number of bits used by the partial word.\n   */\n  getPartial: function (x) {\n    return Math.round(x/0x10000000000) || 32;\n  },\n\n  /**\n   * Compare two arrays for equality in a predictable amount of time.\n   * @param {bitArray} a The first array.\n   * @param {bitArray} b The second array.\n   * @return {boolean} true if a == b; false otherwise.\n   */\n  equal: function (a, b) {\n    if (sjcl.bitArray.bitLength(a) !== sjcl.bitArray.bitLength(b)) {\n      return false;\n    }\n    var x = 0, i;\n    for (i=0; i<a.length; i++) {\n      x |= a[i]^b[i];\n    }\n    return (x === 0);\n  },\n\n  /** Shift an array right.\n   * @param {bitArray} a The array to shift.\n   * @param {Number} shift The number of bits to shift.\n   * @param {Number} [carry=0] A byte to carry in\n   * @param {bitArray} [out=[]] An array to prepend to the output.\n   * @private\n   */\n  _shiftRight: function (a, shift, carry, out) {\n    var i, last2=0, shift2;\n    if (out === undefined) { out = []; }\n    \n    for (; shift >= 32; shift -= 32) {\n      out.push(carry);\n      carry = 0;\n    }\n    if (shift === 0) {\n      return out.concat(a);\n    }\n    \n    for (i=0; i<a.length; i++) {\n      out.push(carry | a[i]>>>shift);\n      carry = a[i] << (32-shift);\n    }\n    last2 = a.length ? a[a.length-1] : 0;\n    shift2 = sjcl.bitArray.getPartial(last2);\n    out.push(sjcl.bitArray.partial(shift+shift2 & 31, (shift + shift2 > 32) ? carry : out.pop(),1));\n    return out;\n  },\n  \n  /** xor a block of 4 words together.\n   * @private\n   */\n  _xor4: function(x,y) {\n    return [x[0]^y[0],x[1]^y[1],x[2]^y[2],x[3]^y[3]];\n  },\n\n  /** byteswap a word array inplace.\n   * (does not handle partial words)\n   * @param {sjcl.bitArray} a word array\n   * @return {sjcl.bitArray} byteswapped array\n   */\n  byteswapM: function(a) {\n    var i, v, m = 0xff00;\n    for (i = 0; i < a.length; ++i) {\n      v = a[i];\n      a[i] = (v >>> 24) | ((v >>> 8) & m) | ((v & m) << 8) | (v << 24);\n    }\n    return a;\n  }\n};\n/** @fileOverview Bit array codec implementations.\n *\n * @author Marco Munizaga\n */\n\n//patch arraybuffers if they don't exist\nif (typeof(ArrayBuffer) === 'undefined') {\n  (function(globals){\n      \"use strict\";\n      globals.ArrayBuffer = function(){};\n      globals.DataView = function(){};\n  }(undefined));\n}\n\n/**\n * ArrayBuffer\n * @namespace\n */\nsjcl.codec.arrayBuffer = {\n  /** Convert from a bitArray to an ArrayBuffer. \n   * Will default to 8byte padding if padding is undefined*/\n  fromBits: function (arr, padding, padding_count) {\n    var out, i, ol, tmp, smallest;\n    padding = padding==undefined  ? true : padding;\n    padding_count = padding_count || 8;\n\n    if (arr.length === 0) {\n      return new ArrayBuffer(0);\n    }\n\n    ol = sjcl.bitArray.bitLength(arr)/8;\n\n    //check to make sure the bitLength is divisible by 8, if it isn't \n    //we can't do anything since arraybuffers work with bytes, not bits\n    if ( sjcl.bitArray.bitLength(arr)%8 !== 0 ) {\n      throw new sjcl.exception.invalid(\"Invalid bit size, must be divisble by 8 to fit in an arraybuffer correctly\");\n    }\n\n    if (padding && ol%padding_count !== 0){\n      ol += padding_count - (ol%padding_count);\n    }\n\n\n    //padded temp for easy copying\n    tmp = new DataView(new ArrayBuffer(arr.length*4));\n    for (i=0; i<arr.length; i++) {\n      tmp.setUint32(i*4, (arr[i]<<32)); //get rid of the higher bits\n    }\n\n    //now copy the final message if we are not going to 0 pad\n    out = new DataView(new ArrayBuffer(ol));\n\n    //save a step when the tmp and out bytelength are ===\n    if (out.byteLength === tmp.byteLength){\n      return tmp.buffer;\n    }\n\n    smallest = tmp.byteLength < out.byteLength ? tmp.byteLength : out.byteLength;\n    for(i=0; i<smallest; i++){\n      out.setUint8(i,tmp.getUint8(i));\n    }\n\n\n    return out.buffer;\n  },\n  /** Convert from an ArrayBuffer to a bitArray. */\n  toBits: function (buffer) {\n    var i, out=[], len, inView, tmp;\n\n    if (buffer.byteLength === 0) {\n      return [];\n    }\n\n    inView = new DataView(buffer);\n    len = inView.byteLength - inView.byteLength%4;\n\n    for (var i = 0; i < len; i+=4) {\n      out.push(inView.getUint32(i));\n    }\n\n    if (inView.byteLength%4 != 0) {\n      tmp = new DataView(new ArrayBuffer(4));\n      for (var i = 0, l = inView.byteLength%4; i < l; i++) {\n        //we want the data to the right, because partial slices off the starting bits\n        tmp.setUint8(i+4-l, inView.getUint8(len+i)); // big-endian, \n      }\n      out.push(\n        sjcl.bitArray.partial( (inView.byteLength%4)*8, tmp.getUint32(0) )\n      ); \n    }\n    return out;\n  },\n\n\n\n  /** Prints a hex output of the buffer contents, akin to hexdump **/\n  hexDumpBuffer: function(buffer){\n      var stringBufferView = new DataView(buffer);\n      var string = '';\n      var pad = function (n, width) {\n          n = n + '';\n          return n.length >= width ? n : new Array(width - n.length + 1).join('0') + n;\n      };\n\n      for (var i = 0; i < stringBufferView.byteLength; i+=2) {\n          if (i%16 == 0) string += ('\\n'+(i).toString(16)+'\\t');\n          string += ( pad(stringBufferView.getUint16(i).toString(16),4) + ' ');\n      }\n\n      if ( typeof console === undefined ){\n        console = console || {log:function(){}}; //fix for IE\n      }\n      console.log(string.toUpperCase());\n  }\n};\n\n/** @fileOverview Javascript SHA-1 implementation.\n *\n * Based on the implementation in RFC 3174, method 1, and on the SJCL\n * SHA-256 implementation.\n *\n * @author Quinn Slack\n */\n\n/**\n * Context for a SHA-1 operation in progress.\n * @constructor\n */\nsjcl.hash.sha1 = function (hash) {\n  if (hash) {\n    this._h = hash._h.slice(0);\n    this._buffer = hash._buffer.slice(0);\n    this._length = hash._length;\n  } else {\n    this.reset();\n  }\n};\n\n/**\n * Hash a string or an array of words.\n * @static\n * @param {bitArray|String} data the data to hash.\n * @return {bitArray} The hash value, an array of 5 big-endian words.\n */\nsjcl.hash.sha1.hash = function (data) {\n  return (new sjcl.hash.sha1()).update(data).finalize();\n};\n\nsjcl.hash.sha1.prototype = {\n  /**\n   * The hash's block size, in bits.\n   * @constant\n   */\n  blockSize: 512,\n   \n  /**\n   * Reset the hash state.\n   * @return this\n   */\n  reset:function () {\n    this._h = this._init.slice(0);\n    this._buffer = [];\n    this._length = 0;\n    return this;\n  },\n  \n  /**\n   * Input several words to the hash.\n   * @param {bitArray|String} data the data to hash.\n   * @return this\n   */\n  update: function (data) {\n    if (typeof data === \"string\") {\n      data = sjcl.codec.utf8String.toBits(data);\n    }\n    var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),\n        ol = this._length,\n        nl = this._length = ol + sjcl.bitArray.bitLength(data);\n    if (nl > 9007199254740991){\n      throw new sjcl.exception.invalid(\"Cannot hash more than 2^53 - 1 bits\");\n    }\n\n    if (typeof Uint32Array !== 'undefined') {\n\tvar c = new Uint32Array(b);\n    \tvar j = 0;\n    \tfor (i = this.blockSize+ol - ((this.blockSize+ol) & (this.blockSize-1)); i <= nl;\n\t\ti+= this.blockSize) {\n      \t    this._block(c.subarray(16 * j, 16 * (j+1)));\n      \t    j += 1;\n    \t}\n    \tb.splice(0, 16 * j);\n    } else {\n    \tfor (i = this.blockSize+ol - ((this.blockSize+ol) & (this.blockSize-1)); i <= nl;\n             i+= this.blockSize) {\n      \t     this._block(b.splice(0,16));\n      \t}\n    }\n    return this;\n  },\n  \n  /**\n   * Complete hashing and output the hash value.\n   * @return {bitArray} The hash value, an array of 5 big-endian words. TODO\n   */\n  finalize:function () {\n    var i, b = this._buffer, h = this._h;\n\n    // Round out and push the buffer\n    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);\n    // Round out the buffer to a multiple of 16 words, less the 2 length words.\n    for (i = b.length + 2; i & 15; i++) {\n      b.push(0);\n    }\n\n    // append the length\n    b.push(Math.floor(this._length / 0x100000000));\n    b.push(this._length | 0);\n\n    while (b.length) {\n      this._block(b.splice(0,16));\n    }\n\n    this.reset();\n    return h;\n  },\n\n  /**\n   * The SHA-1 initialization vector.\n   * @private\n   */\n  _init:[0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0],\n\n  /**\n   * The SHA-1 hash key.\n   * @private\n   */\n  _key:[0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6],\n\n  /**\n   * The SHA-1 logical functions f(0), f(1), ..., f(79).\n   * @private\n   */\n  _f:function(t, b, c, d) {\n    if (t <= 19) {\n      return (b & c) | (~b & d);\n    } else if (t <= 39) {\n      return b ^ c ^ d;\n    } else if (t <= 59) {\n      return (b & c) | (b & d) | (c & d);\n    } else if (t <= 79) {\n      return b ^ c ^ d;\n    }\n  },\n\n  /**\n   * Circular left-shift operator.\n   * @private\n   */\n  _S:function(n, x) {\n    return (x << n) | (x >>> 32-n);\n  },\n  \n  /**\n   * Perform one cycle of SHA-1.\n   * @param {Uint32Array|bitArray} words one block of words.\n   * @private\n   */\n  _block:function (words) {\n    var t, tmp, a, b, c, d, e,\n    h = this._h;\n    var w;\n    if (typeof Uint32Array !== 'undefined') {\n        // When words is passed to _block, it has 16 elements. SHA1 _block\n        // function extends words with new elements (at the end there are 80 elements). \n        // The problem is that if we use Uint32Array instead of Array, \n        // the length of Uint32Array cannot be changed. Thus, we replace words with a \n        // normal Array here.\n        w = Array(80); // do not use Uint32Array here as the instantiation is slower\n        for (var j=0; j<16; j++){\n            w[j] = words[j];\n        }\n    } else {\n        w = words;\n    }\n\n    a = h[0]; b = h[1]; c = h[2]; d = h[3]; e = h[4]; \n\n    for (t=0; t<=79; t++) {\n      if (t >= 16) {\n        w[t] = this._S(1, w[t-3] ^ w[t-8] ^ w[t-14] ^ w[t-16]);\n      }\n      tmp = (this._S(5, a) + this._f(t, b, c, d) + e + w[t] +\n             this._key[Math.floor(t/20)]) | 0;\n      e = d;\n      d = c;\n      c = this._S(30, b);\n      b = a;\n      a = tmp;\n   }\n\n   h[0] = (h[0]+a) |0;\n   h[1] = (h[1]+b) |0;\n   h[2] = (h[2]+c) |0;\n   h[3] = (h[3]+d) |0;\n   h[4] = (h[4]+e) |0;\n  }\n};\n/** @fileOverview Javascript SHA-256 implementation.\n *\n * An older version of this implementation is available in the public\n * domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,\n * Stanford University 2008-2010 and BSD-licensed for liability\n * reasons.\n *\n * Special thanks to Aldo Cortesi for pointing out several bugs in\n * this code.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/**\n * Context for a SHA-256 operation in progress.\n * @constructor\n */\nsjcl.hash.sha256 = function (hash) {\n  if (!this._key[0]) { this._precompute(); }\n  if (hash) {\n    this._h = hash._h.slice(0);\n    this._buffer = hash._buffer.slice(0);\n    this._length = hash._length;\n  } else {\n    this.reset();\n  }\n};\n\n/**\n * Hash a string or an array of words.\n * @static\n * @param {bitArray|String} data the data to hash.\n * @return {bitArray} The hash value, an array of 16 big-endian words.\n */\nsjcl.hash.sha256.hash = function (data) {\n  return (new sjcl.hash.sha256()).update(data).finalize();\n};\n\nsjcl.hash.sha256.prototype = {\n  /**\n   * The hash's block size, in bits.\n   * @constant\n   */\n  blockSize: 512,\n   \n  /**\n   * Reset the hash state.\n   * @return this\n   */\n  reset:function () {\n    this._h = this._init.slice(0);\n    this._buffer = [];\n    this._length = 0;\n    return this;\n  },\n  \n  /**\n   * Input several words to the hash.\n   * @param {bitArray|String} data the data to hash.\n   * @return this\n   */\n  update: function (data) {\n    if (typeof data === \"string\") {\n      data = sjcl.codec.utf8String.toBits(data);\n    }\n    var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),\n        ol = this._length,\n        nl = this._length = ol + sjcl.bitArray.bitLength(data);\n    if (nl > 9007199254740991){\n      throw new sjcl.exception.invalid(\"Cannot hash more than 2^53 - 1 bits\");\n    }\n\n    if (typeof Uint32Array !== 'undefined') {\n\tvar c = new Uint32Array(b);\n    \tvar j = 0;\n    \tfor (i = 512+ol - ((512+ol) & 511); i <= nl; i+= 512) {\n      \t    this._block(c.subarray(16 * j, 16 * (j+1)));\n      \t    j += 1;\n    \t}\n    \tb.splice(0, 16 * j);\n    } else {\n\tfor (i = 512+ol - ((512+ol) & 511); i <= nl; i+= 512) {\n      \t    this._block(b.splice(0,16));\n      \t}\n    }\n    return this;\n  },\n  \n  /**\n   * Complete hashing and output the hash value.\n   * @return {bitArray} The hash value, an array of 8 big-endian words.\n   */\n  finalize:function () {\n    var i, b = this._buffer, h = this._h;\n\n    // Round out and push the buffer\n    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);\n    \n    // Round out the buffer to a multiple of 16 words, less the 2 length words.\n    for (i = b.length + 2; i & 15; i++) {\n      b.push(0);\n    }\n    \n    // append the length\n    b.push(Math.floor(this._length / 0x100000000));\n    b.push(this._length | 0);\n\n    while (b.length) {\n      this._block(b.splice(0,16));\n    }\n\n    this.reset();\n    return h;\n  },\n\n  /**\n   * The SHA-256 initialization vector, to be precomputed.\n   * @private\n   */\n  _init:[],\n  /*\n  _init:[0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19],\n  */\n  \n  /**\n   * The SHA-256 hash key, to be precomputed.\n   * @private\n   */\n  _key:[],\n  /*\n  _key:\n    [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n     0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n     0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n     0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n     0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n     0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n     0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n     0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2],\n  */\n\n\n  /**\n   * Function to precompute _init and _key.\n   * @private\n   */\n  _precompute: function () {\n    var i = 0, prime = 2, factor, isPrime;\n\n    function frac(x) { return (x-Math.floor(x)) * 0x100000000 | 0; }\n\n    for (; i<64; prime++) {\n      isPrime = true;\n      for (factor=2; factor*factor <= prime; factor++) {\n        if (prime % factor === 0) {\n          isPrime = false;\n          break;\n        }\n      }\n      if (isPrime) {\n        if (i<8) {\n          this._init[i] = frac(Math.pow(prime, 1/2));\n        }\n        this._key[i] = frac(Math.pow(prime, 1/3));\n        i++;\n      }\n    }\n  },\n  \n  /**\n   * Perform one cycle of SHA-256.\n   * @param {Uint32Array|bitArray} w one block of words.\n   * @private\n   */\n  _block:function (w) {  \n    var i, tmp, a, b,\n      h = this._h,\n      k = this._key,\n      h0 = h[0], h1 = h[1], h2 = h[2], h3 = h[3],\n      h4 = h[4], h5 = h[5], h6 = h[6], h7 = h[7];\n\n    /* Rationale for placement of |0 :\n     * If a value can overflow is original 32 bits by a factor of more than a few\n     * million (2^23 ish), there is a possibility that it might overflow the\n     * 53-bit mantissa and lose precision.\n     *\n     * To avoid this, we clamp back to 32 bits by |'ing with 0 on any value that\n     * propagates around the loop, and on the hash state h[].  I don't believe\n     * that the clamps on h4 and on h0 are strictly necessary, but it's close\n     * (for h4 anyway), and better safe than sorry.\n     *\n     * The clamps on h[] are necessary for the output to be correct even in the\n     * common case and for short inputs.\n     */\n    for (i=0; i<64; i++) {\n      // load up the input word for this round\n      if (i<16) {\n        tmp = w[i];\n      } else {\n        a   = w[(i+1 ) & 15];\n        b   = w[(i+14) & 15];\n        tmp = w[i&15] = ((a>>>7  ^ a>>>18 ^ a>>>3  ^ a<<25 ^ a<<14) + \n                         (b>>>17 ^ b>>>19 ^ b>>>10 ^ b<<15 ^ b<<13) +\n                         w[i&15] + w[(i+9) & 15]) | 0;\n      }\n      \n      tmp = (tmp + h7 + (h4>>>6 ^ h4>>>11 ^ h4>>>25 ^ h4<<26 ^ h4<<21 ^ h4<<7) +  (h6 ^ h4&(h5^h6)) + k[i]); // | 0;\n      \n      // shift register\n      h7 = h6; h6 = h5; h5 = h4;\n      h4 = h3 + tmp | 0;\n      h3 = h2; h2 = h1; h1 = h0;\n\n      h0 = (tmp +  ((h1&h2) ^ (h3&(h1^h2))) + (h1>>>2 ^ h1>>>13 ^ h1>>>22 ^ h1<<30 ^ h1<<19 ^ h1<<10)) | 0;\n    }\n\n    h[0] = h[0]+h0 | 0;\n    h[1] = h[1]+h1 | 0;\n    h[2] = h[2]+h2 | 0;\n    h[3] = h[3]+h3 | 0;\n    h[4] = h[4]+h4 | 0;\n    h[5] = h[5]+h5 | 0;\n    h[6] = h[6]+h6 | 0;\n    h[7] = h[7]+h7 | 0;\n  }\n};\n\n\n/** @fileOverview Javascript SHA-512 implementation.\n *\n * This implementation was written for CryptoJS by Jeff Mott and adapted for\n * SJCL by Stefan Thomas.\n *\n * CryptoJS (c) 2009–2012 by Jeff Mott. All rights reserved.\n * Released with New BSD License\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n * @author Jeff Mott\n * @author Stefan Thomas\n */\n\n/**\n * Context for a SHA-512 operation in progress.\n * @constructor\n */\nsjcl.hash.sha512 = function (hash) {\n  if (!this._key[0]) { this._precompute(); }\n  if (hash) {\n    this._h = hash._h.slice(0);\n    this._buffer = hash._buffer.slice(0);\n    this._length = hash._length;\n  } else {\n    this.reset();\n  }\n};\n\n/**\n * Hash a string or an array of words.\n * @static\n * @param {bitArray|String} data the data to hash.\n * @return {bitArray} The hash value, an array of 16 big-endian words.\n */\nsjcl.hash.sha512.hash = function (data) {\n  return (new sjcl.hash.sha512()).update(data).finalize();\n};\n\nsjcl.hash.sha512.prototype = {\n  /**\n   * The hash's block size, in bits.\n   * @constant\n   */\n  blockSize: 1024,\n   \n  /**\n   * Reset the hash state.\n   * @return this\n   */\n  reset:function () {\n    this._h = this._init.slice(0);\n    this._buffer = [];\n    this._length = 0;\n    return this;\n  },\n  \n  /**\n   * Input several words to the hash.\n   * @param {bitArray|String} data the data to hash.\n   * @return this\n   */\n  update: function (data) {\n    if (typeof data === \"string\") {\n      data = sjcl.codec.utf8String.toBits(data);\n    }\n    var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),\n        ol = this._length,\n        nl = this._length = ol + sjcl.bitArray.bitLength(data);\n    if (nl > 9007199254740991){\n      throw new sjcl.exception.invalid(\"Cannot hash more than 2^53 - 1 bits\");\n    }\n\n    if (typeof Uint32Array !== 'undefined') {\n        var c = new Uint32Array(b);\n        var j = 0;\n        for (i = 1024+ol - ((1024+ol) & 1023); i <= nl; i+= 1024) {\n            this._block(c.subarray(32 * j, 32 * (j+1)));\n            j += 1;\n        }\n        b.splice(0, 32 * j);\n    } else {\n        for (i = 1024+ol - ((1024+ol) & 1023); i <= nl; i+= 1024) {\n            this._block(b.splice(0,32));\n        }\n    }\n    return this;\n  },\n  \n  /**\n   * Complete hashing and output the hash value.\n   * @return {bitArray} The hash value, an array of 16 big-endian words.\n   */\n  finalize:function () {\n    var i, b = this._buffer, h = this._h;\n\n    // Round out and push the buffer\n    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);\n\n    // Round out the buffer to a multiple of 32 words, less the 4 length words.\n    for (i = b.length + 4; i & 31; i++) {\n      b.push(0);\n    }\n\n    // append the length\n    b.push(0);\n    b.push(0);\n    b.push(Math.floor(this._length / 0x100000000));\n    b.push(this._length | 0);\n\n    while (b.length) {\n      this._block(b.splice(0,32));\n    }\n\n    this.reset();\n    return h;\n  },\n\n  /**\n   * The SHA-512 initialization vector, to be precomputed.\n   * @private\n   */\n  _init:[],\n\n  /**\n   * Least significant 24 bits of SHA512 initialization values.\n   *\n   * Javascript only has 53 bits of precision, so we compute the 40 most\n   * significant bits and add the remaining 24 bits as constants.\n   *\n   * @private\n   */\n  _initr: [ 0xbcc908, 0xcaa73b, 0x94f82b, 0x1d36f1, 0xe682d1, 0x3e6c1f, 0x41bd6b, 0x7e2179 ],\n\n  /*\n  _init:\n  [0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n   0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179],\n  */\n\n  /**\n   * The SHA-512 hash key, to be precomputed.\n   * @private\n   */\n  _key:[],\n\n  /**\n   * Least significant 24 bits of SHA512 key values.\n   * @private\n   */\n  _keyr:\n  [0x28ae22, 0xef65cd, 0x4d3b2f, 0x89dbbc, 0x48b538, 0x05d019, 0x194f9b, 0x6d8118,\n   0x030242, 0x706fbe, 0xe4b28c, 0xffb4e2, 0x7b896f, 0x1696b1, 0xc71235, 0x692694,\n   0xf14ad2, 0x4f25e3, 0x8cd5b5, 0xac9c65, 0x2b0275, 0xa6e483, 0x41fbd4, 0x1153b5,\n   0x66dfab, 0xb43210, 0xfb213f, 0xef0ee4, 0xa88fc2, 0x0aa725, 0x03826f, 0x0e6e70,\n   0xd22ffc, 0x26c926, 0xc42aed, 0x95b3df, 0xaf63de, 0x77b2a8, 0xedaee6, 0x82353b,\n   0xf10364, 0x423001, 0xf89791, 0x54be30, 0xef5218, 0x65a910, 0x71202a, 0xbbd1b8,\n   0xd2d0c8, 0x41ab53, 0x8eeb99, 0x9b48a8, 0xc95a63, 0x418acb, 0x63e373, 0xb2b8a3,\n   0xefb2fc, 0x172f60, 0xf0ab72, 0x6439ec, 0x631e28, 0x82bde9, 0xc67915, 0x72532b,\n   0x26619c, 0xc0c207, 0xe0eb1e, 0x6ed178, 0x176fba, 0xc898a6, 0xf90dae, 0x1c471b,\n   0x047d84, 0xc72493, 0xc9bebc, 0x100d4c, 0x3e42b6, 0x657e2a, 0xd6faec, 0x475817],\n\n  /*\n  _key:\n  [0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,\n   0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,\n   0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,\n   0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,\n   0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,\n   0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,\n   0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,\n   0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,\n   0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,\n   0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,\n   0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,\n   0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,\n   0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,\n   0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,\n   0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,\n   0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,\n   0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,\n   0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,\n   0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,\n   0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817],\n  */\n\n  /**\n   * Function to precompute _init and _key.\n   * @private\n   */\n  _precompute: function () {\n    // XXX: This code is for precomputing the SHA256 constants, change for\n    //      SHA512 and re-enable.\n    var i = 0, prime = 2, factor , isPrime;\n\n    function frac(x)  { return (x-Math.floor(x)) * 0x100000000 | 0; }\n    function frac2(x) { return (x-Math.floor(x)) * 0x10000000000 & 0xff; }\n\n    for (; i<80; prime++) {\n      isPrime = true;\n      for (factor=2; factor*factor <= prime; factor++) {\n        if (prime % factor === 0) {\n          isPrime = false;\n          break;\n        }\n      }\n      if (isPrime) {\n        if (i<8) {\n          this._init[i*2] = frac(Math.pow(prime, 1/2));\n          this._init[i*2+1] = (frac2(Math.pow(prime, 1/2)) << 24) | this._initr[i];\n        }\n        this._key[i*2] = frac(Math.pow(prime, 1/3));\n        this._key[i*2+1] = (frac2(Math.pow(prime, 1/3)) << 24) | this._keyr[i];\n        i++;\n      }\n    }\n  },\n\n  /**\n   * Perform one cycle of SHA-512.\n   * @param {Uint32Array|bitArray} words one block of words.\n   * @private\n   */\n  _block:function (words) {\n    var i, wrh, wrl,\n        h = this._h,\n        k = this._key,\n        h0h = h[ 0], h0l = h[ 1], h1h = h[ 2], h1l = h[ 3],\n        h2h = h[ 4], h2l = h[ 5], h3h = h[ 6], h3l = h[ 7],\n        h4h = h[ 8], h4l = h[ 9], h5h = h[10], h5l = h[11],\n        h6h = h[12], h6l = h[13], h7h = h[14], h7l = h[15];\n    var w;\n    if (typeof Uint32Array !== 'undefined') {\n\t// When words is passed to _block, it has 32 elements. SHA512 _block\n\t// function extends words with new elements (at the end there are 160 elements). \n\t// The problem is that if we use Uint32Array instead of Array, \n\t// the length of Uint32Array cannot be changed. Thus, we replace words with a \n\t// normal Array here.\n        w = Array(160); // do not use Uint32Array here as the instantiation is slower\n        for (var j=0; j<32; j++){\n    \t    w[j] = words[j]; \n        }\n    } else {\n\tw = words;\n    } \n\n    // Working variables\n    var ah = h0h, al = h0l, bh = h1h, bl = h1l,\n        ch = h2h, cl = h2l, dh = h3h, dl = h3l,\n        eh = h4h, el = h4l, fh = h5h, fl = h5l,\n        gh = h6h, gl = h6l, hh = h7h, hl = h7l;\n\n    for (i=0; i<80; i++) {\n      // load up the input word for this round\n      if (i<16) {\n        wrh = w[i * 2];\n        wrl = w[i * 2 + 1];\n      } else {\n        // Gamma0\n        var gamma0xh = w[(i-15) * 2];\n        var gamma0xl = w[(i-15) * 2 + 1];\n        var gamma0h =\n          ((gamma0xl << 31) | (gamma0xh >>> 1)) ^\n          ((gamma0xl << 24) | (gamma0xh >>> 8)) ^\n           (gamma0xh >>> 7);\n        var gamma0l =\n          ((gamma0xh << 31) | (gamma0xl >>> 1)) ^\n          ((gamma0xh << 24) | (gamma0xl >>> 8)) ^\n          ((gamma0xh << 25) | (gamma0xl >>> 7));\n\n        // Gamma1\n        var gamma1xh = w[(i-2) * 2];\n        var gamma1xl = w[(i-2) * 2 + 1];\n        var gamma1h =\n          ((gamma1xl << 13) | (gamma1xh >>> 19)) ^\n          ((gamma1xh << 3)  | (gamma1xl >>> 29)) ^\n           (gamma1xh >>> 6);\n        var gamma1l =\n          ((gamma1xh << 13) | (gamma1xl >>> 19)) ^\n          ((gamma1xl << 3)  | (gamma1xh >>> 29)) ^\n          ((gamma1xh << 26) | (gamma1xl >>> 6));\n\n        // Shortcuts\n        var wr7h = w[(i-7) * 2];\n        var wr7l = w[(i-7) * 2 + 1];\n\n        var wr16h = w[(i-16) * 2];\n        var wr16l = w[(i-16) * 2 + 1];\n\n        // W(round) = gamma0 + W(round - 7) + gamma1 + W(round - 16)\n        wrl = gamma0l + wr7l;\n        wrh = gamma0h + wr7h + ((wrl >>> 0) < (gamma0l >>> 0) ? 1 : 0);\n        wrl += gamma1l;\n        wrh += gamma1h + ((wrl >>> 0) < (gamma1l >>> 0) ? 1 : 0);\n        wrl += wr16l;\n        wrh += wr16h + ((wrl >>> 0) < (wr16l >>> 0) ? 1 : 0);\n      }\n\n      w[i*2]     = wrh |= 0;\n      w[i*2 + 1] = wrl |= 0;\n\n      // Ch\n      var chh = (eh & fh) ^ (~eh & gh);\n      var chl = (el & fl) ^ (~el & gl);\n\n      // Maj\n      var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);\n      var majl = (al & bl) ^ (al & cl) ^ (bl & cl);\n\n      // Sigma0\n      var sigma0h = ((al << 4) | (ah >>> 28)) ^ ((ah << 30) | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));\n      var sigma0l = ((ah << 4) | (al >>> 28)) ^ ((al << 30) | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));\n\n      // Sigma1\n      var sigma1h = ((el << 18) | (eh >>> 14)) ^ ((el << 14) | (eh >>> 18)) ^ ((eh << 23) | (el >>> 9));\n      var sigma1l = ((eh << 18) | (el >>> 14)) ^ ((eh << 14) | (el >>> 18)) ^ ((el << 23) | (eh >>> 9));\n\n      // K(round)\n      var krh = k[i*2];\n      var krl = k[i*2+1];\n\n      // t1 = h + sigma1 + ch + K(round) + W(round)\n      var t1l = hl + sigma1l;\n      var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);\n      t1l += chl;\n      t1h += chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);\n      t1l += krl;\n      t1h += krh + ((t1l >>> 0) < (krl >>> 0) ? 1 : 0);\n      t1l = t1l + wrl|0;   // FF32..FF34 perf issue https://bugzilla.mozilla.org/show_bug.cgi?id=1054972\n      t1h += wrh + ((t1l >>> 0) < (wrl >>> 0) ? 1 : 0);\n\n      // t2 = sigma0 + maj\n      var t2l = sigma0l + majl;\n      var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);\n\n      // Update working variables\n      hh = gh;\n      hl = gl;\n      gh = fh;\n      gl = fl;\n      fh = eh;\n      fl = el;\n      el = (dl + t1l) | 0;\n      eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;\n      dh = ch;\n      dl = cl;\n      ch = bh;\n      cl = bl;\n      bh = ah;\n      bl = al;\n      al = (t1l + t2l) | 0;\n      ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;\n    }\n\n    // Intermediate hash\n    h0l = h[1] = (h0l + al) | 0;\n    h[0] = (h0h + ah + ((h0l >>> 0) < (al >>> 0) ? 1 : 0)) | 0;\n    h1l = h[3] = (h1l + bl) | 0;\n    h[2] = (h1h + bh + ((h1l >>> 0) < (bl >>> 0) ? 1 : 0)) | 0;\n    h2l = h[5] = (h2l + cl) | 0;\n    h[4] = (h2h + ch + ((h2l >>> 0) < (cl >>> 0) ? 1 : 0)) | 0;\n    h3l = h[7] = (h3l + dl) | 0;\n    h[6] = (h3h + dh + ((h3l >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;\n    h4l = h[9] = (h4l + el) | 0;\n    h[8] = (h4h + eh + ((h4l >>> 0) < (el >>> 0) ? 1 : 0)) | 0;\n    h5l = h[11] = (h5l + fl) | 0;\n    h[10] = (h5h + fh + ((h5l >>> 0) < (fl >>> 0) ? 1 : 0)) | 0;\n    h6l = h[13] = (h6l + gl) | 0;\n    h[12] = (h6h + gh + ((h6l >>> 0) < (gl >>> 0) ? 1 : 0)) | 0;\n    h7l = h[15] = (h7l + hl) | 0;\n    h[14] = (h7h + hh + ((h7l >>> 0) < (hl >>> 0) ? 1 : 0)) | 0;\n  }\n};\n\n\n/** @fileOverview HMAC implementation.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** HMAC with the specified hash function.\n * @constructor\n * @param {bitArray} key the key for HMAC.\n * @param {Object} [Hash=sjcl.hash.sha256] The hash function to use.\n */\nsjcl.misc.hmac = function (key, Hash) {\n  this._hash = Hash = Hash || sjcl.hash.sha256;\n  var exKey = [[],[]], i,\n      bs = Hash.prototype.blockSize / 32;\n  this._baseHash = [new Hash(), new Hash()];\n\n  if (key.length > bs) {\n    key = Hash.hash(key);\n  }\n  \n  for (i=0; i<bs; i++) {\n    exKey[0][i] = key[i]^0x36363636;\n    exKey[1][i] = key[i]^0x5C5C5C5C;\n  }\n  \n  this._baseHash[0].update(exKey[0]);\n  this._baseHash[1].update(exKey[1]);\n  this._resultHash = new Hash(this._baseHash[0]);\n};\n\n/** HMAC with the specified hash function.  Also called encrypt since it's a prf.\n * @param {bitArray|String} data The data to mac.\n */\nsjcl.misc.hmac.prototype.encrypt = sjcl.misc.hmac.prototype.mac = function (data) {\n  if (!this._updated) {\n    this.update(data);\n    return this.digest(data);\n  } else {\n    throw new sjcl.exception.invalid(\"encrypt on already updated hmac called!\");\n  }\n};\n\nsjcl.misc.hmac.prototype.reset = function () {\n  this._resultHash = new this._hash(this._baseHash[0]);\n  this._updated = false;\n};\n\nsjcl.misc.hmac.prototype.update = function (data) {\n  this._updated = true;\n  this._resultHash.update(data);\n};\n\nsjcl.misc.hmac.prototype.digest = function () {\n  var w = this._resultHash.finalize(), result = new (this._hash)(this._baseHash[1]).update(w).finalize();\n\n  this.reset();\n\n  return result;\n};\n\n\t\t\t\t\t;/* harmony default export */ __webpack_exports__[\"a\"] = (sjcl);\n\t\t\t\t\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Crypto; });\n/* harmony import */ var sjcl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);\n// eslint-disable-next-line import/no-extraneous-dependencies\n // SJCL is included during compilation.\n\n\n\n/**\n * Node.js Crypto module.\n * @private\n * @type {Object}\n */\nconst NodeCrypto = _utils__WEBPACK_IMPORTED_MODULE_1__[/* InternalUtils */ \"a\"].require('crypto');\n\n/**\n * An object containing some cryptography functions\n * with dirty workarounds for Node.js and browsers.\n * @private\n * @type {Object}\n */\nconst Crypto = {};\n\nif (NodeCrypto) {\n\tlet bufferFrom;\n\n\tif (typeof Buffer.from === 'function') {\n\t\tbufferFrom = Buffer.from;\n\t} else {\n\t\t// Node.js < 5.10.0\n\t\tbufferFrom = arrbuf => {\n\t\t\t// eslint-disable-next-line no-buffer-constructor\n\t\t\tconst nodeBuf = new Buffer(arrbuf.byteLength);\n\t\t\tconst arr = new Uint8Array(arrbuf);\n\n\t\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\t\tnodeBuf[i] = arr[i];\n\t\t\t}\n\n\t\t\treturn nodeBuf;\n\t\t};\n\t}\n\n\tlet bufferTo;\n\n\tif (Buffer.prototype instanceof Uint8Array) {\n\t\tbufferTo = nodeBuf => nodeBuf;\n\t} else {\n\t\t// Node.js < 4.0.0\n\t\tbufferTo = nodeBuf => {\n\t\t\tconst arr = new Uint8Array(nodeBuf.length);\n\n\t\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\t\tarr[i] = nodeBuf[i];\n\t\t\t}\n\n\t\t\treturn arr;\n\t\t};\n\t}\n\n\tCrypto.randomBytes = size => {\n\t\tconst buff = NodeCrypto.randomBytes(size);\n\t\treturn bufferTo(buff);\n\t};\n\n\t// In Node.js, the command:\n\t// $ openssl list -digest-algorithms\n\t// displays the available digest algorithms.\n\tCrypto.hmacDigest = (algorithm, key, message) => {\n\t\tconst buff = NodeCrypto.createHmac(algorithm, bufferFrom(key));\n\t\treturn bufferTo(buff).update(bufferFrom(message)).digest();\n\t};\n} else {\n\tlet getRandomValues;\n\n\tif (typeof global.crypto !== 'undefined' && typeof global.crypto.getRandomValues === 'function') {\n\t\tgetRandomValues = arr => {\n\t\t\tglobal.crypto.getRandomValues(arr);\n\t\t};\n\t} else if (typeof global.msCrypto !== 'undefined' && typeof global.msCrypto.getRandomValues === 'function') {\n\t\tgetRandomValues = arr => {\n\t\t\tglobal.msCrypto.getRandomValues(arr);\n\t\t};\n\t} else {\n\t\tconsole.warn('Cryptography API not available, falling back to \\'Math.random\\'...');\n\t\tgetRandomValues = arr => {\n\t\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\t\tarr[i] = Math.floor(Math.random() * 256);\n\t\t\t}\n\t\t};\n\t}\n\n\tCrypto.randomBytes = size => {\n\t\tconst arr = new Uint8Array(size);\n\t\tgetRandomValues(arr);\n\t\treturn arr;\n\t};\n\n\tCrypto.hmacDigest = (algorithm, key, message) => {\n\t\tconst hash = sjcl__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].hash[algorithm.toLowerCase()];\n\t\tif (typeof hash === 'undefined') {\n\t\t\tthrow new TypeError('Unknown hash function');\n\t\t}\n\n\t\t// eslint-disable-next-line new-cap\n\t\tconst hmac = new sjcl__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].misc.hmac(sjcl__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].codec.arrayBuffer.toBits(key), hash);\n\t\thmac.update(sjcl__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].codec.arrayBuffer.toBits(message));\n\n\t\treturn sjcl__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].codec.arrayBuffer.fromBits(hmac.digest(), false);\n\t};\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(3)))\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nvar g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./src/utils.js\nvar utils = __webpack_require__(0);\n\n// EXTERNAL MODULE: ./src/crypto.js\nvar src_crypto = __webpack_require__(2);\n\n// CONCATENATED MODULE: ./src/secret.js\n\n\n\n/**\n * Secret key object.\n */\nclass secret_Secret {\n\t/**\n\t * @param {Object} [config] Configuration options.\n\t * @param {ArrayBuffer} [config.buffer=Crypto.randomBytes] Secret key.\n\t * @param {number} [config.size=20] Number of random bytes to generate, ignored if 'buffer' is provided.\n\t */\n\tconstructor({ buffer, size = 20 } = {}) {\n\t\t/**\n\t\t * Secret key.\n\t\t * @type {ArrayBuffer}\n\t\t */\n\t\tthis.buffer = typeof buffer === 'undefined'\n\t\t\t? src_crypto[\"a\" /* Crypto */].randomBytes(size).buffer\n\t\t\t: buffer;\n\t}\n\n\t/**\n\t * Converts a raw string to a Secret object.\n\t * @method fromRaw\n\t * @param {string} str Raw string.\n\t * @returns {Secret} Secret object.\n\t */\n\tstatic fromRaw(str) {\n\t\treturn new this({ buffer: utils[\"b\" /* Utils */].raw.encode(str) });\n\t}\n\n\t/**\n\t * Converts a base32 string to a Secret object.\n\t * @method fromB32\n\t * @param {string} str Base32 string.\n\t * @returns {Secret} Secret object.\n\t */\n\tstatic fromB32(str) {\n\t\treturn new this({ buffer: utils[\"b\" /* Utils */].b32.encode(str) });\n\t}\n\n\t/**\n\t * Converts a hexadecimal string to a Secret object.\n\t * @method fromHex\n\t * @param {string} str Hexadecimal string.\n\t * @returns {Secret} Secret object.\n\t */\n\tstatic fromHex(str) {\n\t\treturn new this({ buffer: utils[\"b\" /* Utils */].hex.encode(str) });\n\t}\n\n\t/**\n\t * String representation of secret key.\n\t * @type {string}\n\t */\n\tget raw() {\n\t\tObject.defineProperty(this, 'raw', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\twritable: true,\n\t\t\tvalue: utils[\"b\" /* Utils */].raw.decode(this.buffer)\n\t\t});\n\n\t\treturn this.raw;\n\t}\n\n\t/**\n\t * Base32 representation of secret key.\n\t * @type {string}\n\t */\n\tget b32() {\n\t\tObject.defineProperty(this, 'b32', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\twritable: true,\n\t\t\tvalue: utils[\"b\" /* Utils */].b32.decode(this.buffer)\n\t\t});\n\n\t\treturn this.b32;\n\t}\n\n\t/**\n\t * Hexadecimal representation of secret key.\n\t * @type {string}\n\t */\n\tget hex() {\n\t\tObject.defineProperty(this, 'hex', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\twritable: true,\n\t\t\tvalue: utils[\"b\" /* Utils */].hex.decode(this.buffer)\n\t\t});\n\n\t\treturn this.hex;\n\t}\n}\n\n// CONCATENATED MODULE: ./src/uri.js\n\n\n// eslint-disable-next-line import/no-cycle\n\n\n/**\n * Valid key URI parameters.\n * @private\n * @type {Array}\n */\nconst OTPURI_PARAMS = ['issuer', 'secret', 'algorithm', 'digits', 'counter', 'period'];\n\n/**\n * Key URI regex.\n *   otpauth://TYPE/[ISSUER:]LABEL?PARAMETERS\n * @private\n * @type {RegExp}\n */\nconst OTPURI_REGEX = new RegExp(`^otpauth:\\\\/\\\\/([ht]otp)\\\\/(.+)\\\\?((?:&?(?:${OTPURI_PARAMS.join('|')})=[^&]+)+)$`, 'i');\n\n/**\n * RFC 4648 base32 alphabet without pad.\n * @private\n * @type {string}\n */\nconst SECRET_REGEX = /^[2-7A-Z]+$/i;\n\n/**\n * Regex for supported algorithms.\n * @private\n * @type {RegExp}\n */\nconst ALGORITHM_REGEX = /^SHA(?:1|256|512)$/i;\n\n/**\n * Integer regex.\n * @private\n * @type {RegExp}\n */\nconst INTEGER_REGEX = /^[+-]?\\d+$/;\n\n/**\n * Positive integer regex.\n * @private\n * @type {RegExp}\n */\nconst POSITIVE_INTEGER_REGEX = /^\\+?[1-9]\\d*$/;\n\n/**\n * HOTP/TOTP object/string conversion.\n * @see https://github.com/google/google-authenticator/wiki/Key-Uri-Format\n */\nclass uri_URI {\n\t/**\n\t * Parses a Google Authenticator key URI and returns an HOTP/TOTP object.\n\t * @method parse\n\t * @param {string} uri Google Authenticator Key URI.\n\t * @returns {Object} HOTP/TOTP object.\n\t */\n\tstatic parse(uri) {\n\t\tlet uriGroups;\n\n\t\ttry {\n\t\t\turiGroups = uri.match(OTPURI_REGEX);\n\t\t} catch (error) { /* Handled below */ }\n\n\t\tif (!Array.isArray(uriGroups)) {\n\t\t\tthrow new URIError('Invalid URI format');\n\t\t}\n\n\t\t// Extract URI groups.\n\t\tconst uriType = uriGroups[1].toLowerCase();\n\t\tconst uriLabel = uriGroups[2].split(/:(.+)/, 2).map(decodeURIComponent);\n\t\tconst uriParams = uriGroups[3].split('&').reduce((acc, cur) => {\n\t\t\tconst pairArr = cur.split(/=(.+)/, 2).map(decodeURIComponent);\n\t\t\tconst pairKey = pairArr[0].toLowerCase();\n\t\t\tconst pairVal = pairArr[1];\n\t\t\tconst pairAcc = acc;\n\n\t\t\tpairAcc[pairKey] = pairVal;\n\t\t\treturn pairAcc;\n\t\t}, {});\n\n\t\t// 'OTP' will be instantiated with 'config' argument\n\t\tlet OTP;\n\t\tconst config = {};\n\n\t\tif (uriType === 'hotp') {\n\t\t\tOTP = otp_HOTP;\n\n\t\t\t// Counter: required\n\t\t\tif (typeof uriParams.counter !== 'undefined' && INTEGER_REGEX.test(uriParams.counter)) {\n\t\t\t\tconfig.counter = Number.parseInt(uriParams.counter, 10);\n\t\t\t} else {\n\t\t\t\tthrow new TypeError('Missing or invalid \\'counter\\' parameter');\n\t\t\t}\n\t\t} else if (uriType === 'totp') {\n\t\t\tOTP = otp_TOTP;\n\n\t\t\t// Period: optional\n\t\t\tif (typeof uriParams.period !== 'undefined') {\n\t\t\t\tif (POSITIVE_INTEGER_REGEX.test(uriParams.period)) {\n\t\t\t\t\tconfig.period = Number.parseInt(uriParams.period, 10);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new TypeError('Invalid \\'period\\' parameter');\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new TypeError('Unknown OTP type');\n\t\t}\n\n\t\t// Label: required\n\t\t// Issuer: optional\n\t\tif (uriLabel.length === 2) {\n\t\t\tconfig.label = uriLabel[1];\n\t\t\tif (typeof uriParams.issuer === 'undefined') {\n\t\t\t\tconfig.issuer = uriLabel[0];\n\t\t\t} else if (uriParams.issuer === uriLabel[0]) {\n\t\t\t\tconfig.issuer = uriParams.issuer;\n\t\t\t} else {\n\t\t\t\tthrow new TypeError('Invalid \\'issuer\\' parameter');\n\t\t\t}\n\t\t} else {\n\t\t\tconfig.label = uriLabel[0];\n\t\t\tif (typeof uriParams.issuer !== 'undefined') {\n\t\t\t\tconfig.issuer = uriParams.issuer;\n\t\t\t}\n\t\t}\n\n\t\t// Secret: required\n\t\tif (typeof uriParams.secret !== 'undefined' && SECRET_REGEX.test(uriParams.secret)) {\n\t\t\tconfig.secret = new secret_Secret({ buffer: utils[\"b\" /* Utils */].b32.encode(uriParams.secret) });\n\t\t} else {\n\t\t\tthrow new TypeError('Missing or invalid \\'secret\\' parameter');\n\t\t}\n\n\t\t// Algorithm: optional\n\t\tif (typeof uriParams.algorithm !== 'undefined') {\n\t\t\tif (ALGORITHM_REGEX.test(uriParams.algorithm)) {\n\t\t\t\tconfig.algorithm = uriParams.algorithm;\n\t\t\t} else {\n\t\t\t\tthrow new TypeError('Invalid \\'algorithm\\' parameter');\n\t\t\t}\n\t\t}\n\n\t\t// Digits: optional\n\t\tif (typeof uriParams.digits !== 'undefined') {\n\t\t\tif (POSITIVE_INTEGER_REGEX.test(uriParams.digits)) {\n\t\t\t\tconfig.digits = Number.parseInt(uriParams.digits, 10);\n\t\t\t} else {\n\t\t\t\tthrow new TypeError('Invalid \\'digits\\' parameter');\n\t\t\t}\n\t\t}\n\n\t\treturn new OTP(config);\n\t}\n\n\t/**\n\t * Converts an HOTP/TOTP object to a Google Authenticator key URI.\n\t * @method stringify\n\t * @param {Object} otp HOTP/TOTP object.\n\t * @param {Object} [config] Configuration options.\n\t * @param {boolean} [config.legacyIssuer=true] Set issuer label prefix.\n\t * @returns {string} Google Authenticator Key URI.\n\t */\n\tstatic stringify(otp, { legacyIssuer = true } = {}) {\n\t\tconst isHOTP = otp instanceof otp_HOTP;\n\t\tconst isTOTP = otp instanceof otp_TOTP;\n\n\t\tif (!isHOTP && !isTOTP) {\n\t\t\tthrow new TypeError('Invalid \\'HOTP/TOTP\\' object');\n\t\t}\n\n\t\t// Key URI format:\n\t\t// otpauth://TYPE/[ISSUER:]LABEL?PARAMETERS\n\t\tlet uri = 'otpauth://';\n\n\t\t// Type\n\t\turi += `${isTOTP ? 'totp' : 'hotp'}/`;\n\n\t\t// Label and optional issuer\n\t\tif (otp.issuer.length > 0) {\n\t\t\t// Legacy label prefix\n\t\t\tif (legacyIssuer) uri += `${encodeURIComponent(otp.issuer)}:`;\n\t\t\t// Label\n\t\t\turi += `${encodeURIComponent(otp.label)}?`;\n\t\t\t// Issuer\n\t\t\turi += `issuer=${encodeURIComponent(otp.issuer)}&`;\n\t\t} else {\n\t\t\t// Label\n\t\t\turi += `${encodeURIComponent(otp.label)}?`;\n\t\t}\n\n\t\t// Generic parameters\n\t\turi += `secret=${encodeURIComponent(otp.secret.b32)}`\n\t\t\t+ `&algorithm=${encodeURIComponent(otp.algorithm)}`\n\t\t\t+ `&digits=${encodeURIComponent(otp.digits)}`;\n\n\t\t// Extra parameters\n\t\tif (isTOTP) {\n\t\t\t// TOTP parameters\n\t\t\turi += `&period=${encodeURIComponent(otp.period)}`;\n\t\t} else {\n\t\t\t// HOTP parameters\n\t\t\turi += `&counter=${encodeURIComponent(otp.counter)}`;\n\t\t}\n\n\t\treturn uri;\n\t}\n}\n\n// CONCATENATED MODULE: ./src/otp.js\n\n\n\n// eslint-disable-next-line import/no-cycle\n\n\n/**\n * Default configuration.\n * @private\n * @type {Object}\n */\nconst defaults = {\n\tissuer: '',\n\tlabel: 'OTPAuth',\n\talgorithm: 'SHA1',\n\tdigits: 6,\n\tcounter: 0,\n\tperiod: 30,\n\twindow: 50,\n\tpad: true\n};\n\n/**\n * HOTP: An HMAC-based One-time Password Algorithm (RFC 4226).\n * @see https://tools.ietf.org/html/rfc4226\n */\nclass otp_HOTP {\n\t/**\n\t * @param {Object} [config] Configuration options.\n\t * @param {string} [config.issuer=''] Account provider.\n\t * @param {string} [config.label='OTPAuth'] Account label.\n\t * @param {Secret} [config.secret=Secret] Secret key.\n\t * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n\t * @param {number} [config.digits=6] Token length.\n\t * @param {number} [config.counter=0] Initial counter value.\n\t */\n\tconstructor({\n\t\tissuer = defaults.issuer,\n\t\tlabel = defaults.label,\n\t\tsecret = new secret_Secret(),\n\t\talgorithm = defaults.algorithm,\n\t\tdigits = defaults.digits,\n\t\tcounter = defaults.counter\n\t} = {}) {\n\t\t/**\n\t\t * Account provider.\n\t\t * @type {string}\n\t\t */\n\t\tthis.issuer = issuer;\n\t\t/**\n\t\t * Account label.\n\t\t * @type {string}\n\t\t */\n\t\tthis.label = label;\n\t\t/**\n\t\t * Secret key.\n\t\t * @type {Secret}\n\t\t */\n\t\tthis.secret = secret;\n\t\t/**\n\t\t * HMAC hashing algorithm.\n\t\t * @type {string}\n\t\t */\n\t\tthis.algorithm = algorithm;\n\t\t/**\n\t\t * Token length.\n\t\t * @type {number}\n\t\t */\n\t\tthis.digits = digits;\n\t\t/**\n\t\t * Initial counter value.\n\t\t * @type {number}\n\t\t */\n\t\tthis.counter = counter;\n\t}\n\n\t/**\n\t * Generates an HOTP token.\n\t * @param {Object} config Configuration options.\n\t * @param {Secret} config.secret Secret key.\n\t * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n\t * @param {number} [config.digits=6] Token length.\n\t * @param {number} [config.counter=0] Counter value.\n\t * @param {boolean} [config.pad=true] Add leading zeros to result.\n\t * @returns {string|number} Token.\n\t */\n\tstatic generate({\n\t\tsecret,\n\t\talgorithm = defaults.algorithm,\n\t\tdigits = defaults.digits,\n\t\tcounter = defaults.counter,\n\t\tpad = defaults.pad\n\t}) {\n\t\tconst digest = new Uint8Array(src_crypto[\"a\" /* Crypto */].hmacDigest(algorithm, secret.buffer, utils[\"b\" /* Utils */].uint.encode(counter)));\n\t\tconst offset = digest[digest.byteLength - 1] & 15;\n\t\tconst otp = (\n\t\t\t((digest[offset] & 127) << 24)\n\t\t\t| ((digest[offset + 1] & 255) << 16)\n\t\t\t| ((digest[offset + 2] & 255) << 8)\n\t\t\t| (digest[offset + 3] & 255)\n\t\t) % (10 ** digits);\n\n\t\treturn pad\n\t\t\t? new Array(1 + digits - String(otp).length).join('0') + otp\n\t\t\t: otp;\n\t}\n\n\t/**\n\t * Generates an HOTP token.\n\t * @param {Object} [config] Configuration options.\n\t * @param {number} [config.counter=this.counter++] Counter value.\n\t * @param {boolean} [config.pad=true] Add leading zeros to result.\n\t * @returns {string|number} Token.\n\t */\n\tgenerate({\n\t\tcounter = this.counter++,\n\t\tpad\n\t} = {}) {\n\t\treturn otp_HOTP.generate({\n\t\t\tsecret: this.secret,\n\t\t\talgorithm: this.algorithm,\n\t\t\tdigits: this.digits,\n\t\t\tcounter,\n\t\t\tpad\n\t\t});\n\t}\n\n\t/**\n\t * Validates an HOTP token.\n\t * @param {Object} config Configuration options.\n\t * @param {string} config.token Token value.\n\t * @param {Secret} config.secret Secret key.\n\t * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n\t * @param {number} [config.counter=0] Counter value.\n\t * @param {number} [config.window=50] Window of counter values to test.\n\t * @returns {number|null} Token delta, or null if the token is not found.\n\t */\n\tstatic validate({\n\t\ttoken,\n\t\tsecret,\n\t\talgorithm,\n\t\tcounter = defaults.counter,\n\t\twindow = defaults.window\n\t}) {\n\t\tconst searchToken = Number.parseInt(token, 10);\n\n\t\tfor (let i = counter - window; i <= counter + window; ++i) {\n\t\t\tconst generatedToken = otp_HOTP.generate({\n\t\t\t\tsecret,\n\t\t\t\talgorithm,\n\t\t\t\tcounter: i,\n\t\t\t\tdigits: token.length,\n\t\t\t\tpad: false\n\t\t\t});\n\n\t\t\tif (searchToken === generatedToken) {\n\t\t\t\treturn i - counter;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Validates an HOTP token.\n\t * @param {Object} config Configuration options.\n\t * @param {string} config.token Token value.\n\t * @param {number} [config.counter=this.counter] Counter value.\n\t * @param {number} [config.window=50] Window of counter values to test.\n\t * @returns {number|null} Token delta, or null if the token is not found.\n\t */\n\tvalidate({\n\t\ttoken,\n\t\tcounter = this.counter,\n\t\twindow\n\t}) {\n\t\treturn otp_HOTP.validate({\n\t\t\ttoken,\n\t\t\tsecret: this.secret,\n\t\t\talgorithm: this.algorithm,\n\t\t\tcounter,\n\t\t\twindow\n\t\t});\n\t}\n\n\t/**\n\t * Returns a Google Authenticator key URI.\n\t * @returns {string} URI.\n\t */\n\ttoString() {\n\t\treturn uri_URI.stringify(this);\n\t}\n}\n\n/**\n * TOTP: Time-Based One-Time Password Algorithm (RFC 6238).\n * @see https://tools.ietf.org/html/rfc6238\n */\nclass otp_TOTP {\n\t/**\n\t * @param {Object} [config] Configuration options.\n\t * @param {string} [config.issuer=''] Account provider.\n\t * @param {string} [config.label='OTPAuth'] Account label.\n\t * @param {Secret} [config.secret=Secret] Secret key.\n\t * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n\t * @param {number} [config.digits=6] Token length.\n\t * @param {number} [config.period=30] Token time-step duration.\n\t */\n\tconstructor({\n\t\tissuer = defaults.issuer,\n\t\tlabel = defaults.label,\n\t\tsecret = new secret_Secret(),\n\t\talgorithm = defaults.algorithm,\n\t\tdigits = defaults.digits,\n\t\tperiod = defaults.period\n\t} = {}) {\n\t\t/**\n\t\t * Account provider.\n\t\t * @type {string}\n\t\t */\n\t\tthis.issuer = issuer;\n\t\t/**\n\t\t * Account label.\n\t\t * @type {string}\n\t\t */\n\t\tthis.label = label;\n\t\t/**\n\t\t * Secret key.\n\t\t * @type {string}\n\t\t */\n\t\tthis.secret = secret;\n\t\t/**\n\t\t * HMAC hashing algorithm.\n\t\t * @type {Secret}\n\t\t */\n\t\tthis.algorithm = algorithm;\n\t\t/**\n\t\t * Token length.\n\t\t * @type {number}\n\t\t */\n\t\tthis.digits = digits;\n\t\t/**\n\t\t * Token time-step duration.\n\t\t * @type {number}\n\t\t */\n\t\tthis.period = period;\n\t}\n\n\t/**\n\t * Generates a TOTP token.\n\t * @param {Object} config Configuration options.\n\t * @param {Secret} config.secret Secret key.\n\t * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n\t * @param {number} [config.digits=6] Token length.\n\t * @param {number} [config.period=30] Token time-step duration.\n\t * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n\t * @param {boolean} [config.pad=true] Add leading zeros to result.\n\t * @returns {string|number} Token.\n\t */\n\tstatic generate({\n\t\tsecret,\n\t\talgorithm,\n\t\tdigits,\n\t\tperiod = defaults.period,\n\t\ttimestamp = Date.now(),\n\t\tpad\n\t}) {\n\t\treturn otp_HOTP.generate({\n\t\t\tsecret,\n\t\t\talgorithm,\n\t\t\tdigits,\n\t\t\tcounter: Math.floor(timestamp / 1000 / period),\n\t\t\tpad\n\t\t});\n\t}\n\n\t/**\n\t * Generates a TOTP token.\n\t * @param {Object} [config] Configuration options.\n\t * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n\t * @param {boolean} [config.pad=true] Add leading zeros to result.\n\t * @returns {string|number} Token.\n\t */\n\tgenerate({\n\t\ttimestamp = Date.now(),\n\t\tpad\n\t} = {}) {\n\t\treturn otp_TOTP.generate({\n\t\t\tsecret: this.secret,\n\t\t\talgorithm: this.algorithm,\n\t\t\tdigits: this.digits,\n\t\t\tperiod: this.period,\n\t\t\ttimestamp,\n\t\t\tpad\n\t\t});\n\t}\n\n\t/**\n\t * Validates a TOTP token.\n\t * @param {Object} config Configuration options.\n\t * @param {string} config.token Token value.\n\t * @param {Secret} config.secret Secret key.\n\t * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n\t * @param {number} [config.period=30] Token time-step duration.\n\t * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n\t * @param {number} [config.window=50] Window of counter values to test.\n\t * @returns {number|null} Token delta, or null if the token is not found.\n\t */\n\tstatic validate({\n\t\ttoken,\n\t\tsecret,\n\t\talgorithm,\n\t\tperiod = defaults.period,\n\t\ttimestamp = Date.now(),\n\t\twindow\n\t}) {\n\t\treturn otp_HOTP.validate({\n\t\t\ttoken,\n\t\t\tsecret,\n\t\t\talgorithm,\n\t\t\tcounter: Math.floor(timestamp / 1000 / period),\n\t\t\twindow\n\t\t});\n\t}\n\n\t/**\n\t * Validates a TOTP token.\n\t * @param {Object} config Configuration options.\n\t * @param {string} config.token Token value.\n\t * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n\t * @param {number} [config.window=50] Window of counter values to test.\n\t * @returns {number|null} Token delta, or null if the token is not found.\n\t */\n\tvalidate({\n\t\ttoken,\n\t\ttimestamp,\n\t\twindow\n\t}) {\n\t\treturn otp_TOTP.validate({\n\t\t\ttoken,\n\t\t\tsecret: this.secret,\n\t\t\talgorithm: this.algorithm,\n\t\t\tperiod: this.period,\n\t\t\ttimestamp,\n\t\t\twindow\n\t\t});\n\t}\n\n\t/**\n\t * Returns a Google Authenticator key URI.\n\t * @returns {string} URI.\n\t */\n\ttoString() {\n\t\treturn uri_URI.stringify(this);\n\t}\n}\n\n// CONCATENATED MODULE: ./src/main.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"version\", function() { return version; });\n/* concated harmony reexport HOTP */__webpack_require__.d(__webpack_exports__, \"HOTP\", function() { return otp_HOTP; });\n/* concated harmony reexport TOTP */__webpack_require__.d(__webpack_exports__, \"TOTP\", function() { return otp_TOTP; });\n/* concated harmony reexport URI */__webpack_require__.d(__webpack_exports__, \"URI\", function() { return uri_URI; });\n/* concated harmony reexport Secret */__webpack_require__.d(__webpack_exports__, \"Secret\", function() { return secret_Secret; });\n/* concated harmony reexport Utils */__webpack_require__.d(__webpack_exports__, \"Utils\", function() { return utils[\"b\" /* Utils */]; });\n/**\n * One Time Password (HOTP/TOTP) library for Node.js and browser.\n * @module OTPAuth\n * @author Héctor Molinero Fernández <hector@molinero.dev>\n */\n\n\n\n\n\n/**\n * Library version.\n * @type {string}\n */\nconst version = \"3.2.7\";\n\n\n/***/ })\n/******/ ]);\n});"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","/**\n * An object containing some utilities.\n * @type {Object}\n */\nexport const Utils = {};\n\n/**\n * UInt conversion.\n * @type {Object}\n */\nUtils.uint = {};\n\n/**\n * Converts an ArrayBuffer to an integer.\n * @param {ArrayBuffer} buf ArrayBuffer.\n * @returns {number} Integer.\n */\nUtils.uint.decode = buf => {\n\tconst arr = new Uint8Array(buf);\n\tlet num = 0;\n\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tif (arr[i] !== 0) {\n\t\t\tnum *= 256;\n\t\t\tnum += arr[i];\n\t\t}\n\t}\n\n\treturn num;\n};\n\n/**\n * Converts an integer to an ArrayBuffer.\n * @param {number} num Integer.\n * @returns {ArrayBuffer} ArrayBuffer.\n */\nUtils.uint.encode = num => {\n\tconst buf = new ArrayBuffer(8);\n\tconst arr = new Uint8Array(buf);\n\tlet acc = num;\n\n\tfor (let i = 7; i >= 0; i--) {\n\t\tif (acc === 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tarr[i] = acc & 255;\n\t\tacc -= arr[i];\n\t\tacc /= 256;\n\t}\n\n\treturn buf;\n};\n\n/**\n * Raw string conversion.\n * @type {Object}\n */\nUtils.raw = {};\n\n/**\n * Converts an ArrayBuffer to a string.\n * @param {ArrayBuffer} buf ArrayBuffer.\n * @returns {string} String.\n */\nUtils.raw.decode = buf => {\n\tconst arr = new Uint8Array(buf);\n\tlet str = '';\n\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tstr += String.fromCharCode(arr[i]);\n\t}\n\n\treturn str;\n};\n\n/**\n * Converts a string to an ArrayBuffer.\n * @param {string} str String.\n * @returns {ArrayBuffer} ArrayBuffer.\n */\nUtils.raw.encode = str => {\n\tconst buf = new ArrayBuffer(str.length);\n\tconst arr = new Uint8Array(buf);\n\n\tfor (let i = 0; i < str.length; i++) {\n\t\tarr[i] = str.charCodeAt(i);\n\t}\n\n\treturn buf;\n};\n\n/**\n * Base32 string conversion.\n * @type {Object}\n */\nUtils.b32 = {};\n\n/**\n * RFC 4648 base32 alphabet without pad.\n * @type {string}\n */\nUtils.b32.alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';\n\n/**\n * Converts an ArrayBuffer to a base32 string (RFC 4648).\n * @see https://github.com/LinusU/base32-decode\n * @param {ArrayBuffer} buf ArrayBuffer.\n * @returns {string} Base32 string.\n */\nUtils.b32.decode = buf => {\n\tconst arr = new Uint8Array(buf);\n\n\tlet bits = 0;\n\tlet value = 0;\n\tlet str = '';\n\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tvalue = (value << 8) | arr[i];\n\t\tbits += 8;\n\n\t\twhile (bits >= 5) {\n\t\t\tstr += Utils.b32.alphabet[(value >>> bits - 5) & 31];\n\t\t\tbits -= 5;\n\t\t}\n\t}\n\n\tif (bits > 0) {\n\t\tstr += Utils.b32.alphabet[(value << 5 - bits) & 31];\n\t}\n\n\treturn str;\n};\n\n/**\n * Converts a base32 string to an ArrayBuffer (RFC 4648).\n * @see https://github.com/LinusU/base32-encode\n * @param {string} str Base32 string.\n * @returns {ArrayBuffer} ArrayBuffer.\n */\nUtils.b32.encode = str => {\n\tconst strUpp = str.toUpperCase();\n\tconst buf = new ArrayBuffer(str.length * 5 / 8 | 0);\n\tconst arr = new Uint8Array(buf);\n\n\tlet bits = 0;\n\tlet value = 0;\n\tlet index = 0;\n\n\tfor (let i = 0; i < strUpp.length; i++) {\n\t\tconst idx = Utils.b32.alphabet.indexOf(strUpp[i]);\n\n\t\tif (idx === -1) {\n\t\t\tthrow new TypeError(`Invalid character found: ${strUpp[i]}`);\n\t\t}\n\n\t\tvalue = (value << 5) | idx;\n\t\tbits += 5;\n\n\t\tif (bits >= 8) {\n\t\t\tarr[index++] = (value >>> bits - 8) & 255;\n\t\t\tbits -= 8;\n\t\t}\n\t}\n\n\treturn buf;\n};\n\n/**\n * Hexadecimal string conversion.\n * @type {Object}\n */\nUtils.hex = {};\n\n/**\n * Converts an ArrayBuffer to a hexadecimal string.\n * @param {ArrayBuffer} buf ArrayBuffer.\n * @returns {string} Hexadecimal string.\n */\nUtils.hex.decode = buf => {\n\tconst arr = new Uint8Array(buf);\n\tlet str = '';\n\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tconst hexByte = arr[i].toString(16);\n\n\t\tstr += hexByte.length === 1\n\t\t\t? `0${hexByte}`\n\t\t\t: hexByte;\n\t}\n\n\treturn str.toUpperCase();\n};\n\n/**\n * Converts a hexadecimal string to an ArrayBuffer.\n * @param {string} str Hexadecimal string.\n * @returns {ArrayBuffer} ArrayBuffer.\n */\nUtils.hex.encode = str => {\n\tconst buf = new ArrayBuffer(str.length / 2);\n\tconst arr = new Uint8Array(buf);\n\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tarr[i] = Number.parseInt(str.substr(i * 2, 2), 16);\n\t}\n\n\treturn buf;\n};\n\n/**\n * An object containing some utilities (for internal use only).\n * @private\n * @type {Object}\n */\nexport const InternalUtils = {};\n\n/**\n * Detect if running in \"Node.js\".\n * @type {boolean}\n */\n// eslint-disable-next-line dot-notation\nInternalUtils.isNode = Object.prototype.toString.call(global['process']) === '[object process]';\n\n/**\n * Dynamically import \"Node.js\" modules.\n * @param {string} name Name.\n * @returns {Object} Module.\n */\n// eslint-disable-next-line no-eval\nInternalUtils.require = name => (InternalUtils.isNode ? eval('require')(name) : null);\n","\n\t\t\t\t\t/** @fileOverview Javascript cryptography implementation.\n *\n * Crush to remove comments, shorten variable names and\n * generally reduce transmission size.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n\"use strict\";\n/*jslint indent: 2, bitwise: false, nomen: false, plusplus: false, white: false, regexp: false */\n/*global document, window, escape, unescape, module, require, Uint32Array */\n\n/**\n * The Stanford Javascript Crypto Library, top-level namespace.\n * @namespace\n */\nvar sjcl = {\n  /**\n   * Symmetric ciphers.\n   * @namespace\n   */\n  cipher: {},\n\n  /**\n   * Hash functions.  Right now only SHA256 is implemented.\n   * @namespace\n   */\n  hash: {},\n\n  /**\n   * Key exchange functions.  Right now only SRP is implemented.\n   * @namespace\n   */\n  keyexchange: {},\n  \n  /**\n   * Cipher modes of operation.\n   * @namespace\n   */\n  mode: {},\n\n  /**\n   * Miscellaneous.  HMAC and PBKDF2.\n   * @namespace\n   */\n  misc: {},\n  \n  /**\n   * Bit array encoders and decoders.\n   * @namespace\n   *\n   * @description\n   * The members of this namespace are functions which translate between\n   * SJCL's bitArrays and other objects (usually strings).  Because it\n   * isn't always clear which direction is encoding and which is decoding,\n   * the method names are \"fromBits\" and \"toBits\".\n   */\n  codec: {},\n  \n  /**\n   * Exceptions.\n   * @namespace\n   */\n  exception: {\n    /**\n     * Ciphertext is corrupt.\n     * @constructor\n     */\n    corrupt: function(message) {\n      this.toString = function() { return \"CORRUPT: \"+this.message; };\n      this.message = message;\n    },\n    \n    /**\n     * Invalid parameter.\n     * @constructor\n     */\n    invalid: function(message) {\n      this.toString = function() { return \"INVALID: \"+this.message; };\n      this.message = message;\n    },\n    \n    /**\n     * Bug or missing feature in SJCL.\n     * @constructor\n     */\n    bug: function(message) {\n      this.toString = function() { return \"BUG: \"+this.message; };\n      this.message = message;\n    },\n\n    /**\n     * Something isn't ready.\n     * @constructor\n     */\n    notReady: function(message) {\n      this.toString = function() { return \"NOT READY: \"+this.message; };\n      this.message = message;\n    }\n  }\n};\n/** @fileOverview Arrays of bits, encoded as arrays of Numbers.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/**\n * Arrays of bits, encoded as arrays of Numbers.\n * @namespace\n * @description\n * <p>\n * These objects are the currency accepted by SJCL's crypto functions.\n * </p>\n *\n * <p>\n * Most of our crypto primitives operate on arrays of 4-byte words internally,\n * but many of them can take arguments that are not a multiple of 4 bytes.\n * This library encodes arrays of bits (whose size need not be a multiple of 8\n * bits) as arrays of 32-bit words.  The bits are packed, big-endian, into an\n * array of words, 32 bits at a time.  Since the words are double-precision\n * floating point numbers, they fit some extra data.  We use this (in a private,\n * possibly-changing manner) to encode the number of bits actually  present\n * in the last word of the array.\n * </p>\n *\n * <p>\n * Because bitwise ops clear this out-of-band data, these arrays can be passed\n * to ciphers like AES which want arrays of words.\n * </p>\n */\nsjcl.bitArray = {\n  /**\n   * Array slices in units of bits.\n   * @param {bitArray} a The array to slice.\n   * @param {Number} bstart The offset to the start of the slice, in bits.\n   * @param {Number} bend The offset to the end of the slice, in bits.  If this is undefined,\n   * slice until the end of the array.\n   * @return {bitArray} The requested slice.\n   */\n  bitSlice: function (a, bstart, bend) {\n    a = sjcl.bitArray._shiftRight(a.slice(bstart/32), 32 - (bstart & 31)).slice(1);\n    return (bend === undefined) ? a : sjcl.bitArray.clamp(a, bend-bstart);\n  },\n\n  /**\n   * Extract a number packed into a bit array.\n   * @param {bitArray} a The array to slice.\n   * @param {Number} bstart The offset to the start of the slice, in bits.\n   * @param {Number} blength The length of the number to extract.\n   * @return {Number} The requested slice.\n   */\n  extract: function(a, bstart, blength) {\n    // FIXME: this Math.floor is not necessary at all, but for some reason\n    // seems to suppress a bug in the Chromium JIT.\n    var x, sh = Math.floor((-bstart-blength) & 31);\n    if ((bstart + blength - 1 ^ bstart) & -32) {\n      // it crosses a boundary\n      x = (a[bstart/32|0] << (32 - sh)) ^ (a[bstart/32+1|0] >>> sh);\n    } else {\n      // within a single word\n      x = a[bstart/32|0] >>> sh;\n    }\n    return x & ((1<<blength) - 1);\n  },\n\n  /**\n   * Concatenate two bit arrays.\n   * @param {bitArray} a1 The first array.\n   * @param {bitArray} a2 The second array.\n   * @return {bitArray} The concatenation of a1 and a2.\n   */\n  concat: function (a1, a2) {\n    if (a1.length === 0 || a2.length === 0) {\n      return a1.concat(a2);\n    }\n    \n    var last = a1[a1.length-1], shift = sjcl.bitArray.getPartial(last);\n    if (shift === 32) {\n      return a1.concat(a2);\n    } else {\n      return sjcl.bitArray._shiftRight(a2, shift, last|0, a1.slice(0,a1.length-1));\n    }\n  },\n\n  /**\n   * Find the length of an array of bits.\n   * @param {bitArray} a The array.\n   * @return {Number} The length of a, in bits.\n   */\n  bitLength: function (a) {\n    var l = a.length, x;\n    if (l === 0) { return 0; }\n    x = a[l - 1];\n    return (l-1) * 32 + sjcl.bitArray.getPartial(x);\n  },\n\n  /**\n   * Truncate an array.\n   * @param {bitArray} a The array.\n   * @param {Number} len The length to truncate to, in bits.\n   * @return {bitArray} A new array, truncated to len bits.\n   */\n  clamp: function (a, len) {\n    if (a.length * 32 < len) { return a; }\n    a = a.slice(0, Math.ceil(len / 32));\n    var l = a.length;\n    len = len & 31;\n    if (l > 0 && len) {\n      a[l-1] = sjcl.bitArray.partial(len, a[l-1] & 0x80000000 >> (len-1), 1);\n    }\n    return a;\n  },\n\n  /**\n   * Make a partial word for a bit array.\n   * @param {Number} len The number of bits in the word.\n   * @param {Number} x The bits.\n   * @param {Number} [_end=0] Pass 1 if x has already been shifted to the high side.\n   * @return {Number} The partial word.\n   */\n  partial: function (len, x, _end) {\n    if (len === 32) { return x; }\n    return (_end ? x|0 : x << (32-len)) + len * 0x10000000000;\n  },\n\n  /**\n   * Get the number of bits used by a partial word.\n   * @param {Number} x The partial word.\n   * @return {Number} The number of bits used by the partial word.\n   */\n  getPartial: function (x) {\n    return Math.round(x/0x10000000000) || 32;\n  },\n\n  /**\n   * Compare two arrays for equality in a predictable amount of time.\n   * @param {bitArray} a The first array.\n   * @param {bitArray} b The second array.\n   * @return {boolean} true if a == b; false otherwise.\n   */\n  equal: function (a, b) {\n    if (sjcl.bitArray.bitLength(a) !== sjcl.bitArray.bitLength(b)) {\n      return false;\n    }\n    var x = 0, i;\n    for (i=0; i<a.length; i++) {\n      x |= a[i]^b[i];\n    }\n    return (x === 0);\n  },\n\n  /** Shift an array right.\n   * @param {bitArray} a The array to shift.\n   * @param {Number} shift The number of bits to shift.\n   * @param {Number} [carry=0] A byte to carry in\n   * @param {bitArray} [out=[]] An array to prepend to the output.\n   * @private\n   */\n  _shiftRight: function (a, shift, carry, out) {\n    var i, last2=0, shift2;\n    if (out === undefined) { out = []; }\n    \n    for (; shift >= 32; shift -= 32) {\n      out.push(carry);\n      carry = 0;\n    }\n    if (shift === 0) {\n      return out.concat(a);\n    }\n    \n    for (i=0; i<a.length; i++) {\n      out.push(carry | a[i]>>>shift);\n      carry = a[i] << (32-shift);\n    }\n    last2 = a.length ? a[a.length-1] : 0;\n    shift2 = sjcl.bitArray.getPartial(last2);\n    out.push(sjcl.bitArray.partial(shift+shift2 & 31, (shift + shift2 > 32) ? carry : out.pop(),1));\n    return out;\n  },\n  \n  /** xor a block of 4 words together.\n   * @private\n   */\n  _xor4: function(x,y) {\n    return [x[0]^y[0],x[1]^y[1],x[2]^y[2],x[3]^y[3]];\n  },\n\n  /** byteswap a word array inplace.\n   * (does not handle partial words)\n   * @param {sjcl.bitArray} a word array\n   * @return {sjcl.bitArray} byteswapped array\n   */\n  byteswapM: function(a) {\n    var i, v, m = 0xff00;\n    for (i = 0; i < a.length; ++i) {\n      v = a[i];\n      a[i] = (v >>> 24) | ((v >>> 8) & m) | ((v & m) << 8) | (v << 24);\n    }\n    return a;\n  }\n};\n/** @fileOverview Bit array codec implementations.\n *\n * @author Marco Munizaga\n */\n\n//patch arraybuffers if they don't exist\nif (typeof(ArrayBuffer) === 'undefined') {\n  (function(globals){\n      \"use strict\";\n      globals.ArrayBuffer = function(){};\n      globals.DataView = function(){};\n  }(this));\n}\n\n/**\n * ArrayBuffer\n * @namespace\n */\nsjcl.codec.arrayBuffer = {\n  /** Convert from a bitArray to an ArrayBuffer. \n   * Will default to 8byte padding if padding is undefined*/\n  fromBits: function (arr, padding, padding_count) {\n    var out, i, ol, tmp, smallest;\n    padding = padding==undefined  ? true : padding;\n    padding_count = padding_count || 8;\n\n    if (arr.length === 0) {\n      return new ArrayBuffer(0);\n    }\n\n    ol = sjcl.bitArray.bitLength(arr)/8;\n\n    //check to make sure the bitLength is divisible by 8, if it isn't \n    //we can't do anything since arraybuffers work with bytes, not bits\n    if ( sjcl.bitArray.bitLength(arr)%8 !== 0 ) {\n      throw new sjcl.exception.invalid(\"Invalid bit size, must be divisble by 8 to fit in an arraybuffer correctly\");\n    }\n\n    if (padding && ol%padding_count !== 0){\n      ol += padding_count - (ol%padding_count);\n    }\n\n\n    //padded temp for easy copying\n    tmp = new DataView(new ArrayBuffer(arr.length*4));\n    for (i=0; i<arr.length; i++) {\n      tmp.setUint32(i*4, (arr[i]<<32)); //get rid of the higher bits\n    }\n\n    //now copy the final message if we are not going to 0 pad\n    out = new DataView(new ArrayBuffer(ol));\n\n    //save a step when the tmp and out bytelength are ===\n    if (out.byteLength === tmp.byteLength){\n      return tmp.buffer;\n    }\n\n    smallest = tmp.byteLength < out.byteLength ? tmp.byteLength : out.byteLength;\n    for(i=0; i<smallest; i++){\n      out.setUint8(i,tmp.getUint8(i));\n    }\n\n\n    return out.buffer;\n  },\n  /** Convert from an ArrayBuffer to a bitArray. */\n  toBits: function (buffer) {\n    var i, out=[], len, inView, tmp;\n\n    if (buffer.byteLength === 0) {\n      return [];\n    }\n\n    inView = new DataView(buffer);\n    len = inView.byteLength - inView.byteLength%4;\n\n    for (var i = 0; i < len; i+=4) {\n      out.push(inView.getUint32(i));\n    }\n\n    if (inView.byteLength%4 != 0) {\n      tmp = new DataView(new ArrayBuffer(4));\n      for (var i = 0, l = inView.byteLength%4; i < l; i++) {\n        //we want the data to the right, because partial slices off the starting bits\n        tmp.setUint8(i+4-l, inView.getUint8(len+i)); // big-endian, \n      }\n      out.push(\n        sjcl.bitArray.partial( (inView.byteLength%4)*8, tmp.getUint32(0) )\n      ); \n    }\n    return out;\n  },\n\n\n\n  /** Prints a hex output of the buffer contents, akin to hexdump **/\n  hexDumpBuffer: function(buffer){\n      var stringBufferView = new DataView(buffer);\n      var string = '';\n      var pad = function (n, width) {\n          n = n + '';\n          return n.length >= width ? n : new Array(width - n.length + 1).join('0') + n;\n      };\n\n      for (var i = 0; i < stringBufferView.byteLength; i+=2) {\n          if (i%16 == 0) string += ('\\n'+(i).toString(16)+'\\t');\n          string += ( pad(stringBufferView.getUint16(i).toString(16),4) + ' ');\n      }\n\n      if ( typeof console === undefined ){\n        console = console || {log:function(){}}; //fix for IE\n      }\n      console.log(string.toUpperCase());\n  }\n};\n\n/** @fileOverview Javascript SHA-1 implementation.\n *\n * Based on the implementation in RFC 3174, method 1, and on the SJCL\n * SHA-256 implementation.\n *\n * @author Quinn Slack\n */\n\n/**\n * Context for a SHA-1 operation in progress.\n * @constructor\n */\nsjcl.hash.sha1 = function (hash) {\n  if (hash) {\n    this._h = hash._h.slice(0);\n    this._buffer = hash._buffer.slice(0);\n    this._length = hash._length;\n  } else {\n    this.reset();\n  }\n};\n\n/**\n * Hash a string or an array of words.\n * @static\n * @param {bitArray|String} data the data to hash.\n * @return {bitArray} The hash value, an array of 5 big-endian words.\n */\nsjcl.hash.sha1.hash = function (data) {\n  return (new sjcl.hash.sha1()).update(data).finalize();\n};\n\nsjcl.hash.sha1.prototype = {\n  /**\n   * The hash's block size, in bits.\n   * @constant\n   */\n  blockSize: 512,\n   \n  /**\n   * Reset the hash state.\n   * @return this\n   */\n  reset:function () {\n    this._h = this._init.slice(0);\n    this._buffer = [];\n    this._length = 0;\n    return this;\n  },\n  \n  /**\n   * Input several words to the hash.\n   * @param {bitArray|String} data the data to hash.\n   * @return this\n   */\n  update: function (data) {\n    if (typeof data === \"string\") {\n      data = sjcl.codec.utf8String.toBits(data);\n    }\n    var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),\n        ol = this._length,\n        nl = this._length = ol + sjcl.bitArray.bitLength(data);\n    if (nl > 9007199254740991){\n      throw new sjcl.exception.invalid(\"Cannot hash more than 2^53 - 1 bits\");\n    }\n\n    if (typeof Uint32Array !== 'undefined') {\n\tvar c = new Uint32Array(b);\n    \tvar j = 0;\n    \tfor (i = this.blockSize+ol - ((this.blockSize+ol) & (this.blockSize-1)); i <= nl;\n\t\ti+= this.blockSize) {\n      \t    this._block(c.subarray(16 * j, 16 * (j+1)));\n      \t    j += 1;\n    \t}\n    \tb.splice(0, 16 * j);\n    } else {\n    \tfor (i = this.blockSize+ol - ((this.blockSize+ol) & (this.blockSize-1)); i <= nl;\n             i+= this.blockSize) {\n      \t     this._block(b.splice(0,16));\n      \t}\n    }\n    return this;\n  },\n  \n  /**\n   * Complete hashing and output the hash value.\n   * @return {bitArray} The hash value, an array of 5 big-endian words. TODO\n   */\n  finalize:function () {\n    var i, b = this._buffer, h = this._h;\n\n    // Round out and push the buffer\n    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);\n    // Round out the buffer to a multiple of 16 words, less the 2 length words.\n    for (i = b.length + 2; i & 15; i++) {\n      b.push(0);\n    }\n\n    // append the length\n    b.push(Math.floor(this._length / 0x100000000));\n    b.push(this._length | 0);\n\n    while (b.length) {\n      this._block(b.splice(0,16));\n    }\n\n    this.reset();\n    return h;\n  },\n\n  /**\n   * The SHA-1 initialization vector.\n   * @private\n   */\n  _init:[0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0],\n\n  /**\n   * The SHA-1 hash key.\n   * @private\n   */\n  _key:[0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6],\n\n  /**\n   * The SHA-1 logical functions f(0), f(1), ..., f(79).\n   * @private\n   */\n  _f:function(t, b, c, d) {\n    if (t <= 19) {\n      return (b & c) | (~b & d);\n    } else if (t <= 39) {\n      return b ^ c ^ d;\n    } else if (t <= 59) {\n      return (b & c) | (b & d) | (c & d);\n    } else if (t <= 79) {\n      return b ^ c ^ d;\n    }\n  },\n\n  /**\n   * Circular left-shift operator.\n   * @private\n   */\n  _S:function(n, x) {\n    return (x << n) | (x >>> 32-n);\n  },\n  \n  /**\n   * Perform one cycle of SHA-1.\n   * @param {Uint32Array|bitArray} words one block of words.\n   * @private\n   */\n  _block:function (words) {\n    var t, tmp, a, b, c, d, e,\n    h = this._h;\n    var w;\n    if (typeof Uint32Array !== 'undefined') {\n        // When words is passed to _block, it has 16 elements. SHA1 _block\n        // function extends words with new elements (at the end there are 80 elements). \n        // The problem is that if we use Uint32Array instead of Array, \n        // the length of Uint32Array cannot be changed. Thus, we replace words with a \n        // normal Array here.\n        w = Array(80); // do not use Uint32Array here as the instantiation is slower\n        for (var j=0; j<16; j++){\n            w[j] = words[j];\n        }\n    } else {\n        w = words;\n    }\n\n    a = h[0]; b = h[1]; c = h[2]; d = h[3]; e = h[4]; \n\n    for (t=0; t<=79; t++) {\n      if (t >= 16) {\n        w[t] = this._S(1, w[t-3] ^ w[t-8] ^ w[t-14] ^ w[t-16]);\n      }\n      tmp = (this._S(5, a) + this._f(t, b, c, d) + e + w[t] +\n             this._key[Math.floor(t/20)]) | 0;\n      e = d;\n      d = c;\n      c = this._S(30, b);\n      b = a;\n      a = tmp;\n   }\n\n   h[0] = (h[0]+a) |0;\n   h[1] = (h[1]+b) |0;\n   h[2] = (h[2]+c) |0;\n   h[3] = (h[3]+d) |0;\n   h[4] = (h[4]+e) |0;\n  }\n};\n/** @fileOverview Javascript SHA-256 implementation.\n *\n * An older version of this implementation is available in the public\n * domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,\n * Stanford University 2008-2010 and BSD-licensed for liability\n * reasons.\n *\n * Special thanks to Aldo Cortesi for pointing out several bugs in\n * this code.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/**\n * Context for a SHA-256 operation in progress.\n * @constructor\n */\nsjcl.hash.sha256 = function (hash) {\n  if (!this._key[0]) { this._precompute(); }\n  if (hash) {\n    this._h = hash._h.slice(0);\n    this._buffer = hash._buffer.slice(0);\n    this._length = hash._length;\n  } else {\n    this.reset();\n  }\n};\n\n/**\n * Hash a string or an array of words.\n * @static\n * @param {bitArray|String} data the data to hash.\n * @return {bitArray} The hash value, an array of 16 big-endian words.\n */\nsjcl.hash.sha256.hash = function (data) {\n  return (new sjcl.hash.sha256()).update(data).finalize();\n};\n\nsjcl.hash.sha256.prototype = {\n  /**\n   * The hash's block size, in bits.\n   * @constant\n   */\n  blockSize: 512,\n   \n  /**\n   * Reset the hash state.\n   * @return this\n   */\n  reset:function () {\n    this._h = this._init.slice(0);\n    this._buffer = [];\n    this._length = 0;\n    return this;\n  },\n  \n  /**\n   * Input several words to the hash.\n   * @param {bitArray|String} data the data to hash.\n   * @return this\n   */\n  update: function (data) {\n    if (typeof data === \"string\") {\n      data = sjcl.codec.utf8String.toBits(data);\n    }\n    var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),\n        ol = this._length,\n        nl = this._length = ol + sjcl.bitArray.bitLength(data);\n    if (nl > 9007199254740991){\n      throw new sjcl.exception.invalid(\"Cannot hash more than 2^53 - 1 bits\");\n    }\n\n    if (typeof Uint32Array !== 'undefined') {\n\tvar c = new Uint32Array(b);\n    \tvar j = 0;\n    \tfor (i = 512+ol - ((512+ol) & 511); i <= nl; i+= 512) {\n      \t    this._block(c.subarray(16 * j, 16 * (j+1)));\n      \t    j += 1;\n    \t}\n    \tb.splice(0, 16 * j);\n    } else {\n\tfor (i = 512+ol - ((512+ol) & 511); i <= nl; i+= 512) {\n      \t    this._block(b.splice(0,16));\n      \t}\n    }\n    return this;\n  },\n  \n  /**\n   * Complete hashing and output the hash value.\n   * @return {bitArray} The hash value, an array of 8 big-endian words.\n   */\n  finalize:function () {\n    var i, b = this._buffer, h = this._h;\n\n    // Round out and push the buffer\n    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);\n    \n    // Round out the buffer to a multiple of 16 words, less the 2 length words.\n    for (i = b.length + 2; i & 15; i++) {\n      b.push(0);\n    }\n    \n    // append the length\n    b.push(Math.floor(this._length / 0x100000000));\n    b.push(this._length | 0);\n\n    while (b.length) {\n      this._block(b.splice(0,16));\n    }\n\n    this.reset();\n    return h;\n  },\n\n  /**\n   * The SHA-256 initialization vector, to be precomputed.\n   * @private\n   */\n  _init:[],\n  /*\n  _init:[0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19],\n  */\n  \n  /**\n   * The SHA-256 hash key, to be precomputed.\n   * @private\n   */\n  _key:[],\n  /*\n  _key:\n    [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n     0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n     0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n     0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n     0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n     0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n     0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n     0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2],\n  */\n\n\n  /**\n   * Function to precompute _init and _key.\n   * @private\n   */\n  _precompute: function () {\n    var i = 0, prime = 2, factor, isPrime;\n\n    function frac(x) { return (x-Math.floor(x)) * 0x100000000 | 0; }\n\n    for (; i<64; prime++) {\n      isPrime = true;\n      for (factor=2; factor*factor <= prime; factor++) {\n        if (prime % factor === 0) {\n          isPrime = false;\n          break;\n        }\n      }\n      if (isPrime) {\n        if (i<8) {\n          this._init[i] = frac(Math.pow(prime, 1/2));\n        }\n        this._key[i] = frac(Math.pow(prime, 1/3));\n        i++;\n      }\n    }\n  },\n  \n  /**\n   * Perform one cycle of SHA-256.\n   * @param {Uint32Array|bitArray} w one block of words.\n   * @private\n   */\n  _block:function (w) {  \n    var i, tmp, a, b,\n      h = this._h,\n      k = this._key,\n      h0 = h[0], h1 = h[1], h2 = h[2], h3 = h[3],\n      h4 = h[4], h5 = h[5], h6 = h[6], h7 = h[7];\n\n    /* Rationale for placement of |0 :\n     * If a value can overflow is original 32 bits by a factor of more than a few\n     * million (2^23 ish), there is a possibility that it might overflow the\n     * 53-bit mantissa and lose precision.\n     *\n     * To avoid this, we clamp back to 32 bits by |'ing with 0 on any value that\n     * propagates around the loop, and on the hash state h[].  I don't believe\n     * that the clamps on h4 and on h0 are strictly necessary, but it's close\n     * (for h4 anyway), and better safe than sorry.\n     *\n     * The clamps on h[] are necessary for the output to be correct even in the\n     * common case and for short inputs.\n     */\n    for (i=0; i<64; i++) {\n      // load up the input word for this round\n      if (i<16) {\n        tmp = w[i];\n      } else {\n        a   = w[(i+1 ) & 15];\n        b   = w[(i+14) & 15];\n        tmp = w[i&15] = ((a>>>7  ^ a>>>18 ^ a>>>3  ^ a<<25 ^ a<<14) + \n                         (b>>>17 ^ b>>>19 ^ b>>>10 ^ b<<15 ^ b<<13) +\n                         w[i&15] + w[(i+9) & 15]) | 0;\n      }\n      \n      tmp = (tmp + h7 + (h4>>>6 ^ h4>>>11 ^ h4>>>25 ^ h4<<26 ^ h4<<21 ^ h4<<7) +  (h6 ^ h4&(h5^h6)) + k[i]); // | 0;\n      \n      // shift register\n      h7 = h6; h6 = h5; h5 = h4;\n      h4 = h3 + tmp | 0;\n      h3 = h2; h2 = h1; h1 = h0;\n\n      h0 = (tmp +  ((h1&h2) ^ (h3&(h1^h2))) + (h1>>>2 ^ h1>>>13 ^ h1>>>22 ^ h1<<30 ^ h1<<19 ^ h1<<10)) | 0;\n    }\n\n    h[0] = h[0]+h0 | 0;\n    h[1] = h[1]+h1 | 0;\n    h[2] = h[2]+h2 | 0;\n    h[3] = h[3]+h3 | 0;\n    h[4] = h[4]+h4 | 0;\n    h[5] = h[5]+h5 | 0;\n    h[6] = h[6]+h6 | 0;\n    h[7] = h[7]+h7 | 0;\n  }\n};\n\n\n/** @fileOverview Javascript SHA-512 implementation.\n *\n * This implementation was written for CryptoJS by Jeff Mott and adapted for\n * SJCL by Stefan Thomas.\n *\n * CryptoJS (c) 2009–2012 by Jeff Mott. All rights reserved.\n * Released with New BSD License\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n * @author Jeff Mott\n * @author Stefan Thomas\n */\n\n/**\n * Context for a SHA-512 operation in progress.\n * @constructor\n */\nsjcl.hash.sha512 = function (hash) {\n  if (!this._key[0]) { this._precompute(); }\n  if (hash) {\n    this._h = hash._h.slice(0);\n    this._buffer = hash._buffer.slice(0);\n    this._length = hash._length;\n  } else {\n    this.reset();\n  }\n};\n\n/**\n * Hash a string or an array of words.\n * @static\n * @param {bitArray|String} data the data to hash.\n * @return {bitArray} The hash value, an array of 16 big-endian words.\n */\nsjcl.hash.sha512.hash = function (data) {\n  return (new sjcl.hash.sha512()).update(data).finalize();\n};\n\nsjcl.hash.sha512.prototype = {\n  /**\n   * The hash's block size, in bits.\n   * @constant\n   */\n  blockSize: 1024,\n   \n  /**\n   * Reset the hash state.\n   * @return this\n   */\n  reset:function () {\n    this._h = this._init.slice(0);\n    this._buffer = [];\n    this._length = 0;\n    return this;\n  },\n  \n  /**\n   * Input several words to the hash.\n   * @param {bitArray|String} data the data to hash.\n   * @return this\n   */\n  update: function (data) {\n    if (typeof data === \"string\") {\n      data = sjcl.codec.utf8String.toBits(data);\n    }\n    var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),\n        ol = this._length,\n        nl = this._length = ol + sjcl.bitArray.bitLength(data);\n    if (nl > 9007199254740991){\n      throw new sjcl.exception.invalid(\"Cannot hash more than 2^53 - 1 bits\");\n    }\n\n    if (typeof Uint32Array !== 'undefined') {\n        var c = new Uint32Array(b);\n        var j = 0;\n        for (i = 1024+ol - ((1024+ol) & 1023); i <= nl; i+= 1024) {\n            this._block(c.subarray(32 * j, 32 * (j+1)));\n            j += 1;\n        }\n        b.splice(0, 32 * j);\n    } else {\n        for (i = 1024+ol - ((1024+ol) & 1023); i <= nl; i+= 1024) {\n            this._block(b.splice(0,32));\n        }\n    }\n    return this;\n  },\n  \n  /**\n   * Complete hashing and output the hash value.\n   * @return {bitArray} The hash value, an array of 16 big-endian words.\n   */\n  finalize:function () {\n    var i, b = this._buffer, h = this._h;\n\n    // Round out and push the buffer\n    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);\n\n    // Round out the buffer to a multiple of 32 words, less the 4 length words.\n    for (i = b.length + 4; i & 31; i++) {\n      b.push(0);\n    }\n\n    // append the length\n    b.push(0);\n    b.push(0);\n    b.push(Math.floor(this._length / 0x100000000));\n    b.push(this._length | 0);\n\n    while (b.length) {\n      this._block(b.splice(0,32));\n    }\n\n    this.reset();\n    return h;\n  },\n\n  /**\n   * The SHA-512 initialization vector, to be precomputed.\n   * @private\n   */\n  _init:[],\n\n  /**\n   * Least significant 24 bits of SHA512 initialization values.\n   *\n   * Javascript only has 53 bits of precision, so we compute the 40 most\n   * significant bits and add the remaining 24 bits as constants.\n   *\n   * @private\n   */\n  _initr: [ 0xbcc908, 0xcaa73b, 0x94f82b, 0x1d36f1, 0xe682d1, 0x3e6c1f, 0x41bd6b, 0x7e2179 ],\n\n  /*\n  _init:\n  [0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n   0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179],\n  */\n\n  /**\n   * The SHA-512 hash key, to be precomputed.\n   * @private\n   */\n  _key:[],\n\n  /**\n   * Least significant 24 bits of SHA512 key values.\n   * @private\n   */\n  _keyr:\n  [0x28ae22, 0xef65cd, 0x4d3b2f, 0x89dbbc, 0x48b538, 0x05d019, 0x194f9b, 0x6d8118,\n   0x030242, 0x706fbe, 0xe4b28c, 0xffb4e2, 0x7b896f, 0x1696b1, 0xc71235, 0x692694,\n   0xf14ad2, 0x4f25e3, 0x8cd5b5, 0xac9c65, 0x2b0275, 0xa6e483, 0x41fbd4, 0x1153b5,\n   0x66dfab, 0xb43210, 0xfb213f, 0xef0ee4, 0xa88fc2, 0x0aa725, 0x03826f, 0x0e6e70,\n   0xd22ffc, 0x26c926, 0xc42aed, 0x95b3df, 0xaf63de, 0x77b2a8, 0xedaee6, 0x82353b,\n   0xf10364, 0x423001, 0xf89791, 0x54be30, 0xef5218, 0x65a910, 0x71202a, 0xbbd1b8,\n   0xd2d0c8, 0x41ab53, 0x8eeb99, 0x9b48a8, 0xc95a63, 0x418acb, 0x63e373, 0xb2b8a3,\n   0xefb2fc, 0x172f60, 0xf0ab72, 0x6439ec, 0x631e28, 0x82bde9, 0xc67915, 0x72532b,\n   0x26619c, 0xc0c207, 0xe0eb1e, 0x6ed178, 0x176fba, 0xc898a6, 0xf90dae, 0x1c471b,\n   0x047d84, 0xc72493, 0xc9bebc, 0x100d4c, 0x3e42b6, 0x657e2a, 0xd6faec, 0x475817],\n\n  /*\n  _key:\n  [0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,\n   0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,\n   0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,\n   0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,\n   0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,\n   0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,\n   0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,\n   0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,\n   0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,\n   0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,\n   0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,\n   0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,\n   0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,\n   0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,\n   0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,\n   0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,\n   0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,\n   0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,\n   0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,\n   0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817],\n  */\n\n  /**\n   * Function to precompute _init and _key.\n   * @private\n   */\n  _precompute: function () {\n    // XXX: This code is for precomputing the SHA256 constants, change for\n    //      SHA512 and re-enable.\n    var i = 0, prime = 2, factor , isPrime;\n\n    function frac(x)  { return (x-Math.floor(x)) * 0x100000000 | 0; }\n    function frac2(x) { return (x-Math.floor(x)) * 0x10000000000 & 0xff; }\n\n    for (; i<80; prime++) {\n      isPrime = true;\n      for (factor=2; factor*factor <= prime; factor++) {\n        if (prime % factor === 0) {\n          isPrime = false;\n          break;\n        }\n      }\n      if (isPrime) {\n        if (i<8) {\n          this._init[i*2] = frac(Math.pow(prime, 1/2));\n          this._init[i*2+1] = (frac2(Math.pow(prime, 1/2)) << 24) | this._initr[i];\n        }\n        this._key[i*2] = frac(Math.pow(prime, 1/3));\n        this._key[i*2+1] = (frac2(Math.pow(prime, 1/3)) << 24) | this._keyr[i];\n        i++;\n      }\n    }\n  },\n\n  /**\n   * Perform one cycle of SHA-512.\n   * @param {Uint32Array|bitArray} words one block of words.\n   * @private\n   */\n  _block:function (words) {\n    var i, wrh, wrl,\n        h = this._h,\n        k = this._key,\n        h0h = h[ 0], h0l = h[ 1], h1h = h[ 2], h1l = h[ 3],\n        h2h = h[ 4], h2l = h[ 5], h3h = h[ 6], h3l = h[ 7],\n        h4h = h[ 8], h4l = h[ 9], h5h = h[10], h5l = h[11],\n        h6h = h[12], h6l = h[13], h7h = h[14], h7l = h[15];\n    var w;\n    if (typeof Uint32Array !== 'undefined') {\n\t// When words is passed to _block, it has 32 elements. SHA512 _block\n\t// function extends words with new elements (at the end there are 160 elements). \n\t// The problem is that if we use Uint32Array instead of Array, \n\t// the length of Uint32Array cannot be changed. Thus, we replace words with a \n\t// normal Array here.\n        w = Array(160); // do not use Uint32Array here as the instantiation is slower\n        for (var j=0; j<32; j++){\n    \t    w[j] = words[j]; \n        }\n    } else {\n\tw = words;\n    } \n\n    // Working variables\n    var ah = h0h, al = h0l, bh = h1h, bl = h1l,\n        ch = h2h, cl = h2l, dh = h3h, dl = h3l,\n        eh = h4h, el = h4l, fh = h5h, fl = h5l,\n        gh = h6h, gl = h6l, hh = h7h, hl = h7l;\n\n    for (i=0; i<80; i++) {\n      // load up the input word for this round\n      if (i<16) {\n        wrh = w[i * 2];\n        wrl = w[i * 2 + 1];\n      } else {\n        // Gamma0\n        var gamma0xh = w[(i-15) * 2];\n        var gamma0xl = w[(i-15) * 2 + 1];\n        var gamma0h =\n          ((gamma0xl << 31) | (gamma0xh >>> 1)) ^\n          ((gamma0xl << 24) | (gamma0xh >>> 8)) ^\n           (gamma0xh >>> 7);\n        var gamma0l =\n          ((gamma0xh << 31) | (gamma0xl >>> 1)) ^\n          ((gamma0xh << 24) | (gamma0xl >>> 8)) ^\n          ((gamma0xh << 25) | (gamma0xl >>> 7));\n\n        // Gamma1\n        var gamma1xh = w[(i-2) * 2];\n        var gamma1xl = w[(i-2) * 2 + 1];\n        var gamma1h =\n          ((gamma1xl << 13) | (gamma1xh >>> 19)) ^\n          ((gamma1xh << 3)  | (gamma1xl >>> 29)) ^\n           (gamma1xh >>> 6);\n        var gamma1l =\n          ((gamma1xh << 13) | (gamma1xl >>> 19)) ^\n          ((gamma1xl << 3)  | (gamma1xh >>> 29)) ^\n          ((gamma1xh << 26) | (gamma1xl >>> 6));\n\n        // Shortcuts\n        var wr7h = w[(i-7) * 2];\n        var wr7l = w[(i-7) * 2 + 1];\n\n        var wr16h = w[(i-16) * 2];\n        var wr16l = w[(i-16) * 2 + 1];\n\n        // W(round) = gamma0 + W(round - 7) + gamma1 + W(round - 16)\n        wrl = gamma0l + wr7l;\n        wrh = gamma0h + wr7h + ((wrl >>> 0) < (gamma0l >>> 0) ? 1 : 0);\n        wrl += gamma1l;\n        wrh += gamma1h + ((wrl >>> 0) < (gamma1l >>> 0) ? 1 : 0);\n        wrl += wr16l;\n        wrh += wr16h + ((wrl >>> 0) < (wr16l >>> 0) ? 1 : 0);\n      }\n\n      w[i*2]     = wrh |= 0;\n      w[i*2 + 1] = wrl |= 0;\n\n      // Ch\n      var chh = (eh & fh) ^ (~eh & gh);\n      var chl = (el & fl) ^ (~el & gl);\n\n      // Maj\n      var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);\n      var majl = (al & bl) ^ (al & cl) ^ (bl & cl);\n\n      // Sigma0\n      var sigma0h = ((al << 4) | (ah >>> 28)) ^ ((ah << 30) | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));\n      var sigma0l = ((ah << 4) | (al >>> 28)) ^ ((al << 30) | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));\n\n      // Sigma1\n      var sigma1h = ((el << 18) | (eh >>> 14)) ^ ((el << 14) | (eh >>> 18)) ^ ((eh << 23) | (el >>> 9));\n      var sigma1l = ((eh << 18) | (el >>> 14)) ^ ((eh << 14) | (el >>> 18)) ^ ((el << 23) | (eh >>> 9));\n\n      // K(round)\n      var krh = k[i*2];\n      var krl = k[i*2+1];\n\n      // t1 = h + sigma1 + ch + K(round) + W(round)\n      var t1l = hl + sigma1l;\n      var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);\n      t1l += chl;\n      t1h += chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);\n      t1l += krl;\n      t1h += krh + ((t1l >>> 0) < (krl >>> 0) ? 1 : 0);\n      t1l = t1l + wrl|0;   // FF32..FF34 perf issue https://bugzilla.mozilla.org/show_bug.cgi?id=1054972\n      t1h += wrh + ((t1l >>> 0) < (wrl >>> 0) ? 1 : 0);\n\n      // t2 = sigma0 + maj\n      var t2l = sigma0l + majl;\n      var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);\n\n      // Update working variables\n      hh = gh;\n      hl = gl;\n      gh = fh;\n      gl = fl;\n      fh = eh;\n      fl = el;\n      el = (dl + t1l) | 0;\n      eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;\n      dh = ch;\n      dl = cl;\n      ch = bh;\n      cl = bl;\n      bh = ah;\n      bl = al;\n      al = (t1l + t2l) | 0;\n      ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;\n    }\n\n    // Intermediate hash\n    h0l = h[1] = (h0l + al) | 0;\n    h[0] = (h0h + ah + ((h0l >>> 0) < (al >>> 0) ? 1 : 0)) | 0;\n    h1l = h[3] = (h1l + bl) | 0;\n    h[2] = (h1h + bh + ((h1l >>> 0) < (bl >>> 0) ? 1 : 0)) | 0;\n    h2l = h[5] = (h2l + cl) | 0;\n    h[4] = (h2h + ch + ((h2l >>> 0) < (cl >>> 0) ? 1 : 0)) | 0;\n    h3l = h[7] = (h3l + dl) | 0;\n    h[6] = (h3h + dh + ((h3l >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;\n    h4l = h[9] = (h4l + el) | 0;\n    h[8] = (h4h + eh + ((h4l >>> 0) < (el >>> 0) ? 1 : 0)) | 0;\n    h5l = h[11] = (h5l + fl) | 0;\n    h[10] = (h5h + fh + ((h5l >>> 0) < (fl >>> 0) ? 1 : 0)) | 0;\n    h6l = h[13] = (h6l + gl) | 0;\n    h[12] = (h6h + gh + ((h6l >>> 0) < (gl >>> 0) ? 1 : 0)) | 0;\n    h7l = h[15] = (h7l + hl) | 0;\n    h[14] = (h7h + hh + ((h7l >>> 0) < (hl >>> 0) ? 1 : 0)) | 0;\n  }\n};\n\n\n/** @fileOverview HMAC implementation.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** HMAC with the specified hash function.\n * @constructor\n * @param {bitArray} key the key for HMAC.\n * @param {Object} [Hash=sjcl.hash.sha256] The hash function to use.\n */\nsjcl.misc.hmac = function (key, Hash) {\n  this._hash = Hash = Hash || sjcl.hash.sha256;\n  var exKey = [[],[]], i,\n      bs = Hash.prototype.blockSize / 32;\n  this._baseHash = [new Hash(), new Hash()];\n\n  if (key.length > bs) {\n    key = Hash.hash(key);\n  }\n  \n  for (i=0; i<bs; i++) {\n    exKey[0][i] = key[i]^0x36363636;\n    exKey[1][i] = key[i]^0x5C5C5C5C;\n  }\n  \n  this._baseHash[0].update(exKey[0]);\n  this._baseHash[1].update(exKey[1]);\n  this._resultHash = new Hash(this._baseHash[0]);\n};\n\n/** HMAC with the specified hash function.  Also called encrypt since it's a prf.\n * @param {bitArray|String} data The data to mac.\n */\nsjcl.misc.hmac.prototype.encrypt = sjcl.misc.hmac.prototype.mac = function (data) {\n  if (!this._updated) {\n    this.update(data);\n    return this.digest(data);\n  } else {\n    throw new sjcl.exception.invalid(\"encrypt on already updated hmac called!\");\n  }\n};\n\nsjcl.misc.hmac.prototype.reset = function () {\n  this._resultHash = new this._hash(this._baseHash[0]);\n  this._updated = false;\n};\n\nsjcl.misc.hmac.prototype.update = function (data) {\n  this._updated = true;\n  this._resultHash.update(data);\n};\n\nsjcl.misc.hmac.prototype.digest = function () {\n  var w = this._resultHash.finalize(), result = new (this._hash)(this._baseHash[1]).update(w).finalize();\n\n  this.reset();\n\n  return result;\n};\n\n\t\t\t\t\t;export default sjcl;\n\t\t\t\t","// eslint-disable-next-line import/no-extraneous-dependencies\nimport sjcl from 'sjcl'; // SJCL is included during compilation.\n\nimport { InternalUtils } from './utils';\n\n/**\n * Node.js Crypto module.\n * @private\n * @type {Object}\n */\nconst NodeCrypto = InternalUtils.require('crypto');\n\n/**\n * An object containing some cryptography functions\n * with dirty workarounds for Node.js and browsers.\n * @private\n * @type {Object}\n */\nexport const Crypto = {};\n\nif (NodeCrypto) {\n\tlet bufferFrom;\n\n\tif (typeof Buffer.from === 'function') {\n\t\tbufferFrom = Buffer.from;\n\t} else {\n\t\t// Node.js < 5.10.0\n\t\tbufferFrom = arrbuf => {\n\t\t\t// eslint-disable-next-line no-buffer-constructor\n\t\t\tconst nodeBuf = new Buffer(arrbuf.byteLength);\n\t\t\tconst arr = new Uint8Array(arrbuf);\n\n\t\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\t\tnodeBuf[i] = arr[i];\n\t\t\t}\n\n\t\t\treturn nodeBuf;\n\t\t};\n\t}\n\n\tlet bufferTo;\n\n\tif (Buffer.prototype instanceof Uint8Array) {\n\t\tbufferTo = nodeBuf => nodeBuf;\n\t} else {\n\t\t// Node.js < 4.0.0\n\t\tbufferTo = nodeBuf => {\n\t\t\tconst arr = new Uint8Array(nodeBuf.length);\n\n\t\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\t\tarr[i] = nodeBuf[i];\n\t\t\t}\n\n\t\t\treturn arr;\n\t\t};\n\t}\n\n\tCrypto.randomBytes = size => {\n\t\tconst buff = NodeCrypto.randomBytes(size);\n\t\treturn bufferTo(buff);\n\t};\n\n\t// In Node.js, the command:\n\t// $ openssl list -digest-algorithms\n\t// displays the available digest algorithms.\n\tCrypto.hmacDigest = (algorithm, key, message) => {\n\t\tconst buff = NodeCrypto.createHmac(algorithm, bufferFrom(key));\n\t\treturn bufferTo(buff).update(bufferFrom(message)).digest();\n\t};\n} else {\n\tlet getRandomValues;\n\n\tif (typeof global.crypto !== 'undefined' && typeof global.crypto.getRandomValues === 'function') {\n\t\tgetRandomValues = arr => {\n\t\t\tglobal.crypto.getRandomValues(arr);\n\t\t};\n\t} else if (typeof global.msCrypto !== 'undefined' && typeof global.msCrypto.getRandomValues === 'function') {\n\t\tgetRandomValues = arr => {\n\t\t\tglobal.msCrypto.getRandomValues(arr);\n\t\t};\n\t} else {\n\t\tconsole.warn('Cryptography API not available, falling back to \\'Math.random\\'...');\n\t\tgetRandomValues = arr => {\n\t\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\t\tarr[i] = Math.floor(Math.random() * 256);\n\t\t\t}\n\t\t};\n\t}\n\n\tCrypto.randomBytes = size => {\n\t\tconst arr = new Uint8Array(size);\n\t\tgetRandomValues(arr);\n\t\treturn arr;\n\t};\n\n\tCrypto.hmacDigest = (algorithm, key, message) => {\n\t\tconst hash = sjcl.hash[algorithm.toLowerCase()];\n\t\tif (typeof hash === 'undefined') {\n\t\t\tthrow new TypeError('Unknown hash function');\n\t\t}\n\n\t\t// eslint-disable-next-line new-cap\n\t\tconst hmac = new sjcl.misc.hmac(sjcl.codec.arrayBuffer.toBits(key), hash);\n\t\thmac.update(sjcl.codec.arrayBuffer.toBits(message));\n\n\t\treturn sjcl.codec.arrayBuffer.fromBits(hmac.digest(), false);\n\t};\n}\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","import { Utils } from './utils';\nimport { Crypto } from './crypto';\n\n/**\n * Secret key object.\n */\nexport class Secret {\n\t/**\n\t * @param {Object} [config] Configuration options.\n\t * @param {ArrayBuffer} [config.buffer=Crypto.randomBytes] Secret key.\n\t * @param {number} [config.size=20] Number of random bytes to generate, ignored if 'buffer' is provided.\n\t */\n\tconstructor({ buffer, size = 20 } = {}) {\n\t\t/**\n\t\t * Secret key.\n\t\t * @type {ArrayBuffer}\n\t\t */\n\t\tthis.buffer = typeof buffer === 'undefined'\n\t\t\t? Crypto.randomBytes(size).buffer\n\t\t\t: buffer;\n\t}\n\n\t/**\n\t * Converts a raw string to a Secret object.\n\t * @method fromRaw\n\t * @param {string} str Raw string.\n\t * @returns {Secret} Secret object.\n\t */\n\tstatic fromRaw(str) {\n\t\treturn new this({ buffer: Utils.raw.encode(str) });\n\t}\n\n\t/**\n\t * Converts a base32 string to a Secret object.\n\t * @method fromB32\n\t * @param {string} str Base32 string.\n\t * @returns {Secret} Secret object.\n\t */\n\tstatic fromB32(str) {\n\t\treturn new this({ buffer: Utils.b32.encode(str) });\n\t}\n\n\t/**\n\t * Converts a hexadecimal string to a Secret object.\n\t * @method fromHex\n\t * @param {string} str Hexadecimal string.\n\t * @returns {Secret} Secret object.\n\t */\n\tstatic fromHex(str) {\n\t\treturn new this({ buffer: Utils.hex.encode(str) });\n\t}\n\n\t/**\n\t * String representation of secret key.\n\t * @type {string}\n\t */\n\tget raw() {\n\t\tObject.defineProperty(this, 'raw', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\twritable: true,\n\t\t\tvalue: Utils.raw.decode(this.buffer)\n\t\t});\n\n\t\treturn this.raw;\n\t}\n\n\t/**\n\t * Base32 representation of secret key.\n\t * @type {string}\n\t */\n\tget b32() {\n\t\tObject.defineProperty(this, 'b32', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\twritable: true,\n\t\t\tvalue: Utils.b32.decode(this.buffer)\n\t\t});\n\n\t\treturn this.b32;\n\t}\n\n\t/**\n\t * Hexadecimal representation of secret key.\n\t * @type {string}\n\t */\n\tget hex() {\n\t\tObject.defineProperty(this, 'hex', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\twritable: true,\n\t\t\tvalue: Utils.hex.decode(this.buffer)\n\t\t});\n\n\t\treturn this.hex;\n\t}\n}\n","import { Utils } from './utils';\nimport { Secret } from './secret';\n// eslint-disable-next-line import/no-cycle\nimport { HOTP, TOTP } from './otp';\n\n/**\n * Valid key URI parameters.\n * @private\n * @type {Array}\n */\nconst OTPURI_PARAMS = ['issuer', 'secret', 'algorithm', 'digits', 'counter', 'period'];\n\n/**\n * Key URI regex.\n *   otpauth://TYPE/[ISSUER:]LABEL?PARAMETERS\n * @private\n * @type {RegExp}\n */\nconst OTPURI_REGEX = new RegExp(`^otpauth:\\\\/\\\\/([ht]otp)\\\\/(.+)\\\\?((?:&?(?:${OTPURI_PARAMS.join('|')})=[^&]+)+)$`, 'i');\n\n/**\n * RFC 4648 base32 alphabet without pad.\n * @private\n * @type {string}\n */\nconst SECRET_REGEX = /^[2-7A-Z]+$/i;\n\n/**\n * Regex for supported algorithms.\n * @private\n * @type {RegExp}\n */\nconst ALGORITHM_REGEX = /^SHA(?:1|256|512)$/i;\n\n/**\n * Integer regex.\n * @private\n * @type {RegExp}\n */\nconst INTEGER_REGEX = /^[+-]?\\d+$/;\n\n/**\n * Positive integer regex.\n * @private\n * @type {RegExp}\n */\nconst POSITIVE_INTEGER_REGEX = /^\\+?[1-9]\\d*$/;\n\n/**\n * HOTP/TOTP object/string conversion.\n * @see https://github.com/google/google-authenticator/wiki/Key-Uri-Format\n */\nexport class URI {\n\t/**\n\t * Parses a Google Authenticator key URI and returns an HOTP/TOTP object.\n\t * @method parse\n\t * @param {string} uri Google Authenticator Key URI.\n\t * @returns {Object} HOTP/TOTP object.\n\t */\n\tstatic parse(uri) {\n\t\tlet uriGroups;\n\n\t\ttry {\n\t\t\turiGroups = uri.match(OTPURI_REGEX);\n\t\t} catch (error) { /* Handled below */ }\n\n\t\tif (!Array.isArray(uriGroups)) {\n\t\t\tthrow new URIError('Invalid URI format');\n\t\t}\n\n\t\t// Extract URI groups.\n\t\tconst uriType = uriGroups[1].toLowerCase();\n\t\tconst uriLabel = uriGroups[2].split(/:(.+)/, 2).map(decodeURIComponent);\n\t\tconst uriParams = uriGroups[3].split('&').reduce((acc, cur) => {\n\t\t\tconst pairArr = cur.split(/=(.+)/, 2).map(decodeURIComponent);\n\t\t\tconst pairKey = pairArr[0].toLowerCase();\n\t\t\tconst pairVal = pairArr[1];\n\t\t\tconst pairAcc = acc;\n\n\t\t\tpairAcc[pairKey] = pairVal;\n\t\t\treturn pairAcc;\n\t\t}, {});\n\n\t\t// 'OTP' will be instantiated with 'config' argument\n\t\tlet OTP;\n\t\tconst config = {};\n\n\t\tif (uriType === 'hotp') {\n\t\t\tOTP = HOTP;\n\n\t\t\t// Counter: required\n\t\t\tif (typeof uriParams.counter !== 'undefined' && INTEGER_REGEX.test(uriParams.counter)) {\n\t\t\t\tconfig.counter = Number.parseInt(uriParams.counter, 10);\n\t\t\t} else {\n\t\t\t\tthrow new TypeError('Missing or invalid \\'counter\\' parameter');\n\t\t\t}\n\t\t} else if (uriType === 'totp') {\n\t\t\tOTP = TOTP;\n\n\t\t\t// Period: optional\n\t\t\tif (typeof uriParams.period !== 'undefined') {\n\t\t\t\tif (POSITIVE_INTEGER_REGEX.test(uriParams.period)) {\n\t\t\t\t\tconfig.period = Number.parseInt(uriParams.period, 10);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new TypeError('Invalid \\'period\\' parameter');\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new TypeError('Unknown OTP type');\n\t\t}\n\n\t\t// Label: required\n\t\t// Issuer: optional\n\t\tif (uriLabel.length === 2) {\n\t\t\tconfig.label = uriLabel[1];\n\t\t\tif (typeof uriParams.issuer === 'undefined') {\n\t\t\t\tconfig.issuer = uriLabel[0];\n\t\t\t} else if (uriParams.issuer === uriLabel[0]) {\n\t\t\t\tconfig.issuer = uriParams.issuer;\n\t\t\t} else {\n\t\t\t\tthrow new TypeError('Invalid \\'issuer\\' parameter');\n\t\t\t}\n\t\t} else {\n\t\t\tconfig.label = uriLabel[0];\n\t\t\tif (typeof uriParams.issuer !== 'undefined') {\n\t\t\t\tconfig.issuer = uriParams.issuer;\n\t\t\t}\n\t\t}\n\n\t\t// Secret: required\n\t\tif (typeof uriParams.secret !== 'undefined' && SECRET_REGEX.test(uriParams.secret)) {\n\t\t\tconfig.secret = new Secret({ buffer: Utils.b32.encode(uriParams.secret) });\n\t\t} else {\n\t\t\tthrow new TypeError('Missing or invalid \\'secret\\' parameter');\n\t\t}\n\n\t\t// Algorithm: optional\n\t\tif (typeof uriParams.algorithm !== 'undefined') {\n\t\t\tif (ALGORITHM_REGEX.test(uriParams.algorithm)) {\n\t\t\t\tconfig.algorithm = uriParams.algorithm;\n\t\t\t} else {\n\t\t\t\tthrow new TypeError('Invalid \\'algorithm\\' parameter');\n\t\t\t}\n\t\t}\n\n\t\t// Digits: optional\n\t\tif (typeof uriParams.digits !== 'undefined') {\n\t\t\tif (POSITIVE_INTEGER_REGEX.test(uriParams.digits)) {\n\t\t\t\tconfig.digits = Number.parseInt(uriParams.digits, 10);\n\t\t\t} else {\n\t\t\t\tthrow new TypeError('Invalid \\'digits\\' parameter');\n\t\t\t}\n\t\t}\n\n\t\treturn new OTP(config);\n\t}\n\n\t/**\n\t * Converts an HOTP/TOTP object to a Google Authenticator key URI.\n\t * @method stringify\n\t * @param {Object} otp HOTP/TOTP object.\n\t * @param {Object} [config] Configuration options.\n\t * @param {boolean} [config.legacyIssuer=true] Set issuer label prefix.\n\t * @returns {string} Google Authenticator Key URI.\n\t */\n\tstatic stringify(otp, { legacyIssuer = true } = {}) {\n\t\tconst isHOTP = otp instanceof HOTP;\n\t\tconst isTOTP = otp instanceof TOTP;\n\n\t\tif (!isHOTP && !isTOTP) {\n\t\t\tthrow new TypeError('Invalid \\'HOTP/TOTP\\' object');\n\t\t}\n\n\t\t// Key URI format:\n\t\t// otpauth://TYPE/[ISSUER:]LABEL?PARAMETERS\n\t\tlet uri = 'otpauth://';\n\n\t\t// Type\n\t\turi += `${isTOTP ? 'totp' : 'hotp'}/`;\n\n\t\t// Label and optional issuer\n\t\tif (otp.issuer.length > 0) {\n\t\t\t// Legacy label prefix\n\t\t\tif (legacyIssuer) uri += `${encodeURIComponent(otp.issuer)}:`;\n\t\t\t// Label\n\t\t\turi += `${encodeURIComponent(otp.label)}?`;\n\t\t\t// Issuer\n\t\t\turi += `issuer=${encodeURIComponent(otp.issuer)}&`;\n\t\t} else {\n\t\t\t// Label\n\t\t\turi += `${encodeURIComponent(otp.label)}?`;\n\t\t}\n\n\t\t// Generic parameters\n\t\turi += `secret=${encodeURIComponent(otp.secret.b32)}`\n\t\t\t+ `&algorithm=${encodeURIComponent(otp.algorithm)}`\n\t\t\t+ `&digits=${encodeURIComponent(otp.digits)}`;\n\n\t\t// Extra parameters\n\t\tif (isTOTP) {\n\t\t\t// TOTP parameters\n\t\t\turi += `&period=${encodeURIComponent(otp.period)}`;\n\t\t} else {\n\t\t\t// HOTP parameters\n\t\t\turi += `&counter=${encodeURIComponent(otp.counter)}`;\n\t\t}\n\n\t\treturn uri;\n\t}\n}\n","import { Utils } from './utils';\nimport { Crypto } from './crypto';\nimport { Secret } from './secret';\n// eslint-disable-next-line import/no-cycle\nimport { URI } from './uri';\n\n/**\n * Default configuration.\n * @private\n * @type {Object}\n */\nconst defaults = {\n\tissuer: '',\n\tlabel: 'OTPAuth',\n\talgorithm: 'SHA1',\n\tdigits: 6,\n\tcounter: 0,\n\tperiod: 30,\n\twindow: 50,\n\tpad: true\n};\n\n/**\n * HOTP: An HMAC-based One-time Password Algorithm (RFC 4226).\n * @see https://tools.ietf.org/html/rfc4226\n */\nexport class HOTP {\n\t/**\n\t * @param {Object} [config] Configuration options.\n\t * @param {string} [config.issuer=''] Account provider.\n\t * @param {string} [config.label='OTPAuth'] Account label.\n\t * @param {Secret} [config.secret=Secret] Secret key.\n\t * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n\t * @param {number} [config.digits=6] Token length.\n\t * @param {number} [config.counter=0] Initial counter value.\n\t */\n\tconstructor({\n\t\tissuer = defaults.issuer,\n\t\tlabel = defaults.label,\n\t\tsecret = new Secret(),\n\t\talgorithm = defaults.algorithm,\n\t\tdigits = defaults.digits,\n\t\tcounter = defaults.counter\n\t} = {}) {\n\t\t/**\n\t\t * Account provider.\n\t\t * @type {string}\n\t\t */\n\t\tthis.issuer = issuer;\n\t\t/**\n\t\t * Account label.\n\t\t * @type {string}\n\t\t */\n\t\tthis.label = label;\n\t\t/**\n\t\t * Secret key.\n\t\t * @type {Secret}\n\t\t */\n\t\tthis.secret = secret;\n\t\t/**\n\t\t * HMAC hashing algorithm.\n\t\t * @type {string}\n\t\t */\n\t\tthis.algorithm = algorithm;\n\t\t/**\n\t\t * Token length.\n\t\t * @type {number}\n\t\t */\n\t\tthis.digits = digits;\n\t\t/**\n\t\t * Initial counter value.\n\t\t * @type {number}\n\t\t */\n\t\tthis.counter = counter;\n\t}\n\n\t/**\n\t * Generates an HOTP token.\n\t * @param {Object} config Configuration options.\n\t * @param {Secret} config.secret Secret key.\n\t * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n\t * @param {number} [config.digits=6] Token length.\n\t * @param {number} [config.counter=0] Counter value.\n\t * @param {boolean} [config.pad=true] Add leading zeros to result.\n\t * @returns {string|number} Token.\n\t */\n\tstatic generate({\n\t\tsecret,\n\t\talgorithm = defaults.algorithm,\n\t\tdigits = defaults.digits,\n\t\tcounter = defaults.counter,\n\t\tpad = defaults.pad\n\t}) {\n\t\tconst digest = new Uint8Array(Crypto.hmacDigest(algorithm, secret.buffer, Utils.uint.encode(counter)));\n\t\tconst offset = digest[digest.byteLength - 1] & 15;\n\t\tconst otp = (\n\t\t\t((digest[offset] & 127) << 24)\n\t\t\t| ((digest[offset + 1] & 255) << 16)\n\t\t\t| ((digest[offset + 2] & 255) << 8)\n\t\t\t| (digest[offset + 3] & 255)\n\t\t) % (10 ** digits);\n\n\t\treturn pad\n\t\t\t? new Array(1 + digits - String(otp).length).join('0') + otp\n\t\t\t: otp;\n\t}\n\n\t/**\n\t * Generates an HOTP token.\n\t * @param {Object} [config] Configuration options.\n\t * @param {number} [config.counter=this.counter++] Counter value.\n\t * @param {boolean} [config.pad=true] Add leading zeros to result.\n\t * @returns {string|number} Token.\n\t */\n\tgenerate({\n\t\tcounter = this.counter++,\n\t\tpad\n\t} = {}) {\n\t\treturn HOTP.generate({\n\t\t\tsecret: this.secret,\n\t\t\talgorithm: this.algorithm,\n\t\t\tdigits: this.digits,\n\t\t\tcounter,\n\t\t\tpad\n\t\t});\n\t}\n\n\t/**\n\t * Validates an HOTP token.\n\t * @param {Object} config Configuration options.\n\t * @param {string} config.token Token value.\n\t * @param {Secret} config.secret Secret key.\n\t * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n\t * @param {number} [config.counter=0] Counter value.\n\t * @param {number} [config.window=50] Window of counter values to test.\n\t * @returns {number|null} Token delta, or null if the token is not found.\n\t */\n\tstatic validate({\n\t\ttoken,\n\t\tsecret,\n\t\talgorithm,\n\t\tcounter = defaults.counter,\n\t\twindow = defaults.window\n\t}) {\n\t\tconst searchToken = Number.parseInt(token, 10);\n\n\t\tfor (let i = counter - window; i <= counter + window; ++i) {\n\t\t\tconst generatedToken = HOTP.generate({\n\t\t\t\tsecret,\n\t\t\t\talgorithm,\n\t\t\t\tcounter: i,\n\t\t\t\tdigits: token.length,\n\t\t\t\tpad: false\n\t\t\t});\n\n\t\t\tif (searchToken === generatedToken) {\n\t\t\t\treturn i - counter;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Validates an HOTP token.\n\t * @param {Object} config Configuration options.\n\t * @param {string} config.token Token value.\n\t * @param {number} [config.counter=this.counter] Counter value.\n\t * @param {number} [config.window=50] Window of counter values to test.\n\t * @returns {number|null} Token delta, or null if the token is not found.\n\t */\n\tvalidate({\n\t\ttoken,\n\t\tcounter = this.counter,\n\t\twindow\n\t}) {\n\t\treturn HOTP.validate({\n\t\t\ttoken,\n\t\t\tsecret: this.secret,\n\t\t\talgorithm: this.algorithm,\n\t\t\tcounter,\n\t\t\twindow\n\t\t});\n\t}\n\n\t/**\n\t * Returns a Google Authenticator key URI.\n\t * @returns {string} URI.\n\t */\n\ttoString() {\n\t\treturn URI.stringify(this);\n\t}\n}\n\n/**\n * TOTP: Time-Based One-Time Password Algorithm (RFC 6238).\n * @see https://tools.ietf.org/html/rfc6238\n */\nexport class TOTP {\n\t/**\n\t * @param {Object} [config] Configuration options.\n\t * @param {string} [config.issuer=''] Account provider.\n\t * @param {string} [config.label='OTPAuth'] Account label.\n\t * @param {Secret} [config.secret=Secret] Secret key.\n\t * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n\t * @param {number} [config.digits=6] Token length.\n\t * @param {number} [config.period=30] Token time-step duration.\n\t */\n\tconstructor({\n\t\tissuer = defaults.issuer,\n\t\tlabel = defaults.label,\n\t\tsecret = new Secret(),\n\t\talgorithm = defaults.algorithm,\n\t\tdigits = defaults.digits,\n\t\tperiod = defaults.period\n\t} = {}) {\n\t\t/**\n\t\t * Account provider.\n\t\t * @type {string}\n\t\t */\n\t\tthis.issuer = issuer;\n\t\t/**\n\t\t * Account label.\n\t\t * @type {string}\n\t\t */\n\t\tthis.label = label;\n\t\t/**\n\t\t * Secret key.\n\t\t * @type {string}\n\t\t */\n\t\tthis.secret = secret;\n\t\t/**\n\t\t * HMAC hashing algorithm.\n\t\t * @type {Secret}\n\t\t */\n\t\tthis.algorithm = algorithm;\n\t\t/**\n\t\t * Token length.\n\t\t * @type {number}\n\t\t */\n\t\tthis.digits = digits;\n\t\t/**\n\t\t * Token time-step duration.\n\t\t * @type {number}\n\t\t */\n\t\tthis.period = period;\n\t}\n\n\t/**\n\t * Generates a TOTP token.\n\t * @param {Object} config Configuration options.\n\t * @param {Secret} config.secret Secret key.\n\t * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n\t * @param {number} [config.digits=6] Token length.\n\t * @param {number} [config.period=30] Token time-step duration.\n\t * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n\t * @param {boolean} [config.pad=true] Add leading zeros to result.\n\t * @returns {string|number} Token.\n\t */\n\tstatic generate({\n\t\tsecret,\n\t\talgorithm,\n\t\tdigits,\n\t\tperiod = defaults.period,\n\t\ttimestamp = Date.now(),\n\t\tpad\n\t}) {\n\t\treturn HOTP.generate({\n\t\t\tsecret,\n\t\t\talgorithm,\n\t\t\tdigits,\n\t\t\tcounter: Math.floor(timestamp / 1000 / period),\n\t\t\tpad\n\t\t});\n\t}\n\n\t/**\n\t * Generates a TOTP token.\n\t * @param {Object} [config] Configuration options.\n\t * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n\t * @param {boolean} [config.pad=true] Add leading zeros to result.\n\t * @returns {string|number} Token.\n\t */\n\tgenerate({\n\t\ttimestamp = Date.now(),\n\t\tpad\n\t} = {}) {\n\t\treturn TOTP.generate({\n\t\t\tsecret: this.secret,\n\t\t\talgorithm: this.algorithm,\n\t\t\tdigits: this.digits,\n\t\t\tperiod: this.period,\n\t\t\ttimestamp,\n\t\t\tpad\n\t\t});\n\t}\n\n\t/**\n\t * Validates a TOTP token.\n\t * @param {Object} config Configuration options.\n\t * @param {string} config.token Token value.\n\t * @param {Secret} config.secret Secret key.\n\t * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n\t * @param {number} [config.period=30] Token time-step duration.\n\t * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n\t * @param {number} [config.window=50] Window of counter values to test.\n\t * @returns {number|null} Token delta, or null if the token is not found.\n\t */\n\tstatic validate({\n\t\ttoken,\n\t\tsecret,\n\t\talgorithm,\n\t\tperiod = defaults.period,\n\t\ttimestamp = Date.now(),\n\t\twindow\n\t}) {\n\t\treturn HOTP.validate({\n\t\t\ttoken,\n\t\t\tsecret,\n\t\t\talgorithm,\n\t\t\tcounter: Math.floor(timestamp / 1000 / period),\n\t\t\twindow\n\t\t});\n\t}\n\n\t/**\n\t * Validates a TOTP token.\n\t * @param {Object} config Configuration options.\n\t * @param {string} config.token Token value.\n\t * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n\t * @param {number} [config.window=50] Window of counter values to test.\n\t * @returns {number|null} Token delta, or null if the token is not found.\n\t */\n\tvalidate({\n\t\ttoken,\n\t\ttimestamp,\n\t\twindow\n\t}) {\n\t\treturn TOTP.validate({\n\t\t\ttoken,\n\t\t\tsecret: this.secret,\n\t\t\talgorithm: this.algorithm,\n\t\t\tperiod: this.period,\n\t\t\ttimestamp,\n\t\t\twindow\n\t\t});\n\t}\n\n\t/**\n\t * Returns a Google Authenticator key URI.\n\t * @returns {string} URI.\n\t */\n\ttoString() {\n\t\treturn URI.stringify(this);\n\t}\n}\n","/**\n * One Time Password (HOTP/TOTP) library for Node.js and browser.\n * @module OTPAuth\n * @author Héctor Molinero Fernández <hector@molinero.dev>\n */\nexport { HOTP, TOTP } from './otp';\nexport { URI } from './uri';\nexport { Secret } from './secret';\nexport { Utils } from './utils';\n\n/**\n * Library version.\n * @type {string}\n */\nexport const version = process.env.VERSION;\n"],"sourceRoot":""}
##############################################
/src/dist/otpauth.min.js.map:1:{"version":3,"sources":["webpack://OTPAuth/ [synthetic:base] ","webpack://OTPAuth/ [synthetic:es6/util/arrayiterator] ","webpack://OTPAuth/ [synthetic:util/defines] ","webpack://OTPAuth/ [synthetic:util/defineproperty] ","webpack://OTPAuth/ [synthetic:util/global] ","webpack://OTPAuth/ [synthetic:es6/symbol] ","webpack://OTPAuth/ [synthetic:util/polyfill] ","webpack://OTPAuth/ [synthetic:es6/number/parseint] ","webpack://OTPAuth/webpack/universalModuleDefinition","webpack://OTPAuth/otpauth.min.js","webpack://OTPAuth/webpack/bootstrap","webpack://OTPAuth/./src/utils.js","webpack://OTPAuth//tmp/tmp-9610ks1K9cTFdJTB","webpack://OTPAuth/./src/crypto.js","webpack://OTPAuth/(webpack)/buildin/global.js","webpack://OTPAuth/./src/secret.js","webpack://OTPAuth/./src/uri.js","webpack://OTPAuth/./src/otp.js","webpack://OTPAuth/./src/main.js"],"names":["webpackUniversalModuleDefinition","root","factory","exports","module","define","amd","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","__webpack_require__.d","name","getter","o","Object","defineProperty","enumerable","get","r","__webpack_require__.r","Symbol","toStringTag","value","t","__webpack_require__.t","mode","__esModule","ns","create","key","bind","n","__webpack_require__.n","getDefault","getModuleExports","__webpack_require__.o","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","global","Utils","InternalUtils","uint","decode","Utils.uint.decode","buf","arr","Uint8Array","num","length","encode","Utils.uint.encode","ArrayBuffer","acc","raw","Utils.raw.decode","str","String","fromCharCode","Utils.raw.encode","charCodeAt","b32","alphabet","Utils.b32.decode","bits","Utils.b32.encode","strUpp","toUpperCase","index","idx","indexOf","TypeError","hex","Utils.hex.decode","hexByte","toString","Utils.hex.encode","Number","parseInt","substr","isNode","require","InternalUtils.require","eval","sjcl","cipher","hash","keyexchange","misc","codec","exception","corrupt","message","this.toString","invalid","bug","notReady","bitSlice","a","bstart","bend","bitArray","_shiftRight","slice","undefined","clamp","extract","blength","sh","Math","floor","x","concat","a1","a2","last","shift","getPartial","bitLength","len","ceil","partial","_end","round","equal","b","carry","out","push","shift2","last2","pop","_xor4","y","byteswapM","v","globals","globals.ArrayBuffer","DataView","globals.DataView","arrayBuffer","fromBits","padding","padding_count","ol","tmp","setUint32","byteLength","buffer","smallest","setUint8","getUint8","toBits","inView","getUint32","hexDumpBuffer","stringBufferView","string","getUint16","width","Array","join","console","log","sha1","sjcl.hash.sha1","_h","_buffer","_length","reset","sjcl.hash.sha1.hash","data","update","finalize","blockSize","_init","utf8String","nl","Uint32Array","j","_block","subarray","splice","h","_key","_f","_S","words","w","e","sha256","sjcl.hash.sha256","_precompute","sjcl.hash.sha256.hash","frac","prime","factor","isPrime","pow","k","h0","h1","h2","h3","h4","h5","h6","h7","sha512","sjcl.hash.sha512","sjcl.hash.sha512.hash","_initr","_keyr","frac2","h0h","h0l","h1h","h1l","h2h","h2l","h3h","h3l","h4h","h4l","h5h","h5l","h6h","h6l","h7h","h7l","ah","al","bh","bl","ch","cl","dh","dl","eh","el","fh","fl","gh","gl","hh","hl","wrh","wrl","gamma0xh","gamma0xl","gamma0h","gamma0l","gamma1xh","gamma1xl","gamma1h","gamma1l","wr7h","wr16h","wr16l","wr7l","chh","chl","majh","majl","sigma0h","sigma0l","krh","krl","t1l","t1h","t2l","t2h","hmac","sjcl.misc.hmac","Hash","_hash","exKey","bs","_baseHash","_resultHash","encrypt","mac","sjcl.misc.hmac.prototype.mac","_updated","digest","sjcl.misc.hmac.prototype.reset","sjcl.misc.hmac.prototype.update","sjcl.misc.hmac.prototype.digest","result","Crypto","sjcl__WEBPACK_IMPORTED_MODULE_0__","NodeCrypto","_utils__WEBPACK_IMPORTED_MODULE_1__","bufferFrom","Buffer","from","arrbuf","nodeBuf","bufferTo","randomBytes","Crypto.randomBytes","size","buff","hmacDigest","Crypto.hmacDigest","algorithm","createHmac","crypto","getRandomValues","msCrypto","warn","random","toLowerCase","g","Function","window","utils","src_crypto","secret_Secret","constructor","fromRaw","fromB32","fromHex","configurable","writable","OTPURI_REGEX","SECRET_REGEX","ALGORITHM_REGEX","INTEGER_REGEX","POSITIVE_INTEGER_REGEX","uri_URI","parse","uri","uriGroups","match","error","isArray","URIError","uriType","uriLabel","split","map","decodeURIComponent","uriParams","reduce","cur","pairArr","pairKey","pairVal","config","OTP","otp_HOTP","counter","test","otp_TOTP","period","label","issuer","secret","digits","stringify","otp","legacyIssuer","isTOTP","encodeURIComponent","generate","pad","offset","validate","token","searchToken","generatedToken","timestamp","Date","now","version"],"mappings":"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","file":"otpauth.min.js","sourcesContent":["","","","","","","","","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"OTPAuth\"] = factory();\n\telse\n\t\troot[\"OTPAuth\"] = factory();\n})(this, function() {\nreturn ","/*! otpauth v3.2.7 | (c) Héctor Molinero Fernández <hector@molinero.dev> | https://github.com/hectorm/otpauth | MIT */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"OTPAuth\"] = factory();\n\telse\n\t\troot[\"OTPAuth\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 4);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return Utils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return InternalUtils; });\n/**\n * An object containing some utilities.\n * @type {Object}\n */\nconst Utils = {};\n\n/**\n * UInt conversion.\n * @type {Object}\n */\nUtils.uint = {};\n\n/**\n * Converts an ArrayBuffer to an integer.\n * @param {ArrayBuffer} buf ArrayBuffer.\n * @returns {number} Integer.\n */\nUtils.uint.decode = buf => {\n\tconst arr = new Uint8Array(buf);\n\tlet num = 0;\n\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tif (arr[i] !== 0) {\n\t\t\tnum *= 256;\n\t\t\tnum += arr[i];\n\t\t}\n\t}\n\n\treturn num;\n};\n\n/**\n * Converts an integer to an ArrayBuffer.\n * @param {number} num Integer.\n * @returns {ArrayBuffer} ArrayBuffer.\n */\nUtils.uint.encode = num => {\n\tconst buf = new ArrayBuffer(8);\n\tconst arr = new Uint8Array(buf);\n\tlet acc = num;\n\n\tfor (let i = 7; i >= 0; i--) {\n\t\tif (acc === 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tarr[i] = acc & 255;\n\t\tacc -= arr[i];\n\t\tacc /= 256;\n\t}\n\n\treturn buf;\n};\n\n/**\n * Raw string conversion.\n * @type {Object}\n */\nUtils.raw = {};\n\n/**\n * Converts an ArrayBuffer to a string.\n * @param {ArrayBuffer} buf ArrayBuffer.\n * @returns {string} String.\n */\nUtils.raw.decode = buf => {\n\tconst arr = new Uint8Array(buf);\n\tlet str = '';\n\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tstr += String.fromCharCode(arr[i]);\n\t}\n\n\treturn str;\n};\n\n/**\n * Converts a string to an ArrayBuffer.\n * @param {string} str String.\n * @returns {ArrayBuffer} ArrayBuffer.\n */\nUtils.raw.encode = str => {\n\tconst buf = new ArrayBuffer(str.length);\n\tconst arr = new Uint8Array(buf);\n\n\tfor (let i = 0; i < str.length; i++) {\n\t\tarr[i] = str.charCodeAt(i);\n\t}\n\n\treturn buf;\n};\n\n/**\n * Base32 string conversion.\n * @type {Object}\n */\nUtils.b32 = {};\n\n/**\n * RFC 4648 base32 alphabet without pad.\n * @type {string}\n */\nUtils.b32.alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';\n\n/**\n * Converts an ArrayBuffer to a base32 string (RFC 4648).\n * @see https://github.com/LinusU/base32-decode\n * @param {ArrayBuffer} buf ArrayBuffer.\n * @returns {string} Base32 string.\n */\nUtils.b32.decode = buf => {\n\tconst arr = new Uint8Array(buf);\n\n\tlet bits = 0;\n\tlet value = 0;\n\tlet str = '';\n\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tvalue = (value << 8) | arr[i];\n\t\tbits += 8;\n\n\t\twhile (bits >= 5) {\n\t\t\tstr += Utils.b32.alphabet[(value >>> bits - 5) & 31];\n\t\t\tbits -= 5;\n\t\t}\n\t}\n\n\tif (bits > 0) {\n\t\tstr += Utils.b32.alphabet[(value << 5 - bits) & 31];\n\t}\n\n\treturn str;\n};\n\n/**\n * Converts a base32 string to an ArrayBuffer (RFC 4648).\n * @see https://github.com/LinusU/base32-encode\n * @param {string} str Base32 string.\n * @returns {ArrayBuffer} ArrayBuffer.\n */\nUtils.b32.encode = str => {\n\tconst strUpp = str.toUpperCase();\n\tconst buf = new ArrayBuffer(str.length * 5 / 8 | 0);\n\tconst arr = new Uint8Array(buf);\n\n\tlet bits = 0;\n\tlet value = 0;\n\tlet index = 0;\n\n\tfor (let i = 0; i < strUpp.length; i++) {\n\t\tconst idx = Utils.b32.alphabet.indexOf(strUpp[i]);\n\n\t\tif (idx === -1) {\n\t\t\tthrow new TypeError(`Invalid character found: ${strUpp[i]}`);\n\t\t}\n\n\t\tvalue = (value << 5) | idx;\n\t\tbits += 5;\n\n\t\tif (bits >= 8) {\n\t\t\tarr[index++] = (value >>> bits - 8) & 255;\n\t\t\tbits -= 8;\n\t\t}\n\t}\n\n\treturn buf;\n};\n\n/**\n * Hexadecimal string conversion.\n * @type {Object}\n */\nUtils.hex = {};\n\n/**\n * Converts an ArrayBuffer to a hexadecimal string.\n * @param {ArrayBuffer} buf ArrayBuffer.\n * @returns {string} Hexadecimal string.\n */\nUtils.hex.decode = buf => {\n\tconst arr = new Uint8Array(buf);\n\tlet str = '';\n\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tconst hexByte = arr[i].toString(16);\n\n\t\tstr += hexByte.length === 1\n\t\t\t? `0${hexByte}`\n\t\t\t: hexByte;\n\t}\n\n\treturn str.toUpperCase();\n};\n\n/**\n * Converts a hexadecimal string to an ArrayBuffer.\n * @param {string} str Hexadecimal string.\n * @returns {ArrayBuffer} ArrayBuffer.\n */\nUtils.hex.encode = str => {\n\tconst buf = new ArrayBuffer(str.length / 2);\n\tconst arr = new Uint8Array(buf);\n\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tarr[i] = Number.parseInt(str.substr(i * 2, 2), 16);\n\t}\n\n\treturn buf;\n};\n\n/**\n * An object containing some utilities (for internal use only).\n * @private\n * @type {Object}\n */\nconst InternalUtils = {};\n\n/**\n * Detect if running in \"Node.js\".\n * @type {boolean}\n */\n// eslint-disable-next-line dot-notation\nInternalUtils.isNode = Object.prototype.toString.call(global['process']) === '[object process]';\n\n/**\n * Dynamically import \"Node.js\" modules.\n * @param {string} name Name.\n * @returns {Object} Module.\n */\n// eslint-disable-next-line no-eval\nInternalUtils.require = name => (InternalUtils.isNode ? eval('require')(name) : null);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(3)))\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n\t\t\t\t\t/** @fileOverview Javascript cryptography implementation.\n *\n * Crush to remove comments, shorten variable names and\n * generally reduce transmission size.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n\n/*jslint indent: 2, bitwise: false, nomen: false, plusplus: false, white: false, regexp: false */\n/*global document, window, escape, unescape, module, require, Uint32Array */\n\n/**\n * The Stanford Javascript Crypto Library, top-level namespace.\n * @namespace\n */\nvar sjcl = {\n  /**\n   * Symmetric ciphers.\n   * @namespace\n   */\n  cipher: {},\n\n  /**\n   * Hash functions.  Right now only SHA256 is implemented.\n   * @namespace\n   */\n  hash: {},\n\n  /**\n   * Key exchange functions.  Right now only SRP is implemented.\n   * @namespace\n   */\n  keyexchange: {},\n  \n  /**\n   * Cipher modes of operation.\n   * @namespace\n   */\n  mode: {},\n\n  /**\n   * Miscellaneous.  HMAC and PBKDF2.\n   * @namespace\n   */\n  misc: {},\n  \n  /**\n   * Bit array encoders and decoders.\n   * @namespace\n   *\n   * @description\n   * The members of this namespace are functions which translate between\n   * SJCL's bitArrays and other objects (usually strings).  Because it\n   * isn't always clear which direction is encoding and which is decoding,\n   * the method names are \"fromBits\" and \"toBits\".\n   */\n  codec: {},\n  \n  /**\n   * Exceptions.\n   * @namespace\n   */\n  exception: {\n    /**\n     * Ciphertext is corrupt.\n     * @constructor\n     */\n    corrupt: function(message) {\n      this.toString = function() { return \"CORRUPT: \"+this.message; };\n      this.message = message;\n    },\n    \n    /**\n     * Invalid parameter.\n     * @constructor\n     */\n    invalid: function(message) {\n      this.toString = function() { return \"INVALID: \"+this.message; };\n      this.message = message;\n    },\n    \n    /**\n     * Bug or missing feature in SJCL.\n     * @constructor\n     */\n    bug: function(message) {\n      this.toString = function() { return \"BUG: \"+this.message; };\n      this.message = message;\n    },\n\n    /**\n     * Something isn't ready.\n     * @constructor\n     */\n    notReady: function(message) {\n      this.toString = function() { return \"NOT READY: \"+this.message; };\n      this.message = message;\n    }\n  }\n};\n/** @fileOverview Arrays of bits, encoded as arrays of Numbers.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/**\n * Arrays of bits, encoded as arrays of Numbers.\n * @namespace\n * @description\n * <p>\n * These objects are the currency accepted by SJCL's crypto functions.\n * </p>\n *\n * <p>\n * Most of our crypto primitives operate on arrays of 4-byte words internally,\n * but many of them can take arguments that are not a multiple of 4 bytes.\n * This library encodes arrays of bits (whose size need not be a multiple of 8\n * bits) as arrays of 32-bit words.  The bits are packed, big-endian, into an\n * array of words, 32 bits at a time.  Since the words are double-precision\n * floating point numbers, they fit some extra data.  We use this (in a private,\n * possibly-changing manner) to encode the number of bits actually  present\n * in the last word of the array.\n * </p>\n *\n * <p>\n * Because bitwise ops clear this out-of-band data, these arrays can be passed\n * to ciphers like AES which want arrays of words.\n * </p>\n */\nsjcl.bitArray = {\n  /**\n   * Array slices in units of bits.\n   * @param {bitArray} a The array to slice.\n   * @param {Number} bstart The offset to the start of the slice, in bits.\n   * @param {Number} bend The offset to the end of the slice, in bits.  If this is undefined,\n   * slice until the end of the array.\n   * @return {bitArray} The requested slice.\n   */\n  bitSlice: function (a, bstart, bend) {\n    a = sjcl.bitArray._shiftRight(a.slice(bstart/32), 32 - (bstart & 31)).slice(1);\n    return (bend === undefined) ? a : sjcl.bitArray.clamp(a, bend-bstart);\n  },\n\n  /**\n   * Extract a number packed into a bit array.\n   * @param {bitArray} a The array to slice.\n   * @param {Number} bstart The offset to the start of the slice, in bits.\n   * @param {Number} blength The length of the number to extract.\n   * @return {Number} The requested slice.\n   */\n  extract: function(a, bstart, blength) {\n    // FIXME: this Math.floor is not necessary at all, but for some reason\n    // seems to suppress a bug in the Chromium JIT.\n    var x, sh = Math.floor((-bstart-blength) & 31);\n    if ((bstart + blength - 1 ^ bstart) & -32) {\n      // it crosses a boundary\n      x = (a[bstart/32|0] << (32 - sh)) ^ (a[bstart/32+1|0] >>> sh);\n    } else {\n      // within a single word\n      x = a[bstart/32|0] >>> sh;\n    }\n    return x & ((1<<blength) - 1);\n  },\n\n  /**\n   * Concatenate two bit arrays.\n   * @param {bitArray} a1 The first array.\n   * @param {bitArray} a2 The second array.\n   * @return {bitArray} The concatenation of a1 and a2.\n   */\n  concat: function (a1, a2) {\n    if (a1.length === 0 || a2.length === 0) {\n      return a1.concat(a2);\n    }\n    \n    var last = a1[a1.length-1], shift = sjcl.bitArray.getPartial(last);\n    if (shift === 32) {\n      return a1.concat(a2);\n    } else {\n      return sjcl.bitArray._shiftRight(a2, shift, last|0, a1.slice(0,a1.length-1));\n    }\n  },\n\n  /**\n   * Find the length of an array of bits.\n   * @param {bitArray} a The array.\n   * @return {Number} The length of a, in bits.\n   */\n  bitLength: function (a) {\n    var l = a.length, x;\n    if (l === 0) { return 0; }\n    x = a[l - 1];\n    return (l-1) * 32 + sjcl.bitArray.getPartial(x);\n  },\n\n  /**\n   * Truncate an array.\n   * @param {bitArray} a The array.\n   * @param {Number} len The length to truncate to, in bits.\n   * @return {bitArray} A new array, truncated to len bits.\n   */\n  clamp: function (a, len) {\n    if (a.length * 32 < len) { return a; }\n    a = a.slice(0, Math.ceil(len / 32));\n    var l = a.length;\n    len = len & 31;\n    if (l > 0 && len) {\n      a[l-1] = sjcl.bitArray.partial(len, a[l-1] & 0x80000000 >> (len-1), 1);\n    }\n    return a;\n  },\n\n  /**\n   * Make a partial word for a bit array.\n   * @param {Number} len The number of bits in the word.\n   * @param {Number} x The bits.\n   * @param {Number} [_end=0] Pass 1 if x has already been shifted to the high side.\n   * @return {Number} The partial word.\n   */\n  partial: function (len, x, _end) {\n    if (len === 32) { return x; }\n    return (_end ? x|0 : x << (32-len)) + len * 0x10000000000;\n  },\n\n  /**\n   * Get the number of bits used by a partial word.\n   * @param {Number} x The partial word.\n   * @return {Number} The number of bits used by the partial word.\n   */\n  getPartial: function (x) {\n    return Math.round(x/0x10000000000) || 32;\n  },\n\n  /**\n   * Compare two arrays for equality in a predictable amount of time.\n   * @param {bitArray} a The first array.\n   * @param {bitArray} b The second array.\n   * @return {boolean} true if a == b; false otherwise.\n   */\n  equal: function (a, b) {\n    if (sjcl.bitArray.bitLength(a) !== sjcl.bitArray.bitLength(b)) {\n      return false;\n    }\n    var x = 0, i;\n    for (i=0; i<a.length; i++) {\n      x |= a[i]^b[i];\n    }\n    return (x === 0);\n  },\n\n  /** Shift an array right.\n   * @param {bitArray} a The array to shift.\n   * @param {Number} shift The number of bits to shift.\n   * @param {Number} [carry=0] A byte to carry in\n   * @param {bitArray} [out=[]] An array to prepend to the output.\n   * @private\n   */\n  _shiftRight: function (a, shift, carry, out) {\n    var i, last2=0, shift2;\n    if (out === undefined) { out = []; }\n    \n    for (; shift >= 32; shift -= 32) {\n      out.push(carry);\n      carry = 0;\n    }\n    if (shift === 0) {\n      return out.concat(a);\n    }\n    \n    for (i=0; i<a.length; i++) {\n      out.push(carry | a[i]>>>shift);\n      carry = a[i] << (32-shift);\n    }\n    last2 = a.length ? a[a.length-1] : 0;\n    shift2 = sjcl.bitArray.getPartial(last2);\n    out.push(sjcl.bitArray.partial(shift+shift2 & 31, (shift + shift2 > 32) ? carry : out.pop(),1));\n    return out;\n  },\n  \n  /** xor a block of 4 words together.\n   * @private\n   */\n  _xor4: function(x,y) {\n    return [x[0]^y[0],x[1]^y[1],x[2]^y[2],x[3]^y[3]];\n  },\n\n  /** byteswap a word array inplace.\n   * (does not handle partial words)\n   * @param {sjcl.bitArray} a word array\n   * @return {sjcl.bitArray} byteswapped array\n   */\n  byteswapM: function(a) {\n    var i, v, m = 0xff00;\n    for (i = 0; i < a.length; ++i) {\n      v = a[i];\n      a[i] = (v >>> 24) | ((v >>> 8) & m) | ((v & m) << 8) | (v << 24);\n    }\n    return a;\n  }\n};\n/** @fileOverview Bit array codec implementations.\n *\n * @author Marco Munizaga\n */\n\n//patch arraybuffers if they don't exist\nif (typeof(ArrayBuffer) === 'undefined') {\n  (function(globals){\n      \"use strict\";\n      globals.ArrayBuffer = function(){};\n      globals.DataView = function(){};\n  }(undefined));\n}\n\n/**\n * ArrayBuffer\n * @namespace\n */\nsjcl.codec.arrayBuffer = {\n  /** Convert from a bitArray to an ArrayBuffer. \n   * Will default to 8byte padding if padding is undefined*/\n  fromBits: function (arr, padding, padding_count) {\n    var out, i, ol, tmp, smallest;\n    padding = padding==undefined  ? true : padding;\n    padding_count = padding_count || 8;\n\n    if (arr.length === 0) {\n      return new ArrayBuffer(0);\n    }\n\n    ol = sjcl.bitArray.bitLength(arr)/8;\n\n    //check to make sure the bitLength is divisible by 8, if it isn't \n    //we can't do anything since arraybuffers work with bytes, not bits\n    if ( sjcl.bitArray.bitLength(arr)%8 !== 0 ) {\n      throw new sjcl.exception.invalid(\"Invalid bit size, must be divisble by 8 to fit in an arraybuffer correctly\");\n    }\n\n    if (padding && ol%padding_count !== 0){\n      ol += padding_count - (ol%padding_count);\n    }\n\n\n    //padded temp for easy copying\n    tmp = new DataView(new ArrayBuffer(arr.length*4));\n    for (i=0; i<arr.length; i++) {\n      tmp.setUint32(i*4, (arr[i]<<32)); //get rid of the higher bits\n    }\n\n    //now copy the final message if we are not going to 0 pad\n    out = new DataView(new ArrayBuffer(ol));\n\n    //save a step when the tmp and out bytelength are ===\n    if (out.byteLength === tmp.byteLength){\n      return tmp.buffer;\n    }\n\n    smallest = tmp.byteLength < out.byteLength ? tmp.byteLength : out.byteLength;\n    for(i=0; i<smallest; i++){\n      out.setUint8(i,tmp.getUint8(i));\n    }\n\n\n    return out.buffer;\n  },\n  /** Convert from an ArrayBuffer to a bitArray. */\n  toBits: function (buffer) {\n    var i, out=[], len, inView, tmp;\n\n    if (buffer.byteLength === 0) {\n      return [];\n    }\n\n    inView = new DataView(buffer);\n    len = inView.byteLength - inView.byteLength%4;\n\n    for (var i = 0; i < len; i+=4) {\n      out.push(inView.getUint32(i));\n    }\n\n    if (inView.byteLength%4 != 0) {\n      tmp = new DataView(new ArrayBuffer(4));\n      for (var i = 0, l = inView.byteLength%4; i < l; i++) {\n        //we want the data to the right, because partial slices off the starting bits\n        tmp.setUint8(i+4-l, inView.getUint8(len+i)); // big-endian, \n      }\n      out.push(\n        sjcl.bitArray.partial( (inView.byteLength%4)*8, tmp.getUint32(0) )\n      ); \n    }\n    return out;\n  },\n\n\n\n  /** Prints a hex output of the buffer contents, akin to hexdump **/\n  hexDumpBuffer: function(buffer){\n      var stringBufferView = new DataView(buffer);\n      var string = '';\n      var pad = function (n, width) {\n          n = n + '';\n          return n.length >= width ? n : new Array(width - n.length + 1).join('0') + n;\n      };\n\n      for (var i = 0; i < stringBufferView.byteLength; i+=2) {\n          if (i%16 == 0) string += ('\\n'+(i).toString(16)+'\\t');\n          string += ( pad(stringBufferView.getUint16(i).toString(16),4) + ' ');\n      }\n\n      if ( typeof console === undefined ){\n        console = console || {log:function(){}}; //fix for IE\n      }\n      console.log(string.toUpperCase());\n  }\n};\n\n/** @fileOverview Javascript SHA-1 implementation.\n *\n * Based on the implementation in RFC 3174, method 1, and on the SJCL\n * SHA-256 implementation.\n *\n * @author Quinn Slack\n */\n\n/**\n * Context for a SHA-1 operation in progress.\n * @constructor\n */\nsjcl.hash.sha1 = function (hash) {\n  if (hash) {\n    this._h = hash._h.slice(0);\n    this._buffer = hash._buffer.slice(0);\n    this._length = hash._length;\n  } else {\n    this.reset();\n  }\n};\n\n/**\n * Hash a string or an array of words.\n * @static\n * @param {bitArray|String} data the data to hash.\n * @return {bitArray} The hash value, an array of 5 big-endian words.\n */\nsjcl.hash.sha1.hash = function (data) {\n  return (new sjcl.hash.sha1()).update(data).finalize();\n};\n\nsjcl.hash.sha1.prototype = {\n  /**\n   * The hash's block size, in bits.\n   * @constant\n   */\n  blockSize: 512,\n   \n  /**\n   * Reset the hash state.\n   * @return this\n   */\n  reset:function () {\n    this._h = this._init.slice(0);\n    this._buffer = [];\n    this._length = 0;\n    return this;\n  },\n  \n  /**\n   * Input several words to the hash.\n   * @param {bitArray|String} data the data to hash.\n   * @return this\n   */\n  update: function (data) {\n    if (typeof data === \"string\") {\n      data = sjcl.codec.utf8String.toBits(data);\n    }\n    var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),\n        ol = this._length,\n        nl = this._length = ol + sjcl.bitArray.bitLength(data);\n    if (nl > 9007199254740991){\n      throw new sjcl.exception.invalid(\"Cannot hash more than 2^53 - 1 bits\");\n    }\n\n    if (typeof Uint32Array !== 'undefined') {\n\tvar c = new Uint32Array(b);\n    \tvar j = 0;\n    \tfor (i = this.blockSize+ol - ((this.blockSize+ol) & (this.blockSize-1)); i <= nl;\n\t\ti+= this.blockSize) {\n      \t    this._block(c.subarray(16 * j, 16 * (j+1)));\n      \t    j += 1;\n    \t}\n    \tb.splice(0, 16 * j);\n    } else {\n    \tfor (i = this.blockSize+ol - ((this.blockSize+ol) & (this.blockSize-1)); i <= nl;\n             i+= this.blockSize) {\n      \t     this._block(b.splice(0,16));\n      \t}\n    }\n    return this;\n  },\n  \n  /**\n   * Complete hashing and output the hash value.\n   * @return {bitArray} The hash value, an array of 5 big-endian words. TODO\n   */\n  finalize:function () {\n    var i, b = this._buffer, h = this._h;\n\n    // Round out and push the buffer\n    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);\n    // Round out the buffer to a multiple of 16 words, less the 2 length words.\n    for (i = b.length + 2; i & 15; i++) {\n      b.push(0);\n    }\n\n    // append the length\n    b.push(Math.floor(this._length / 0x100000000));\n    b.push(this._length | 0);\n\n    while (b.length) {\n      this._block(b.splice(0,16));\n    }\n\n    this.reset();\n    return h;\n  },\n\n  /**\n   * The SHA-1 initialization vector.\n   * @private\n   */\n  _init:[0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0],\n\n  /**\n   * The SHA-1 hash key.\n   * @private\n   */\n  _key:[0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6],\n\n  /**\n   * The SHA-1 logical functions f(0), f(1), ..., f(79).\n   * @private\n   */\n  _f:function(t, b, c, d) {\n    if (t <= 19) {\n      return (b & c) | (~b & d);\n    } else if (t <= 39) {\n      return b ^ c ^ d;\n    } else if (t <= 59) {\n      return (b & c) | (b & d) | (c & d);\n    } else if (t <= 79) {\n      return b ^ c ^ d;\n    }\n  },\n\n  /**\n   * Circular left-shift operator.\n   * @private\n   */\n  _S:function(n, x) {\n    return (x << n) | (x >>> 32-n);\n  },\n  \n  /**\n   * Perform one cycle of SHA-1.\n   * @param {Uint32Array|bitArray} words one block of words.\n   * @private\n   */\n  _block:function (words) {\n    var t, tmp, a, b, c, d, e,\n    h = this._h;\n    var w;\n    if (typeof Uint32Array !== 'undefined') {\n        // When words is passed to _block, it has 16 elements. SHA1 _block\n        // function extends words with new elements (at the end there are 80 elements). \n        // The problem is that if we use Uint32Array instead of Array, \n        // the length of Uint32Array cannot be changed. Thus, we replace words with a \n        // normal Array here.\n        w = Array(80); // do not use Uint32Array here as the instantiation is slower\n        for (var j=0; j<16; j++){\n            w[j] = words[j];\n        }\n    } else {\n        w = words;\n    }\n\n    a = h[0]; b = h[1]; c = h[2]; d = h[3]; e = h[4]; \n\n    for (t=0; t<=79; t++) {\n      if (t >= 16) {\n        w[t] = this._S(1, w[t-3] ^ w[t-8] ^ w[t-14] ^ w[t-16]);\n      }\n      tmp = (this._S(5, a) + this._f(t, b, c, d) + e + w[t] +\n             this._key[Math.floor(t/20)]) | 0;\n      e = d;\n      d = c;\n      c = this._S(30, b);\n      b = a;\n      a = tmp;\n   }\n\n   h[0] = (h[0]+a) |0;\n   h[1] = (h[1]+b) |0;\n   h[2] = (h[2]+c) |0;\n   h[3] = (h[3]+d) |0;\n   h[4] = (h[4]+e) |0;\n  }\n};\n/** @fileOverview Javascript SHA-256 implementation.\n *\n * An older version of this implementation is available in the public\n * domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,\n * Stanford University 2008-2010 and BSD-licensed for liability\n * reasons.\n *\n * Special thanks to Aldo Cortesi for pointing out several bugs in\n * this code.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/**\n * Context for a SHA-256 operation in progress.\n * @constructor\n */\nsjcl.hash.sha256 = function (hash) {\n  if (!this._key[0]) { this._precompute(); }\n  if (hash) {\n    this._h = hash._h.slice(0);\n    this._buffer = hash._buffer.slice(0);\n    this._length = hash._length;\n  } else {\n    this.reset();\n  }\n};\n\n/**\n * Hash a string or an array of words.\n * @static\n * @param {bitArray|String} data the data to hash.\n * @return {bitArray} The hash value, an array of 16 big-endian words.\n */\nsjcl.hash.sha256.hash = function (data) {\n  return (new sjcl.hash.sha256()).update(data).finalize();\n};\n\nsjcl.hash.sha256.prototype = {\n  /**\n   * The hash's block size, in bits.\n   * @constant\n   */\n  blockSize: 512,\n   \n  /**\n   * Reset the hash state.\n   * @return this\n   */\n  reset:function () {\n    this._h = this._init.slice(0);\n    this._buffer = [];\n    this._length = 0;\n    return this;\n  },\n  \n  /**\n   * Input several words to the hash.\n   * @param {bitArray|String} data the data to hash.\n   * @return this\n   */\n  update: function (data) {\n    if (typeof data === \"string\") {\n      data = sjcl.codec.utf8String.toBits(data);\n    }\n    var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),\n        ol = this._length,\n        nl = this._length = ol + sjcl.bitArray.bitLength(data);\n    if (nl > 9007199254740991){\n      throw new sjcl.exception.invalid(\"Cannot hash more than 2^53 - 1 bits\");\n    }\n\n    if (typeof Uint32Array !== 'undefined') {\n\tvar c = new Uint32Array(b);\n    \tvar j = 0;\n    \tfor (i = 512+ol - ((512+ol) & 511); i <= nl; i+= 512) {\n      \t    this._block(c.subarray(16 * j, 16 * (j+1)));\n      \t    j += 1;\n    \t}\n    \tb.splice(0, 16 * j);\n    } else {\n\tfor (i = 512+ol - ((512+ol) & 511); i <= nl; i+= 512) {\n      \t    this._block(b.splice(0,16));\n      \t}\n    }\n    return this;\n  },\n  \n  /**\n   * Complete hashing and output the hash value.\n   * @return {bitArray} The hash value, an array of 8 big-endian words.\n   */\n  finalize:function () {\n    var i, b = this._buffer, h = this._h;\n\n    // Round out and push the buffer\n    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);\n    \n    // Round out the buffer to a multiple of 16 words, less the 2 length words.\n    for (i = b.length + 2; i & 15; i++) {\n      b.push(0);\n    }\n    \n    // append the length\n    b.push(Math.floor(this._length / 0x100000000));\n    b.push(this._length | 0);\n\n    while (b.length) {\n      this._block(b.splice(0,16));\n    }\n\n    this.reset();\n    return h;\n  },\n\n  /**\n   * The SHA-256 initialization vector, to be precomputed.\n   * @private\n   */\n  _init:[],\n  /*\n  _init:[0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19],\n  */\n  \n  /**\n   * The SHA-256 hash key, to be precomputed.\n   * @private\n   */\n  _key:[],\n  /*\n  _key:\n    [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n     0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n     0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n     0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n     0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n     0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n     0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n     0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2],\n  */\n\n\n  /**\n   * Function to precompute _init and _key.\n   * @private\n   */\n  _precompute: function () {\n    var i = 0, prime = 2, factor, isPrime;\n\n    function frac(x) { return (x-Math.floor(x)) * 0x100000000 | 0; }\n\n    for (; i<64; prime++) {\n      isPrime = true;\n      for (factor=2; factor*factor <= prime; factor++) {\n        if (prime % factor === 0) {\n          isPrime = false;\n          break;\n        }\n      }\n      if (isPrime) {\n        if (i<8) {\n          this._init[i] = frac(Math.pow(prime, 1/2));\n        }\n        this._key[i] = frac(Math.pow(prime, 1/3));\n        i++;\n      }\n    }\n  },\n  \n  /**\n   * Perform one cycle of SHA-256.\n   * @param {Uint32Array|bitArray} w one block of words.\n   * @private\n   */\n  _block:function (w) {  \n    var i, tmp, a, b,\n      h = this._h,\n      k = this._key,\n      h0 = h[0], h1 = h[1], h2 = h[2], h3 = h[3],\n      h4 = h[4], h5 = h[5], h6 = h[6], h7 = h[7];\n\n    /* Rationale for placement of |0 :\n     * If a value can overflow is original 32 bits by a factor of more than a few\n     * million (2^23 ish), there is a possibility that it might overflow the\n     * 53-bit mantissa and lose precision.\n     *\n     * To avoid this, we clamp back to 32 bits by |'ing with 0 on any value that\n     * propagates around the loop, and on the hash state h[].  I don't believe\n     * that the clamps on h4 and on h0 are strictly necessary, but it's close\n     * (for h4 anyway), and better safe than sorry.\n     *\n     * The clamps on h[] are necessary for the output to be correct even in the\n     * common case and for short inputs.\n     */\n    for (i=0; i<64; i++) {\n      // load up the input word for this round\n      if (i<16) {\n        tmp = w[i];\n      } else {\n        a   = w[(i+1 ) & 15];\n        b   = w[(i+14) & 15];\n        tmp = w[i&15] = ((a>>>7  ^ a>>>18 ^ a>>>3  ^ a<<25 ^ a<<14) + \n                         (b>>>17 ^ b>>>19 ^ b>>>10 ^ b<<15 ^ b<<13) +\n                         w[i&15] + w[(i+9) & 15]) | 0;\n      }\n      \n      tmp = (tmp + h7 + (h4>>>6 ^ h4>>>11 ^ h4>>>25 ^ h4<<26 ^ h4<<21 ^ h4<<7) +  (h6 ^ h4&(h5^h6)) + k[i]); // | 0;\n      \n      // shift register\n      h7 = h6; h6 = h5; h5 = h4;\n      h4 = h3 + tmp | 0;\n      h3 = h2; h2 = h1; h1 = h0;\n\n      h0 = (tmp +  ((h1&h2) ^ (h3&(h1^h2))) + (h1>>>2 ^ h1>>>13 ^ h1>>>22 ^ h1<<30 ^ h1<<19 ^ h1<<10)) | 0;\n    }\n\n    h[0] = h[0]+h0 | 0;\n    h[1] = h[1]+h1 | 0;\n    h[2] = h[2]+h2 | 0;\n    h[3] = h[3]+h3 | 0;\n    h[4] = h[4]+h4 | 0;\n    h[5] = h[5]+h5 | 0;\n    h[6] = h[6]+h6 | 0;\n    h[7] = h[7]+h7 | 0;\n  }\n};\n\n\n/** @fileOverview Javascript SHA-512 implementation.\n *\n * This implementation was written for CryptoJS by Jeff Mott and adapted for\n * SJCL by Stefan Thomas.\n *\n * CryptoJS (c) 2009–2012 by Jeff Mott. All rights reserved.\n * Released with New BSD License\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n * @author Jeff Mott\n * @author Stefan Thomas\n */\n\n/**\n * Context for a SHA-512 operation in progress.\n * @constructor\n */\nsjcl.hash.sha512 = function (hash) {\n  if (!this._key[0]) { this._precompute(); }\n  if (hash) {\n    this._h = hash._h.slice(0);\n    this._buffer = hash._buffer.slice(0);\n    this._length = hash._length;\n  } else {\n    this.reset();\n  }\n};\n\n/**\n * Hash a string or an array of words.\n * @static\n * @param {bitArray|String} data the data to hash.\n * @return {bitArray} The hash value, an array of 16 big-endian words.\n */\nsjcl.hash.sha512.hash = function (data) {\n  return (new sjcl.hash.sha512()).update(data).finalize();\n};\n\nsjcl.hash.sha512.prototype = {\n  /**\n   * The hash's block size, in bits.\n   * @constant\n   */\n  blockSize: 1024,\n   \n  /**\n   * Reset the hash state.\n   * @return this\n   */\n  reset:function () {\n    this._h = this._init.slice(0);\n    this._buffer = [];\n    this._length = 0;\n    return this;\n  },\n  \n  /**\n   * Input several words to the hash.\n   * @param {bitArray|String} data the data to hash.\n   * @return this\n   */\n  update: function (data) {\n    if (typeof data === \"string\") {\n      data = sjcl.codec.utf8String.toBits(data);\n    }\n    var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),\n        ol = this._length,\n        nl = this._length = ol + sjcl.bitArray.bitLength(data);\n    if (nl > 9007199254740991){\n      throw new sjcl.exception.invalid(\"Cannot hash more than 2^53 - 1 bits\");\n    }\n\n    if (typeof Uint32Array !== 'undefined') {\n        var c = new Uint32Array(b);\n        var j = 0;\n        for (i = 1024+ol - ((1024+ol) & 1023); i <= nl; i+= 1024) {\n            this._block(c.subarray(32 * j, 32 * (j+1)));\n            j += 1;\n        }\n        b.splice(0, 32 * j);\n    } else {\n        for (i = 1024+ol - ((1024+ol) & 1023); i <= nl; i+= 1024) {\n            this._block(b.splice(0,32));\n        }\n    }\n    return this;\n  },\n  \n  /**\n   * Complete hashing and output the hash value.\n   * @return {bitArray} The hash value, an array of 16 big-endian words.\n   */\n  finalize:function () {\n    var i, b = this._buffer, h = this._h;\n\n    // Round out and push the buffer\n    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);\n\n    // Round out the buffer to a multiple of 32 words, less the 4 length words.\n    for (i = b.length + 4; i & 31; i++) {\n      b.push(0);\n    }\n\n    // append the length\n    b.push(0);\n    b.push(0);\n    b.push(Math.floor(this._length / 0x100000000));\n    b.push(this._length | 0);\n\n    while (b.length) {\n      this._block(b.splice(0,32));\n    }\n\n    this.reset();\n    return h;\n  },\n\n  /**\n   * The SHA-512 initialization vector, to be precomputed.\n   * @private\n   */\n  _init:[],\n\n  /**\n   * Least significant 24 bits of SHA512 initialization values.\n   *\n   * Javascript only has 53 bits of precision, so we compute the 40 most\n   * significant bits and add the remaining 24 bits as constants.\n   *\n   * @private\n   */\n  _initr: [ 0xbcc908, 0xcaa73b, 0x94f82b, 0x1d36f1, 0xe682d1, 0x3e6c1f, 0x41bd6b, 0x7e2179 ],\n\n  /*\n  _init:\n  [0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n   0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179],\n  */\n\n  /**\n   * The SHA-512 hash key, to be precomputed.\n   * @private\n   */\n  _key:[],\n\n  /**\n   * Least significant 24 bits of SHA512 key values.\n   * @private\n   */\n  _keyr:\n  [0x28ae22, 0xef65cd, 0x4d3b2f, 0x89dbbc, 0x48b538, 0x05d019, 0x194f9b, 0x6d8118,\n   0x030242, 0x706fbe, 0xe4b28c, 0xffb4e2, 0x7b896f, 0x1696b1, 0xc71235, 0x692694,\n   0xf14ad2, 0x4f25e3, 0x8cd5b5, 0xac9c65, 0x2b0275, 0xa6e483, 0x41fbd4, 0x1153b5,\n   0x66dfab, 0xb43210, 0xfb213f, 0xef0ee4, 0xa88fc2, 0x0aa725, 0x03826f, 0x0e6e70,\n   0xd22ffc, 0x26c926, 0xc42aed, 0x95b3df, 0xaf63de, 0x77b2a8, 0xedaee6, 0x82353b,\n   0xf10364, 0x423001, 0xf89791, 0x54be30, 0xef5218, 0x65a910, 0x71202a, 0xbbd1b8,\n   0xd2d0c8, 0x41ab53, 0x8eeb99, 0x9b48a8, 0xc95a63, 0x418acb, 0x63e373, 0xb2b8a3,\n   0xefb2fc, 0x172f60, 0xf0ab72, 0x6439ec, 0x631e28, 0x82bde9, 0xc67915, 0x72532b,\n   0x26619c, 0xc0c207, 0xe0eb1e, 0x6ed178, 0x176fba, 0xc898a6, 0xf90dae, 0x1c471b,\n   0x047d84, 0xc72493, 0xc9bebc, 0x100d4c, 0x3e42b6, 0x657e2a, 0xd6faec, 0x475817],\n\n  /*\n  _key:\n  [0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,\n   0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,\n   0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,\n   0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,\n   0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,\n   0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,\n   0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,\n   0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,\n   0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,\n   0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,\n   0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,\n   0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,\n   0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,\n   0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,\n   0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,\n   0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,\n   0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,\n   0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,\n   0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,\n   0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817],\n  */\n\n  /**\n   * Function to precompute _init and _key.\n   * @private\n   */\n  _precompute: function () {\n    // XXX: This code is for precomputing the SHA256 constants, change for\n    //      SHA512 and re-enable.\n    var i = 0, prime = 2, factor , isPrime;\n\n    function frac(x)  { return (x-Math.floor(x)) * 0x100000000 | 0; }\n    function frac2(x) { return (x-Math.floor(x)) * 0x10000000000 & 0xff; }\n\n    for (; i<80; prime++) {\n      isPrime = true;\n      for (factor=2; factor*factor <= prime; factor++) {\n        if (prime % factor === 0) {\n          isPrime = false;\n          break;\n        }\n      }\n      if (isPrime) {\n        if (i<8) {\n          this._init[i*2] = frac(Math.pow(prime, 1/2));\n          this._init[i*2+1] = (frac2(Math.pow(prime, 1/2)) << 24) | this._initr[i];\n        }\n        this._key[i*2] = frac(Math.pow(prime, 1/3));\n        this._key[i*2+1] = (frac2(Math.pow(prime, 1/3)) << 24) | this._keyr[i];\n        i++;\n      }\n    }\n  },\n\n  /**\n   * Perform one cycle of SHA-512.\n   * @param {Uint32Array|bitArray} words one block of words.\n   * @private\n   */\n  _block:function (words) {\n    var i, wrh, wrl,\n        h = this._h,\n        k = this._key,\n        h0h = h[ 0], h0l = h[ 1], h1h = h[ 2], h1l = h[ 3],\n        h2h = h[ 4], h2l = h[ 5], h3h = h[ 6], h3l = h[ 7],\n        h4h = h[ 8], h4l = h[ 9], h5h = h[10], h5l = h[11],\n        h6h = h[12], h6l = h[13], h7h = h[14], h7l = h[15];\n    var w;\n    if (typeof Uint32Array !== 'undefined') {\n\t// When words is passed to _block, it has 32 elements. SHA512 _block\n\t// function extends words with new elements (at the end there are 160 elements). \n\t// The problem is that if we use Uint32Array instead of Array, \n\t// the length of Uint32Array cannot be changed. Thus, we replace words with a \n\t// normal Array here.\n        w = Array(160); // do not use Uint32Array here as the instantiation is slower\n        for (var j=0; j<32; j++){\n    \t    w[j] = words[j]; \n        }\n    } else {\n\tw = words;\n    } \n\n    // Working variables\n    var ah = h0h, al = h0l, bh = h1h, bl = h1l,\n        ch = h2h, cl = h2l, dh = h3h, dl = h3l,\n        eh = h4h, el = h4l, fh = h5h, fl = h5l,\n        gh = h6h, gl = h6l, hh = h7h, hl = h7l;\n\n    for (i=0; i<80; i++) {\n      // load up the input word for this round\n      if (i<16) {\n        wrh = w[i * 2];\n        wrl = w[i * 2 + 1];\n      } else {\n        // Gamma0\n        var gamma0xh = w[(i-15) * 2];\n        var gamma0xl = w[(i-15) * 2 + 1];\n        var gamma0h =\n          ((gamma0xl << 31) | (gamma0xh >>> 1)) ^\n          ((gamma0xl << 24) | (gamma0xh >>> 8)) ^\n           (gamma0xh >>> 7);\n        var gamma0l =\n          ((gamma0xh << 31) | (gamma0xl >>> 1)) ^\n          ((gamma0xh << 24) | (gamma0xl >>> 8)) ^\n          ((gamma0xh << 25) | (gamma0xl >>> 7));\n\n        // Gamma1\n        var gamma1xh = w[(i-2) * 2];\n        var gamma1xl = w[(i-2) * 2 + 1];\n        var gamma1h =\n          ((gamma1xl << 13) | (gamma1xh >>> 19)) ^\n          ((gamma1xh << 3)  | (gamma1xl >>> 29)) ^\n           (gamma1xh >>> 6);\n        var gamma1l =\n          ((gamma1xh << 13) | (gamma1xl >>> 19)) ^\n          ((gamma1xl << 3)  | (gamma1xh >>> 29)) ^\n          ((gamma1xh << 26) | (gamma1xl >>> 6));\n\n        // Shortcuts\n        var wr7h = w[(i-7) * 2];\n        var wr7l = w[(i-7) * 2 + 1];\n\n        var wr16h = w[(i-16) * 2];\n        var wr16l = w[(i-16) * 2 + 1];\n\n        // W(round) = gamma0 + W(round - 7) + gamma1 + W(round - 16)\n        wrl = gamma0l + wr7l;\n        wrh = gamma0h + wr7h + ((wrl >>> 0) < (gamma0l >>> 0) ? 1 : 0);\n        wrl += gamma1l;\n        wrh += gamma1h + ((wrl >>> 0) < (gamma1l >>> 0) ? 1 : 0);\n        wrl += wr16l;\n        wrh += wr16h + ((wrl >>> 0) < (wr16l >>> 0) ? 1 : 0);\n      }\n\n      w[i*2]     = wrh |= 0;\n      w[i*2 + 1] = wrl |= 0;\n\n      // Ch\n      var chh = (eh & fh) ^ (~eh & gh);\n      var chl = (el & fl) ^ (~el & gl);\n\n      // Maj\n      var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);\n      var majl = (al & bl) ^ (al & cl) ^ (bl & cl);\n\n      // Sigma0\n      var sigma0h = ((al << 4) | (ah >>> 28)) ^ ((ah << 30) | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));\n      var sigma0l = ((ah << 4) | (al >>> 28)) ^ ((al << 30) | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));\n\n      // Sigma1\n      var sigma1h = ((el << 18) | (eh >>> 14)) ^ ((el << 14) | (eh >>> 18)) ^ ((eh << 23) | (el >>> 9));\n      var sigma1l = ((eh << 18) | (el >>> 14)) ^ ((eh << 14) | (el >>> 18)) ^ ((el << 23) | (eh >>> 9));\n\n      // K(round)\n      var krh = k[i*2];\n      var krl = k[i*2+1];\n\n      // t1 = h + sigma1 + ch + K(round) + W(round)\n      var t1l = hl + sigma1l;\n      var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);\n      t1l += chl;\n      t1h += chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);\n      t1l += krl;\n      t1h += krh + ((t1l >>> 0) < (krl >>> 0) ? 1 : 0);\n      t1l = t1l + wrl|0;   // FF32..FF34 perf issue https://bugzilla.mozilla.org/show_bug.cgi?id=1054972\n      t1h += wrh + ((t1l >>> 0) < (wrl >>> 0) ? 1 : 0);\n\n      // t2 = sigma0 + maj\n      var t2l = sigma0l + majl;\n      var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);\n\n      // Update working variables\n      hh = gh;\n      hl = gl;\n      gh = fh;\n      gl = fl;\n      fh = eh;\n      fl = el;\n      el = (dl + t1l) | 0;\n      eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;\n      dh = ch;\n      dl = cl;\n      ch = bh;\n      cl = bl;\n      bh = ah;\n      bl = al;\n      al = (t1l + t2l) | 0;\n      ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;\n    }\n\n    // Intermediate hash\n    h0l = h[1] = (h0l + al) | 0;\n    h[0] = (h0h + ah + ((h0l >>> 0) < (al >>> 0) ? 1 : 0)) | 0;\n    h1l = h[3] = (h1l + bl) | 0;\n    h[2] = (h1h + bh + ((h1l >>> 0) < (bl >>> 0) ? 1 : 0)) | 0;\n    h2l = h[5] = (h2l + cl) | 0;\n    h[4] = (h2h + ch + ((h2l >>> 0) < (cl >>> 0) ? 1 : 0)) | 0;\n    h3l = h[7] = (h3l + dl) | 0;\n    h[6] = (h3h + dh + ((h3l >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;\n    h4l = h[9] = (h4l + el) | 0;\n    h[8] = (h4h + eh + ((h4l >>> 0) < (el >>> 0) ? 1 : 0)) | 0;\n    h5l = h[11] = (h5l + fl) | 0;\n    h[10] = (h5h + fh + ((h5l >>> 0) < (fl >>> 0) ? 1 : 0)) | 0;\n    h6l = h[13] = (h6l + gl) | 0;\n    h[12] = (h6h + gh + ((h6l >>> 0) < (gl >>> 0) ? 1 : 0)) | 0;\n    h7l = h[15] = (h7l + hl) | 0;\n    h[14] = (h7h + hh + ((h7l >>> 0) < (hl >>> 0) ? 1 : 0)) | 0;\n  }\n};\n\n\n/** @fileOverview HMAC implementation.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** HMAC with the specified hash function.\n * @constructor\n * @param {bitArray} key the key for HMAC.\n * @param {Object} [Hash=sjcl.hash.sha256] The hash function to use.\n */\nsjcl.misc.hmac = function (key, Hash) {\n  this._hash = Hash = Hash || sjcl.hash.sha256;\n  var exKey = [[],[]], i,\n      bs = Hash.prototype.blockSize / 32;\n  this._baseHash = [new Hash(), new Hash()];\n\n  if (key.length > bs) {\n    key = Hash.hash(key);\n  }\n  \n  for (i=0; i<bs; i++) {\n    exKey[0][i] = key[i]^0x36363636;\n    exKey[1][i] = key[i]^0x5C5C5C5C;\n  }\n  \n  this._baseHash[0].update(exKey[0]);\n  this._baseHash[1].update(exKey[1]);\n  this._resultHash = new Hash(this._baseHash[0]);\n};\n\n/** HMAC with the specified hash function.  Also called encrypt since it's a prf.\n * @param {bitArray|String} data The data to mac.\n */\nsjcl.misc.hmac.prototype.encrypt = sjcl.misc.hmac.prototype.mac = function (data) {\n  if (!this._updated) {\n    this.update(data);\n    return this.digest(data);\n  } else {\n    throw new sjcl.exception.invalid(\"encrypt on already updated hmac called!\");\n  }\n};\n\nsjcl.misc.hmac.prototype.reset = function () {\n  this._resultHash = new this._hash(this._baseHash[0]);\n  this._updated = false;\n};\n\nsjcl.misc.hmac.prototype.update = function (data) {\n  this._updated = true;\n  this._resultHash.update(data);\n};\n\nsjcl.misc.hmac.prototype.digest = function () {\n  var w = this._resultHash.finalize(), result = new (this._hash)(this._baseHash[1]).update(w).finalize();\n\n  this.reset();\n\n  return result;\n};\n\n\t\t\t\t\t;/* harmony default export */ __webpack_exports__[\"a\"] = (sjcl);\n\t\t\t\t\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Crypto; });\n/* harmony import */ var sjcl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);\n// eslint-disable-next-line import/no-extraneous-dependencies\n // SJCL is included during compilation.\n\n\n\n/**\n * Node.js Crypto module.\n * @private\n * @type {Object}\n */\nconst NodeCrypto = _utils__WEBPACK_IMPORTED_MODULE_1__[/* InternalUtils */ \"a\"].require('crypto');\n\n/**\n * An object containing some cryptography functions\n * with dirty workarounds for Node.js and browsers.\n * @private\n * @type {Object}\n */\nconst Crypto = {};\n\nif (NodeCrypto) {\n\tlet bufferFrom;\n\n\tif (typeof Buffer.from === 'function') {\n\t\tbufferFrom = Buffer.from;\n\t} else {\n\t\t// Node.js < 5.10.0\n\t\tbufferFrom = arrbuf => {\n\t\t\t// eslint-disable-next-line no-buffer-constructor\n\t\t\tconst nodeBuf = new Buffer(arrbuf.byteLength);\n\t\t\tconst arr = new Uint8Array(arrbuf);\n\n\t\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\t\tnodeBuf[i] = arr[i];\n\t\t\t}\n\n\t\t\treturn nodeBuf;\n\t\t};\n\t}\n\n\tlet bufferTo;\n\n\tif (Buffer.prototype instanceof Uint8Array) {\n\t\tbufferTo = nodeBuf => nodeBuf;\n\t} else {\n\t\t// Node.js < 4.0.0\n\t\tbufferTo = nodeBuf => {\n\t\t\tconst arr = new Uint8Array(nodeBuf.length);\n\n\t\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\t\tarr[i] = nodeBuf[i];\n\t\t\t}\n\n\t\t\treturn arr;\n\t\t};\n\t}\n\n\tCrypto.randomBytes = size => {\n\t\tconst buff = NodeCrypto.randomBytes(size);\n\t\treturn bufferTo(buff);\n\t};\n\n\t// In Node.js, the command:\n\t// $ openssl list -digest-algorithms\n\t// displays the available digest algorithms.\n\tCrypto.hmacDigest = (algorithm, key, message) => {\n\t\tconst buff = NodeCrypto.createHmac(algorithm, bufferFrom(key));\n\t\treturn bufferTo(buff).update(bufferFrom(message)).digest();\n\t};\n} else {\n\tlet getRandomValues;\n\n\tif (typeof global.crypto !== 'undefined' && typeof global.crypto.getRandomValues === 'function') {\n\t\tgetRandomValues = arr => {\n\t\t\tglobal.crypto.getRandomValues(arr);\n\t\t};\n\t} else if (typeof global.msCrypto !== 'undefined' && typeof global.msCrypto.getRandomValues === 'function') {\n\t\tgetRandomValues = arr => {\n\t\t\tglobal.msCrypto.getRandomValues(arr);\n\t\t};\n\t} else {\n\t\tconsole.warn('Cryptography API not available, falling back to \\'Math.random\\'...');\n\t\tgetRandomValues = arr => {\n\t\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\t\tarr[i] = Math.floor(Math.random() * 256);\n\t\t\t}\n\t\t};\n\t}\n\n\tCrypto.randomBytes = size => {\n\t\tconst arr = new Uint8Array(size);\n\t\tgetRandomValues(arr);\n\t\treturn arr;\n\t};\n\n\tCrypto.hmacDigest = (algorithm, key, message) => {\n\t\tconst hash = sjcl__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].hash[algorithm.toLowerCase()];\n\t\tif (typeof hash === 'undefined') {\n\t\t\tthrow new TypeError('Unknown hash function');\n\t\t}\n\n\t\t// eslint-disable-next-line new-cap\n\t\tconst hmac = new sjcl__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].misc.hmac(sjcl__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].codec.arrayBuffer.toBits(key), hash);\n\t\thmac.update(sjcl__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].codec.arrayBuffer.toBits(message));\n\n\t\treturn sjcl__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].codec.arrayBuffer.fromBits(hmac.digest(), false);\n\t};\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(3)))\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nvar g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./src/utils.js\nvar utils = __webpack_require__(0);\n\n// EXTERNAL MODULE: ./src/crypto.js\nvar src_crypto = __webpack_require__(2);\n\n// CONCATENATED MODULE: ./src/secret.js\n\n\n\n/**\n * Secret key object.\n */\nclass secret_Secret {\n\t/**\n\t * @param {Object} [config] Configuration options.\n\t * @param {ArrayBuffer} [config.buffer=Crypto.randomBytes] Secret key.\n\t * @param {number} [config.size=20] Number of random bytes to generate, ignored if 'buffer' is provided.\n\t */\n\tconstructor({ buffer, size = 20 } = {}) {\n\t\t/**\n\t\t * Secret key.\n\t\t * @type {ArrayBuffer}\n\t\t */\n\t\tthis.buffer = typeof buffer === 'undefined'\n\t\t\t? src_crypto[\"a\" /* Crypto */].randomBytes(size).buffer\n\t\t\t: buffer;\n\t}\n\n\t/**\n\t * Converts a raw string to a Secret object.\n\t * @method fromRaw\n\t * @param {string} str Raw string.\n\t * @returns {Secret} Secret object.\n\t */\n\tstatic fromRaw(str) {\n\t\treturn new this({ buffer: utils[\"b\" /* Utils */].raw.encode(str) });\n\t}\n\n\t/**\n\t * Converts a base32 string to a Secret object.\n\t * @method fromB32\n\t * @param {string} str Base32 string.\n\t * @returns {Secret} Secret object.\n\t */\n\tstatic fromB32(str) {\n\t\treturn new this({ buffer: utils[\"b\" /* Utils */].b32.encode(str) });\n\t}\n\n\t/**\n\t * Converts a hexadecimal string to a Secret object.\n\t * @method fromHex\n\t * @param {string} str Hexadecimal string.\n\t * @returns {Secret} Secret object.\n\t */\n\tstatic fromHex(str) {\n\t\treturn new this({ buffer: utils[\"b\" /* Utils */].hex.encode(str) });\n\t}\n\n\t/**\n\t * String representation of secret key.\n\t * @type {string}\n\t */\n\tget raw() {\n\t\tObject.defineProperty(this, 'raw', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\twritable: true,\n\t\t\tvalue: utils[\"b\" /* Utils */].raw.decode(this.buffer)\n\t\t});\n\n\t\treturn this.raw;\n\t}\n\n\t/**\n\t * Base32 representation of secret key.\n\t * @type {string}\n\t */\n\tget b32() {\n\t\tObject.defineProperty(this, 'b32', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\twritable: true,\n\t\t\tvalue: utils[\"b\" /* Utils */].b32.decode(this.buffer)\n\t\t});\n\n\t\treturn this.b32;\n\t}\n\n\t/**\n\t * Hexadecimal representation of secret key.\n\t * @type {string}\n\t */\n\tget hex() {\n\t\tObject.defineProperty(this, 'hex', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\twritable: true,\n\t\t\tvalue: utils[\"b\" /* Utils */].hex.decode(this.buffer)\n\t\t});\n\n\t\treturn this.hex;\n\t}\n}\n\n// CONCATENATED MODULE: ./src/uri.js\n\n\n// eslint-disable-next-line import/no-cycle\n\n\n/**\n * Valid key URI parameters.\n * @private\n * @type {Array}\n */\nconst OTPURI_PARAMS = ['issuer', 'secret', 'algorithm', 'digits', 'counter', 'period'];\n\n/**\n * Key URI regex.\n *   otpauth://TYPE/[ISSUER:]LABEL?PARAMETERS\n * @private\n * @type {RegExp}\n */\nconst OTPURI_REGEX = new RegExp(`^otpauth:\\\\/\\\\/([ht]otp)\\\\/(.+)\\\\?((?:&?(?:${OTPURI_PARAMS.join('|')})=[^&]+)+)$`, 'i');\n\n/**\n * RFC 4648 base32 alphabet without pad.\n * @private\n * @type {string}\n */\nconst SECRET_REGEX = /^[2-7A-Z]+$/i;\n\n/**\n * Regex for supported algorithms.\n * @private\n * @type {RegExp}\n */\nconst ALGORITHM_REGEX = /^SHA(?:1|256|512)$/i;\n\n/**\n * Integer regex.\n * @private\n * @type {RegExp}\n */\nconst INTEGER_REGEX = /^[+-]?\\d+$/;\n\n/**\n * Positive integer regex.\n * @private\n * @type {RegExp}\n */\nconst POSITIVE_INTEGER_REGEX = /^\\+?[1-9]\\d*$/;\n\n/**\n * HOTP/TOTP object/string conversion.\n * @see https://github.com/google/google-authenticator/wiki/Key-Uri-Format\n */\nclass uri_URI {\n\t/**\n\t * Parses a Google Authenticator key URI and returns an HOTP/TOTP object.\n\t * @method parse\n\t * @param {string} uri Google Authenticator Key URI.\n\t * @returns {Object} HOTP/TOTP object.\n\t */\n\tstatic parse(uri) {\n\t\tlet uriGroups;\n\n\t\ttry {\n\t\t\turiGroups = uri.match(OTPURI_REGEX);\n\t\t} catch (error) { /* Handled below */ }\n\n\t\tif (!Array.isArray(uriGroups)) {\n\t\t\tthrow new URIError('Invalid URI format');\n\t\t}\n\n\t\t// Extract URI groups.\n\t\tconst uriType = uriGroups[1].toLowerCase();\n\t\tconst uriLabel = uriGroups[2].split(/:(.+)/, 2).map(decodeURIComponent);\n\t\tconst uriParams = uriGroups[3].split('&').reduce((acc, cur) => {\n\t\t\tconst pairArr = cur.split(/=(.+)/, 2).map(decodeURIComponent);\n\t\t\tconst pairKey = pairArr[0].toLowerCase();\n\t\t\tconst pairVal = pairArr[1];\n\t\t\tconst pairAcc = acc;\n\n\t\t\tpairAcc[pairKey] = pairVal;\n\t\t\treturn pairAcc;\n\t\t}, {});\n\n\t\t// 'OTP' will be instantiated with 'config' argument\n\t\tlet OTP;\n\t\tconst config = {};\n\n\t\tif (uriType === 'hotp') {\n\t\t\tOTP = otp_HOTP;\n\n\t\t\t// Counter: required\n\t\t\tif (typeof uriParams.counter !== 'undefined' && INTEGER_REGEX.test(uriParams.counter)) {\n\t\t\t\tconfig.counter = Number.parseInt(uriParams.counter, 10);\n\t\t\t} else {\n\t\t\t\tthrow new TypeError('Missing or invalid \\'counter\\' parameter');\n\t\t\t}\n\t\t} else if (uriType === 'totp') {\n\t\t\tOTP = otp_TOTP;\n\n\t\t\t// Period: optional\n\t\t\tif (typeof uriParams.period !== 'undefined') {\n\t\t\t\tif (POSITIVE_INTEGER_REGEX.test(uriParams.period)) {\n\t\t\t\t\tconfig.period = Number.parseInt(uriParams.period, 10);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new TypeError('Invalid \\'period\\' parameter');\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new TypeError('Unknown OTP type');\n\t\t}\n\n\t\t// Label: required\n\t\t// Issuer: optional\n\t\tif (uriLabel.length === 2) {\n\t\t\tconfig.label = uriLabel[1];\n\t\t\tif (typeof uriParams.issuer === 'undefined') {\n\t\t\t\tconfig.issuer = uriLabel[0];\n\t\t\t} else if (uriParams.issuer === uriLabel[0]) {\n\t\t\t\tconfig.issuer = uriParams.issuer;\n\t\t\t} else {\n\t\t\t\tthrow new TypeError('Invalid \\'issuer\\' parameter');\n\t\t\t}\n\t\t} else {\n\t\t\tconfig.label = uriLabel[0];\n\t\t\tif (typeof uriParams.issuer !== 'undefined') {\n\t\t\t\tconfig.issuer = uriParams.issuer;\n\t\t\t}\n\t\t}\n\n\t\t// Secret: required\n\t\tif (typeof uriParams.secret !== 'undefined' && SECRET_REGEX.test(uriParams.secret)) {\n\t\t\tconfig.secret = new secret_Secret({ buffer: utils[\"b\" /* Utils */].b32.encode(uriParams.secret) });\n\t\t} else {\n\t\t\tthrow new TypeError('Missing or invalid \\'secret\\' parameter');\n\t\t}\n\n\t\t// Algorithm: optional\n\t\tif (typeof uriParams.algorithm !== 'undefined') {\n\t\t\tif (ALGORITHM_REGEX.test(uriParams.algorithm)) {\n\t\t\t\tconfig.algorithm = uriParams.algorithm;\n\t\t\t} else {\n\t\t\t\tthrow new TypeError('Invalid \\'algorithm\\' parameter');\n\t\t\t}\n\t\t}\n\n\t\t// Digits: optional\n\t\tif (typeof uriParams.digits !== 'undefined') {\n\t\t\tif (POSITIVE_INTEGER_REGEX.test(uriParams.digits)) {\n\t\t\t\tconfig.digits = Number.parseInt(uriParams.digits, 10);\n\t\t\t} else {\n\t\t\t\tthrow new TypeError('Invalid \\'digits\\' parameter');\n\t\t\t}\n\t\t}\n\n\t\treturn new OTP(config);\n\t}\n\n\t/**\n\t * Converts an HOTP/TOTP object to a Google Authenticator key URI.\n\t * @method stringify\n\t * @param {Object} otp HOTP/TOTP object.\n\t * @param {Object} [config] Configuration options.\n\t * @param {boolean} [config.legacyIssuer=true] Set issuer label prefix.\n\t * @returns {string} Google Authenticator Key URI.\n\t */\n\tstatic stringify(otp, { legacyIssuer = true } = {}) {\n\t\tconst isHOTP = otp instanceof otp_HOTP;\n\t\tconst isTOTP = otp instanceof otp_TOTP;\n\n\t\tif (!isHOTP && !isTOTP) {\n\t\t\tthrow new TypeError('Invalid \\'HOTP/TOTP\\' object');\n\t\t}\n\n\t\t// Key URI format:\n\t\t// otpauth://TYPE/[ISSUER:]LABEL?PARAMETERS\n\t\tlet uri = 'otpauth://';\n\n\t\t// Type\n\t\turi += `${isTOTP ? 'totp' : 'hotp'}/`;\n\n\t\t// Label and optional issuer\n\t\tif (otp.issuer.length > 0) {\n\t\t\t// Legacy label prefix\n\t\t\tif (legacyIssuer) uri += `${encodeURIComponent(otp.issuer)}:`;\n\t\t\t// Label\n\t\t\turi += `${encodeURIComponent(otp.label)}?`;\n\t\t\t// Issuer\n\t\t\turi += `issuer=${encodeURIComponent(otp.issuer)}&`;\n\t\t} else {\n\t\t\t// Label\n\t\t\turi += `${encodeURIComponent(otp.label)}?`;\n\t\t}\n\n\t\t// Generic parameters\n\t\turi += `secret=${encodeURIComponent(otp.secret.b32)}`\n\t\t\t+ `&algorithm=${encodeURIComponent(otp.algorithm)}`\n\t\t\t+ `&digits=${encodeURIComponent(otp.digits)}`;\n\n\t\t// Extra parameters\n\t\tif (isTOTP) {\n\t\t\t// TOTP parameters\n\t\t\turi += `&period=${encodeURIComponent(otp.period)}`;\n\t\t} else {\n\t\t\t// HOTP parameters\n\t\t\turi += `&counter=${encodeURIComponent(otp.counter)}`;\n\t\t}\n\n\t\treturn uri;\n\t}\n}\n\n// CONCATENATED MODULE: ./src/otp.js\n\n\n\n// eslint-disable-next-line import/no-cycle\n\n\n/**\n * Default configuration.\n * @private\n * @type {Object}\n */\nconst defaults = {\n\tissuer: '',\n\tlabel: 'OTPAuth',\n\talgorithm: 'SHA1',\n\tdigits: 6,\n\tcounter: 0,\n\tperiod: 30,\n\twindow: 50,\n\tpad: true\n};\n\n/**\n * HOTP: An HMAC-based One-time Password Algorithm (RFC 4226).\n * @see https://tools.ietf.org/html/rfc4226\n */\nclass otp_HOTP {\n\t/**\n\t * @param {Object} [config] Configuration options.\n\t * @param {string} [config.issuer=''] Account provider.\n\t * @param {string} [config.label='OTPAuth'] Account label.\n\t * @param {Secret} [config.secret=Secret] Secret key.\n\t * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n\t * @param {number} [config.digits=6] Token length.\n\t * @param {number} [config.counter=0] Initial counter value.\n\t */\n\tconstructor({\n\t\tissuer = defaults.issuer,\n\t\tlabel = defaults.label,\n\t\tsecret = new secret_Secret(),\n\t\talgorithm = defaults.algorithm,\n\t\tdigits = defaults.digits,\n\t\tcounter = defaults.counter\n\t} = {}) {\n\t\t/**\n\t\t * Account provider.\n\t\t * @type {string}\n\t\t */\n\t\tthis.issuer = issuer;\n\t\t/**\n\t\t * Account label.\n\t\t * @type {string}\n\t\t */\n\t\tthis.label = label;\n\t\t/**\n\t\t * Secret key.\n\t\t * @type {Secret}\n\t\t */\n\t\tthis.secret = secret;\n\t\t/**\n\t\t * HMAC hashing algorithm.\n\t\t * @type {string}\n\t\t */\n\t\tthis.algorithm = algorithm;\n\t\t/**\n\t\t * Token length.\n\t\t * @type {number}\n\t\t */\n\t\tthis.digits = digits;\n\t\t/**\n\t\t * Initial counter value.\n\t\t * @type {number}\n\t\t */\n\t\tthis.counter = counter;\n\t}\n\n\t/**\n\t * Generates an HOTP token.\n\t * @param {Object} config Configuration options.\n\t * @param {Secret} config.secret Secret key.\n\t * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n\t * @param {number} [config.digits=6] Token length.\n\t * @param {number} [config.counter=0] Counter value.\n\t * @param {boolean} [config.pad=true] Add leading zeros to result.\n\t * @returns {string|number} Token.\n\t */\n\tstatic generate({\n\t\tsecret,\n\t\talgorithm = defaults.algorithm,\n\t\tdigits = defaults.digits,\n\t\tcounter = defaults.counter,\n\t\tpad = defaults.pad\n\t}) {\n\t\tconst digest = new Uint8Array(src_crypto[\"a\" /* Crypto */].hmacDigest(algorithm, secret.buffer, utils[\"b\" /* Utils */].uint.encode(counter)));\n\t\tconst offset = digest[digest.byteLength - 1] & 15;\n\t\tconst otp = (\n\t\t\t((digest[offset] & 127) << 24)\n\t\t\t| ((digest[offset + 1] & 255) << 16)\n\t\t\t| ((digest[offset + 2] & 255) << 8)\n\t\t\t| (digest[offset + 3] & 255)\n\t\t) % (10 ** digits);\n\n\t\treturn pad\n\t\t\t? new Array(1 + digits - String(otp).length).join('0') + otp\n\t\t\t: otp;\n\t}\n\n\t/**\n\t * Generates an HOTP token.\n\t * @param {Object} [config] Configuration options.\n\t * @param {number} [config.counter=this.counter++] Counter value.\n\t * @param {boolean} [config.pad=true] Add leading zeros to result.\n\t * @returns {string|number} Token.\n\t */\n\tgenerate({\n\t\tcounter = this.counter++,\n\t\tpad\n\t} = {}) {\n\t\treturn otp_HOTP.generate({\n\t\t\tsecret: this.secret,\n\t\t\talgorithm: this.algorithm,\n\t\t\tdigits: this.digits,\n\t\t\tcounter,\n\t\t\tpad\n\t\t});\n\t}\n\n\t/**\n\t * Validates an HOTP token.\n\t * @param {Object} config Configuration options.\n\t * @param {string} config.token Token value.\n\t * @param {Secret} config.secret Secret key.\n\t * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n\t * @param {number} [config.counter=0] Counter value.\n\t * @param {number} [config.window=50] Window of counter values to test.\n\t * @returns {number|null} Token delta, or null if the token is not found.\n\t */\n\tstatic validate({\n\t\ttoken,\n\t\tsecret,\n\t\talgorithm,\n\t\tcounter = defaults.counter,\n\t\twindow = defaults.window\n\t}) {\n\t\tconst searchToken = Number.parseInt(token, 10);\n\n\t\tfor (let i = counter - window; i <= counter + window; ++i) {\n\t\t\tconst generatedToken = otp_HOTP.generate({\n\t\t\t\tsecret,\n\t\t\t\talgorithm,\n\t\t\t\tcounter: i,\n\t\t\t\tdigits: token.length,\n\t\t\t\tpad: false\n\t\t\t});\n\n\t\t\tif (searchToken === generatedToken) {\n\t\t\t\treturn i - counter;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Validates an HOTP token.\n\t * @param {Object} config Configuration options.\n\t * @param {string} config.token Token value.\n\t * @param {number} [config.counter=this.counter] Counter value.\n\t * @param {number} [config.window=50] Window of counter values to test.\n\t * @returns {number|null} Token delta, or null if the token is not found.\n\t */\n\tvalidate({\n\t\ttoken,\n\t\tcounter = this.counter,\n\t\twindow\n\t}) {\n\t\treturn otp_HOTP.validate({\n\t\t\ttoken,\n\t\t\tsecret: this.secret,\n\t\t\talgorithm: this.algorithm,\n\t\t\tcounter,\n\t\t\twindow\n\t\t});\n\t}\n\n\t/**\n\t * Returns a Google Authenticator key URI.\n\t * @returns {string} URI.\n\t */\n\ttoString() {\n\t\treturn uri_URI.stringify(this);\n\t}\n}\n\n/**\n * TOTP: Time-Based One-Time Password Algorithm (RFC 6238).\n * @see https://tools.ietf.org/html/rfc6238\n */\nclass otp_TOTP {\n\t/**\n\t * @param {Object} [config] Configuration options.\n\t * @param {string} [config.issuer=''] Account provider.\n\t * @param {string} [config.label='OTPAuth'] Account label.\n\t * @param {Secret} [config.secret=Secret] Secret key.\n\t * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n\t * @param {number} [config.digits=6] Token length.\n\t * @param {number} [config.period=30] Token time-step duration.\n\t */\n\tconstructor({\n\t\tissuer = defaults.issuer,\n\t\tlabel = defaults.label,\n\t\tsecret = new secret_Secret(),\n\t\talgorithm = defaults.algorithm,\n\t\tdigits = defaults.digits,\n\t\tperiod = defaults.period\n\t} = {}) {\n\t\t/**\n\t\t * Account provider.\n\t\t * @type {string}\n\t\t */\n\t\tthis.issuer = issuer;\n\t\t/**\n\t\t * Account label.\n\t\t * @type {string}\n\t\t */\n\t\tthis.label = label;\n\t\t/**\n\t\t * Secret key.\n\t\t * @type {string}\n\t\t */\n\t\tthis.secret = secret;\n\t\t/**\n\t\t * HMAC hashing algorithm.\n\t\t * @type {Secret}\n\t\t */\n\t\tthis.algorithm = algorithm;\n\t\t/**\n\t\t * Token length.\n\t\t * @type {number}\n\t\t */\n\t\tthis.digits = digits;\n\t\t/**\n\t\t * Token time-step duration.\n\t\t * @type {number}\n\t\t */\n\t\tthis.period = period;\n\t}\n\n\t/**\n\t * Generates a TOTP token.\n\t * @param {Object} config Configuration options.\n\t * @param {Secret} config.secret Secret key.\n\t * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n\t * @param {number} [config.digits=6] Token length.\n\t * @param {number} [config.period=30] Token time-step duration.\n\t * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n\t * @param {boolean} [config.pad=true] Add leading zeros to result.\n\t * @returns {string|number} Token.\n\t */\n\tstatic generate({\n\t\tsecret,\n\t\talgorithm,\n\t\tdigits,\n\t\tperiod = defaults.period,\n\t\ttimestamp = Date.now(),\n\t\tpad\n\t}) {\n\t\treturn otp_HOTP.generate({\n\t\t\tsecret,\n\t\t\talgorithm,\n\t\t\tdigits,\n\t\t\tcounter: Math.floor(timestamp / 1000 / period),\n\t\t\tpad\n\t\t});\n\t}\n\n\t/**\n\t * Generates a TOTP token.\n\t * @param {Object} [config] Configuration options.\n\t * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n\t * @param {boolean} [config.pad=true] Add leading zeros to result.\n\t * @returns {string|number} Token.\n\t */\n\tgenerate({\n\t\ttimestamp = Date.now(),\n\t\tpad\n\t} = {}) {\n\t\treturn otp_TOTP.generate({\n\t\t\tsecret: this.secret,\n\t\t\talgorithm: this.algorithm,\n\t\t\tdigits: this.digits,\n\t\t\tperiod: this.period,\n\t\t\ttimestamp,\n\t\t\tpad\n\t\t});\n\t}\n\n\t/**\n\t * Validates a TOTP token.\n\t * @param {Object} config Configuration options.\n\t * @param {string} config.token Token value.\n\t * @param {Secret} config.secret Secret key.\n\t * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n\t * @param {number} [config.period=30] Token time-step duration.\n\t * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n\t * @param {number} [config.window=50] Window of counter values to test.\n\t * @returns {number|null} Token delta, or null if the token is not found.\n\t */\n\tstatic validate({\n\t\ttoken,\n\t\tsecret,\n\t\talgorithm,\n\t\tperiod = defaults.period,\n\t\ttimestamp = Date.now(),\n\t\twindow\n\t}) {\n\t\treturn otp_HOTP.validate({\n\t\t\ttoken,\n\t\t\tsecret,\n\t\t\talgorithm,\n\t\t\tcounter: Math.floor(timestamp / 1000 / period),\n\t\t\twindow\n\t\t});\n\t}\n\n\t/**\n\t * Validates a TOTP token.\n\t * @param {Object} config Configuration options.\n\t * @param {string} config.token Token value.\n\t * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n\t * @param {number} [config.window=50] Window of counter values to test.\n\t * @returns {number|null} Token delta, or null if the token is not found.\n\t */\n\tvalidate({\n\t\ttoken,\n\t\ttimestamp,\n\t\twindow\n\t}) {\n\t\treturn otp_TOTP.validate({\n\t\t\ttoken,\n\t\t\tsecret: this.secret,\n\t\t\talgorithm: this.algorithm,\n\t\t\tperiod: this.period,\n\t\t\ttimestamp,\n\t\t\twindow\n\t\t});\n\t}\n\n\t/**\n\t * Returns a Google Authenticator key URI.\n\t * @returns {string} URI.\n\t */\n\ttoString() {\n\t\treturn uri_URI.stringify(this);\n\t}\n}\n\n// CONCATENATED MODULE: ./src/main.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"version\", function() { return version; });\n/* concated harmony reexport HOTP */__webpack_require__.d(__webpack_exports__, \"HOTP\", function() { return otp_HOTP; });\n/* concated harmony reexport TOTP */__webpack_require__.d(__webpack_exports__, \"TOTP\", function() { return otp_TOTP; });\n/* concated harmony reexport URI */__webpack_require__.d(__webpack_exports__, \"URI\", function() { return uri_URI; });\n/* concated harmony reexport Secret */__webpack_require__.d(__webpack_exports__, \"Secret\", function() { return secret_Secret; });\n/* concated harmony reexport Utils */__webpack_require__.d(__webpack_exports__, \"Utils\", function() { return utils[\"b\" /* Utils */]; });\n/**\n * One Time Password (HOTP/TOTP) library for Node.js and browser.\n * @module OTPAuth\n * @author Héctor Molinero Fernández <hector@molinero.dev>\n */\n\n\n\n\n\n/**\n * Library version.\n * @type {string}\n */\nconst version = \"3.2.7\";\n\n\n/***/ })\n/******/ ]);\n});"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","/**\n * An object containing some utilities.\n * @type {Object}\n */\nexport const Utils = {};\n\n/**\n * UInt conversion.\n * @type {Object}\n */\nUtils.uint = {};\n\n/**\n * Converts an ArrayBuffer to an integer.\n * @param {ArrayBuffer} buf ArrayBuffer.\n * @returns {number} Integer.\n */\nUtils.uint.decode = buf => {\n\tconst arr = new Uint8Array(buf);\n\tlet num = 0;\n\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tif (arr[i] !== 0) {\n\t\t\tnum *= 256;\n\t\t\tnum += arr[i];\n\t\t}\n\t}\n\n\treturn num;\n};\n\n/**\n * Converts an integer to an ArrayBuffer.\n * @param {number} num Integer.\n * @returns {ArrayBuffer} ArrayBuffer.\n */\nUtils.uint.encode = num => {\n\tconst buf = new ArrayBuffer(8);\n\tconst arr = new Uint8Array(buf);\n\tlet acc = num;\n\n\tfor (let i = 7; i >= 0; i--) {\n\t\tif (acc === 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tarr[i] = acc & 255;\n\t\tacc -= arr[i];\n\t\tacc /= 256;\n\t}\n\n\treturn buf;\n};\n\n/**\n * Raw string conversion.\n * @type {Object}\n */\nUtils.raw = {};\n\n/**\n * Converts an ArrayBuffer to a string.\n * @param {ArrayBuffer} buf ArrayBuffer.\n * @returns {string} String.\n */\nUtils.raw.decode = buf => {\n\tconst arr = new Uint8Array(buf);\n\tlet str = '';\n\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tstr += String.fromCharCode(arr[i]);\n\t}\n\n\treturn str;\n};\n\n/**\n * Converts a string to an ArrayBuffer.\n * @param {string} str String.\n * @returns {ArrayBuffer} ArrayBuffer.\n */\nUtils.raw.encode = str => {\n\tconst buf = new ArrayBuffer(str.length);\n\tconst arr = new Uint8Array(buf);\n\n\tfor (let i = 0; i < str.length; i++) {\n\t\tarr[i] = str.charCodeAt(i);\n\t}\n\n\treturn buf;\n};\n\n/**\n * Base32 string conversion.\n * @type {Object}\n */\nUtils.b32 = {};\n\n/**\n * RFC 4648 base32 alphabet without pad.\n * @type {string}\n */\nUtils.b32.alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';\n\n/**\n * Converts an ArrayBuffer to a base32 string (RFC 4648).\n * @see https://github.com/LinusU/base32-decode\n * @param {ArrayBuffer} buf ArrayBuffer.\n * @returns {string} Base32 string.\n */\nUtils.b32.decode = buf => {\n\tconst arr = new Uint8Array(buf);\n\n\tlet bits = 0;\n\tlet value = 0;\n\tlet str = '';\n\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tvalue = (value << 8) | arr[i];\n\t\tbits += 8;\n\n\t\twhile (bits >= 5) {\n\t\t\tstr += Utils.b32.alphabet[(value >>> bits - 5) & 31];\n\t\t\tbits -= 5;\n\t\t}\n\t}\n\n\tif (bits > 0) {\n\t\tstr += Utils.b32.alphabet[(value << 5 - bits) & 31];\n\t}\n\n\treturn str;\n};\n\n/**\n * Converts a base32 string to an ArrayBuffer (RFC 4648).\n * @see https://github.com/LinusU/base32-encode\n * @param {string} str Base32 string.\n * @returns {ArrayBuffer} ArrayBuffer.\n */\nUtils.b32.encode = str => {\n\tconst strUpp = str.toUpperCase();\n\tconst buf = new ArrayBuffer(str.length * 5 / 8 | 0);\n\tconst arr = new Uint8Array(buf);\n\n\tlet bits = 0;\n\tlet value = 0;\n\tlet index = 0;\n\n\tfor (let i = 0; i < strUpp.length; i++) {\n\t\tconst idx = Utils.b32.alphabet.indexOf(strUpp[i]);\n\n\t\tif (idx === -1) {\n\t\t\tthrow new TypeError(`Invalid character found: ${strUpp[i]}`);\n\t\t}\n\n\t\tvalue = (value << 5) | idx;\n\t\tbits += 5;\n\n\t\tif (bits >= 8) {\n\t\t\tarr[index++] = (value >>> bits - 8) & 255;\n\t\t\tbits -= 8;\n\t\t}\n\t}\n\n\treturn buf;\n};\n\n/**\n * Hexadecimal string conversion.\n * @type {Object}\n */\nUtils.hex = {};\n\n/**\n * Converts an ArrayBuffer to a hexadecimal string.\n * @param {ArrayBuffer} buf ArrayBuffer.\n * @returns {string} Hexadecimal string.\n */\nUtils.hex.decode = buf => {\n\tconst arr = new Uint8Array(buf);\n\tlet str = '';\n\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tconst hexByte = arr[i].toString(16);\n\n\t\tstr += hexByte.length === 1\n\t\t\t? `0${hexByte}`\n\t\t\t: hexByte;\n\t}\n\n\treturn str.toUpperCase();\n};\n\n/**\n * Converts a hexadecimal string to an ArrayBuffer.\n * @param {string} str Hexadecimal string.\n * @returns {ArrayBuffer} ArrayBuffer.\n */\nUtils.hex.encode = str => {\n\tconst buf = new ArrayBuffer(str.length / 2);\n\tconst arr = new Uint8Array(buf);\n\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tarr[i] = Number.parseInt(str.substr(i * 2, 2), 16);\n\t}\n\n\treturn buf;\n};\n\n/**\n * An object containing some utilities (for internal use only).\n * @private\n * @type {Object}\n */\nexport const InternalUtils = {};\n\n/**\n * Detect if running in \"Node.js\".\n * @type {boolean}\n */\n// eslint-disable-next-line dot-notation\nInternalUtils.isNode = Object.prototype.toString.call(global['process']) === '[object process]';\n\n/**\n * Dynamically import \"Node.js\" modules.\n * @param {string} name Name.\n * @returns {Object} Module.\n */\n// eslint-disable-next-line no-eval\nInternalUtils.require = name => (InternalUtils.isNode ? eval('require')(name) : null);\n","\n\t\t\t\t\t/** @fileOverview Javascript cryptography implementation.\n *\n * Crush to remove comments, shorten variable names and\n * generally reduce transmission size.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n\"use strict\";\n/*jslint indent: 2, bitwise: false, nomen: false, plusplus: false, white: false, regexp: false */\n/*global document, window, escape, unescape, module, require, Uint32Array */\n\n/**\n * The Stanford Javascript Crypto Library, top-level namespace.\n * @namespace\n */\nvar sjcl = {\n  /**\n   * Symmetric ciphers.\n   * @namespace\n   */\n  cipher: {},\n\n  /**\n   * Hash functions.  Right now only SHA256 is implemented.\n   * @namespace\n   */\n  hash: {},\n\n  /**\n   * Key exchange functions.  Right now only SRP is implemented.\n   * @namespace\n   */\n  keyexchange: {},\n  \n  /**\n   * Cipher modes of operation.\n   * @namespace\n   */\n  mode: {},\n\n  /**\n   * Miscellaneous.  HMAC and PBKDF2.\n   * @namespace\n   */\n  misc: {},\n  \n  /**\n   * Bit array encoders and decoders.\n   * @namespace\n   *\n   * @description\n   * The members of this namespace are functions which translate between\n   * SJCL's bitArrays and other objects (usually strings).  Because it\n   * isn't always clear which direction is encoding and which is decoding,\n   * the method names are \"fromBits\" and \"toBits\".\n   */\n  codec: {},\n  \n  /**\n   * Exceptions.\n   * @namespace\n   */\n  exception: {\n    /**\n     * Ciphertext is corrupt.\n     * @constructor\n     */\n    corrupt: function(message) {\n      this.toString = function() { return \"CORRUPT: \"+this.message; };\n      this.message = message;\n    },\n    \n    /**\n     * Invalid parameter.\n     * @constructor\n     */\n    invalid: function(message) {\n      this.toString = function() { return \"INVALID: \"+this.message; };\n      this.message = message;\n    },\n    \n    /**\n     * Bug or missing feature in SJCL.\n     * @constructor\n     */\n    bug: function(message) {\n      this.toString = function() { return \"BUG: \"+this.message; };\n      this.message = message;\n    },\n\n    /**\n     * Something isn't ready.\n     * @constructor\n     */\n    notReady: function(message) {\n      this.toString = function() { return \"NOT READY: \"+this.message; };\n      this.message = message;\n    }\n  }\n};\n/** @fileOverview Arrays of bits, encoded as arrays of Numbers.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/**\n * Arrays of bits, encoded as arrays of Numbers.\n * @namespace\n * @description\n * <p>\n * These objects are the currency accepted by SJCL's crypto functions.\n * </p>\n *\n * <p>\n * Most of our crypto primitives operate on arrays of 4-byte words internally,\n * but many of them can take arguments that are not a multiple of 4 bytes.\n * This library encodes arrays of bits (whose size need not be a multiple of 8\n * bits) as arrays of 32-bit words.  The bits are packed, big-endian, into an\n * array of words, 32 bits at a time.  Since the words are double-precision\n * floating point numbers, they fit some extra data.  We use this (in a private,\n * possibly-changing manner) to encode the number of bits actually  present\n * in the last word of the array.\n * </p>\n *\n * <p>\n * Because bitwise ops clear this out-of-band data, these arrays can be passed\n * to ciphers like AES which want arrays of words.\n * </p>\n */\nsjcl.bitArray = {\n  /**\n   * Array slices in units of bits.\n   * @param {bitArray} a The array to slice.\n   * @param {Number} bstart The offset to the start of the slice, in bits.\n   * @param {Number} bend The offset to the end of the slice, in bits.  If this is undefined,\n   * slice until the end of the array.\n   * @return {bitArray} The requested slice.\n   */\n  bitSlice: function (a, bstart, bend) {\n    a = sjcl.bitArray._shiftRight(a.slice(bstart/32), 32 - (bstart & 31)).slice(1);\n    return (bend === undefined) ? a : sjcl.bitArray.clamp(a, bend-bstart);\n  },\n\n  /**\n   * Extract a number packed into a bit array.\n   * @param {bitArray} a The array to slice.\n   * @param {Number} bstart The offset to the start of the slice, in bits.\n   * @param {Number} blength The length of the number to extract.\n   * @return {Number} The requested slice.\n   */\n  extract: function(a, bstart, blength) {\n    // FIXME: this Math.floor is not necessary at all, but for some reason\n    // seems to suppress a bug in the Chromium JIT.\n    var x, sh = Math.floor((-bstart-blength) & 31);\n    if ((bstart + blength - 1 ^ bstart) & -32) {\n      // it crosses a boundary\n      x = (a[bstart/32|0] << (32 - sh)) ^ (a[bstart/32+1|0] >>> sh);\n    } else {\n      // within a single word\n      x = a[bstart/32|0] >>> sh;\n    }\n    return x & ((1<<blength) - 1);\n  },\n\n  /**\n   * Concatenate two bit arrays.\n   * @param {bitArray} a1 The first array.\n   * @param {bitArray} a2 The second array.\n   * @return {bitArray} The concatenation of a1 and a2.\n   */\n  concat: function (a1, a2) {\n    if (a1.length === 0 || a2.length === 0) {\n      return a1.concat(a2);\n    }\n    \n    var last = a1[a1.length-1], shift = sjcl.bitArray.getPartial(last);\n    if (shift === 32) {\n      return a1.concat(a2);\n    } else {\n      return sjcl.bitArray._shiftRight(a2, shift, last|0, a1.slice(0,a1.length-1));\n    }\n  },\n\n  /**\n   * Find the length of an array of bits.\n   * @param {bitArray} a The array.\n   * @return {Number} The length of a, in bits.\n   */\n  bitLength: function (a) {\n    var l = a.length, x;\n    if (l === 0) { return 0; }\n    x = a[l - 1];\n    return (l-1) * 32 + sjcl.bitArray.getPartial(x);\n  },\n\n  /**\n   * Truncate an array.\n   * @param {bitArray} a The array.\n   * @param {Number} len The length to truncate to, in bits.\n   * @return {bitArray} A new array, truncated to len bits.\n   */\n  clamp: function (a, len) {\n    if (a.length * 32 < len) { return a; }\n    a = a.slice(0, Math.ceil(len / 32));\n    var l = a.length;\n    len = len & 31;\n    if (l > 0 && len) {\n      a[l-1] = sjcl.bitArray.partial(len, a[l-1] & 0x80000000 >> (len-1), 1);\n    }\n    return a;\n  },\n\n  /**\n   * Make a partial word for a bit array.\n   * @param {Number} len The number of bits in the word.\n   * @param {Number} x The bits.\n   * @param {Number} [_end=0] Pass 1 if x has already been shifted to the high side.\n   * @return {Number} The partial word.\n   */\n  partial: function (len, x, _end) {\n    if (len === 32) { return x; }\n    return (_end ? x|0 : x << (32-len)) + len * 0x10000000000;\n  },\n\n  /**\n   * Get the number of bits used by a partial word.\n   * @param {Number} x The partial word.\n   * @return {Number} The number of bits used by the partial word.\n   */\n  getPartial: function (x) {\n    return Math.round(x/0x10000000000) || 32;\n  },\n\n  /**\n   * Compare two arrays for equality in a predictable amount of time.\n   * @param {bitArray} a The first array.\n   * @param {bitArray} b The second array.\n   * @return {boolean} true if a == b; false otherwise.\n   */\n  equal: function (a, b) {\n    if (sjcl.bitArray.bitLength(a) !== sjcl.bitArray.bitLength(b)) {\n      return false;\n    }\n    var x = 0, i;\n    for (i=0; i<a.length; i++) {\n      x |= a[i]^b[i];\n    }\n    return (x === 0);\n  },\n\n  /** Shift an array right.\n   * @param {bitArray} a The array to shift.\n   * @param {Number} shift The number of bits to shift.\n   * @param {Number} [carry=0] A byte to carry in\n   * @param {bitArray} [out=[]] An array to prepend to the output.\n   * @private\n   */\n  _shiftRight: function (a, shift, carry, out) {\n    var i, last2=0, shift2;\n    if (out === undefined) { out = []; }\n    \n    for (; shift >= 32; shift -= 32) {\n      out.push(carry);\n      carry = 0;\n    }\n    if (shift === 0) {\n      return out.concat(a);\n    }\n    \n    for (i=0; i<a.length; i++) {\n      out.push(carry | a[i]>>>shift);\n      carry = a[i] << (32-shift);\n    }\n    last2 = a.length ? a[a.length-1] : 0;\n    shift2 = sjcl.bitArray.getPartial(last2);\n    out.push(sjcl.bitArray.partial(shift+shift2 & 31, (shift + shift2 > 32) ? carry : out.pop(),1));\n    return out;\n  },\n  \n  /** xor a block of 4 words together.\n   * @private\n   */\n  _xor4: function(x,y) {\n    return [x[0]^y[0],x[1]^y[1],x[2]^y[2],x[3]^y[3]];\n  },\n\n  /** byteswap a word array inplace.\n   * (does not handle partial words)\n   * @param {sjcl.bitArray} a word array\n   * @return {sjcl.bitArray} byteswapped array\n   */\n  byteswapM: function(a) {\n    var i, v, m = 0xff00;\n    for (i = 0; i < a.length; ++i) {\n      v = a[i];\n      a[i] = (v >>> 24) | ((v >>> 8) & m) | ((v & m) << 8) | (v << 24);\n    }\n    return a;\n  }\n};\n/** @fileOverview Bit array codec implementations.\n *\n * @author Marco Munizaga\n */\n\n//patch arraybuffers if they don't exist\nif (typeof(ArrayBuffer) === 'undefined') {\n  (function(globals){\n      \"use strict\";\n      globals.ArrayBuffer = function(){};\n      globals.DataView = function(){};\n  }(this));\n}\n\n/**\n * ArrayBuffer\n * @namespace\n */\nsjcl.codec.arrayBuffer = {\n  /** Convert from a bitArray to an ArrayBuffer. \n   * Will default to 8byte padding if padding is undefined*/\n  fromBits: function (arr, padding, padding_count) {\n    var out, i, ol, tmp, smallest;\n    padding = padding==undefined  ? true : padding;\n    padding_count = padding_count || 8;\n\n    if (arr.length === 0) {\n      return new ArrayBuffer(0);\n    }\n\n    ol = sjcl.bitArray.bitLength(arr)/8;\n\n    //check to make sure the bitLength is divisible by 8, if it isn't \n    //we can't do anything since arraybuffers work with bytes, not bits\n    if ( sjcl.bitArray.bitLength(arr)%8 !== 0 ) {\n      throw new sjcl.exception.invalid(\"Invalid bit size, must be divisble by 8 to fit in an arraybuffer correctly\");\n    }\n\n    if (padding && ol%padding_count !== 0){\n      ol += padding_count - (ol%padding_count);\n    }\n\n\n    //padded temp for easy copying\n    tmp = new DataView(new ArrayBuffer(arr.length*4));\n    for (i=0; i<arr.length; i++) {\n      tmp.setUint32(i*4, (arr[i]<<32)); //get rid of the higher bits\n    }\n\n    //now copy the final message if we are not going to 0 pad\n    out = new DataView(new ArrayBuffer(ol));\n\n    //save a step when the tmp and out bytelength are ===\n    if (out.byteLength === tmp.byteLength){\n      return tmp.buffer;\n    }\n\n    smallest = tmp.byteLength < out.byteLength ? tmp.byteLength : out.byteLength;\n    for(i=0; i<smallest; i++){\n      out.setUint8(i,tmp.getUint8(i));\n    }\n\n\n    return out.buffer;\n  },\n  /** Convert from an ArrayBuffer to a bitArray. */\n  toBits: function (buffer) {\n    var i, out=[], len, inView, tmp;\n\n    if (buffer.byteLength === 0) {\n      return [];\n    }\n\n    inView = new DataView(buffer);\n    len = inView.byteLength - inView.byteLength%4;\n\n    for (var i = 0; i < len; i+=4) {\n      out.push(inView.getUint32(i));\n    }\n\n    if (inView.byteLength%4 != 0) {\n      tmp = new DataView(new ArrayBuffer(4));\n      for (var i = 0, l = inView.byteLength%4; i < l; i++) {\n        //we want the data to the right, because partial slices off the starting bits\n        tmp.setUint8(i+4-l, inView.getUint8(len+i)); // big-endian, \n      }\n      out.push(\n        sjcl.bitArray.partial( (inView.byteLength%4)*8, tmp.getUint32(0) )\n      ); \n    }\n    return out;\n  },\n\n\n\n  /** Prints a hex output of the buffer contents, akin to hexdump **/\n  hexDumpBuffer: function(buffer){\n      var stringBufferView = new DataView(buffer);\n      var string = '';\n      var pad = function (n, width) {\n          n = n + '';\n          return n.length >= width ? n : new Array(width - n.length + 1).join('0') + n;\n      };\n\n      for (var i = 0; i < stringBufferView.byteLength; i+=2) {\n          if (i%16 == 0) string += ('\\n'+(i).toString(16)+'\\t');\n          string += ( pad(stringBufferView.getUint16(i).toString(16),4) + ' ');\n      }\n\n      if ( typeof console === undefined ){\n        console = console || {log:function(){}}; //fix for IE\n      }\n      console.log(string.toUpperCase());\n  }\n};\n\n/** @fileOverview Javascript SHA-1 implementation.\n *\n * Based on the implementation in RFC 3174, method 1, and on the SJCL\n * SHA-256 implementation.\n *\n * @author Quinn Slack\n */\n\n/**\n * Context for a SHA-1 operation in progress.\n * @constructor\n */\nsjcl.hash.sha1 = function (hash) {\n  if (hash) {\n    this._h = hash._h.slice(0);\n    this._buffer = hash._buffer.slice(0);\n    this._length = hash._length;\n  } else {\n    this.reset();\n  }\n};\n\n/**\n * Hash a string or an array of words.\n * @static\n * @param {bitArray|String} data the data to hash.\n * @return {bitArray} The hash value, an array of 5 big-endian words.\n */\nsjcl.hash.sha1.hash = function (data) {\n  return (new sjcl.hash.sha1()).update(data).finalize();\n};\n\nsjcl.hash.sha1.prototype = {\n  /**\n   * The hash's block size, in bits.\n   * @constant\n   */\n  blockSize: 512,\n   \n  /**\n   * Reset the hash state.\n   * @return this\n   */\n  reset:function () {\n    this._h = this._init.slice(0);\n    this._buffer = [];\n    this._length = 0;\n    return this;\n  },\n  \n  /**\n   * Input several words to the hash.\n   * @param {bitArray|String} data the data to hash.\n   * @return this\n   */\n  update: function (data) {\n    if (typeof data === \"string\") {\n      data = sjcl.codec.utf8String.toBits(data);\n    }\n    var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),\n        ol = this._length,\n        nl = this._length = ol + sjcl.bitArray.bitLength(data);\n    if (nl > 9007199254740991){\n      throw new sjcl.exception.invalid(\"Cannot hash more than 2^53 - 1 bits\");\n    }\n\n    if (typeof Uint32Array !== 'undefined') {\n\tvar c = new Uint32Array(b);\n    \tvar j = 0;\n    \tfor (i = this.blockSize+ol - ((this.blockSize+ol) & (this.blockSize-1)); i <= nl;\n\t\ti+= this.blockSize) {\n      \t    this._block(c.subarray(16 * j, 16 * (j+1)));\n      \t    j += 1;\n    \t}\n    \tb.splice(0, 16 * j);\n    } else {\n    \tfor (i = this.blockSize+ol - ((this.blockSize+ol) & (this.blockSize-1)); i <= nl;\n             i+= this.blockSize) {\n      \t     this._block(b.splice(0,16));\n      \t}\n    }\n    return this;\n  },\n  \n  /**\n   * Complete hashing and output the hash value.\n   * @return {bitArray} The hash value, an array of 5 big-endian words. TODO\n   */\n  finalize:function () {\n    var i, b = this._buffer, h = this._h;\n\n    // Round out and push the buffer\n    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);\n    // Round out the buffer to a multiple of 16 words, less the 2 length words.\n    for (i = b.length + 2; i & 15; i++) {\n      b.push(0);\n    }\n\n    // append the length\n    b.push(Math.floor(this._length / 0x100000000));\n    b.push(this._length | 0);\n\n    while (b.length) {\n      this._block(b.splice(0,16));\n    }\n\n    this.reset();\n    return h;\n  },\n\n  /**\n   * The SHA-1 initialization vector.\n   * @private\n   */\n  _init:[0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0],\n\n  /**\n   * The SHA-1 hash key.\n   * @private\n   */\n  _key:[0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6],\n\n  /**\n   * The SHA-1 logical functions f(0), f(1), ..., f(79).\n   * @private\n   */\n  _f:function(t, b, c, d) {\n    if (t <= 19) {\n      return (b & c) | (~b & d);\n    } else if (t <= 39) {\n      return b ^ c ^ d;\n    } else if (t <= 59) {\n      return (b & c) | (b & d) | (c & d);\n    } else if (t <= 79) {\n      return b ^ c ^ d;\n    }\n  },\n\n  /**\n   * Circular left-shift operator.\n   * @private\n   */\n  _S:function(n, x) {\n    return (x << n) | (x >>> 32-n);\n  },\n  \n  /**\n   * Perform one cycle of SHA-1.\n   * @param {Uint32Array|bitArray} words one block of words.\n   * @private\n   */\n  _block:function (words) {\n    var t, tmp, a, b, c, d, e,\n    h = this._h;\n    var w;\n    if (typeof Uint32Array !== 'undefined') {\n        // When words is passed to _block, it has 16 elements. SHA1 _block\n        // function extends words with new elements (at the end there are 80 elements). \n        // The problem is that if we use Uint32Array instead of Array, \n        // the length of Uint32Array cannot be changed. Thus, we replace words with a \n        // normal Array here.\n        w = Array(80); // do not use Uint32Array here as the instantiation is slower\n        for (var j=0; j<16; j++){\n            w[j] = words[j];\n        }\n    } else {\n        w = words;\n    }\n\n    a = h[0]; b = h[1]; c = h[2]; d = h[3]; e = h[4]; \n\n    for (t=0; t<=79; t++) {\n      if (t >= 16) {\n        w[t] = this._S(1, w[t-3] ^ w[t-8] ^ w[t-14] ^ w[t-16]);\n      }\n      tmp = (this._S(5, a) + this._f(t, b, c, d) + e + w[t] +\n             this._key[Math.floor(t/20)]) | 0;\n      e = d;\n      d = c;\n      c = this._S(30, b);\n      b = a;\n      a = tmp;\n   }\n\n   h[0] = (h[0]+a) |0;\n   h[1] = (h[1]+b) |0;\n   h[2] = (h[2]+c) |0;\n   h[3] = (h[3]+d) |0;\n   h[4] = (h[4]+e) |0;\n  }\n};\n/** @fileOverview Javascript SHA-256 implementation.\n *\n * An older version of this implementation is available in the public\n * domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,\n * Stanford University 2008-2010 and BSD-licensed for liability\n * reasons.\n *\n * Special thanks to Aldo Cortesi for pointing out several bugs in\n * this code.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/**\n * Context for a SHA-256 operation in progress.\n * @constructor\n */\nsjcl.hash.sha256 = function (hash) {\n  if (!this._key[0]) { this._precompute(); }\n  if (hash) {\n    this._h = hash._h.slice(0);\n    this._buffer = hash._buffer.slice(0);\n    this._length = hash._length;\n  } else {\n    this.reset();\n  }\n};\n\n/**\n * Hash a string or an array of words.\n * @static\n * @param {bitArray|String} data the data to hash.\n * @return {bitArray} The hash value, an array of 16 big-endian words.\n */\nsjcl.hash.sha256.hash = function (data) {\n  return (new sjcl.hash.sha256()).update(data).finalize();\n};\n\nsjcl.hash.sha256.prototype = {\n  /**\n   * The hash's block size, in bits.\n   * @constant\n   */\n  blockSize: 512,\n   \n  /**\n   * Reset the hash state.\n   * @return this\n   */\n  reset:function () {\n    this._h = this._init.slice(0);\n    this._buffer = [];\n    this._length = 0;\n    return this;\n  },\n  \n  /**\n   * Input several words to the hash.\n   * @param {bitArray|String} data the data to hash.\n   * @return this\n   */\n  update: function (data) {\n    if (typeof data === \"string\") {\n      data = sjcl.codec.utf8String.toBits(data);\n    }\n    var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),\n        ol = this._length,\n        nl = this._length = ol + sjcl.bitArray.bitLength(data);\n    if (nl > 9007199254740991){\n      throw new sjcl.exception.invalid(\"Cannot hash more than 2^53 - 1 bits\");\n    }\n\n    if (typeof Uint32Array !== 'undefined') {\n\tvar c = new Uint32Array(b);\n    \tvar j = 0;\n    \tfor (i = 512+ol - ((512+ol) & 511); i <= nl; i+= 512) {\n      \t    this._block(c.subarray(16 * j, 16 * (j+1)));\n      \t    j += 1;\n    \t}\n    \tb.splice(0, 16 * j);\n    } else {\n\tfor (i = 512+ol - ((512+ol) & 511); i <= nl; i+= 512) {\n      \t    this._block(b.splice(0,16));\n      \t}\n    }\n    return this;\n  },\n  \n  /**\n   * Complete hashing and output the hash value.\n   * @return {bitArray} The hash value, an array of 8 big-endian words.\n   */\n  finalize:function () {\n    var i, b = this._buffer, h = this._h;\n\n    // Round out and push the buffer\n    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);\n    \n    // Round out the buffer to a multiple of 16 words, less the 2 length words.\n    for (i = b.length + 2; i & 15; i++) {\n      b.push(0);\n    }\n    \n    // append the length\n    b.push(Math.floor(this._length / 0x100000000));\n    b.push(this._length | 0);\n\n    while (b.length) {\n      this._block(b.splice(0,16));\n    }\n\n    this.reset();\n    return h;\n  },\n\n  /**\n   * The SHA-256 initialization vector, to be precomputed.\n   * @private\n   */\n  _init:[],\n  /*\n  _init:[0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19],\n  */\n  \n  /**\n   * The SHA-256 hash key, to be precomputed.\n   * @private\n   */\n  _key:[],\n  /*\n  _key:\n    [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n     0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n     0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n     0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n     0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n     0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n     0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n     0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2],\n  */\n\n\n  /**\n   * Function to precompute _init and _key.\n   * @private\n   */\n  _precompute: function () {\n    var i = 0, prime = 2, factor, isPrime;\n\n    function frac(x) { return (x-Math.floor(x)) * 0x100000000 | 0; }\n\n    for (; i<64; prime++) {\n      isPrime = true;\n      for (factor=2; factor*factor <= prime; factor++) {\n        if (prime % factor === 0) {\n          isPrime = false;\n          break;\n        }\n      }\n      if (isPrime) {\n        if (i<8) {\n          this._init[i] = frac(Math.pow(prime, 1/2));\n        }\n        this._key[i] = frac(Math.pow(prime, 1/3));\n        i++;\n      }\n    }\n  },\n  \n  /**\n   * Perform one cycle of SHA-256.\n   * @param {Uint32Array|bitArray} w one block of words.\n   * @private\n   */\n  _block:function (w) {  \n    var i, tmp, a, b,\n      h = this._h,\n      k = this._key,\n      h0 = h[0], h1 = h[1], h2 = h[2], h3 = h[3],\n      h4 = h[4], h5 = h[5], h6 = h[6], h7 = h[7];\n\n    /* Rationale for placement of |0 :\n     * If a value can overflow is original 32 bits by a factor of more than a few\n     * million (2^23 ish), there is a possibility that it might overflow the\n     * 53-bit mantissa and lose precision.\n     *\n     * To avoid this, we clamp back to 32 bits by |'ing with 0 on any value that\n     * propagates around the loop, and on the hash state h[].  I don't believe\n     * that the clamps on h4 and on h0 are strictly necessary, but it's close\n     * (for h4 anyway), and better safe than sorry.\n     *\n     * The clamps on h[] are necessary for the output to be correct even in the\n     * common case and for short inputs.\n     */\n    for (i=0; i<64; i++) {\n      // load up the input word for this round\n      if (i<16) {\n        tmp = w[i];\n      } else {\n        a   = w[(i+1 ) & 15];\n        b   = w[(i+14) & 15];\n        tmp = w[i&15] = ((a>>>7  ^ a>>>18 ^ a>>>3  ^ a<<25 ^ a<<14) + \n                         (b>>>17 ^ b>>>19 ^ b>>>10 ^ b<<15 ^ b<<13) +\n                         w[i&15] + w[(i+9) & 15]) | 0;\n      }\n      \n      tmp = (tmp + h7 + (h4>>>6 ^ h4>>>11 ^ h4>>>25 ^ h4<<26 ^ h4<<21 ^ h4<<7) +  (h6 ^ h4&(h5^h6)) + k[i]); // | 0;\n      \n      // shift register\n      h7 = h6; h6 = h5; h5 = h4;\n      h4 = h3 + tmp | 0;\n      h3 = h2; h2 = h1; h1 = h0;\n\n      h0 = (tmp +  ((h1&h2) ^ (h3&(h1^h2))) + (h1>>>2 ^ h1>>>13 ^ h1>>>22 ^ h1<<30 ^ h1<<19 ^ h1<<10)) | 0;\n    }\n\n    h[0] = h[0]+h0 | 0;\n    h[1] = h[1]+h1 | 0;\n    h[2] = h[2]+h2 | 0;\n    h[3] = h[3]+h3 | 0;\n    h[4] = h[4]+h4 | 0;\n    h[5] = h[5]+h5 | 0;\n    h[6] = h[6]+h6 | 0;\n    h[7] = h[7]+h7 | 0;\n  }\n};\n\n\n/** @fileOverview Javascript SHA-512 implementation.\n *\n * This implementation was written for CryptoJS by Jeff Mott and adapted for\n * SJCL by Stefan Thomas.\n *\n * CryptoJS (c) 2009–2012 by Jeff Mott. All rights reserved.\n * Released with New BSD License\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n * @author Jeff Mott\n * @author Stefan Thomas\n */\n\n/**\n * Context for a SHA-512 operation in progress.\n * @constructor\n */\nsjcl.hash.sha512 = function (hash) {\n  if (!this._key[0]) { this._precompute(); }\n  if (hash) {\n    this._h = hash._h.slice(0);\n    this._buffer = hash._buffer.slice(0);\n    this._length = hash._length;\n  } else {\n    this.reset();\n  }\n};\n\n/**\n * Hash a string or an array of words.\n * @static\n * @param {bitArray|String} data the data to hash.\n * @return {bitArray} The hash value, an array of 16 big-endian words.\n */\nsjcl.hash.sha512.hash = function (data) {\n  return (new sjcl.hash.sha512()).update(data).finalize();\n};\n\nsjcl.hash.sha512.prototype = {\n  /**\n   * The hash's block size, in bits.\n   * @constant\n   */\n  blockSize: 1024,\n   \n  /**\n   * Reset the hash state.\n   * @return this\n   */\n  reset:function () {\n    this._h = this._init.slice(0);\n    this._buffer = [];\n    this._length = 0;\n    return this;\n  },\n  \n  /**\n   * Input several words to the hash.\n   * @param {bitArray|String} data the data to hash.\n   * @return this\n   */\n  update: function (data) {\n    if (typeof data === \"string\") {\n      data = sjcl.codec.utf8String.toBits(data);\n    }\n    var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),\n        ol = this._length,\n        nl = this._length = ol + sjcl.bitArray.bitLength(data);\n    if (nl > 9007199254740991){\n      throw new sjcl.exception.invalid(\"Cannot hash more than 2^53 - 1 bits\");\n    }\n\n    if (typeof Uint32Array !== 'undefined') {\n        var c = new Uint32Array(b);\n        var j = 0;\n        for (i = 1024+ol - ((1024+ol) & 1023); i <= nl; i+= 1024) {\n            this._block(c.subarray(32 * j, 32 * (j+1)));\n            j += 1;\n        }\n        b.splice(0, 32 * j);\n    } else {\n        for (i = 1024+ol - ((1024+ol) & 1023); i <= nl; i+= 1024) {\n            this._block(b.splice(0,32));\n        }\n    }\n    return this;\n  },\n  \n  /**\n   * Complete hashing and output the hash value.\n   * @return {bitArray} The hash value, an array of 16 big-endian words.\n   */\n  finalize:function () {\n    var i, b = this._buffer, h = this._h;\n\n    // Round out and push the buffer\n    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);\n\n    // Round out the buffer to a multiple of 32 words, less the 4 length words.\n    for (i = b.length + 4; i & 31; i++) {\n      b.push(0);\n    }\n\n    // append the length\n    b.push(0);\n    b.push(0);\n    b.push(Math.floor(this._length / 0x100000000));\n    b.push(this._length | 0);\n\n    while (b.length) {\n      this._block(b.splice(0,32));\n    }\n\n    this.reset();\n    return h;\n  },\n\n  /**\n   * The SHA-512 initialization vector, to be precomputed.\n   * @private\n   */\n  _init:[],\n\n  /**\n   * Least significant 24 bits of SHA512 initialization values.\n   *\n   * Javascript only has 53 bits of precision, so we compute the 40 most\n   * significant bits and add the remaining 24 bits as constants.\n   *\n   * @private\n   */\n  _initr: [ 0xbcc908, 0xcaa73b, 0x94f82b, 0x1d36f1, 0xe682d1, 0x3e6c1f, 0x41bd6b, 0x7e2179 ],\n\n  /*\n  _init:\n  [0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n   0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179],\n  */\n\n  /**\n   * The SHA-512 hash key, to be precomputed.\n   * @private\n   */\n  _key:[],\n\n  /**\n   * Least significant 24 bits of SHA512 key values.\n   * @private\n   */\n  _keyr:\n  [0x28ae22, 0xef65cd, 0x4d3b2f, 0x89dbbc, 0x48b538, 0x05d019, 0x194f9b, 0x6d8118,\n   0x030242, 0x706fbe, 0xe4b28c, 0xffb4e2, 0x7b896f, 0x1696b1, 0xc71235, 0x692694,\n   0xf14ad2, 0x4f25e3, 0x8cd5b5, 0xac9c65, 0x2b0275, 0xa6e483, 0x41fbd4, 0x1153b5,\n   0x66dfab, 0xb43210, 0xfb213f, 0xef0ee4, 0xa88fc2, 0x0aa725, 0x03826f, 0x0e6e70,\n   0xd22ffc, 0x26c926, 0xc42aed, 0x95b3df, 0xaf63de, 0x77b2a8, 0xedaee6, 0x82353b,\n   0xf10364, 0x423001, 0xf89791, 0x54be30, 0xef5218, 0x65a910, 0x71202a, 0xbbd1b8,\n   0xd2d0c8, 0x41ab53, 0x8eeb99, 0x9b48a8, 0xc95a63, 0x418acb, 0x63e373, 0xb2b8a3,\n   0xefb2fc, 0x172f60, 0xf0ab72, 0x6439ec, 0x631e28, 0x82bde9, 0xc67915, 0x72532b,\n   0x26619c, 0xc0c207, 0xe0eb1e, 0x6ed178, 0x176fba, 0xc898a6, 0xf90dae, 0x1c471b,\n   0x047d84, 0xc72493, 0xc9bebc, 0x100d4c, 0x3e42b6, 0x657e2a, 0xd6faec, 0x475817],\n\n  /*\n  _key:\n  [0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,\n   0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,\n   0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,\n   0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,\n   0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,\n   0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,\n   0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,\n   0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,\n   0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,\n   0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,\n   0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,\n   0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,\n   0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,\n   0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,\n   0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,\n   0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,\n   0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,\n   0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,\n   0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,\n   0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817],\n  */\n\n  /**\n   * Function to precompute _init and _key.\n   * @private\n   */\n  _precompute: function () {\n    // XXX: This code is for precomputing the SHA256 constants, change for\n    //      SHA512 and re-enable.\n    var i = 0, prime = 2, factor , isPrime;\n\n    function frac(x)  { return (x-Math.floor(x)) * 0x100000000 | 0; }\n    function frac2(x) { return (x-Math.floor(x)) * 0x10000000000 & 0xff; }\n\n    for (; i<80; prime++) {\n      isPrime = true;\n      for (factor=2; factor*factor <= prime; factor++) {\n        if (prime % factor === 0) {\n          isPrime = false;\n          break;\n        }\n      }\n      if (isPrime) {\n        if (i<8) {\n          this._init[i*2] = frac(Math.pow(prime, 1/2));\n          this._init[i*2+1] = (frac2(Math.pow(prime, 1/2)) << 24) | this._initr[i];\n        }\n        this._key[i*2] = frac(Math.pow(prime, 1/3));\n        this._key[i*2+1] = (frac2(Math.pow(prime, 1/3)) << 24) | this._keyr[i];\n        i++;\n      }\n    }\n  },\n\n  /**\n   * Perform one cycle of SHA-512.\n   * @param {Uint32Array|bitArray} words one block of words.\n   * @private\n   */\n  _block:function (words) {\n    var i, wrh, wrl,\n        h = this._h,\n        k = this._key,\n        h0h = h[ 0], h0l = h[ 1], h1h = h[ 2], h1l = h[ 3],\n        h2h = h[ 4], h2l = h[ 5], h3h = h[ 6], h3l = h[ 7],\n        h4h = h[ 8], h4l = h[ 9], h5h = h[10], h5l = h[11],\n        h6h = h[12], h6l = h[13], h7h = h[14], h7l = h[15];\n    var w;\n    if (typeof Uint32Array !== 'undefined') {\n\t// When words is passed to _block, it has 32 elements. SHA512 _block\n\t// function extends words with new elements (at the end there are 160 elements). \n\t// The problem is that if we use Uint32Array instead of Array, \n\t// the length of Uint32Array cannot be changed. Thus, we replace words with a \n\t// normal Array here.\n        w = Array(160); // do not use Uint32Array here as the instantiation is slower\n        for (var j=0; j<32; j++){\n    \t    w[j] = words[j]; \n        }\n    } else {\n\tw = words;\n    } \n\n    // Working variables\n    var ah = h0h, al = h0l, bh = h1h, bl = h1l,\n        ch = h2h, cl = h2l, dh = h3h, dl = h3l,\n        eh = h4h, el = h4l, fh = h5h, fl = h5l,\n        gh = h6h, gl = h6l, hh = h7h, hl = h7l;\n\n    for (i=0; i<80; i++) {\n      // load up the input word for this round\n      if (i<16) {\n        wrh = w[i * 2];\n        wrl = w[i * 2 + 1];\n      } else {\n        // Gamma0\n        var gamma0xh = w[(i-15) * 2];\n        var gamma0xl = w[(i-15) * 2 + 1];\n        var gamma0h =\n          ((gamma0xl << 31) | (gamma0xh >>> 1)) ^\n          ((gamma0xl << 24) | (gamma0xh >>> 8)) ^\n           (gamma0xh >>> 7);\n        var gamma0l =\n          ((gamma0xh << 31) | (gamma0xl >>> 1)) ^\n          ((gamma0xh << 24) | (gamma0xl >>> 8)) ^\n          ((gamma0xh << 25) | (gamma0xl >>> 7));\n\n        // Gamma1\n        var gamma1xh = w[(i-2) * 2];\n        var gamma1xl = w[(i-2) * 2 + 1];\n        var gamma1h =\n          ((gamma1xl << 13) | (gamma1xh >>> 19)) ^\n          ((gamma1xh << 3)  | (gamma1xl >>> 29)) ^\n           (gamma1xh >>> 6);\n        var gamma1l =\n          ((gamma1xh << 13) | (gamma1xl >>> 19)) ^\n          ((gamma1xl << 3)  | (gamma1xh >>> 29)) ^\n          ((gamma1xh << 26) | (gamma1xl >>> 6));\n\n        // Shortcuts\n        var wr7h = w[(i-7) * 2];\n        var wr7l = w[(i-7) * 2 + 1];\n\n        var wr16h = w[(i-16) * 2];\n        var wr16l = w[(i-16) * 2 + 1];\n\n        // W(round) = gamma0 + W(round - 7) + gamma1 + W(round - 16)\n        wrl = gamma0l + wr7l;\n        wrh = gamma0h + wr7h + ((wrl >>> 0) < (gamma0l >>> 0) ? 1 : 0);\n        wrl += gamma1l;\n        wrh += gamma1h + ((wrl >>> 0) < (gamma1l >>> 0) ? 1 : 0);\n        wrl += wr16l;\n        wrh += wr16h + ((wrl >>> 0) < (wr16l >>> 0) ? 1 : 0);\n      }\n\n      w[i*2]     = wrh |= 0;\n      w[i*2 + 1] = wrl |= 0;\n\n      // Ch\n      var chh = (eh & fh) ^ (~eh & gh);\n      var chl = (el & fl) ^ (~el & gl);\n\n      // Maj\n      var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);\n      var majl = (al & bl) ^ (al & cl) ^ (bl & cl);\n\n      // Sigma0\n      var sigma0h = ((al << 4) | (ah >>> 28)) ^ ((ah << 30) | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));\n      var sigma0l = ((ah << 4) | (al >>> 28)) ^ ((al << 30) | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));\n\n      // Sigma1\n      var sigma1h = ((el << 18) | (eh >>> 14)) ^ ((el << 14) | (eh >>> 18)) ^ ((eh << 23) | (el >>> 9));\n      var sigma1l = ((eh << 18) | (el >>> 14)) ^ ((eh << 14) | (el >>> 18)) ^ ((el << 23) | (eh >>> 9));\n\n      // K(round)\n      var krh = k[i*2];\n      var krl = k[i*2+1];\n\n      // t1 = h + sigma1 + ch + K(round) + W(round)\n      var t1l = hl + sigma1l;\n      var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);\n      t1l += chl;\n      t1h += chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);\n      t1l += krl;\n      t1h += krh + ((t1l >>> 0) < (krl >>> 0) ? 1 : 0);\n      t1l = t1l + wrl|0;   // FF32..FF34 perf issue https://bugzilla.mozilla.org/show_bug.cgi?id=1054972\n      t1h += wrh + ((t1l >>> 0) < (wrl >>> 0) ? 1 : 0);\n\n      // t2 = sigma0 + maj\n      var t2l = sigma0l + majl;\n      var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);\n\n      // Update working variables\n      hh = gh;\n      hl = gl;\n      gh = fh;\n      gl = fl;\n      fh = eh;\n      fl = el;\n      el = (dl + t1l) | 0;\n      eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;\n      dh = ch;\n      dl = cl;\n      ch = bh;\n      cl = bl;\n      bh = ah;\n      bl = al;\n      al = (t1l + t2l) | 0;\n      ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;\n    }\n\n    // Intermediate hash\n    h0l = h[1] = (h0l + al) | 0;\n    h[0] = (h0h + ah + ((h0l >>> 0) < (al >>> 0) ? 1 : 0)) | 0;\n    h1l = h[3] = (h1l + bl) | 0;\n    h[2] = (h1h + bh + ((h1l >>> 0) < (bl >>> 0) ? 1 : 0)) | 0;\n    h2l = h[5] = (h2l + cl) | 0;\n    h[4] = (h2h + ch + ((h2l >>> 0) < (cl >>> 0) ? 1 : 0)) | 0;\n    h3l = h[7] = (h3l + dl) | 0;\n    h[6] = (h3h + dh + ((h3l >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;\n    h4l = h[9] = (h4l + el) | 0;\n    h[8] = (h4h + eh + ((h4l >>> 0) < (el >>> 0) ? 1 : 0)) | 0;\n    h5l = h[11] = (h5l + fl) | 0;\n    h[10] = (h5h + fh + ((h5l >>> 0) < (fl >>> 0) ? 1 : 0)) | 0;\n    h6l = h[13] = (h6l + gl) | 0;\n    h[12] = (h6h + gh + ((h6l >>> 0) < (gl >>> 0) ? 1 : 0)) | 0;\n    h7l = h[15] = (h7l + hl) | 0;\n    h[14] = (h7h + hh + ((h7l >>> 0) < (hl >>> 0) ? 1 : 0)) | 0;\n  }\n};\n\n\n/** @fileOverview HMAC implementation.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** HMAC with the specified hash function.\n * @constructor\n * @param {bitArray} key the key for HMAC.\n * @param {Object} [Hash=sjcl.hash.sha256] The hash function to use.\n */\nsjcl.misc.hmac = function (key, Hash) {\n  this._hash = Hash = Hash || sjcl.hash.sha256;\n  var exKey = [[],[]], i,\n      bs = Hash.prototype.blockSize / 32;\n  this._baseHash = [new Hash(), new Hash()];\n\n  if (key.length > bs) {\n    key = Hash.hash(key);\n  }\n  \n  for (i=0; i<bs; i++) {\n    exKey[0][i] = key[i]^0x36363636;\n    exKey[1][i] = key[i]^0x5C5C5C5C;\n  }\n  \n  this._baseHash[0].update(exKey[0]);\n  this._baseHash[1].update(exKey[1]);\n  this._resultHash = new Hash(this._baseHash[0]);\n};\n\n/** HMAC with the specified hash function.  Also called encrypt since it's a prf.\n * @param {bitArray|String} data The data to mac.\n */\nsjcl.misc.hmac.prototype.encrypt = sjcl.misc.hmac.prototype.mac = function (data) {\n  if (!this._updated) {\n    this.update(data);\n    return this.digest(data);\n  } else {\n    throw new sjcl.exception.invalid(\"encrypt on already updated hmac called!\");\n  }\n};\n\nsjcl.misc.hmac.prototype.reset = function () {\n  this._resultHash = new this._hash(this._baseHash[0]);\n  this._updated = false;\n};\n\nsjcl.misc.hmac.prototype.update = function (data) {\n  this._updated = true;\n  this._resultHash.update(data);\n};\n\nsjcl.misc.hmac.prototype.digest = function () {\n  var w = this._resultHash.finalize(), result = new (this._hash)(this._baseHash[1]).update(w).finalize();\n\n  this.reset();\n\n  return result;\n};\n\n\t\t\t\t\t;export default sjcl;\n\t\t\t\t","// eslint-disable-next-line import/no-extraneous-dependencies\nimport sjcl from 'sjcl'; // SJCL is included during compilation.\n\nimport { InternalUtils } from './utils';\n\n/**\n * Node.js Crypto module.\n * @private\n * @type {Object}\n */\nconst NodeCrypto = InternalUtils.require('crypto');\n\n/**\n * An object containing some cryptography functions\n * with dirty workarounds for Node.js and browsers.\n * @private\n * @type {Object}\n */\nexport const Crypto = {};\n\nif (NodeCrypto) {\n\tlet bufferFrom;\n\n\tif (typeof Buffer.from === 'function') {\n\t\tbufferFrom = Buffer.from;\n\t} else {\n\t\t// Node.js < 5.10.0\n\t\tbufferFrom = arrbuf => {\n\t\t\t// eslint-disable-next-line no-buffer-constructor\n\t\t\tconst nodeBuf = new Buffer(arrbuf.byteLength);\n\t\t\tconst arr = new Uint8Array(arrbuf);\n\n\t\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\t\tnodeBuf[i] = arr[i];\n\t\t\t}\n\n\t\t\treturn nodeBuf;\n\t\t};\n\t}\n\n\tlet bufferTo;\n\n\tif (Buffer.prototype instanceof Uint8Array) {\n\t\tbufferTo = nodeBuf => nodeBuf;\n\t} else {\n\t\t// Node.js < 4.0.0\n\t\tbufferTo = nodeBuf => {\n\t\t\tconst arr = new Uint8Array(nodeBuf.length);\n\n\t\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\t\tarr[i] = nodeBuf[i];\n\t\t\t}\n\n\t\t\treturn arr;\n\t\t};\n\t}\n\n\tCrypto.randomBytes = size => {\n\t\tconst buff = NodeCrypto.randomBytes(size);\n\t\treturn bufferTo(buff);\n\t};\n\n\t// In Node.js, the command:\n\t// $ openssl list -digest-algorithms\n\t// displays the available digest algorithms.\n\tCrypto.hmacDigest = (algorithm, key, message) => {\n\t\tconst buff = NodeCrypto.createHmac(algorithm, bufferFrom(key));\n\t\treturn bufferTo(buff).update(bufferFrom(message)).digest();\n\t};\n} else {\n\tlet getRandomValues;\n\n\tif (typeof global.crypto !== 'undefined' && typeof global.crypto.getRandomValues === 'function') {\n\t\tgetRandomValues = arr => {\n\t\t\tglobal.crypto.getRandomValues(arr);\n\t\t};\n\t} else if (typeof global.msCrypto !== 'undefined' && typeof global.msCrypto.getRandomValues === 'function') {\n\t\tgetRandomValues = arr => {\n\t\t\tglobal.msCrypto.getRandomValues(arr);\n\t\t};\n\t} else {\n\t\tconsole.warn('Cryptography API not available, falling back to \\'Math.random\\'...');\n\t\tgetRandomValues = arr => {\n\t\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\t\tarr[i] = Math.floor(Math.random() * 256);\n\t\t\t}\n\t\t};\n\t}\n\n\tCrypto.randomBytes = size => {\n\t\tconst arr = new Uint8Array(size);\n\t\tgetRandomValues(arr);\n\t\treturn arr;\n\t};\n\n\tCrypto.hmacDigest = (algorithm, key, message) => {\n\t\tconst hash = sjcl.hash[algorithm.toLowerCase()];\n\t\tif (typeof hash === 'undefined') {\n\t\t\tthrow new TypeError('Unknown hash function');\n\t\t}\n\n\t\t// eslint-disable-next-line new-cap\n\t\tconst hmac = new sjcl.misc.hmac(sjcl.codec.arrayBuffer.toBits(key), hash);\n\t\thmac.update(sjcl.codec.arrayBuffer.toBits(message));\n\n\t\treturn sjcl.codec.arrayBuffer.fromBits(hmac.digest(), false);\n\t};\n}\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","import { Utils } from './utils';\nimport { Crypto } from './crypto';\n\n/**\n * Secret key object.\n */\nexport class Secret {\n\t/**\n\t * @param {Object} [config] Configuration options.\n\t * @param {ArrayBuffer} [config.buffer=Crypto.randomBytes] Secret key.\n\t * @param {number} [config.size=20] Number of random bytes to generate, ignored if 'buffer' is provided.\n\t */\n\tconstructor({ buffer, size = 20 } = {}) {\n\t\t/**\n\t\t * Secret key.\n\t\t * @type {ArrayBuffer}\n\t\t */\n\t\tthis.buffer = typeof buffer === 'undefined'\n\t\t\t? Crypto.randomBytes(size).buffer\n\t\t\t: buffer;\n\t}\n\n\t/**\n\t * Converts a raw string to a Secret object.\n\t * @method fromRaw\n\t * @param {string} str Raw string.\n\t * @returns {Secret} Secret object.\n\t */\n\tstatic fromRaw(str) {\n\t\treturn new this({ buffer: Utils.raw.encode(str) });\n\t}\n\n\t/**\n\t * Converts a base32 string to a Secret object.\n\t * @method fromB32\n\t * @param {string} str Base32 string.\n\t * @returns {Secret} Secret object.\n\t */\n\tstatic fromB32(str) {\n\t\treturn new this({ buffer: Utils.b32.encode(str) });\n\t}\n\n\t/**\n\t * Converts a hexadecimal string to a Secret object.\n\t * @method fromHex\n\t * @param {string} str Hexadecimal string.\n\t * @returns {Secret} Secret object.\n\t */\n\tstatic fromHex(str) {\n\t\treturn new this({ buffer: Utils.hex.encode(str) });\n\t}\n\n\t/**\n\t * String representation of secret key.\n\t * @type {string}\n\t */\n\tget raw() {\n\t\tObject.defineProperty(this, 'raw', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\twritable: true,\n\t\t\tvalue: Utils.raw.decode(this.buffer)\n\t\t});\n\n\t\treturn this.raw;\n\t}\n\n\t/**\n\t * Base32 representation of secret key.\n\t * @type {string}\n\t */\n\tget b32() {\n\t\tObject.defineProperty(this, 'b32', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\twritable: true,\n\t\t\tvalue: Utils.b32.decode(this.buffer)\n\t\t});\n\n\t\treturn this.b32;\n\t}\n\n\t/**\n\t * Hexadecimal representation of secret key.\n\t * @type {string}\n\t */\n\tget hex() {\n\t\tObject.defineProperty(this, 'hex', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\twritable: true,\n\t\t\tvalue: Utils.hex.decode(this.buffer)\n\t\t});\n\n\t\treturn this.hex;\n\t}\n}\n","import { Utils } from './utils';\nimport { Secret } from './secret';\n// eslint-disable-next-line import/no-cycle\nimport { HOTP, TOTP } from './otp';\n\n/**\n * Valid key URI parameters.\n * @private\n * @type {Array}\n */\nconst OTPURI_PARAMS = ['issuer', 'secret', 'algorithm', 'digits', 'counter', 'period'];\n\n/**\n * Key URI regex.\n *   otpauth://TYPE/[ISSUER:]LABEL?PARAMETERS\n * @private\n * @type {RegExp}\n */\nconst OTPURI_REGEX = new RegExp(`^otpauth:\\\\/\\\\/([ht]otp)\\\\/(.+)\\\\?((?:&?(?:${OTPURI_PARAMS.join('|')})=[^&]+)+)$`, 'i');\n\n/**\n * RFC 4648 base32 alphabet without pad.\n * @private\n * @type {string}\n */\nconst SECRET_REGEX = /^[2-7A-Z]+$/i;\n\n/**\n * Regex for supported algorithms.\n * @private\n * @type {RegExp}\n */\nconst ALGORITHM_REGEX = /^SHA(?:1|256|512)$/i;\n\n/**\n * Integer regex.\n * @private\n * @type {RegExp}\n */\nconst INTEGER_REGEX = /^[+-]?\\d+$/;\n\n/**\n * Positive integer regex.\n * @private\n * @type {RegExp}\n */\nconst POSITIVE_INTEGER_REGEX = /^\\+?[1-9]\\d*$/;\n\n/**\n * HOTP/TOTP object/string conversion.\n * @see https://github.com/google/google-authenticator/wiki/Key-Uri-Format\n */\nexport class URI {\n\t/**\n\t * Parses a Google Authenticator key URI and returns an HOTP/TOTP object.\n\t * @method parse\n\t * @param {string} uri Google Authenticator Key URI.\n\t * @returns {Object} HOTP/TOTP object.\n\t */\n\tstatic parse(uri) {\n\t\tlet uriGroups;\n\n\t\ttry {\n\t\t\turiGroups = uri.match(OTPURI_REGEX);\n\t\t} catch (error) { /* Handled below */ }\n\n\t\tif (!Array.isArray(uriGroups)) {\n\t\t\tthrow new URIError('Invalid URI format');\n\t\t}\n\n\t\t// Extract URI groups.\n\t\tconst uriType = uriGroups[1].toLowerCase();\n\t\tconst uriLabel = uriGroups[2].split(/:(.+)/, 2).map(decodeURIComponent);\n\t\tconst uriParams = uriGroups[3].split('&').reduce((acc, cur) => {\n\t\t\tconst pairArr = cur.split(/=(.+)/, 2).map(decodeURIComponent);\n\t\t\tconst pairKey = pairArr[0].toLowerCase();\n\t\t\tconst pairVal = pairArr[1];\n\t\t\tconst pairAcc = acc;\n\n\t\t\tpairAcc[pairKey] = pairVal;\n\t\t\treturn pairAcc;\n\t\t}, {});\n\n\t\t// 'OTP' will be instantiated with 'config' argument\n\t\tlet OTP;\n\t\tconst config = {};\n\n\t\tif (uriType === 'hotp') {\n\t\t\tOTP = HOTP;\n\n\t\t\t// Counter: required\n\t\t\tif (typeof uriParams.counter !== 'undefined' && INTEGER_REGEX.test(uriParams.counter)) {\n\t\t\t\tconfig.counter = Number.parseInt(uriParams.counter, 10);\n\t\t\t} else {\n\t\t\t\tthrow new TypeError('Missing or invalid \\'counter\\' parameter');\n\t\t\t}\n\t\t} else if (uriType === 'totp') {\n\t\t\tOTP = TOTP;\n\n\t\t\t// Period: optional\n\t\t\tif (typeof uriParams.period !== 'undefined') {\n\t\t\t\tif (POSITIVE_INTEGER_REGEX.test(uriParams.period)) {\n\t\t\t\t\tconfig.period = Number.parseInt(uriParams.period, 10);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new TypeError('Invalid \\'period\\' parameter');\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new TypeError('Unknown OTP type');\n\t\t}\n\n\t\t// Label: required\n\t\t// Issuer: optional\n\t\tif (uriLabel.length === 2) {\n\t\t\tconfig.label = uriLabel[1];\n\t\t\tif (typeof uriParams.issuer === 'undefined') {\n\t\t\t\tconfig.issuer = uriLabel[0];\n\t\t\t} else if (uriParams.issuer === uriLabel[0]) {\n\t\t\t\tconfig.issuer = uriParams.issuer;\n\t\t\t} else {\n\t\t\t\tthrow new TypeError('Invalid \\'issuer\\' parameter');\n\t\t\t}\n\t\t} else {\n\t\t\tconfig.label = uriLabel[0];\n\t\t\tif (typeof uriParams.issuer !== 'undefined') {\n\t\t\t\tconfig.issuer = uriParams.issuer;\n\t\t\t}\n\t\t}\n\n\t\t// Secret: required\n\t\tif (typeof uriParams.secret !== 'undefined' && SECRET_REGEX.test(uriParams.secret)) {\n\t\t\tconfig.secret = new Secret({ buffer: Utils.b32.encode(uriParams.secret) });\n\t\t} else {\n\t\t\tthrow new TypeError('Missing or invalid \\'secret\\' parameter');\n\t\t}\n\n\t\t// Algorithm: optional\n\t\tif (typeof uriParams.algorithm !== 'undefined') {\n\t\t\tif (ALGORITHM_REGEX.test(uriParams.algorithm)) {\n\t\t\t\tconfig.algorithm = uriParams.algorithm;\n\t\t\t} else {\n\t\t\t\tthrow new TypeError('Invalid \\'algorithm\\' parameter');\n\t\t\t}\n\t\t}\n\n\t\t// Digits: optional\n\t\tif (typeof uriParams.digits !== 'undefined') {\n\t\t\tif (POSITIVE_INTEGER_REGEX.test(uriParams.digits)) {\n\t\t\t\tconfig.digits = Number.parseInt(uriParams.digits, 10);\n\t\t\t} else {\n\t\t\t\tthrow new TypeError('Invalid \\'digits\\' parameter');\n\t\t\t}\n\t\t}\n\n\t\treturn new OTP(config);\n\t}\n\n\t/**\n\t * Converts an HOTP/TOTP object to a Google Authenticator key URI.\n\t * @method stringify\n\t * @param {Object} otp HOTP/TOTP object.\n\t * @param {Object} [config] Configuration options.\n\t * @param {boolean} [config.legacyIssuer=true] Set issuer label prefix.\n\t * @returns {string} Google Authenticator Key URI.\n\t */\n\tstatic stringify(otp, { legacyIssuer = true } = {}) {\n\t\tconst isHOTP = otp instanceof HOTP;\n\t\tconst isTOTP = otp instanceof TOTP;\n\n\t\tif (!isHOTP && !isTOTP) {\n\t\t\tthrow new TypeError('Invalid \\'HOTP/TOTP\\' object');\n\t\t}\n\n\t\t// Key URI format:\n\t\t// otpauth://TYPE/[ISSUER:]LABEL?PARAMETERS\n\t\tlet uri = 'otpauth://';\n\n\t\t// Type\n\t\turi += `${isTOTP ? 'totp' : 'hotp'}/`;\n\n\t\t// Label and optional issuer\n\t\tif (otp.issuer.length > 0) {\n\t\t\t// Legacy label prefix\n\t\t\tif (legacyIssuer) uri += `${encodeURIComponent(otp.issuer)}:`;\n\t\t\t// Label\n\t\t\turi += `${encodeURIComponent(otp.label)}?`;\n\t\t\t// Issuer\n\t\t\turi += `issuer=${encodeURIComponent(otp.issuer)}&`;\n\t\t} else {\n\t\t\t// Label\n\t\t\turi += `${encodeURIComponent(otp.label)}?`;\n\t\t}\n\n\t\t// Generic parameters\n\t\turi += `secret=${encodeURIComponent(otp.secret.b32)}`\n\t\t\t+ `&algorithm=${encodeURIComponent(otp.algorithm)}`\n\t\t\t+ `&digits=${encodeURIComponent(otp.digits)}`;\n\n\t\t// Extra parameters\n\t\tif (isTOTP) {\n\t\t\t// TOTP parameters\n\t\t\turi += `&period=${encodeURIComponent(otp.period)}`;\n\t\t} else {\n\t\t\t// HOTP parameters\n\t\t\turi += `&counter=${encodeURIComponent(otp.counter)}`;\n\t\t}\n\n\t\treturn uri;\n\t}\n}\n","import { Utils } from './utils';\nimport { Crypto } from './crypto';\nimport { Secret } from './secret';\n// eslint-disable-next-line import/no-cycle\nimport { URI } from './uri';\n\n/**\n * Default configuration.\n * @private\n * @type {Object}\n */\nconst defaults = {\n\tissuer: '',\n\tlabel: 'OTPAuth',\n\talgorithm: 'SHA1',\n\tdigits: 6,\n\tcounter: 0,\n\tperiod: 30,\n\twindow: 50,\n\tpad: true\n};\n\n/**\n * HOTP: An HMAC-based One-time Password Algorithm (RFC 4226).\n * @see https://tools.ietf.org/html/rfc4226\n */\nexport class HOTP {\n\t/**\n\t * @param {Object} [config] Configuration options.\n\t * @param {string} [config.issuer=''] Account provider.\n\t * @param {string} [config.label='OTPAuth'] Account label.\n\t * @param {Secret} [config.secret=Secret] Secret key.\n\t * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n\t * @param {number} [config.digits=6] Token length.\n\t * @param {number} [config.counter=0] Initial counter value.\n\t */\n\tconstructor({\n\t\tissuer = defaults.issuer,\n\t\tlabel = defaults.label,\n\t\tsecret = new Secret(),\n\t\talgorithm = defaults.algorithm,\n\t\tdigits = defaults.digits,\n\t\tcounter = defaults.counter\n\t} = {}) {\n\t\t/**\n\t\t * Account provider.\n\t\t * @type {string}\n\t\t */\n\t\tthis.issuer = issuer;\n\t\t/**\n\t\t * Account label.\n\t\t * @type {string}\n\t\t */\n\t\tthis.label = label;\n\t\t/**\n\t\t * Secret key.\n\t\t * @type {Secret}\n\t\t */\n\t\tthis.secret = secret;\n\t\t/**\n\t\t * HMAC hashing algorithm.\n\t\t * @type {string}\n\t\t */\n\t\tthis.algorithm = algorithm;\n\t\t/**\n\t\t * Token length.\n\t\t * @type {number}\n\t\t */\n\t\tthis.digits = digits;\n\t\t/**\n\t\t * Initial counter value.\n\t\t * @type {number}\n\t\t */\n\t\tthis.counter = counter;\n\t}\n\n\t/**\n\t * Generates an HOTP token.\n\t * @param {Object} config Configuration options.\n\t * @param {Secret} config.secret Secret key.\n\t * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n\t * @param {number} [config.digits=6] Token length.\n\t * @param {number} [config.counter=0] Counter value.\n\t * @param {boolean} [config.pad=true] Add leading zeros to result.\n\t * @returns {string|number} Token.\n\t */\n\tstatic generate({\n\t\tsecret,\n\t\talgorithm = defaults.algorithm,\n\t\tdigits = defaults.digits,\n\t\tcounter = defaults.counter,\n\t\tpad = defaults.pad\n\t}) {\n\t\tconst digest = new Uint8Array(Crypto.hmacDigest(algorithm, secret.buffer, Utils.uint.encode(counter)));\n\t\tconst offset = digest[digest.byteLength - 1] & 15;\n\t\tconst otp = (\n\t\t\t((digest[offset] & 127) << 24)\n\t\t\t| ((digest[offset + 1] & 255) << 16)\n\t\t\t| ((digest[offset + 2] & 255) << 8)\n\t\t\t| (digest[offset + 3] & 255)\n\t\t) % (10 ** digits);\n\n\t\treturn pad\n\t\t\t? new Array(1 + digits - String(otp).length).join('0') + otp\n\t\t\t: otp;\n\t}\n\n\t/**\n\t * Generates an HOTP token.\n\t * @param {Object} [config] Configuration options.\n\t * @param {number} [config.counter=this.counter++] Counter value.\n\t * @param {boolean} [config.pad=true] Add leading zeros to result.\n\t * @returns {string|number} Token.\n\t */\n\tgenerate({\n\t\tcounter = this.counter++,\n\t\tpad\n\t} = {}) {\n\t\treturn HOTP.generate({\n\t\t\tsecret: this.secret,\n\t\t\talgorithm: this.algorithm,\n\t\t\tdigits: this.digits,\n\t\t\tcounter,\n\t\t\tpad\n\t\t});\n\t}\n\n\t/**\n\t * Validates an HOTP token.\n\t * @param {Object} config Configuration options.\n\t * @param {string} config.token Token value.\n\t * @param {Secret} config.secret Secret key.\n\t * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n\t * @param {number} [config.counter=0] Counter value.\n\t * @param {number} [config.window=50] Window of counter values to test.\n\t * @returns {number|null} Token delta, or null if the token is not found.\n\t */\n\tstatic validate({\n\t\ttoken,\n\t\tsecret,\n\t\talgorithm,\n\t\tcounter = defaults.counter,\n\t\twindow = defaults.window\n\t}) {\n\t\tconst searchToken = Number.parseInt(token, 10);\n\n\t\tfor (let i = counter - window; i <= counter + window; ++i) {\n\t\t\tconst generatedToken = HOTP.generate({\n\t\t\t\tsecret,\n\t\t\t\talgorithm,\n\t\t\t\tcounter: i,\n\t\t\t\tdigits: token.length,\n\t\t\t\tpad: false\n\t\t\t});\n\n\t\t\tif (searchToken === generatedToken) {\n\t\t\t\treturn i - counter;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Validates an HOTP token.\n\t * @param {Object} config Configuration options.\n\t * @param {string} config.token Token value.\n\t * @param {number} [config.counter=this.counter] Counter value.\n\t * @param {number} [config.window=50] Window of counter values to test.\n\t * @returns {number|null} Token delta, or null if the token is not found.\n\t */\n\tvalidate({\n\t\ttoken,\n\t\tcounter = this.counter,\n\t\twindow\n\t}) {\n\t\treturn HOTP.validate({\n\t\t\ttoken,\n\t\t\tsecret: this.secret,\n\t\t\talgorithm: this.algorithm,\n\t\t\tcounter,\n\t\t\twindow\n\t\t});\n\t}\n\n\t/**\n\t * Returns a Google Authenticator key URI.\n\t * @returns {string} URI.\n\t */\n\ttoString() {\n\t\treturn URI.stringify(this);\n\t}\n}\n\n/**\n * TOTP: Time-Based One-Time Password Algorithm (RFC 6238).\n * @see https://tools.ietf.org/html/rfc6238\n */\nexport class TOTP {\n\t/**\n\t * @param {Object} [config] Configuration options.\n\t * @param {string} [config.issuer=''] Account provider.\n\t * @param {string} [config.label='OTPAuth'] Account label.\n\t * @param {Secret} [config.secret=Secret] Secret key.\n\t * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n\t * @param {number} [config.digits=6] Token length.\n\t * @param {number} [config.period=30] Token time-step duration.\n\t */\n\tconstructor({\n\t\tissuer = defaults.issuer,\n\t\tlabel = defaults.label,\n\t\tsecret = new Secret(),\n\t\talgorithm = defaults.algorithm,\n\t\tdigits = defaults.digits,\n\t\tperiod = defaults.period\n\t} = {}) {\n\t\t/**\n\t\t * Account provider.\n\t\t * @type {string}\n\t\t */\n\t\tthis.issuer = issuer;\n\t\t/**\n\t\t * Account label.\n\t\t * @type {string}\n\t\t */\n\t\tthis.label = label;\n\t\t/**\n\t\t * Secret key.\n\t\t * @type {string}\n\t\t */\n\t\tthis.secret = secret;\n\t\t/**\n\t\t * HMAC hashing algorithm.\n\t\t * @type {Secret}\n\t\t */\n\t\tthis.algorithm = algorithm;\n\t\t/**\n\t\t * Token length.\n\t\t * @type {number}\n\t\t */\n\t\tthis.digits = digits;\n\t\t/**\n\t\t * Token time-step duration.\n\t\t * @type {number}\n\t\t */\n\t\tthis.period = period;\n\t}\n\n\t/**\n\t * Generates a TOTP token.\n\t * @param {Object} config Configuration options.\n\t * @param {Secret} config.secret Secret key.\n\t * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n\t * @param {number} [config.digits=6] Token length.\n\t * @param {number} [config.period=30] Token time-step duration.\n\t * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n\t * @param {boolean} [config.pad=true] Add leading zeros to result.\n\t * @returns {string|number} Token.\n\t */\n\tstatic generate({\n\t\tsecret,\n\t\talgorithm,\n\t\tdigits,\n\t\tperiod = defaults.period,\n\t\ttimestamp = Date.now(),\n\t\tpad\n\t}) {\n\t\treturn HOTP.generate({\n\t\t\tsecret,\n\t\t\talgorithm,\n\t\t\tdigits,\n\t\t\tcounter: Math.floor(timestamp / 1000 / period),\n\t\t\tpad\n\t\t});\n\t}\n\n\t/**\n\t * Generates a TOTP token.\n\t * @param {Object} [config] Configuration options.\n\t * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n\t * @param {boolean} [config.pad=true] Add leading zeros to result.\n\t * @returns {string|number} Token.\n\t */\n\tgenerate({\n\t\ttimestamp = Date.now(),\n\t\tpad\n\t} = {}) {\n\t\treturn TOTP.generate({\n\t\t\tsecret: this.secret,\n\t\t\talgorithm: this.algorithm,\n\t\t\tdigits: this.digits,\n\t\t\tperiod: this.period,\n\t\t\ttimestamp,\n\t\t\tpad\n\t\t});\n\t}\n\n\t/**\n\t * Validates a TOTP token.\n\t * @param {Object} config Configuration options.\n\t * @param {string} config.token Token value.\n\t * @param {Secret} config.secret Secret key.\n\t * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n\t * @param {number} [config.period=30] Token time-step duration.\n\t * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n\t * @param {number} [config.window=50] Window of counter values to test.\n\t * @returns {number|null} Token delta, or null if the token is not found.\n\t */\n\tstatic validate({\n\t\ttoken,\n\t\tsecret,\n\t\talgorithm,\n\t\tperiod = defaults.period,\n\t\ttimestamp = Date.now(),\n\t\twindow\n\t}) {\n\t\treturn HOTP.validate({\n\t\t\ttoken,\n\t\t\tsecret,\n\t\t\talgorithm,\n\t\t\tcounter: Math.floor(timestamp / 1000 / period),\n\t\t\twindow\n\t\t});\n\t}\n\n\t/**\n\t * Validates a TOTP token.\n\t * @param {Object} config Configuration options.\n\t * @param {string} config.token Token value.\n\t * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n\t * @param {number} [config.window=50] Window of counter values to test.\n\t * @returns {number|null} Token delta, or null if the token is not found.\n\t */\n\tvalidate({\n\t\ttoken,\n\t\ttimestamp,\n\t\twindow\n\t}) {\n\t\treturn TOTP.validate({\n\t\t\ttoken,\n\t\t\tsecret: this.secret,\n\t\t\talgorithm: this.algorithm,\n\t\t\tperiod: this.period,\n\t\t\ttimestamp,\n\t\t\twindow\n\t\t});\n\t}\n\n\t/**\n\t * Returns a Google Authenticator key URI.\n\t * @returns {string} URI.\n\t */\n\ttoString() {\n\t\treturn URI.stringify(this);\n\t}\n}\n","/**\n * One Time Password (HOTP/TOTP) library for Node.js and browser.\n * @module OTPAuth\n * @author Héctor Molinero Fernández <hector@molinero.dev>\n */\nexport { HOTP, TOTP } from './otp';\nexport { URI } from './uri';\nexport { Secret } from './secret';\nexport { Utils } from './utils';\n\n/**\n * Library version.\n * @type {string}\n */\nexport const version = process.env.VERSION;\n"],"sourceRoot":""}

/src/debug/src/check-props.js:1:const ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
/src/debug/src/check-props.js-2-
##############################################
/src/debug/dist/debug.umd.js.map:1:{"version":3,"file":"debug.umd.js","sources":["../src/check-props.js","../src/devtools/custom.js","../src/debug.js","../src/devtools/renderer.js","../src/devtools/index.js","../src/index.js","../src/constants.js"],"sourcesContent":["const ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nlet loggedTypeFailures = {};\n\nexport function checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n  Object.keys(typeSpecs).forEach((typeSpecName) => {\n    let error;\n    try {\n      error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n    } catch (e) {\n      error = e;\n    }\n    if (error && !(error.message in loggedTypeFailures)) {\n      loggedTypeFailures[error.message] = true;\n      console.error(`Failed ${location} type: ${error.message}${getStack && getStack() || ''}`);\n    }\n  });\n}\n","import { Component, Fragment } from 'preact';\n\n/**\n * Get the type/category of a vnode\n * @param {import('../internal').VNode} vnode\n * @returns {import('../internal').NodeType}\n */\nexport function getNodeType(vnode) {\n\tif (vnode.type===Fragment) return 'Wrapper';\n\telse if (typeof vnode.type==='function') return 'Composite';\n\telse if (typeof vnode.type==='string') return 'Native';\n\treturn 'Text';\n}\n\n/**\n * Get human readable name of the component/dom element\n * @param {import('../internal').VNode} vnode\n * @returns {string}\n */\nexport function getDisplayName(vnode) {\n\tif (vnode.type===Fragment) return 'Fragment';\n\telse if (typeof vnode.type==='function') return vnode.type.displayName || vnode.type.name;\n\telse if (typeof vnode.type==='string') return vnode.type;\n\treturn '#text';\n}\n\n/**\n * Deeply mutate a property by walking down an array of property keys\n * @param {object} obj\n * @param {Array<string | number>} path\n * @param {any} value\n */\nexport function setIn(obj, path, value) {\n\tlet last = path.pop();\n\tlet parent = path.reduce((acc, attr) => acc ? acc[attr] : null, obj);\n\tif (parent) {\n\t\tparent[last] = value;\n\t}\n}\n\n/**\n * Get devtools compatible data from vnode\n * @param {import('../internal').VNode} vnode\n * @returns {import('../internal').DevtoolData}\n */\nexport function getData(vnode) {\n\tlet c = vnode._component;\n\n\t/** @type {import('../internal').DevtoolsUpdater | null} */\n\tlet updater = null;\n\n\tif (c!=null && c instanceof Component) {\n\t\t// These functions will be called when the user changes state, props or\n\t\t// context values via the devtools ui panel\n\t\tupdater = {\n\t\t\tsetState: c.setState.bind(c),\n\t\t\tforceUpdate: c.forceUpdate.bind(c),\n\t\t\tsetInState(path, value) {\n\t\t\t\tc.setState(prev => {\n\t\t\t\t\tsetIn(prev, path, value);\n\t\t\t\t\treturn prev;\n\t\t\t\t});\n\t\t\t},\n\t\t\tsetInProps(path, value) {\n\t\t\t\tsetIn(vnode.props, path, value);\n\t\t\t\tc.setState({});\n\t\t\t},\n\t\t\tsetInContext(path, value) {\n\t\t\t\tsetIn(c.context, path, value);\n\t\t\t\tc.setState({});\n\t\t\t}\n\t\t};\n\t}\n\n\tlet children = getChildren(vnode);\n\n\tlet duration = vnode.endTime - vnode.startTime;\n\treturn {\n\t\tnodeType: getNodeType(vnode),\n\t\ttype: vnode.type,\n\t\tname: getDisplayName(vnode),\n\t\tref: vnode.ref || null,\n\t\tkey: vnode.key || null,\n\t\tupdater,\n\t\ttext: vnode.text,\n\t\tstate: c!=null && c instanceof Component ? c.state : null,\n\t\tprops: vnode.props,\n\t\t// The devtools inline text children if they are the only child\n\t\tchildren: vnode.text==null\n\t\t\t? children!=null && children.length==1 && children[0].text!=null\n\t\t\t\t? children[0].text\n\t\t\t\t: children\n\t\t\t: null,\n\t\tpublicInstance: getInstance(vnode),\n\t\tmemoizedInteractions: [],\n\n\t\t// Profiler data\n\t\tactualDuration: duration,\n\t\tactualStartTime: vnode.startTime,\n\t\ttreeBaseDuration: duration\n\t};\n}\n\n/**\n * Get all rendered vnode children as an array. Moreover we need to filter\n * out `null` or other falsy children.\n * @param {import('../internal').VNode} vnode\n * @returns {import('../internal').VNode[]}\n */\nexport function getChildren(vnode) {\n\tlet c = vnode._component;\n\n\tif (c==null) {\n\t\treturn vnode._children!=null ? vnode._children.filter(Boolean) : [];\n\t}\n\n\treturn !Array.isArray(c._prevVNode) && c._prevVNode!=null\n\t\t? [c._prevVNode]\n\t\t: null;\n}\n\n/**\n * Check if a vnode is a root node\n * @param {import('../internal').VNode} vnode\n * @returns {boolean}\n */\nexport function isRoot(vnode) {\n\t// Timings of root vnodes will never be set\n\treturn vnode.type===Fragment && vnode.endTime==-1;\n}\n\n/**\n * Cache a vnode by its instance and retrieve previous vnodes by the next\n * instance.\n *\n * We need this to be able to identify the previous vnode of a given instance.\n * For components we want to check if we already rendered it and use the class\n * instance as key. For html elements we use the dom node as key.\n *\n * @param {import('../internal').VNode} vnode\n * @returns {import('../internal').Component | import('../internal').PreactElement | Text | null}\n */\nexport function getInstance(vnode) {\n\t// Use the parent element as instance for root nodes\n\tif (isRoot(vnode)) {\n\t\t// Edge case: When the tree only consists of components that have not rendered\n\t\t// anything into the DOM we revert to using the vnode as instance.\n\t\treturn vnode._children.length > 0 && vnode._children[0]!=null && vnode._children[0]._dom!=null\n\t\t\t? /** @type {import('../internal').PreactElement | null} */\n\t\t\t(vnode._children[0]._dom.parentNode)\n\t\t\t: vnode;\n\t}\n\tif (vnode._component!=null) return vnode._component;\n\tif (vnode.type===Fragment) return vnode.props;\n\treturn vnode._dom;\n}\n\n/**\n * Compare two objects\n * @param {object} a\n * @param {object} b\n * @param {boolean} [isProps]\n * @returns {boolean}\n */\nexport function shallowEqual(a, b, isProps) {\n\tif (a==null || b==null) return false;\n\n\tfor (let key in a) {\n\t\tif (isProps && key=='children' && b[key]!=null) continue;\n\t\tif (a[key]!==b[key]) return false;\n\t}\n\n\tif (Object.keys(a).length!==Object.keys(b).length) return false;\n\treturn true;\n}\n\n/**\n * Check if a vnode was actually updated\n * @param {import('../internal').VNode} next\n * @param {import('../internal').VNode} prev\n * @returns {boolean}\n */\nexport function hasDataChanged(prev, next) {\n\treturn (prev.props !== next.props && !shallowEqual(prev.props, next.props, true))\n\t\t|| (prev._component!=null &&\n\t\t\t!shallowEqual(next._component._prevState, next._component.state))\n\t\t|| prev._dom !== next._dom\n\t\t|| prev.ref !== next.ref;\n}\n","import { checkPropTypes } from './check-props';\nimport { getDisplayName } from './devtools/custom';\nimport { options, toChildArray } from 'preact';\nimport { ELEMENT_NODE, DOCUMENT_NODE, DOCUMENT_FRAGMENT_NODE } from './constants';\n\nexport function initDebug() {\n\t/* eslint-disable no-console */\n\tlet oldBeforeDiff = options.diff;\n\tlet oldDiffed = options.diffed;\n\tlet oldVnode = options.vnode;\n\n\toptions.root = (vnode, parentNode) => {\n\t\tif (!parentNode) {\n\t\t\tthrow new Error('Undefined parent passed to render(), this is the second argument.\\nCheck if the element is available in the DOM/has the correct id.');\n\t\t}\n\t\tlet isValid;\n\t\tswitch (parentNode.nodeType) {\n\t\t\tcase ELEMENT_NODE:\n\t\t\tcase DOCUMENT_FRAGMENT_NODE:\n\t\t\tcase DOCUMENT_NODE: isValid = true; break;\n\t\t\tdefault: isValid = false;\n\t\t}\n\t\tif (!isValid) throw new Error(`\n\t\t\tExpected a valid HTML node as a second argument to render.\n\t\t\tReceived ${parentNode} instead: render(<${vnode.type.name || vnode.type} />, ${parentNode});\n\t\t`);\n\t};\n\n\toptions.diff = vnode => {\n\t\tlet { type, props } = vnode;\n\t\tlet children = props && props.children;\n\n\t\tif (type===undefined) {\n\t\t\tthrow new Error('Undefined component passed to createElement()\\n\\n'+\n\t\t\t'You likely forgot to export your component or might have mixed up default and named imports'+\n\t\t\tserializeVNode(vnode));\n\t\t}\n\t\telse if (type!=null && typeof type==='object') {\n\t\t\tif (type._lastDomChild!==undefined && type._dom!==undefined) {\n\t\t\t\tlet info = 'Did you accidentally pass a JSX literal as JSX twice?\\n\\n'+\n\t\t\t\t'  let My'+getDisplayName(type)+' = '+serializeVNode(type)+';\\n'+\n\t\t\t\t'  let vnode = <My'+getDisplayName(type)+' />;\\n\\n'+\n\t\t\t\t'This usually happens when you export a JSX literal and not the component.';\n\t\t\t\tthrow new Error('Invalid type passed to createElement(): '+type+'\\n\\n'+info+'\\n');\n\t\t\t}\n\n\t\t\tthrow new Error('Invalid type passed to createElement(): '+(Array.isArray(type) ? 'array' : type));\n\t\t}\n\n\t\tif (\n\t\t\tvnode.ref!==undefined &&\n\t\t\ttypeof vnode.ref!=='function' &&\n\t\t\ttypeof vnode.ref!=='object' &&\n\t\t\t!('$$typeof' in vnode)  // allow string refs when preact-compat is installed\n\t\t) {\n\t\t\tthrow new Error(\n\t\t\t\t`Component's \"ref\" property should be a function, or an object created ` +\n\t\t\t\t`by createRef(), but got [${typeof vnode.ref}] instead\\n` +\n\t\t\t\tserializeVNode(vnode)\n\t\t\t);\n\t\t}\n\n\t\tif (typeof vnode.type==='string') {\n\t\t\tfor (const key in vnode.props) {\n\t\t\t\tif (key[0]==='o' && key[1]==='n' && typeof vnode.props[key]!=='function' && vnode.props[key]!=null) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Component's \"${key}\" property should be a function, ` +\n\t\t\t\t\t\t`but got [${typeof vnode.props[key]}] instead\\n` +\n\t\t\t\t\t\tserializeVNode(vnode)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check prop-types if available\n\t\tif (typeof vnode.type==='function' && vnode.type.propTypes) {\n\t\t\tcheckPropTypes(vnode.type.propTypes, vnode.props, getDisplayName(vnode), serializeVNode(vnode));\n\t\t}\n\n\t\tlet keys = [];\n\t\tfor (let deepChild of toChildArray(children)) {\n\t\t\tif (!deepChild || deepChild.key==null) continue;\n\n\t\t\tlet key = deepChild.key;\n\n\t\t\tif (keys.indexOf(key) !== -1) {\n\t\t\t\tconsole.error(\n\t\t\t\t\t'Following component has two or more children with the ' +\n\t\t\t\t\t`same key attribute: \"${key}\". This may cause glitches and misbehavior ` +\n\t\t\t\t\t'in rendering process. Component: \\n\\n' +\n\t\t\t\t\tserializeVNode(vnode)\n\t\t\t\t);\n\n\t\t\t\t// Break early to not spam the console\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tkeys.push(key);\n\t\t}\n\n\t\tif (oldBeforeDiff) oldBeforeDiff(vnode);\n\t};\n\n\tconst warn = (property, err) => ({\n\t\tget() {\n\t\t\tthrow new Error(`getting vnode.${property} is deprecated, ${err}`);\n\t\t},\n\t\tset() {\n\t\t\tthrow new Error(`setting vnode.${property} is not allowed, ${err}`);\n\t\t}\n\t});\n\n\tconst deprecatedAttributes = {\n\t\tnodeName: warn('nodeName', 'use vnode.type'),\n\t\tattributes: warn('attributes', 'use vnode.props'),\n\t\tchildren: warn('children', 'use vnode.props.children')\n\t};\n\n\toptions.vnode = (vnode) => {\n\t\tObject.defineProperties(vnode, deprecatedAttributes);\n\t\tif (oldVnode) oldVnode(vnode);\n\t};\n\n\toptions.diffed = (vnode) => {\n\t\tif (vnode._component && vnode._component.__hooks) {\n\t\t\tlet hooks = vnode._component.__hooks;\n\t\t\tif (hooks._list.length > 0) {\n\t\t\t\thooks._list.forEach(hook => {\n\t\t\t\t\tif (hook._callback && (!hook._args || !Array.isArray(hook._args))) {\n\t\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t\t`In ${vnode.type.name || vnode.type} you are calling useMemo/useCallback without passing arguments.\\n` +\n\t\t\t\t\t\t\t`This is a noop since it will not be able to memoize, it will execute it every render.`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (hooks._pendingEffects.length > 0) {\n\t\t\t\thooks._pendingEffects.forEach((effect) => {\n\t\t\t\t\tif (!effect._args || !Array.isArray(effect._args)) {\n\t\t\t\t\t\tthrow new Error('You should provide an array of arguments as the second argument to the \"useEffect\" hook.\\n\\n' +\n\t\t\t\t\t\t\t'Not doing so will invoke this effect on every render.\\n\\n' +\n\t\t\t\t\t\t\t'This effect can be found in the render of ' + (vnode.type.name || vnode.type) + '.');\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (hooks._pendingLayoutEffects.length > 0) {\n\t\t\t\thooks._pendingLayoutEffects.forEach((layoutEffect) => {\n\t\t\t\t\tif (!layoutEffect._args || !Array.isArray(layoutEffect._args)) {\n\t\t\t\t\t\tthrow new Error('You should provide an array of arguments as the second argument to the \"useEffect\" hook.\\n\\n' +\n\t\t\t\t\t\t\t'Not doing so will invoke this effect on every render.\\n\\n' +\n\t\t\t\t\t\t\t'This effect can be found in the render of ' + (vnode.type.name || vnode.type) + '.');\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (oldDiffed) oldDiffed(vnode);\n\t};\n}\n\n/**\n * Serialize a vnode tree to a string\n * @param {import('./internal').VNode} vnode\n * @returns {string}\n */\nexport function serializeVNode(vnode) {\n\tlet { props } = vnode;\n\tlet name = getDisplayName(vnode);\n\n\tlet attrs = '';\n\tif (props) {\n\t\tfor (let prop in props) {\n\t\t\tif (props.hasOwnProperty(prop) && prop!=='children') {\n\t\t\t\tlet value = props[prop];\n\n\t\t\t\t// If it is an object but doesn't have toString(), use Object.toString\n\t\t\t\tif (typeof value==='function') {\n\t\t\t\t\tvalue = `function ${value.displayName || value.name}() {}`;\n\t\t\t\t}\n\n\t\t\t\tvalue = Object(value) === value && !value.toString\n\t\t\t\t\t? Object.prototype.toString.call(value)\n\t\t\t\t\t: value + '';\n\n\t\t\t\tattrs += ` ${prop}=${JSON.stringify(value)}`;\n\t\t\t}\n\t\t}\n\t}\n\n\tlet children = props.children;\n\treturn `<${name}${attrs}${children && children.length\n\t\t? '>..</'+name+'>'\n\t\t: ' />'}`;\n}\n","import { getData, getChildren, getInstance, hasDataChanged, isRoot } from './custom';\n\n/**\n * Custom renderer tailored for Preact. It converts updated vnode trees\n * to events the devtools can understand.\n * @class Renderer\n */\nexport class Renderer {\n\tconstructor(hook, rid) {\n\n\t\t/** @type {string} */\n\t\tthis.rid = rid;\n\t\tthis.hook = hook;\n\n\t\t/** @type {Array<import('../internal').DevtoolsEvent>} */\n\t\tthis.pending = [];\n\n\t\t/**\n\t\t * Store the instance of a vnode. This will be later used to decide if a\n\t\t * vnode needs to be mounted or updated. For components the instance refers\n\t\t * to the actuall class instance whereas for dom nodes it refers to the\n\t\t * underlying dom element.\n\t\t * @type {WeakMap<import('../internal').Component | import('../internal').PreactElement | HTMLElement | Text, import('../internal').VNode>}\n\t\t */\n\t\tthis.inst2vnode = new WeakMap();\n\t\tthis.connected = false;\n\t}\n\n\t/**\n\t * Mark the connection status as ready so that we can proceed\n\t * to actually flush events.\n\t */\n\tmarkConnected() {\n\t\tthis.connected = true;\n\t\tthis.flushPendingEvents();\n\t}\n\n\t/**\n\t * Flush all queued events\n\t */\n\tflushPendingEvents() {\n\t\tif (!this.connected) return;\n\n\t\tlet events = this.pending;\n\t\tthis.pending = [];\n\t\tfor (let i = 0; i < events.length; i++) {\n\t\t\tlet event = events[i];\n\t\t\tthis.hook.emit(event.type, event);\n\t\t}\n\t}\n\n\t/**\n\t * Recursively mount a vnode tree. Note that the devtools expectes the tree to\n\t * be mounted from the bottom up, otherwise the order will be messed up.\n\t * Therefore we mount children prior to mounting the vnode itself.\n\t * @param {import('../internal').VNode} vnode\n\t */\n\tmount(vnode) {\n\t\tthis.inst2vnode.set(getInstance(vnode), vnode);\n\t\tlet data = getData(vnode);\n\n\t\t/** @type {Array<import('../internal').DevtoolsEvent>} */\n\t\tlet work = [{\n\t\t\tinternalInstance: vnode,\n\t\t\tdata,\n\t\t\trenderer: this.rid,\n\t\t\ttype: 'mount'\n\t\t}];\n\n\t\t// Children must be mounted first\n\t\tif (Array.isArray(data.children)) {\n\t\t\tlet stack = data.children.slice();\n\t\t\tlet item;\n\t\t\twhile ((item = stack.pop())!=null) {\n\t\t\t\tlet children = getChildren(item);\n\t\t\t\tstack.push(...children);\n\n\t\t\t\tthis.inst2vnode.set(getInstance(item), item);\n\n\t\t\t\tlet data = getData(item);\n\n\t\t\t\twork.push({\n\t\t\t\t\tinternalInstance: item,\n\t\t\t\t\tdata,\n\t\t\t\t\trenderer: this.rid,\n\t\t\t\t\ttype: 'mount'\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = work.length; --i>=0;) {\n\t\t\tthis.pending.push(work[i]);\n\t\t}\n\n\t\t// Special event if we have a root\n\t\tif (isRoot(vnode)) {\n\t\t\tthis.pending.push({\n\t\t\t\tinternalInstance: vnode,\n\t\t\t\tdata,\n\t\t\t\trenderer: this.rid,\n\t\t\t\ttype: 'root'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Update a vnode tree\n\t * @param {import('../internal').VNode} vnode\n\t */\n\tupdate(vnode) {\n\t\tlet data = getData(vnode);\n\n\t\t// Children must be updated first\n\t\tif (Array.isArray(data.children)) {\n\t\t\tfor (let i = 0; i < data.children.length; i++) {\n\t\t\t\tlet child = data.children[i];\n\t\t\t\tlet inst = getInstance(child);\n\n\t\t\t\tlet prevChild = this.inst2vnode.get(inst);\n\t\t\t\tif (prevChild==null) this.mount(child);\n\t\t\t\telse this.update(child);\n\n\t\t\t\t// Mutate child to keep referential equality intact\n\t\t\t\tdata.children[i] = this.inst2vnode.get(inst);\n\t\t\t}\n\t\t}\n\n\t\tlet prev = this.inst2vnode.get(data.publicInstance);\n\n\t\t// The `updateProfileTimes` event is a faster version of `updated` and\n\t\t// is processed much quicker inside the devtools extension.\n\t\tif (!hasDataChanged(prev, vnode)) {\n\t\t\t// Always assume profiling data has changed. When we skip an event here\n\t\t\t// the devtools element picker will somehow break.\n\t\t\tthis.pending.push({\n\t\t\t\t// This property is only used as an id inside the devtools. The\n\t\t\t\t// relevant data will be read from `.data` instead which is a\n\t\t\t\t// normalized structure that every react release adheres to. This\n\t\t\t\t// makes backwards-compatibility easier instead of relying on internal\n\t\t\t\t// vnode/fiber shape.\n\t\t\t\tinternalInstance: prev,\n\t\t\t\tdata,\n\t\t\t\trenderer: this.rid,\n\t\t\t\ttype: 'updateProfileTimes'\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tthis.pending.push({\n\t\t\t// This property is only used as an id inside the devtools. The\n\t\t\t// relevant data will be read from `.data` instead which is a\n\t\t\t// normalized structure that every react release adheres to. This\n\t\t\t// makes backwards-compatibility easier instead of relying on internal\n\t\t\t// vnode/fiber shape.\n\t\t\tinternalInstance: prev,\n\t\t\tdata,\n\t\t\trenderer: this.rid,\n\t\t\ttype: 'update'\n\t\t});\n\t}\n\n\t/**\n\t * Pass a rendered tree to the devtools. At this point elements have already\n\t * unmounted, so we don't need to check for removals and only update vs mount\n\t * instead.\n\t * @param {import('../internal').VNode} vnode\n\t */\n\thandleCommitFiberRoot(vnode) {\n\t\tlet inst = getInstance(vnode);\n\n\t\tif (this.inst2vnode.has(inst)) this.update(vnode);\n\t\telse this.mount(vnode);\n\n\t\t// The devtools checks via the existance of this property if the devtools\n\t\t// profiler should be enabled or not. If it is missing from the first root\n\t\t// node the \"Profiler\" tab won't show up.\n\t\t/** @type {import('../internal').VNode} */\n\t\tlet root = null;\n\t\tif (isRoot(vnode)) {\n\n\t\t\t/** @type {*} */\n\t\t\t(vnode).treeBaseDuration = 0;\n\t\t\troot = vnode;\n\t\t}\n\t\telse {\n\t\t\t// \"rootCommitted\" always needs the actual root node for the profiler\n\t\t\t// to be able to collect timings. The `_ancestorComponent` property will\n\t\t\t// point to a vnode for a root node.\n\t\t\troot = vnode._component;\n\t\t\twhile (root._ancestorComponent!=null) {\n\t\t\t\troot = root._ancestorComponent;\n\t\t\t}\n\t\t}\n\n\t\tthis.pending.push({\n\t\t\tinternalInstance: root,\n\t\t\trenderer: this.rid,\n\t\t\tdata: getData(root),\n\t\t\ttype: 'rootCommitted'\n\t\t});\n\n\t\tthis.flushPendingEvents();\n\t\treturn vnode;\n\t}\n\n\t/**\n\t * Unmount a vnode recursively. Contrary to mounting or updating unmounting needs\n\t * to push the events in parent-first order. Because `options.unmount` is\n\t * already fired in parent-first order we don't need to traverse anything here.\n\t * @param {import('../internal').VNode} vnode\n\t */\n\thandleCommitFiberUnmount(vnode) {\n\t\tlet inst = getInstance(vnode);\n\t\tthis.inst2vnode.delete(inst);\n\n\t\t// Special case when unmounting a root (most prominently caused by webpack's\n\t\t// `hot-module-reloading`). If this happens we need to unmount the virtual\n\t\t// `Fragment` we're wrapping around each root just for the devtools.\n\n\t\tthis.pending.push({\n\t\t\tinternalInstance: vnode,\n\t\t\trenderer: this.rid,\n\t\t\ttype: 'unmount'\n\t\t});\n\t}\n\n\t/**\n\t * Get the dom element by a vnode\n\t * @param {import('../internal').VNode} vnode\n\t * @returns {import('../internal').PreactElement | Text}\n\t */\n\tgetNativeFromReactElement(vnode) {\n\t\treturn vnode._dom;\n\t}\n\n\t/**\n\t * Get a vnode by a dom element\n\t * @param {import('../internal').PreactElement | Text} dom\n\t * @returns {import('../internal').VNode | null}\n\t */\n\tgetReactElementFromNative(dom) {\n\t\treturn this.inst2vnode.get(dom) || null;\n\t}\n\n\t// Unused, but devtools expects it to be there\n\t/* istanbul ignore next */\n\twalkTree() {}\n\n\t// Unused, but devtools expects it to be there\n\t/* istanbul ignore next */\n\tcleanup() {}\n}\n","import { options, Component, Fragment } from 'preact';\nimport { Renderer } from './renderer';\n\n/**\n * Wrap function with generic error logging\n *\n * @param {*} fn\n * @returns\n */\nfunction catchErrors(fn) {\n\treturn function(arg) {\n\t\ttry {\n\t\t\treturn fn(arg);\n\t\t}\n\t\tcatch (e) {\n\t\t\t/* istanbul ignore next */\n\t\t\tconsole.error('The react devtools encountered an error');\n\t\t\t/* istanbul ignore next */\n\t\t\tconsole.error(e); // eslint-disable-line no-console\n\t\t}\n\t};\n}\n\n/* istanbul ignore next */\nlet noop = () => undefined;\n\nexport function initDevTools() {\n\t// This global variable is injected by the devtools\n\t/** @type {import('../internal').DevtoolsWindow} */\n\tlet hook = (window).__REACT_DEVTOOLS_GLOBAL_HOOK__;\n\tif (hook==null) return;\n\n\t/** @type {(vnode: import('../internal').VNode) => void} */\n\tlet onCommitRoot = noop;\n\n\t/** @type {(vnode: import('../internal').VNode) => void} */\n\tlet onCommitUnmount = noop;\n\n\t// Initialize our custom renderer\n\tlet rid = Math.random().toString(16).slice(2);\n\tlet preactRenderer = new Renderer(hook, rid);\n\n\tcatchErrors(() => {\n\t\tlet isDev = false;\n\t\ttry {\n\t\t\tisDev = process.env.NODE_ENV!=='production';\n\t\t}\n\t\tcatch (e) {}\n\n\t\t// Tell devtools which bundle type we run in\n\t\twindow.parent.postMessage({\n\t\t\tsource: 'react-devtools-detector',\n\t\t\treactBuildType: /* istanbul ignore next */  isDev\n\t\t\t\t? 'development'\n\t\t\t\t: 'production'\n\t\t}, '*');\n\n\t\tlet renderer = {\n\t\t\tbundleType: /* istanbul ignore next */  isDev ? 1 : 0,\n\t\t\tversion: '16.5.2',\n\t\t\trendererPackageName: 'preact',\n\t\t\t// We don't need this, but the devtools `attachRenderer` function relys\n\t\t\t// it being there.\n\t\t\tfindHostInstanceByFiber(vnode) {\n\t\t\t\treturn vnode._dom;\n\t\t\t},\n\t\t\t// We don't need this, but the devtools `attachRenderer` function relys\n\t\t\t// it being there.\n\t\t\tfindFiberByHostInstance(instance) {\n\t\t\t\treturn preactRenderer.inst2vnode.get(instance) || null;\n\t\t\t}\n\t\t};\n\n\t\thook._renderers[rid] = renderer;\n\n\t\t// We can't bring our own `attachRenderer` function therefore we simply\n\t\t// prevent the devtools from overwriting our custom renderer by creating\n\t\t// a noop setter.\n\t\tObject.defineProperty(hook.helpers, rid, {\n\t\t\tget: () => preactRenderer,\n\t\t\tset: () => {\n\t\t\t\tif (!preactRenderer.connected) {\n\t\t\t\t\thelpers.markConnected();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tlet helpers = hook.helpers[rid];\n\n\t\t// Tell the devtools that we are ready to start\n\t\thook.emit('renderer-attached', {\n\t\t\tid: rid,\n\t\t\trenderer,\n\t\t\thelpers\n\t\t});\n\n\t\tonCommitRoot = catchErrors(root => {\n\t\t\t// Empty root\n\t\t\tif (root.type===Fragment && root._children.length==0) return;\n\n\t\t\tlet roots = hook.getFiberRoots(rid);\n\t\t\troot = helpers.handleCommitFiberRoot(root);\n\t\t\tif (!roots.has(root)) roots.add(root);\n\t\t});\n\n\t\tonCommitUnmount = catchErrors(vnode => {\n\t\t\thook.onCommitFiberUnmount(rid, vnode);\n\t\t});\n\t})();\n\n\t// Store (possible) previous hooks so that we don't overwrite them\n\tlet prevVNodeHook = options.vnode;\n\tlet prevCommitRoot = options.commit;\n\tlet prevBeforeUnmount = options.unmount;\n\tlet prevBeforeDiff = options.diff;\n\tlet prevAfterDiff = options.diffed;\n\n\toptions.vnode = (vnode) => {\n\t\t// Tiny performance improvement by initializing fields as doubles\n\t\t// from the start. `performance.now()` will always return a double.\n\t\t// See https://github.com/facebook/react/issues/14365\n\t\t// and https://slidr.io/bmeurer/javascript-engine-fundamentals-the-good-the-bad-and-the-ugly\n\t\tvnode.startTime = NaN;\n\t\tvnode.endTime = NaN;\n\n\t\tvnode.startTime = 0;\n\t\tvnode.endTime = -1;\n\t\tif (prevVNodeHook) prevVNodeHook(vnode);\n\t};\n\n\toptions.diff = (vnode) => {\n\t\tvnode.startTime = now();\n\t\tif (prevBeforeDiff!=null) prevBeforeDiff(vnode);\n\t};\n\n\toptions.diffed = (vnode) => {\n\t\tvnode.endTime = now();\n\t\tif (prevAfterDiff!=null) prevAfterDiff(vnode);\n\t};\n\n\toptions.commit = catchErrors((vnode) => {\n\t\t// Call previously defined hook\n\t\tif (prevCommitRoot!=null) prevCommitRoot(vnode);\n\n\t\t// These cases are already handled by `unmount`\n\t\tif (vnode==null) return;\n\t\tonCommitRoot(vnode);\n\t});\n\n\toptions.unmount = catchErrors((vnode) => {\n\t\t// Call previously defined hook\n\t\tif (prevBeforeUnmount!=null) prevBeforeUnmount(vnode);\n\t\tonCommitUnmount(vnode);\n\t});\n\n\t// Inject tracking into setState\n\tconst setState = Component.prototype.setState;\n\tComponent.prototype.setState = function(update, callback) {\n\t\t// Duplicated in setState() but doesn't matter due to the guard.\n\t\tlet s = (this._nextState!==this.state && this._nextState) || (this._nextState = Object.assign({}, this.state));\n\n\t\t// Needed in order to check if state has changed after the tree has been committed:\n\t\tthis._prevState = Object.assign({}, s);\n\n\t\treturn setState.call(this, update, callback);\n\t};\n}\n\n/**\n * Get current timestamp in ms. Used for profiling.\n * @returns {number}\n */\nexport let now = Date.now;\n\ntry {\n\t/* istanbul ignore else */\n\tnow = performance.now.bind(performance);\n}\ncatch (e) {}\n","import { initDebug } from './debug';\nimport { initDevTools } from './devtools';\n\nif (process.env.NODE_ENV==='development') {\n\tinitDebug();\n\tinitDevTools();\n}\n","export const ELEMENT_NODE = 1;\nexport const DOCUMENT_NODE = 9;\nexport const DOCUMENT_FRAGMENT_NODE = 11;\n"],"names":["const","loggedTypeFailures","getNodeType","vnode","type","Fragment","getDisplayName","displayName","name","setIn","obj","path","value","last","pop","parent","reduce","acc","attr","getData","c","_component","updater","Component","setState","bind","forceUpdate","setInState","prev","setInProps","props","setInContext","context","children","getChildren","duration","endTime","startTime","nodeType","ref","key","text","state","length","publicInstance","getInstance","memoizedInteractions","actualDuration","actualStartTime","treeBaseDuration","_children","filter","Boolean","Array","isArray","_prevVNode","isRoot","_dom","parentNode","shallowEqual","a","b","isProps","let","Object","keys","serializeVNode","attrs","prop","hasOwnProperty","toString","prototype","call","JSON","stringify","Renderer","constructor","hook","rid","pending","inst2vnode","WeakMap","connected","catchErrors","fn","arg","e","console","error","markConnected","flushPendingEvents","this","events","i","event","emit","mount","set","data","work","renderer","item","stack","slice","push","update","child","inst","get","next","_prevState","hasDataChanged","handleCommitFiberRoot","has","root","_ancestorComponent","handleCommitFiberUnmount","delete","getNativeFromReactElement","getReactElementFromNative","dom","walkTree","cleanup","noop","now","Date","performance","process","env","NODE_ENV","oldBeforeDiff","options","diff","oldDiffed","diffed","oldVnode","Error","isValid","typeSpecs","values","location","componentName","undefined","_lastDomChild","info","propTypes","forEach","typeSpecName","message","toChildArray","deepChild","indexOf","warn","property","err","deprecatedAttributes","nodeName","attributes","defineProperties","__hooks","hooks","_list","_callback","_args","_pendingEffects","effect","_pendingLayoutEffects","layoutEffect","initDebug","window","__REACT_DEVTOOLS_GLOBAL_HOOK__","onCommitRoot","onCommitUnmount","Math","random","preactRenderer","isDev","postMessage","source","reactBuildType","bundleType","version","rendererPackageName","findHostInstanceByFiber","findFiberByHostInstance","instance","_renderers","defineProperty","helpers","id","roots","getFiberRoots","add","onCommitFiberUnmount","prevVNodeHook","prevCommitRoot","commit","prevBeforeUnmount","unmount","prevBeforeDiff","prevAfterDiff","NaN","callback","s","_nextState","assign","initDevTools"],"mappings":"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"}
##############################################
/src/debug/dist/debug.module.js.map:1:{"version":3,"file":"debug.module.js","sources":["../src/check-props.js","../src/devtools/custom.js","../src/debug.js","../src/devtools/renderer.js","../src/devtools/index.js","../src/index.js","../src/constants.js"],"sourcesContent":["const ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nlet loggedTypeFailures = {};\n\nexport function checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n  Object.keys(typeSpecs).forEach((typeSpecName) => {\n    let error;\n    try {\n      error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n    } catch (e) {\n      error = e;\n    }\n    if (error && !(error.message in loggedTypeFailures)) {\n      loggedTypeFailures[error.message] = true;\n      console.error(`Failed ${location} type: ${error.message}${getStack && getStack() || ''}`);\n    }\n  });\n}\n","import { Component, Fragment } from 'preact';\n\n/**\n * Get the type/category of a vnode\n * @param {import('../internal').VNode} vnode\n * @returns {import('../internal').NodeType}\n */\nexport function getNodeType(vnode) {\n\tif (vnode.type===Fragment) return 'Wrapper';\n\telse if (typeof vnode.type==='function') return 'Composite';\n\telse if (typeof vnode.type==='string') return 'Native';\n\treturn 'Text';\n}\n\n/**\n * Get human readable name of the component/dom element\n * @param {import('../internal').VNode} vnode\n * @returns {string}\n */\nexport function getDisplayName(vnode) {\n\tif (vnode.type===Fragment) return 'Fragment';\n\telse if (typeof vnode.type==='function') return vnode.type.displayName || vnode.type.name;\n\telse if (typeof vnode.type==='string') return vnode.type;\n\treturn '#text';\n}\n\n/**\n * Deeply mutate a property by walking down an array of property keys\n * @param {object} obj\n * @param {Array<string | number>} path\n * @param {any} value\n */\nexport function setIn(obj, path, value) {\n\tlet last = path.pop();\n\tlet parent = path.reduce((acc, attr) => acc ? acc[attr] : null, obj);\n\tif (parent) {\n\t\tparent[last] = value;\n\t}\n}\n\n/**\n * Get devtools compatible data from vnode\n * @param {import('../internal').VNode} vnode\n * @returns {import('../internal').DevtoolData}\n */\nexport function getData(vnode) {\n\tlet c = vnode._component;\n\n\t/** @type {import('../internal').DevtoolsUpdater | null} */\n\tlet updater = null;\n\n\tif (c!=null && c instanceof Component) {\n\t\t// These functions will be called when the user changes state, props or\n\t\t// context values via the devtools ui panel\n\t\tupdater = {\n\t\t\tsetState: c.setState.bind(c),\n\t\t\tforceUpdate: c.forceUpdate.bind(c),\n\t\t\tsetInState(path, value) {\n\t\t\t\tc.setState(prev => {\n\t\t\t\t\tsetIn(prev, path, value);\n\t\t\t\t\treturn prev;\n\t\t\t\t});\n\t\t\t},\n\t\t\tsetInProps(path, value) {\n\t\t\t\tsetIn(vnode.props, path, value);\n\t\t\t\tc.setState({});\n\t\t\t},\n\t\t\tsetInContext(path, value) {\n\t\t\t\tsetIn(c.context, path, value);\n\t\t\t\tc.setState({});\n\t\t\t}\n\t\t};\n\t}\n\n\tlet children = getChildren(vnode);\n\n\tlet duration = vnode.endTime - vnode.startTime;\n\treturn {\n\t\tnodeType: getNodeType(vnode),\n\t\ttype: vnode.type,\n\t\tname: getDisplayName(vnode),\n\t\tref: vnode.ref || null,\n\t\tkey: vnode.key || null,\n\t\tupdater,\n\t\ttext: vnode.text,\n\t\tstate: c!=null && c instanceof Component ? c.state : null,\n\t\tprops: vnode.props,\n\t\t// The devtools inline text children if they are the only child\n\t\tchildren: vnode.text==null\n\t\t\t? children!=null && children.length==1 && children[0].text!=null\n\t\t\t\t? children[0].text\n\t\t\t\t: children\n\t\t\t: null,\n\t\tpublicInstance: getInstance(vnode),\n\t\tmemoizedInteractions: [],\n\n\t\t// Profiler data\n\t\tactualDuration: duration,\n\t\tactualStartTime: vnode.startTime,\n\t\ttreeBaseDuration: duration\n\t};\n}\n\n/**\n * Get all rendered vnode children as an array. Moreover we need to filter\n * out `null` or other falsy children.\n * @param {import('../internal').VNode} vnode\n * @returns {import('../internal').VNode[]}\n */\nexport function getChildren(vnode) {\n\tlet c = vnode._component;\n\n\tif (c==null) {\n\t\treturn vnode._children!=null ? vnode._children.filter(Boolean) : [];\n\t}\n\n\treturn !Array.isArray(c._prevVNode) && c._prevVNode!=null\n\t\t? [c._prevVNode]\n\t\t: null;\n}\n\n/**\n * Check if a vnode is a root node\n * @param {import('../internal').VNode} vnode\n * @returns {boolean}\n */\nexport function isRoot(vnode) {\n\t// Timings of root vnodes will never be set\n\treturn vnode.type===Fragment && vnode.endTime==-1;\n}\n\n/**\n * Cache a vnode by its instance and retrieve previous vnodes by the next\n * instance.\n *\n * We need this to be able to identify the previous vnode of a given instance.\n * For components we want to check if we already rendered it and use the class\n * instance as key. For html elements we use the dom node as key.\n *\n * @param {import('../internal').VNode} vnode\n * @returns {import('../internal').Component | import('../internal').PreactElement | Text | null}\n */\nexport function getInstance(vnode) {\n\t// Use the parent element as instance for root nodes\n\tif (isRoot(vnode)) {\n\t\t// Edge case: When the tree only consists of components that have not rendered\n\t\t// anything into the DOM we revert to using the vnode as instance.\n\t\treturn vnode._children.length > 0 && vnode._children[0]!=null && vnode._children[0]._dom!=null\n\t\t\t? /** @type {import('../internal').PreactElement | null} */\n\t\t\t(vnode._children[0]._dom.parentNode)\n\t\t\t: vnode;\n\t}\n\tif (vnode._component!=null) return vnode._component;\n\tif (vnode.type===Fragment) return vnode.props;\n\treturn vnode._dom;\n}\n\n/**\n * Compare two objects\n * @param {object} a\n * @param {object} b\n * @param {boolean} [isProps]\n * @returns {boolean}\n */\nexport function shallowEqual(a, b, isProps) {\n\tif (a==null || b==null) return false;\n\n\tfor (let key in a) {\n\t\tif (isProps && key=='children' && b[key]!=null) continue;\n\t\tif (a[key]!==b[key]) return false;\n\t}\n\n\tif (Object.keys(a).length!==Object.keys(b).length) return false;\n\treturn true;\n}\n\n/**\n * Check if a vnode was actually updated\n * @param {import('../internal').VNode} next\n * @param {import('../internal').VNode} prev\n * @returns {boolean}\n */\nexport function hasDataChanged(prev, next) {\n\treturn (prev.props !== next.props && !shallowEqual(prev.props, next.props, true))\n\t\t|| (prev._component!=null &&\n\t\t\t!shallowEqual(next._component._prevState, next._component.state))\n\t\t|| prev._dom !== next._dom\n\t\t|| prev.ref !== next.ref;\n}\n","import { checkPropTypes } from './check-props';\nimport { getDisplayName } from './devtools/custom';\nimport { options, toChildArray } from 'preact';\nimport { ELEMENT_NODE, DOCUMENT_NODE, DOCUMENT_FRAGMENT_NODE } from './constants';\n\nexport function initDebug() {\n\t/* eslint-disable no-console */\n\tlet oldBeforeDiff = options.diff;\n\tlet oldDiffed = options.diffed;\n\tlet oldVnode = options.vnode;\n\n\toptions.root = (vnode, parentNode) => {\n\t\tif (!parentNode) {\n\t\t\tthrow new Error('Undefined parent passed to render(), this is the second argument.\\nCheck if the element is available in the DOM/has the correct id.');\n\t\t}\n\t\tlet isValid;\n\t\tswitch (parentNode.nodeType) {\n\t\t\tcase ELEMENT_NODE:\n\t\t\tcase DOCUMENT_FRAGMENT_NODE:\n\t\t\tcase DOCUMENT_NODE: isValid = true; break;\n\t\t\tdefault: isValid = false;\n\t\t}\n\t\tif (!isValid) throw new Error(`\n\t\t\tExpected a valid HTML node as a second argument to render.\n\t\t\tReceived ${parentNode} instead: render(<${vnode.type.name || vnode.type} />, ${parentNode});\n\t\t`);\n\t};\n\n\toptions.diff = vnode => {\n\t\tlet { type, props } = vnode;\n\t\tlet children = props && props.children;\n\n\t\tif (type===undefined) {\n\t\t\tthrow new Error('Undefined component passed to createElement()\\n\\n'+\n\t\t\t'You likely forgot to export your component or might have mixed up default and named imports'+\n\t\t\tserializeVNode(vnode));\n\t\t}\n\t\telse if (type!=null && typeof type==='object') {\n\t\t\tif (type._lastDomChild!==undefined && type._dom!==undefined) {\n\t\t\t\tlet info = 'Did you accidentally pass a JSX literal as JSX twice?\\n\\n'+\n\t\t\t\t'  let My'+getDisplayName(type)+' = '+serializeVNode(type)+';\\n'+\n\t\t\t\t'  let vnode = <My'+getDisplayName(type)+' />;\\n\\n'+\n\t\t\t\t'This usually happens when you export a JSX literal and not the component.';\n\t\t\t\tthrow new Error('Invalid type passed to createElement(): '+type+'\\n\\n'+info+'\\n');\n\t\t\t}\n\n\t\t\tthrow new Error('Invalid type passed to createElement(): '+(Array.isArray(type) ? 'array' : type));\n\t\t}\n\n\t\tif (\n\t\t\tvnode.ref!==undefined &&\n\t\t\ttypeof vnode.ref!=='function' &&\n\t\t\ttypeof vnode.ref!=='object' &&\n\t\t\t!('$$typeof' in vnode)  // allow string refs when preact-compat is installed\n\t\t) {\n\t\t\tthrow new Error(\n\t\t\t\t`Component's \"ref\" property should be a function, or an object created ` +\n\t\t\t\t`by createRef(), but got [${typeof vnode.ref}] instead\\n` +\n\t\t\t\tserializeVNode(vnode)\n\t\t\t);\n\t\t}\n\n\t\tif (typeof vnode.type==='string') {\n\t\t\tfor (const key in vnode.props) {\n\t\t\t\tif (key[0]==='o' && key[1]==='n' && typeof vnode.props[key]!=='function' && vnode.props[key]!=null) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Component's \"${key}\" property should be a function, ` +\n\t\t\t\t\t\t`but got [${typeof vnode.props[key]}] instead\\n` +\n\t\t\t\t\t\tserializeVNode(vnode)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check prop-types if available\n\t\tif (typeof vnode.type==='function' && vnode.type.propTypes) {\n\t\t\tcheckPropTypes(vnode.type.propTypes, vnode.props, getDisplayName(vnode), serializeVNode(vnode));\n\t\t}\n\n\t\tlet keys = [];\n\t\tfor (let deepChild of toChildArray(children)) {\n\t\t\tif (!deepChild || deepChild.key==null) continue;\n\n\t\t\tlet key = deepChild.key;\n\n\t\t\tif (keys.indexOf(key) !== -1) {\n\t\t\t\tconsole.error(\n\t\t\t\t\t'Following component has two or more children with the ' +\n\t\t\t\t\t`same key attribute: \"${key}\". This may cause glitches and misbehavior ` +\n\t\t\t\t\t'in rendering process. Component: \\n\\n' +\n\t\t\t\t\tserializeVNode(vnode)\n\t\t\t\t);\n\n\t\t\t\t// Break early to not spam the console\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tkeys.push(key);\n\t\t}\n\n\t\tif (oldBeforeDiff) oldBeforeDiff(vnode);\n\t};\n\n\tconst warn = (property, err) => ({\n\t\tget() {\n\t\t\tthrow new Error(`getting vnode.${property} is deprecated, ${err}`);\n\t\t},\n\t\tset() {\n\t\t\tthrow new Error(`setting vnode.${property} is not allowed, ${err}`);\n\t\t}\n\t});\n\n\tconst deprecatedAttributes = {\n\t\tnodeName: warn('nodeName', 'use vnode.type'),\n\t\tattributes: warn('attributes', 'use vnode.props'),\n\t\tchildren: warn('children', 'use vnode.props.children')\n\t};\n\n\toptions.vnode = (vnode) => {\n\t\tObject.defineProperties(vnode, deprecatedAttributes);\n\t\tif (oldVnode) oldVnode(vnode);\n\t};\n\n\toptions.diffed = (vnode) => {\n\t\tif (vnode._component && vnode._component.__hooks) {\n\t\t\tlet hooks = vnode._component.__hooks;\n\t\t\tif (hooks._list.length > 0) {\n\t\t\t\thooks._list.forEach(hook => {\n\t\t\t\t\tif (hook._callback && (!hook._args || !Array.isArray(hook._args))) {\n\t\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t\t`In ${vnode.type.name || vnode.type} you are calling useMemo/useCallback without passing arguments.\\n` +\n\t\t\t\t\t\t\t`This is a noop since it will not be able to memoize, it will execute it every render.`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (hooks._pendingEffects.length > 0) {\n\t\t\t\thooks._pendingEffects.forEach((effect) => {\n\t\t\t\t\tif (!effect._args || !Array.isArray(effect._args)) {\n\t\t\t\t\t\tthrow new Error('You should provide an array of arguments as the second argument to the \"useEffect\" hook.\\n\\n' +\n\t\t\t\t\t\t\t'Not doing so will invoke this effect on every render.\\n\\n' +\n\t\t\t\t\t\t\t'This effect can be found in the render of ' + (vnode.type.name || vnode.type) + '.');\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (hooks._pendingLayoutEffects.length > 0) {\n\t\t\t\thooks._pendingLayoutEffects.forEach((layoutEffect) => {\n\t\t\t\t\tif (!layoutEffect._args || !Array.isArray(layoutEffect._args)) {\n\t\t\t\t\t\tthrow new Error('You should provide an array of arguments as the second argument to the \"useEffect\" hook.\\n\\n' +\n\t\t\t\t\t\t\t'Not doing so will invoke this effect on every render.\\n\\n' +\n\t\t\t\t\t\t\t'This effect can be found in the render of ' + (vnode.type.name || vnode.type) + '.');\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (oldDiffed) oldDiffed(vnode);\n\t};\n}\n\n/**\n * Serialize a vnode tree to a string\n * @param {import('./internal').VNode} vnode\n * @returns {string}\n */\nexport function serializeVNode(vnode) {\n\tlet { props } = vnode;\n\tlet name = getDisplayName(vnode);\n\n\tlet attrs = '';\n\tif (props) {\n\t\tfor (let prop in props) {\n\t\t\tif (props.hasOwnProperty(prop) && prop!=='children') {\n\t\t\t\tlet value = props[prop];\n\n\t\t\t\t// If it is an object but doesn't have toString(), use Object.toString\n\t\t\t\tif (typeof value==='function') {\n\t\t\t\t\tvalue = `function ${value.displayName || value.name}() {}`;\n\t\t\t\t}\n\n\t\t\t\tvalue = Object(value) === value && !value.toString\n\t\t\t\t\t? Object.prototype.toString.call(value)\n\t\t\t\t\t: value + '';\n\n\t\t\t\tattrs += ` ${prop}=${JSON.stringify(value)}`;\n\t\t\t}\n\t\t}\n\t}\n\n\tlet children = props.children;\n\treturn `<${name}${attrs}${children && children.length\n\t\t? '>..</'+name+'>'\n\t\t: ' />'}`;\n}\n","import { getData, getChildren, getInstance, hasDataChanged, isRoot } from './custom';\n\n/**\n * Custom renderer tailored for Preact. It converts updated vnode trees\n * to events the devtools can understand.\n * @class Renderer\n */\nexport class Renderer {\n\tconstructor(hook, rid) {\n\n\t\t/** @type {string} */\n\t\tthis.rid = rid;\n\t\tthis.hook = hook;\n\n\t\t/** @type {Array<import('../internal').DevtoolsEvent>} */\n\t\tthis.pending = [];\n\n\t\t/**\n\t\t * Store the instance of a vnode. This will be later used to decide if a\n\t\t * vnode needs to be mounted or updated. For components the instance refers\n\t\t * to the actuall class instance whereas for dom nodes it refers to the\n\t\t * underlying dom element.\n\t\t * @type {WeakMap<import('../internal').Component | import('../internal').PreactElement | HTMLElement | Text, import('../internal').VNode>}\n\t\t */\n\t\tthis.inst2vnode = new WeakMap();\n\t\tthis.connected = false;\n\t}\n\n\t/**\n\t * Mark the connection status as ready so that we can proceed\n\t * to actually flush events.\n\t */\n\tmarkConnected() {\n\t\tthis.connected = true;\n\t\tthis.flushPendingEvents();\n\t}\n\n\t/**\n\t * Flush all queued events\n\t */\n\tflushPendingEvents() {\n\t\tif (!this.connected) return;\n\n\t\tlet events = this.pending;\n\t\tthis.pending = [];\n\t\tfor (let i = 0; i < events.length; i++) {\n\t\t\tlet event = events[i];\n\t\t\tthis.hook.emit(event.type, event);\n\t\t}\n\t}\n\n\t/**\n\t * Recursively mount a vnode tree. Note that the devtools expectes the tree to\n\t * be mounted from the bottom up, otherwise the order will be messed up.\n\t * Therefore we mount children prior to mounting the vnode itself.\n\t * @param {import('../internal').VNode} vnode\n\t */\n\tmount(vnode) {\n\t\tthis.inst2vnode.set(getInstance(vnode), vnode);\n\t\tlet data = getData(vnode);\n\n\t\t/** @type {Array<import('../internal').DevtoolsEvent>} */\n\t\tlet work = [{\n\t\t\tinternalInstance: vnode,\n\t\t\tdata,\n\t\t\trenderer: this.rid,\n\t\t\ttype: 'mount'\n\t\t}];\n\n\t\t// Children must be mounted first\n\t\tif (Array.isArray(data.children)) {\n\t\t\tlet stack = data.children.slice();\n\t\t\tlet item;\n\t\t\twhile ((item = stack.pop())!=null) {\n\t\t\t\tlet children = getChildren(item);\n\t\t\t\tstack.push(...children);\n\n\t\t\t\tthis.inst2vnode.set(getInstance(item), item);\n\n\t\t\t\tlet data = getData(item);\n\n\t\t\t\twork.push({\n\t\t\t\t\tinternalInstance: item,\n\t\t\t\t\tdata,\n\t\t\t\t\trenderer: this.rid,\n\t\t\t\t\ttype: 'mount'\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = work.length; --i>=0;) {\n\t\t\tthis.pending.push(work[i]);\n\t\t}\n\n\t\t// Special event if we have a root\n\t\tif (isRoot(vnode)) {\n\t\t\tthis.pending.push({\n\t\t\t\tinternalInstance: vnode,\n\t\t\t\tdata,\n\t\t\t\trenderer: this.rid,\n\t\t\t\ttype: 'root'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Update a vnode tree\n\t * @param {import('../internal').VNode} vnode\n\t */\n\tupdate(vnode) {\n\t\tlet data = getData(vnode);\n\n\t\t// Children must be updated first\n\t\tif (Array.isArray(data.children)) {\n\t\t\tfor (let i = 0; i < data.children.length; i++) {\n\t\t\t\tlet child = data.children[i];\n\t\t\t\tlet inst = getInstance(child);\n\n\t\t\t\tlet prevChild = this.inst2vnode.get(inst);\n\t\t\t\tif (prevChild==null) this.mount(child);\n\t\t\t\telse this.update(child);\n\n\t\t\t\t// Mutate child to keep referential equality intact\n\t\t\t\tdata.children[i] = this.inst2vnode.get(inst);\n\t\t\t}\n\t\t}\n\n\t\tlet prev = this.inst2vnode.get(data.publicInstance);\n\n\t\t// The `updateProfileTimes` event is a faster version of `updated` and\n\t\t// is processed much quicker inside the devtools extension.\n\t\tif (!hasDataChanged(prev, vnode)) {\n\t\t\t// Always assume profiling data has changed. When we skip an event here\n\t\t\t// the devtools element picker will somehow break.\n\t\t\tthis.pending.push({\n\t\t\t\t// This property is only used as an id inside the devtools. The\n\t\t\t\t// relevant data will be read from `.data` instead which is a\n\t\t\t\t// normalized structure that every react release adheres to. This\n\t\t\t\t// makes backwards-compatibility easier instead of relying on internal\n\t\t\t\t// vnode/fiber shape.\n\t\t\t\tinternalInstance: prev,\n\t\t\t\tdata,\n\t\t\t\trenderer: this.rid,\n\t\t\t\ttype: 'updateProfileTimes'\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tthis.pending.push({\n\t\t\t// This property is only used as an id inside the devtools. The\n\t\t\t// relevant data will be read from `.data` instead which is a\n\t\t\t// normalized structure that every react release adheres to. This\n\t\t\t// makes backwards-compatibility easier instead of relying on internal\n\t\t\t// vnode/fiber shape.\n\t\t\tinternalInstance: prev,\n\t\t\tdata,\n\t\t\trenderer: this.rid,\n\t\t\ttype: 'update'\n\t\t});\n\t}\n\n\t/**\n\t * Pass a rendered tree to the devtools. At this point elements have already\n\t * unmounted, so we don't need to check for removals and only update vs mount\n\t * instead.\n\t * @param {import('../internal').VNode} vnode\n\t */\n\thandleCommitFiberRoot(vnode) {\n\t\tlet inst = getInstance(vnode);\n\n\t\tif (this.inst2vnode.has(inst)) this.update(vnode);\n\t\telse this.mount(vnode);\n\n\t\t// The devtools checks via the existance of this property if the devtools\n\t\t// profiler should be enabled or not. If it is missing from the first root\n\t\t// node the \"Profiler\" tab won't show up.\n\t\t/** @type {import('../internal').VNode} */\n\t\tlet root = null;\n\t\tif (isRoot(vnode)) {\n\n\t\t\t/** @type {*} */\n\t\t\t(vnode).treeBaseDuration = 0;\n\t\t\troot = vnode;\n\t\t}\n\t\telse {\n\t\t\t// \"rootCommitted\" always needs the actual root node for the profiler\n\t\t\t// to be able to collect timings. The `_ancestorComponent` property will\n\t\t\t// point to a vnode for a root node.\n\t\t\troot = vnode._component;\n\t\t\twhile (root._ancestorComponent!=null) {\n\t\t\t\troot = root._ancestorComponent;\n\t\t\t}\n\t\t}\n\n\t\tthis.pending.push({\n\t\t\tinternalInstance: root,\n\t\t\trenderer: this.rid,\n\t\t\tdata: getData(root),\n\t\t\ttype: 'rootCommitted'\n\t\t});\n\n\t\tthis.flushPendingEvents();\n\t\treturn vnode;\n\t}\n\n\t/**\n\t * Unmount a vnode recursively. Contrary to mounting or updating unmounting needs\n\t * to push the events in parent-first order. Because `options.unmount` is\n\t * already fired in parent-first order we don't need to traverse anything here.\n\t * @param {import('../internal').VNode} vnode\n\t */\n\thandleCommitFiberUnmount(vnode) {\n\t\tlet inst = getInstance(vnode);\n\t\tthis.inst2vnode.delete(inst);\n\n\t\t// Special case when unmounting a root (most prominently caused by webpack's\n\t\t// `hot-module-reloading`). If this happens we need to unmount the virtual\n\t\t// `Fragment` we're wrapping around each root just for the devtools.\n\n\t\tthis.pending.push({\n\t\t\tinternalInstance: vnode,\n\t\t\trenderer: this.rid,\n\t\t\ttype: 'unmount'\n\t\t});\n\t}\n\n\t/**\n\t * Get the dom element by a vnode\n\t * @param {import('../internal').VNode} vnode\n\t * @returns {import('../internal').PreactElement | Text}\n\t */\n\tgetNativeFromReactElement(vnode) {\n\t\treturn vnode._dom;\n\t}\n\n\t/**\n\t * Get a vnode by a dom element\n\t * @param {import('../internal').PreactElement | Text} dom\n\t * @returns {import('../internal').VNode | null}\n\t */\n\tgetReactElementFromNative(dom) {\n\t\treturn this.inst2vnode.get(dom) || null;\n\t}\n\n\t// Unused, but devtools expects it to be there\n\t/* istanbul ignore next */\n\twalkTree() {}\n\n\t// Unused, but devtools expects it to be there\n\t/* istanbul ignore next */\n\tcleanup() {}\n}\n","import { options, Component, Fragment } from 'preact';\nimport { Renderer } from './renderer';\n\n/**\n * Wrap function with generic error logging\n *\n * @param {*} fn\n * @returns\n */\nfunction catchErrors(fn) {\n\treturn function(arg) {\n\t\ttry {\n\t\t\treturn fn(arg);\n\t\t}\n\t\tcatch (e) {\n\t\t\t/* istanbul ignore next */\n\t\t\tconsole.error('The react devtools encountered an error');\n\t\t\t/* istanbul ignore next */\n\t\t\tconsole.error(e); // eslint-disable-line no-console\n\t\t}\n\t};\n}\n\n/* istanbul ignore next */\nlet noop = () => undefined;\n\nexport function initDevTools() {\n\t// This global variable is injected by the devtools\n\t/** @type {import('../internal').DevtoolsWindow} */\n\tlet hook = (window).__REACT_DEVTOOLS_GLOBAL_HOOK__;\n\tif (hook==null) return;\n\n\t/** @type {(vnode: import('../internal').VNode) => void} */\n\tlet onCommitRoot = noop;\n\n\t/** @type {(vnode: import('../internal').VNode) => void} */\n\tlet onCommitUnmount = noop;\n\n\t// Initialize our custom renderer\n\tlet rid = Math.random().toString(16).slice(2);\n\tlet preactRenderer = new Renderer(hook, rid);\n\n\tcatchErrors(() => {\n\t\tlet isDev = false;\n\t\ttry {\n\t\t\tisDev = process.env.NODE_ENV!=='production';\n\t\t}\n\t\tcatch (e) {}\n\n\t\t// Tell devtools which bundle type we run in\n\t\twindow.parent.postMessage({\n\t\t\tsource: 'react-devtools-detector',\n\t\t\treactBuildType: /* istanbul ignore next */  isDev\n\t\t\t\t? 'development'\n\t\t\t\t: 'production'\n\t\t}, '*');\n\n\t\tlet renderer = {\n\t\t\tbundleType: /* istanbul ignore next */  isDev ? 1 : 0,\n\t\t\tversion: '16.5.2',\n\t\t\trendererPackageName: 'preact',\n\t\t\t// We don't need this, but the devtools `attachRenderer` function relys\n\t\t\t// it being there.\n\t\t\tfindHostInstanceByFiber(vnode) {\n\t\t\t\treturn vnode._dom;\n\t\t\t},\n\t\t\t// We don't need this, but the devtools `attachRenderer` function relys\n\t\t\t// it being there.\n\t\t\tfindFiberByHostInstance(instance) {\n\t\t\t\treturn preactRenderer.inst2vnode.get(instance) || null;\n\t\t\t}\n\t\t};\n\n\t\thook._renderers[rid] = renderer;\n\n\t\t// We can't bring our own `attachRenderer` function therefore we simply\n\t\t// prevent the devtools from overwriting our custom renderer by creating\n\t\t// a noop setter.\n\t\tObject.defineProperty(hook.helpers, rid, {\n\t\t\tget: () => preactRenderer,\n\t\t\tset: () => {\n\t\t\t\tif (!preactRenderer.connected) {\n\t\t\t\t\thelpers.markConnected();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tlet helpers = hook.helpers[rid];\n\n\t\t// Tell the devtools that we are ready to start\n\t\thook.emit('renderer-attached', {\n\t\t\tid: rid,\n\t\t\trenderer,\n\t\t\thelpers\n\t\t});\n\n\t\tonCommitRoot = catchErrors(root => {\n\t\t\t// Empty root\n\t\t\tif (root.type===Fragment && root._children.length==0) return;\n\n\t\t\tlet roots = hook.getFiberRoots(rid);\n\t\t\troot = helpers.handleCommitFiberRoot(root);\n\t\t\tif (!roots.has(root)) roots.add(root);\n\t\t});\n\n\t\tonCommitUnmount = catchErrors(vnode => {\n\t\t\thook.onCommitFiberUnmount(rid, vnode);\n\t\t});\n\t})();\n\n\t// Store (possible) previous hooks so that we don't overwrite them\n\tlet prevVNodeHook = options.vnode;\n\tlet prevCommitRoot = options.commit;\n\tlet prevBeforeUnmount = options.unmount;\n\tlet prevBeforeDiff = options.diff;\n\tlet prevAfterDiff = options.diffed;\n\n\toptions.vnode = (vnode) => {\n\t\t// Tiny performance improvement by initializing fields as doubles\n\t\t// from the start. `performance.now()` will always return a double.\n\t\t// See https://github.com/facebook/react/issues/14365\n\t\t// and https://slidr.io/bmeurer/javascript-engine-fundamentals-the-good-the-bad-and-the-ugly\n\t\tvnode.startTime = NaN;\n\t\tvnode.endTime = NaN;\n\n\t\tvnode.startTime = 0;\n\t\tvnode.endTime = -1;\n\t\tif (prevVNodeHook) prevVNodeHook(vnode);\n\t};\n\n\toptions.diff = (vnode) => {\n\t\tvnode.startTime = now();\n\t\tif (prevBeforeDiff!=null) prevBeforeDiff(vnode);\n\t};\n\n\toptions.diffed = (vnode) => {\n\t\tvnode.endTime = now();\n\t\tif (prevAfterDiff!=null) prevAfterDiff(vnode);\n\t};\n\n\toptions.commit = catchErrors((vnode) => {\n\t\t// Call previously defined hook\n\t\tif (prevCommitRoot!=null) prevCommitRoot(vnode);\n\n\t\t// These cases are already handled by `unmount`\n\t\tif (vnode==null) return;\n\t\tonCommitRoot(vnode);\n\t});\n\n\toptions.unmount = catchErrors((vnode) => {\n\t\t// Call previously defined hook\n\t\tif (prevBeforeUnmount!=null) prevBeforeUnmount(vnode);\n\t\tonCommitUnmount(vnode);\n\t});\n\n\t// Inject tracking into setState\n\tconst setState = Component.prototype.setState;\n\tComponent.prototype.setState = function(update, callback) {\n\t\t// Duplicated in setState() but doesn't matter due to the guard.\n\t\tlet s = (this._nextState!==this.state && this._nextState) || (this._nextState = Object.assign({}, this.state));\n\n\t\t// Needed in order to check if state has changed after the tree has been committed:\n\t\tthis._prevState = Object.assign({}, s);\n\n\t\treturn setState.call(this, update, callback);\n\t};\n}\n\n/**\n * Get current timestamp in ms. Used for profiling.\n * @returns {number}\n */\nexport let now = Date.now;\n\ntry {\n\t/* istanbul ignore else */\n\tnow = performance.now.bind(performance);\n}\ncatch (e) {}\n","import { initDebug } from './debug';\nimport { initDevTools } from './devtools';\n\nif (process.env.NODE_ENV==='development') {\n\tinitDebug();\n\tinitDevTools();\n}\n","export const ELEMENT_NODE = 1;\nexport const DOCUMENT_NODE = 9;\nexport const DOCUMENT_FRAGMENT_NODE = 11;\n"],"names":["const","loggedTypeFailures","getNodeType","vnode","type","Fragment","getDisplayName","displayName","name","setIn","obj","path","value","last","pop","parent","reduce","acc","attr","getData","c","_component","updater","Component","setState","bind","forceUpdate","setInState","prev","setInProps","props","setInContext","context","children","getChildren","duration","endTime","startTime","nodeType","ref","key","text","state","length","publicInstance","getInstance","memoizedInteractions","actualDuration","actualStartTime","treeBaseDuration","_children","filter","Boolean","Array","isArray","_prevVNode","isRoot","_dom","parentNode","shallowEqual","a","b","isProps","let","Object","keys","serializeVNode","attrs","prop","hasOwnProperty","toString","prototype","call","JSON","stringify","Renderer","constructor","hook","rid","pending","inst2vnode","WeakMap","connected","catchErrors","fn","arg","e","console","error","markConnected","flushPendingEvents","this","events","i","event","emit","mount","set","data","work","renderer","item","stack","slice","push","update","child","inst","get","next","_prevState","hasDataChanged","handleCommitFiberRoot","has","root","_ancestorComponent","handleCommitFiberUnmount","delete","getNativeFromReactElement","getReactElementFromNative","dom","walkTree","cleanup","noop","now","Date","performance","process","env","NODE_ENV","oldBeforeDiff","options","diff","oldDiffed","diffed","oldVnode","Error","isValid","typeSpecs","values","location","componentName","undefined","_lastDomChild","info","propTypes","forEach","typeSpecName","message","toChildArray","deepChild","indexOf","warn","property","err","deprecatedAttributes","nodeName","attributes","defineProperties","__hooks","hooks","_list","_callback","_args","_pendingEffects","effect","_pendingLayoutEffects","layoutEffect","initDebug","window","__REACT_DEVTOOLS_GLOBAL_HOOK__","onCommitRoot","onCommitUnmount","Math","random","preactRenderer","isDev","postMessage","source","reactBuildType","bundleType","version","rendererPackageName","findHostInstanceByFiber","findFiberByHostInstance","instance","_renderers","defineProperty","helpers","id","roots","getFiberRoots","add","onCommitFiberUnmount","prevVNodeHook","prevCommitRoot","commit","prevBeforeUnmount","unmount","prevBeforeDiff","prevAfterDiff","NaN","callback","s","_nextState","assign","initDevTools"],"mappings":"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"}
##############################################
/src/debug/dist/debug.js.map:1:{"version":3,"file":"debug.js","sources":["../src/check-props.js","../src/devtools/custom.js","../src/debug.js","../src/devtools/renderer.js","../src/devtools/index.js","../src/index.js","../src/constants.js"],"sourcesContent":["const ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nlet loggedTypeFailures = {};\n\nexport function checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n  Object.keys(typeSpecs).forEach((typeSpecName) => {\n    let error;\n    try {\n      error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n    } catch (e) {\n      error = e;\n    }\n    if (error && !(error.message in loggedTypeFailures)) {\n      loggedTypeFailures[error.message] = true;\n      console.error(`Failed ${location} type: ${error.message}${getStack && getStack() || ''}`);\n    }\n  });\n}\n","import { Component, Fragment } from 'preact';\n\n/**\n * Get the type/category of a vnode\n * @param {import('../internal').VNode} vnode\n * @returns {import('../internal').NodeType}\n */\nexport function getNodeType(vnode) {\n\tif (vnode.type===Fragment) return 'Wrapper';\n\telse if (typeof vnode.type==='function') return 'Composite';\n\telse if (typeof vnode.type==='string') return 'Native';\n\treturn 'Text';\n}\n\n/**\n * Get human readable name of the component/dom element\n * @param {import('../internal').VNode} vnode\n * @returns {string}\n */\nexport function getDisplayName(vnode) {\n\tif (vnode.type===Fragment) return 'Fragment';\n\telse if (typeof vnode.type==='function') return vnode.type.displayName || vnode.type.name;\n\telse if (typeof vnode.type==='string') return vnode.type;\n\treturn '#text';\n}\n\n/**\n * Deeply mutate a property by walking down an array of property keys\n * @param {object} obj\n * @param {Array<string | number>} path\n * @param {any} value\n */\nexport function setIn(obj, path, value) {\n\tlet last = path.pop();\n\tlet parent = path.reduce((acc, attr) => acc ? acc[attr] : null, obj);\n\tif (parent) {\n\t\tparent[last] = value;\n\t}\n}\n\n/**\n * Get devtools compatible data from vnode\n * @param {import('../internal').VNode} vnode\n * @returns {import('../internal').DevtoolData}\n */\nexport function getData(vnode) {\n\tlet c = vnode._component;\n\n\t/** @type {import('../internal').DevtoolsUpdater | null} */\n\tlet updater = null;\n\n\tif (c!=null && c instanceof Component) {\n\t\t// These functions will be called when the user changes state, props or\n\t\t// context values via the devtools ui panel\n\t\tupdater = {\n\t\t\tsetState: c.setState.bind(c),\n\t\t\tforceUpdate: c.forceUpdate.bind(c),\n\t\t\tsetInState(path, value) {\n\t\t\t\tc.setState(prev => {\n\t\t\t\t\tsetIn(prev, path, value);\n\t\t\t\t\treturn prev;\n\t\t\t\t});\n\t\t\t},\n\t\t\tsetInProps(path, value) {\n\t\t\t\tsetIn(vnode.props, path, value);\n\t\t\t\tc.setState({});\n\t\t\t},\n\t\t\tsetInContext(path, value) {\n\t\t\t\tsetIn(c.context, path, value);\n\t\t\t\tc.setState({});\n\t\t\t}\n\t\t};\n\t}\n\n\tlet children = getChildren(vnode);\n\n\tlet duration = vnode.endTime - vnode.startTime;\n\treturn {\n\t\tnodeType: getNodeType(vnode),\n\t\ttype: vnode.type,\n\t\tname: getDisplayName(vnode),\n\t\tref: vnode.ref || null,\n\t\tkey: vnode.key || null,\n\t\tupdater,\n\t\ttext: vnode.text,\n\t\tstate: c!=null && c instanceof Component ? c.state : null,\n\t\tprops: vnode.props,\n\t\t// The devtools inline text children if they are the only child\n\t\tchildren: vnode.text==null\n\t\t\t? children!=null && children.length==1 && children[0].text!=null\n\t\t\t\t? children[0].text\n\t\t\t\t: children\n\t\t\t: null,\n\t\tpublicInstance: getInstance(vnode),\n\t\tmemoizedInteractions: [],\n\n\t\t// Profiler data\n\t\tactualDuration: duration,\n\t\tactualStartTime: vnode.startTime,\n\t\ttreeBaseDuration: duration\n\t};\n}\n\n/**\n * Get all rendered vnode children as an array. Moreover we need to filter\n * out `null` or other falsy children.\n * @param {import('../internal').VNode} vnode\n * @returns {import('../internal').VNode[]}\n */\nexport function getChildren(vnode) {\n\tlet c = vnode._component;\n\n\tif (c==null) {\n\t\treturn vnode._children!=null ? vnode._children.filter(Boolean) : [];\n\t}\n\n\treturn !Array.isArray(c._prevVNode) && c._prevVNode!=null\n\t\t? [c._prevVNode]\n\t\t: null;\n}\n\n/**\n * Check if a vnode is a root node\n * @param {import('../internal').VNode} vnode\n * @returns {boolean}\n */\nexport function isRoot(vnode) {\n\t// Timings of root vnodes will never be set\n\treturn vnode.type===Fragment && vnode.endTime==-1;\n}\n\n/**\n * Cache a vnode by its instance and retrieve previous vnodes by the next\n * instance.\n *\n * We need this to be able to identify the previous vnode of a given instance.\n * For components we want to check if we already rendered it and use the class\n * instance as key. For html elements we use the dom node as key.\n *\n * @param {import('../internal').VNode} vnode\n * @returns {import('../internal').Component | import('../internal').PreactElement | Text | null}\n */\nexport function getInstance(vnode) {\n\t// Use the parent element as instance for root nodes\n\tif (isRoot(vnode)) {\n\t\t// Edge case: When the tree only consists of components that have not rendered\n\t\t// anything into the DOM we revert to using the vnode as instance.\n\t\treturn vnode._children.length > 0 && vnode._children[0]!=null && vnode._children[0]._dom!=null\n\t\t\t? /** @type {import('../internal').PreactElement | null} */\n\t\t\t(vnode._children[0]._dom.parentNode)\n\t\t\t: vnode;\n\t}\n\tif (vnode._component!=null) return vnode._component;\n\tif (vnode.type===Fragment) return vnode.props;\n\treturn vnode._dom;\n}\n\n/**\n * Compare two objects\n * @param {object} a\n * @param {object} b\n * @param {boolean} [isProps]\n * @returns {boolean}\n */\nexport function shallowEqual(a, b, isProps) {\n\tif (a==null || b==null) return false;\n\n\tfor (let key in a) {\n\t\tif (isProps && key=='children' && b[key]!=null) continue;\n\t\tif (a[key]!==b[key]) return false;\n\t}\n\n\tif (Object.keys(a).length!==Object.keys(b).length) return false;\n\treturn true;\n}\n\n/**\n * Check if a vnode was actually updated\n * @param {import('../internal').VNode} next\n * @param {import('../internal').VNode} prev\n * @returns {boolean}\n */\nexport function hasDataChanged(prev, next) {\n\treturn (prev.props !== next.props && !shallowEqual(prev.props, next.props, true))\n\t\t|| (prev._component!=null &&\n\t\t\t!shallowEqual(next._component._prevState, next._component.state))\n\t\t|| prev._dom !== next._dom\n\t\t|| prev.ref !== next.ref;\n}\n","import { checkPropTypes } from './check-props';\nimport { getDisplayName } from './devtools/custom';\nimport { options, toChildArray } from 'preact';\nimport { ELEMENT_NODE, DOCUMENT_NODE, DOCUMENT_FRAGMENT_NODE } from './constants';\n\nexport function initDebug() {\n\t/* eslint-disable no-console */\n\tlet oldBeforeDiff = options.diff;\n\tlet oldDiffed = options.diffed;\n\tlet oldVnode = options.vnode;\n\n\toptions.root = (vnode, parentNode) => {\n\t\tif (!parentNode) {\n\t\t\tthrow new Error('Undefined parent passed to render(), this is the second argument.\\nCheck if the element is available in the DOM/has the correct id.');\n\t\t}\n\t\tlet isValid;\n\t\tswitch (parentNode.nodeType) {\n\t\t\tcase ELEMENT_NODE:\n\t\t\tcase DOCUMENT_FRAGMENT_NODE:\n\t\t\tcase DOCUMENT_NODE: isValid = true; break;\n\t\t\tdefault: isValid = false;\n\t\t}\n\t\tif (!isValid) throw new Error(`\n\t\t\tExpected a valid HTML node as a second argument to render.\n\t\t\tReceived ${parentNode} instead: render(<${vnode.type.name || vnode.type} />, ${parentNode});\n\t\t`);\n\t};\n\n\toptions.diff = vnode => {\n\t\tlet { type, props } = vnode;\n\t\tlet children = props && props.children;\n\n\t\tif (type===undefined) {\n\t\t\tthrow new Error('Undefined component passed to createElement()\\n\\n'+\n\t\t\t'You likely forgot to export your component or might have mixed up default and named imports'+\n\t\t\tserializeVNode(vnode));\n\t\t}\n\t\telse if (type!=null && typeof type==='object') {\n\t\t\tif (type._lastDomChild!==undefined && type._dom!==undefined) {\n\t\t\t\tlet info = 'Did you accidentally pass a JSX literal as JSX twice?\\n\\n'+\n\t\t\t\t'  let My'+getDisplayName(type)+' = '+serializeVNode(type)+';\\n'+\n\t\t\t\t'  let vnode = <My'+getDisplayName(type)+' />;\\n\\n'+\n\t\t\t\t'This usually happens when you export a JSX literal and not the component.';\n\t\t\t\tthrow new Error('Invalid type passed to createElement(): '+type+'\\n\\n'+info+'\\n');\n\t\t\t}\n\n\t\t\tthrow new Error('Invalid type passed to createElement(): '+(Array.isArray(type) ? 'array' : type));\n\t\t}\n\n\t\tif (\n\t\t\tvnode.ref!==undefined &&\n\t\t\ttypeof vnode.ref!=='function' &&\n\t\t\ttypeof vnode.ref!=='object' &&\n\t\t\t!('$$typeof' in vnode)  // allow string refs when preact-compat is installed\n\t\t) {\n\t\t\tthrow new Error(\n\t\t\t\t`Component's \"ref\" property should be a function, or an object created ` +\n\t\t\t\t`by createRef(), but got [${typeof vnode.ref}] instead\\n` +\n\t\t\t\tserializeVNode(vnode)\n\t\t\t);\n\t\t}\n\n\t\tif (typeof vnode.type==='string') {\n\t\t\tfor (const key in vnode.props) {\n\t\t\t\tif (key[0]==='o' && key[1]==='n' && typeof vnode.props[key]!=='function' && vnode.props[key]!=null) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Component's \"${key}\" property should be a function, ` +\n\t\t\t\t\t\t`but got [${typeof vnode.props[key]}] instead\\n` +\n\t\t\t\t\t\tserializeVNode(vnode)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check prop-types if available\n\t\tif (typeof vnode.type==='function' && vnode.type.propTypes) {\n\t\t\tcheckPropTypes(vnode.type.propTypes, vnode.props, getDisplayName(vnode), serializeVNode(vnode));\n\t\t}\n\n\t\tlet keys = [];\n\t\tfor (let deepChild of toChildArray(children)) {\n\t\t\tif (!deepChild || deepChild.key==null) continue;\n\n\t\t\tlet key = deepChild.key;\n\n\t\t\tif (keys.indexOf(key) !== -1) {\n\t\t\t\tconsole.error(\n\t\t\t\t\t'Following component has two or more children with the ' +\n\t\t\t\t\t`same key attribute: \"${key}\". This may cause glitches and misbehavior ` +\n\t\t\t\t\t'in rendering process. Component: \\n\\n' +\n\t\t\t\t\tserializeVNode(vnode)\n\t\t\t\t);\n\n\t\t\t\t// Break early to not spam the console\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tkeys.push(key);\n\t\t}\n\n\t\tif (oldBeforeDiff) oldBeforeDiff(vnode);\n\t};\n\n\tconst warn = (property, err) => ({\n\t\tget() {\n\t\t\tthrow new Error(`getting vnode.${property} is deprecated, ${err}`);\n\t\t},\n\t\tset() {\n\t\t\tthrow new Error(`setting vnode.${property} is not allowed, ${err}`);\n\t\t}\n\t});\n\n\tconst deprecatedAttributes = {\n\t\tnodeName: warn('nodeName', 'use vnode.type'),\n\t\tattributes: warn('attributes', 'use vnode.props'),\n\t\tchildren: warn('children', 'use vnode.props.children')\n\t};\n\n\toptions.vnode = (vnode) => {\n\t\tObject.defineProperties(vnode, deprecatedAttributes);\n\t\tif (oldVnode) oldVnode(vnode);\n\t};\n\n\toptions.diffed = (vnode) => {\n\t\tif (vnode._component && vnode._component.__hooks) {\n\t\t\tlet hooks = vnode._component.__hooks;\n\t\t\tif (hooks._list.length > 0) {\n\t\t\t\thooks._list.forEach(hook => {\n\t\t\t\t\tif (hook._callback && (!hook._args || !Array.isArray(hook._args))) {\n\t\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t\t`In ${vnode.type.name || vnode.type} you are calling useMemo/useCallback without passing arguments.\\n` +\n\t\t\t\t\t\t\t`This is a noop since it will not be able to memoize, it will execute it every render.`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (hooks._pendingEffects.length > 0) {\n\t\t\t\thooks._pendingEffects.forEach((effect) => {\n\t\t\t\t\tif (!effect._args || !Array.isArray(effect._args)) {\n\t\t\t\t\t\tthrow new Error('You should provide an array of arguments as the second argument to the \"useEffect\" hook.\\n\\n' +\n\t\t\t\t\t\t\t'Not doing so will invoke this effect on every render.\\n\\n' +\n\t\t\t\t\t\t\t'This effect can be found in the render of ' + (vnode.type.name || vnode.type) + '.');\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (hooks._pendingLayoutEffects.length > 0) {\n\t\t\t\thooks._pendingLayoutEffects.forEach((layoutEffect) => {\n\t\t\t\t\tif (!layoutEffect._args || !Array.isArray(layoutEffect._args)) {\n\t\t\t\t\t\tthrow new Error('You should provide an array of arguments as the second argument to the \"useEffect\" hook.\\n\\n' +\n\t\t\t\t\t\t\t'Not doing so will invoke this effect on every render.\\n\\n' +\n\t\t\t\t\t\t\t'This effect can be found in the render of ' + (vnode.type.name || vnode.type) + '.');\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (oldDiffed) oldDiffed(vnode);\n\t};\n}\n\n/**\n * Serialize a vnode tree to a string\n * @param {import('./internal').VNode} vnode\n * @returns {string}\n */\nexport function serializeVNode(vnode) {\n\tlet { props } = vnode;\n\tlet name = getDisplayName(vnode);\n\n\tlet attrs = '';\n\tif (props) {\n\t\tfor (let prop in props) {\n\t\t\tif (props.hasOwnProperty(prop) && prop!=='children') {\n\t\t\t\tlet value = props[prop];\n\n\t\t\t\t// If it is an object but doesn't have toString(), use Object.toString\n\t\t\t\tif (typeof value==='function') {\n\t\t\t\t\tvalue = `function ${value.displayName || value.name}() {}`;\n\t\t\t\t}\n\n\t\t\t\tvalue = Object(value) === value && !value.toString\n\t\t\t\t\t? Object.prototype.toString.call(value)\n\t\t\t\t\t: value + '';\n\n\t\t\t\tattrs += ` ${prop}=${JSON.stringify(value)}`;\n\t\t\t}\n\t\t}\n\t}\n\n\tlet children = props.children;\n\treturn `<${name}${attrs}${children && children.length\n\t\t? '>..</'+name+'>'\n\t\t: ' />'}`;\n}\n","import { getData, getChildren, getInstance, hasDataChanged, isRoot } from './custom';\n\n/**\n * Custom renderer tailored for Preact. It converts updated vnode trees\n * to events the devtools can understand.\n * @class Renderer\n */\nexport class Renderer {\n\tconstructor(hook, rid) {\n\n\t\t/** @type {string} */\n\t\tthis.rid = rid;\n\t\tthis.hook = hook;\n\n\t\t/** @type {Array<import('../internal').DevtoolsEvent>} */\n\t\tthis.pending = [];\n\n\t\t/**\n\t\t * Store the instance of a vnode. This will be later used to decide if a\n\t\t * vnode needs to be mounted or updated. For components the instance refers\n\t\t * to the actuall class instance whereas for dom nodes it refers to the\n\t\t * underlying dom element.\n\t\t * @type {WeakMap<import('../internal').Component | import('../internal').PreactElement | HTMLElement | Text, import('../internal').VNode>}\n\t\t */\n\t\tthis.inst2vnode = new WeakMap();\n\t\tthis.connected = false;\n\t}\n\n\t/**\n\t * Mark the connection status as ready so that we can proceed\n\t * to actually flush events.\n\t */\n\tmarkConnected() {\n\t\tthis.connected = true;\n\t\tthis.flushPendingEvents();\n\t}\n\n\t/**\n\t * Flush all queued events\n\t */\n\tflushPendingEvents() {\n\t\tif (!this.connected) return;\n\n\t\tlet events = this.pending;\n\t\tthis.pending = [];\n\t\tfor (let i = 0; i < events.length; i++) {\n\t\t\tlet event = events[i];\n\t\t\tthis.hook.emit(event.type, event);\n\t\t}\n\t}\n\n\t/**\n\t * Recursively mount a vnode tree. Note that the devtools expectes the tree to\n\t * be mounted from the bottom up, otherwise the order will be messed up.\n\t * Therefore we mount children prior to mounting the vnode itself.\n\t * @param {import('../internal').VNode} vnode\n\t */\n\tmount(vnode) {\n\t\tthis.inst2vnode.set(getInstance(vnode), vnode);\n\t\tlet data = getData(vnode);\n\n\t\t/** @type {Array<import('../internal').DevtoolsEvent>} */\n\t\tlet work = [{\n\t\t\tinternalInstance: vnode,\n\t\t\tdata,\n\t\t\trenderer: this.rid,\n\t\t\ttype: 'mount'\n\t\t}];\n\n\t\t// Children must be mounted first\n\t\tif (Array.isArray(data.children)) {\n\t\t\tlet stack = data.children.slice();\n\t\t\tlet item;\n\t\t\twhile ((item = stack.pop())!=null) {\n\t\t\t\tlet children = getChildren(item);\n\t\t\t\tstack.push(...children);\n\n\t\t\t\tthis.inst2vnode.set(getInstance(item), item);\n\n\t\t\t\tlet data = getData(item);\n\n\t\t\t\twork.push({\n\t\t\t\t\tinternalInstance: item,\n\t\t\t\t\tdata,\n\t\t\t\t\trenderer: this.rid,\n\t\t\t\t\ttype: 'mount'\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = work.length; --i>=0;) {\n\t\t\tthis.pending.push(work[i]);\n\t\t}\n\n\t\t// Special event if we have a root\n\t\tif (isRoot(vnode)) {\n\t\t\tthis.pending.push({\n\t\t\t\tinternalInstance: vnode,\n\t\t\t\tdata,\n\t\t\t\trenderer: this.rid,\n\t\t\t\ttype: 'root'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Update a vnode tree\n\t * @param {import('../internal').VNode} vnode\n\t */\n\tupdate(vnode) {\n\t\tlet data = getData(vnode);\n\n\t\t// Children must be updated first\n\t\tif (Array.isArray(data.children)) {\n\t\t\tfor (let i = 0; i < data.children.length; i++) {\n\t\t\t\tlet child = data.children[i];\n\t\t\t\tlet inst = getInstance(child);\n\n\t\t\t\tlet prevChild = this.inst2vnode.get(inst);\n\t\t\t\tif (prevChild==null) this.mount(child);\n\t\t\t\telse this.update(child);\n\n\t\t\t\t// Mutate child to keep referential equality intact\n\t\t\t\tdata.children[i] = this.inst2vnode.get(inst);\n\t\t\t}\n\t\t}\n\n\t\tlet prev = this.inst2vnode.get(data.publicInstance);\n\n\t\t// The `updateProfileTimes` event is a faster version of `updated` and\n\t\t// is processed much quicker inside the devtools extension.\n\t\tif (!hasDataChanged(prev, vnode)) {\n\t\t\t// Always assume profiling data has changed. When we skip an event here\n\t\t\t// the devtools element picker will somehow break.\n\t\t\tthis.pending.push({\n\t\t\t\t// This property is only used as an id inside the devtools. The\n\t\t\t\t// relevant data will be read from `.data` instead which is a\n\t\t\t\t// normalized structure that every react release adheres to. This\n\t\t\t\t// makes backwards-compatibility easier instead of relying on internal\n\t\t\t\t// vnode/fiber shape.\n\t\t\t\tinternalInstance: prev,\n\t\t\t\tdata,\n\t\t\t\trenderer: this.rid,\n\t\t\t\ttype: 'updateProfileTimes'\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tthis.pending.push({\n\t\t\t// This property is only used as an id inside the devtools. The\n\t\t\t// relevant data will be read from `.data` instead which is a\n\t\t\t// normalized structure that every react release adheres to. This\n\t\t\t// makes backwards-compatibility easier instead of relying on internal\n\t\t\t// vnode/fiber shape.\n\t\t\tinternalInstance: prev,\n\t\t\tdata,\n\t\t\trenderer: this.rid,\n\t\t\ttype: 'update'\n\t\t});\n\t}\n\n\t/**\n\t * Pass a rendered tree to the devtools. At this point elements have already\n\t * unmounted, so we don't need to check for removals and only update vs mount\n\t * instead.\n\t * @param {import('../internal').VNode} vnode\n\t */\n\thandleCommitFiberRoot(vnode) {\n\t\tlet inst = getInstance(vnode);\n\n\t\tif (this.inst2vnode.has(inst)) this.update(vnode);\n\t\telse this.mount(vnode);\n\n\t\t// The devtools checks via the existance of this property if the devtools\n\t\t// profiler should be enabled or not. If it is missing from the first root\n\t\t// node the \"Profiler\" tab won't show up.\n\t\t/** @type {import('../internal').VNode} */\n\t\tlet root = null;\n\t\tif (isRoot(vnode)) {\n\n\t\t\t/** @type {*} */\n\t\t\t(vnode).treeBaseDuration = 0;\n\t\t\troot = vnode;\n\t\t}\n\t\telse {\n\t\t\t// \"rootCommitted\" always needs the actual root node for the profiler\n\t\t\t// to be able to collect timings. The `_ancestorComponent` property will\n\t\t\t// point to a vnode for a root node.\n\t\t\troot = vnode._component;\n\t\t\twhile (root._ancestorComponent!=null) {\n\t\t\t\troot = root._ancestorComponent;\n\t\t\t}\n\t\t}\n\n\t\tthis.pending.push({\n\t\t\tinternalInstance: root,\n\t\t\trenderer: this.rid,\n\t\t\tdata: getData(root),\n\t\t\ttype: 'rootCommitted'\n\t\t});\n\n\t\tthis.flushPendingEvents();\n\t\treturn vnode;\n\t}\n\n\t/**\n\t * Unmount a vnode recursively. Contrary to mounting or updating unmounting needs\n\t * to push the events in parent-first order. Because `options.unmount` is\n\t * already fired in parent-first order we don't need to traverse anything here.\n\t * @param {import('../internal').VNode} vnode\n\t */\n\thandleCommitFiberUnmount(vnode) {\n\t\tlet inst = getInstance(vnode);\n\t\tthis.inst2vnode.delete(inst);\n\n\t\t// Special case when unmounting a root (most prominently caused by webpack's\n\t\t// `hot-module-reloading`). If this happens we need to unmount the virtual\n\t\t// `Fragment` we're wrapping around each root just for the devtools.\n\n\t\tthis.pending.push({\n\t\t\tinternalInstance: vnode,\n\t\t\trenderer: this.rid,\n\t\t\ttype: 'unmount'\n\t\t});\n\t}\n\n\t/**\n\t * Get the dom element by a vnode\n\t * @param {import('../internal').VNode} vnode\n\t * @returns {import('../internal').PreactElement | Text}\n\t */\n\tgetNativeFromReactElement(vnode) {\n\t\treturn vnode._dom;\n\t}\n\n\t/**\n\t * Get a vnode by a dom element\n\t * @param {import('../internal').PreactElement | Text} dom\n\t * @returns {import('../internal').VNode | null}\n\t */\n\tgetReactElementFromNative(dom) {\n\t\treturn this.inst2vnode.get(dom) || null;\n\t}\n\n\t// Unused, but devtools expects it to be there\n\t/* istanbul ignore next */\n\twalkTree() {}\n\n\t// Unused, but devtools expects it to be there\n\t/* istanbul ignore next */\n\tcleanup() {}\n}\n","import { options, Component, Fragment } from 'preact';\nimport { Renderer } from './renderer';\n\n/**\n * Wrap function with generic error logging\n *\n * @param {*} fn\n * @returns\n */\nfunction catchErrors(fn) {\n\treturn function(arg) {\n\t\ttry {\n\t\t\treturn fn(arg);\n\t\t}\n\t\tcatch (e) {\n\t\t\t/* istanbul ignore next */\n\t\t\tconsole.error('The react devtools encountered an error');\n\t\t\t/* istanbul ignore next */\n\t\t\tconsole.error(e); // eslint-disable-line no-console\n\t\t}\n\t};\n}\n\n/* istanbul ignore next */\nlet noop = () => undefined;\n\nexport function initDevTools() {\n\t// This global variable is injected by the devtools\n\t/** @type {import('../internal').DevtoolsWindow} */\n\tlet hook = (window).__REACT_DEVTOOLS_GLOBAL_HOOK__;\n\tif (hook==null) return;\n\n\t/** @type {(vnode: import('../internal').VNode) => void} */\n\tlet onCommitRoot = noop;\n\n\t/** @type {(vnode: import('../internal').VNode) => void} */\n\tlet onCommitUnmount = noop;\n\n\t// Initialize our custom renderer\n\tlet rid = Math.random().toString(16).slice(2);\n\tlet preactRenderer = new Renderer(hook, rid);\n\n\tcatchErrors(() => {\n\t\tlet isDev = false;\n\t\ttry {\n\t\t\tisDev = process.env.NODE_ENV!=='production';\n\t\t}\n\t\tcatch (e) {}\n\n\t\t// Tell devtools which bundle type we run in\n\t\twindow.parent.postMessage({\n\t\t\tsource: 'react-devtools-detector',\n\t\t\treactBuildType: /* istanbul ignore next */  isDev\n\t\t\t\t? 'development'\n\t\t\t\t: 'production'\n\t\t}, '*');\n\n\t\tlet renderer = {\n\t\t\tbundleType: /* istanbul ignore next */  isDev ? 1 : 0,\n\t\t\tversion: '16.5.2',\n\t\t\trendererPackageName: 'preact',\n\t\t\t// We don't need this, but the devtools `attachRenderer` function relys\n\t\t\t// it being there.\n\t\t\tfindHostInstanceByFiber(vnode) {\n\t\t\t\treturn vnode._dom;\n\t\t\t},\n\t\t\t// We don't need this, but the devtools `attachRenderer` function relys\n\t\t\t// it being there.\n\t\t\tfindFiberByHostInstance(instance) {\n\t\t\t\treturn preactRenderer.inst2vnode.get(instance) || null;\n\t\t\t}\n\t\t};\n\n\t\thook._renderers[rid] = renderer;\n\n\t\t// We can't bring our own `attachRenderer` function therefore we simply\n\t\t// prevent the devtools from overwriting our custom renderer by creating\n\t\t// a noop setter.\n\t\tObject.defineProperty(hook.helpers, rid, {\n\t\t\tget: () => preactRenderer,\n\t\t\tset: () => {\n\t\t\t\tif (!preactRenderer.connected) {\n\t\t\t\t\thelpers.markConnected();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tlet helpers = hook.helpers[rid];\n\n\t\t// Tell the devtools that we are ready to start\n\t\thook.emit('renderer-attached', {\n\t\t\tid: rid,\n\t\t\trenderer,\n\t\t\thelpers\n\t\t});\n\n\t\tonCommitRoot = catchErrors(root => {\n\t\t\t// Empty root\n\t\t\tif (root.type===Fragment && root._children.length==0) return;\n\n\t\t\tlet roots = hook.getFiberRoots(rid);\n\t\t\troot = helpers.handleCommitFiberRoot(root);\n\t\t\tif (!roots.has(root)) roots.add(root);\n\t\t});\n\n\t\tonCommitUnmount = catchErrors(vnode => {\n\t\t\thook.onCommitFiberUnmount(rid, vnode);\n\t\t});\n\t})();\n\n\t// Store (possible) previous hooks so that we don't overwrite them\n\tlet prevVNodeHook = options.vnode;\n\tlet prevCommitRoot = options.commit;\n\tlet prevBeforeUnmount = options.unmount;\n\tlet prevBeforeDiff = options.diff;\n\tlet prevAfterDiff = options.diffed;\n\n\toptions.vnode = (vnode) => {\n\t\t// Tiny performance improvement by initializing fields as doubles\n\t\t// from the start. `performance.now()` will always return a double.\n\t\t// See https://github.com/facebook/react/issues/14365\n\t\t// and https://slidr.io/bmeurer/javascript-engine-fundamentals-the-good-the-bad-and-the-ugly\n\t\tvnode.startTime = NaN;\n\t\tvnode.endTime = NaN;\n\n\t\tvnode.startTime = 0;\n\t\tvnode.endTime = -1;\n\t\tif (prevVNodeHook) prevVNodeHook(vnode);\n\t};\n\n\toptions.diff = (vnode) => {\n\t\tvnode.startTime = now();\n\t\tif (prevBeforeDiff!=null) prevBeforeDiff(vnode);\n\t};\n\n\toptions.diffed = (vnode) => {\n\t\tvnode.endTime = now();\n\t\tif (prevAfterDiff!=null) prevAfterDiff(vnode);\n\t};\n\n\toptions.commit = catchErrors((vnode) => {\n\t\t// Call previously defined hook\n\t\tif (prevCommitRoot!=null) prevCommitRoot(vnode);\n\n\t\t// These cases are already handled by `unmount`\n\t\tif (vnode==null) return;\n\t\tonCommitRoot(vnode);\n\t});\n\n\toptions.unmount = catchErrors((vnode) => {\n\t\t// Call previously defined hook\n\t\tif (prevBeforeUnmount!=null) prevBeforeUnmount(vnode);\n\t\tonCommitUnmount(vnode);\n\t});\n\n\t// Inject tracking into setState\n\tconst setState = Component.prototype.setState;\n\tComponent.prototype.setState = function(update, callback) {\n\t\t// Duplicated in setState() but doesn't matter due to the guard.\n\t\tlet s = (this._nextState!==this.state && this._nextState) || (this._nextState = Object.assign({}, this.state));\n\n\t\t// Needed in order to check if state has changed after the tree has been committed:\n\t\tthis._prevState = Object.assign({}, s);\n\n\t\treturn setState.call(this, update, callback);\n\t};\n}\n\n/**\n * Get current timestamp in ms. Used for profiling.\n * @returns {number}\n */\nexport let now = Date.now;\n\ntry {\n\t/* istanbul ignore else */\n\tnow = performance.now.bind(performance);\n}\ncatch (e) {}\n","import { initDebug } from './debug';\nimport { initDevTools } from './devtools';\n\nif (process.env.NODE_ENV==='development') {\n\tinitDebug();\n\tinitDevTools();\n}\n","export const ELEMENT_NODE = 1;\nexport const DOCUMENT_NODE = 9;\nexport const DOCUMENT_FRAGMENT_NODE = 11;\n"],"names":["loggedTypeFailures","getNodeType","vnode","type","Fragment","getDisplayName","displayName","name","setIn","obj","path","value","last","pop","parent","reduce","acc","attr","getData","c","_component","updater","Component","setState","bind","forceUpdate","setInState","prev","setInProps","props","setInContext","context","children","getChildren","duration","endTime","startTime","nodeType","ref","key","text","state","length","publicInstance","getInstance","memoizedInteractions","actualDuration","actualStartTime","treeBaseDuration","_children","filter","Boolean","Array","isArray","_prevVNode","isRoot","_dom","parentNode","shallowEqual","a","b","isProps","let","Object","keys","serializeVNode","attrs","prop","hasOwnProperty","toString","prototype","call","JSON","stringify","Renderer","constructor","hook","rid","pending","inst2vnode","WeakMap","connected","catchErrors","fn","arg","e","console","error","markConnected","flushPendingEvents","this","events","i","event","emit","mount","set","data","work","renderer","item","stack","slice","push","update","child","inst","get","next","_prevState","hasDataChanged","handleCommitFiberRoot","has","root","_ancestorComponent","handleCommitFiberUnmount","delete","getNativeFromReactElement","getReactElementFromNative","dom","walkTree","cleanup","noop","now","Date","performance","process","env","NODE_ENV","oldBeforeDiff","options","diff","oldDiffed","diffed","oldVnode","Error","isValid","typeSpecs","values","location","componentName","undefined","_lastDomChild","info","const","propTypes","forEach","typeSpecName","message","toChildArray","deepChild","indexOf","warn","property","err","deprecatedAttributes","nodeName","attributes","defineProperties","__hooks","hooks","_list","_callback","_args","_pendingEffects","effect","_pendingLayoutEffects","layoutEffect","initDebug","window","__REACT_DEVTOOLS_GLOBAL_HOOK__","onCommitRoot","onCommitUnmount","Math","random","preactRenderer","isDev","postMessage","source","reactBuildType","bundleType","version","rendererPackageName","findHostInstanceByFiber","findFiberByHostInstance","instance","_renderers","defineProperty","helpers","id","roots","getFiberRoots","add","onCommitFiberUnmount","prevVNodeHook","prevCommitRoot","commit","prevBeforeUnmount","unmount","prevBeforeDiff","prevAfterDiff","NaN","callback","s","_nextState","assign","initDevTools"],"mappings":"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"}
